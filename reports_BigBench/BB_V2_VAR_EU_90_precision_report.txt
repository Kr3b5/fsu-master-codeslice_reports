Found 16/400 pairs as clones in the BCB
-----Function Pair=1=-----==

private Set getSelectableEditParts (GraphicalViewer viewer) {
    HashSet selectableChildren = new HashSet ();
    for (Object child : viewer.getContents ().getChildren ()) {
        if (child instanceof GraphicalEditPart) {
            GraphicalEditPart childPart = (GraphicalEditPart) child;
            if (childPart.isSelectable ()) {
                selectableChildren.add (childPart);
                for (Object o : childPart.getSourceConnections ()) {
                    GraphicalEditPart connectionEditPart = (GraphicalEditPart) o;
                    if (connectionEditPart.isSelectable ()) {
                        selectableChildren.add (connectionEditPart);
                    }
                }
                for (Object o : childPart.getTargetConnections ()) {
                    GraphicalEditPart connectionEditPart = (GraphicalEditPart) o;
                    if (connectionEditPart.isSelectable ()) {
                        selectableChildren.add (connectionEditPart);
                    }
                }
            }
        }
    }
    return selectableChildren;
}


public static Resource createDiagram (URI diagramURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.TelcoblocksDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.TelcoblocksDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            org.germinus.telcoblocks.RED model = createInitialModel ();
            attachModelToResource (model, diagramResource);
            Diagram diagram = ViewService.createDiagram (model, REDEditPart.MODEL_ID, TelcoblocksInfraestructurasDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                diagramResource.save (org.germinus.telcoblocks.infraestructuras.diagram.part.TelcoblocksDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                TelcoblocksInfraestructurasDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        TelcoblocksInfraestructurasDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=2=-----==

private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=3=-----==

protected void printPages () {
    Graphics graphics = getFreshPrinterGraphics ();
    IFigure figure = getPrintSource ();
    maxDim = new Dimension ();
    RMBenchPrintOperation.calcChildrensArea (figure, maxDim);
    PrinterData pdata = printer.getPrinterData ();
    int numberOfRounds = 0;
    int numberOfCopies = 0;
    if (pdata.collate) {
        numberOfRounds = pdata.copyCount;
        numberOfCopies = 1;
    }
    else {
        numberOfRounds = 1;
        numberOfCopies = pdata.copyCount;
    }
    setupPrinterGraphicsFor (graphics, figure);
    graphics.scale (dpiScale * modeScale);
    Rectangle bounds = figure.getBounds ();
    Rectangle clipRect = new Rectangle ();
    int currentRound = 0;
    while (currentRound < numberOfRounds) {
        int pageCount = 1;
        int copyCount = 0;
        int x = bounds.x - margin;
        int y = bounds.y - margin;
        while (y < bounds.y + maxDim.height) {
            while (x < bounds.x + maxDim.width) {
                graphics.pushState ();
                graphics.translate (- x, - y);
                graphics.getClip (clipRect);
                clipRect.setLocation (x + margin, y + margin);
                clipRect.width -= 2 * margin;
                clipRect.height -= 2 * margin + bannerMargin;
                graphics.clipRect (clipRect);
                if (containsPage (pageCount) && containsPrintableElements (figure, clipRect, 1.0)) {
                    getPrinter ().startPage ();
                    figure.paint (graphics);
                    if (bannerMargin > 0) {
                        Rectangle newRect = new Rectangle (clipRect);
                        newRect.x -= margin;
                        newRect.width += 2 * margin;
                        newRect.height += bannerMargin + margin;
                        graphics.setClip (newRect);
                        graphics.drawText (bannerText, newRect.x + ((newRect.width - bannerTextWidth) / 2), newRect.y + newRect.height - bannerMargin);
                    }
                    getPrinter ().endPage ();
                    copyCount ++;
                }
                graphics.popState ();
                if ((copyCount == 0) || (copyCount >= numberOfCopies)) {
                    x += clipRect.width;
                    pageCount ++;
                    copyCount = 0;
                }
            }
            x = bounds.x - margin;
            y += clipRect.height;
        }
        currentRound ++;
    }
}


protected void performSaveAs (IProgressMonitor progressMonitor) {
    Shell shell = getSite ().getShell ();
    IEditorInput input = getEditorInput ();
    SaveAsDialog dialog = new SaveAsDialog (shell);
    IFile original = input instanceof IFileEditorInput ? ((IFileEditorInput) input).getFile () : null;
    if (original != null) {
        dialog.setOriginalFile (original);
    }
    dialog.create ();
    IDocumentProvider provider = getDocumentProvider ();
    if (provider == null) {
        return;
    }
    if (provider.isDeleted (input) && original != null) {
        String message = NLS.bind (Messages.FilesystemDiagramEditor_SavingDeletedFile, original.getName ());
        dialog.setErrorMessage (null);
        dialog.setMessage (message, IMessageProvider.WARNING);
    }
    if (dialog.open () == Window.CANCEL) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IPath filePath = dialog.getResult ();
    if (filePath == null) {
        if (progressMonitor != null) {
            progressMonitor.setCanceled (true);
        }
        return;
    }
    IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace ().getRoot ();
    IFile file = workspaceRoot.getFile (filePath);
    final IEditorInput newInput = new FileEditorInput (file);
    IEditorMatchingStrategy matchingStrategy = getEditorDescriptor ().getEditorMatchingStrategy ();
    IEditorReference [] editorRefs = PlatformUI.getWorkbench ().getActiveWorkbenchWindow ().getActivePage ().getEditorReferences ();
    for (int i = 0; i < editorRefs.length; i ++) {
        if (matchingStrategy.matches (editorRefs [i], newInput)) {
            MessageDialog.openWarning (shell, Messages.FilesystemDiagramEditor_SaveAsErrorTitle, Messages.FilesystemDiagramEditor_SaveAsErrorMessage);
            return;
        }
    }
    boolean success = false;
    try {
        provider.aboutToChange (newInput);
        getDocumentProvider (newInput).saveDocument (progressMonitor, newInput, getDocumentProvider ().getDocument (getEditorInput ()), true);
        success = true;
    } catch (CoreException x) {
        IStatus status = x.getStatus ();
        if (status == null || status.getSeverity () != IStatus.CANCEL) {
            ErrorDialog.openError (shell, Messages.FilesystemDiagramEditor_SaveErrorTitle, Messages.FilesystemDiagramEditor_SaveErrorMessage, x.getStatus ());
        }
    } finally {
        provider.changed (newInput);
        if (success) {
            setInput (newInput);
        }
    }
    if (progressMonitor != null) {
        progressMonitor.setCanceled (! success);
    }
}


-----Function Pair=4=-----==

public IAdaptable createElement (IMemento memento) {
    String modelKey = memento.getString (MODEL_MEMENTO_KEY);
    if (modelKey != null) {
        boolean activated = RMBenchPlugin.getModelManager ().activateModelStorage (modelKey, null);
        Diagram diagram = null;
        if (activated) {
            String diagramName = memento.getString (DIAGRAM_MEMENTO_KEY);
            diagram = RMBenchPlugin.getModelManager ().getModel ().getDiagram (diagramName);
        }
        else {
            String msg = MessageFormat.format (ExceptionMessages.errorActivateModel, new Object [] {modelKey});
            RMBenchPlugin.logError (msg);
        }
        return diagram != null ? new Input (diagram) : null;
    }
    else return null;
}


public IContentOutlinePage getContentOutlinePage () {
    if (contentOutlinePage == null) {
        class MyContentOutlinePage extends ContentOutlinePage {
            @Override
            public void createControl (Composite parent) {
                super.createControl (parent);
                contentOutlineViewer = getTreeViewer ();
                contentOutlineViewer.addSelectionChangedListener (this);
                contentOutlineViewer.setContentProvider (new AdapterFactoryContentProvider (adapterFactory));
                contentOutlineViewer.setLabelProvider (new AdapterFactoryLabelProvider (adapterFactory));
                contentOutlineViewer.setInput (editingDomain.getResourceSet ());
                if (! editingDomain.getResourceSet ().getResources ().isEmpty ()) {
                    contentOutlineViewer.setSelection (new StructuredSelection (editingDomain.getResourceSet ().getResources ().get (0)), true);
                }
            }@Override
            public void makeContributions (IMenuManager menuManager, IToolBarManager toolBarManager, IStatusLineManager statusLineManager) {
                super.makeContributions (menuManager, toolBarManager, statusLineManager);
            }
        }
        contentOutlinePage = new MyContentOutlinePage ();
    }
    return contentOutlinePage;
}


-----Function Pair=5=-----==

protected void setInput (final IEditorInput input) {
    super.setInput (input);
    try {
        final IFile file = ((IFileEditorInput) input).getFile ();
        final IContentType contentType = IDE.getContentType (file);
        if (contentType.getId ().equals ("bigraph.biged.bigraphBTL")) {
            format = IOConstants.FORMAT_BTL;
        }
        else {
            format = IOConstants.FORMAT_XML;
        }
        final BigraphReader reader = XmlIOFactory.getReader (format, new BasicSignature ());
        bigraph = new Bigraph (reader.read (file.getContents ()));
        bigraph.setName (file.getName ());
        setPartName (file.getName ());
    } catch (final Exception e) {
        e.printStackTrace ();
    }
}


private static IEditorInput getEditorInput (Diagram diagram) {
    Resource diagramResource = diagram.eResource ();
    for (Iterator it = diagramResource.getContents ().iterator (); it.hasNext ();) {
        EObject nextEObject = (EObject) it.next ();
        if (nextEObject == diagram) {
            return new FileEditorInput (WorkspaceSynchronizer.getFile (diagramResource));
        }
        if (nextEObject instanceof Diagram) {
            break;
        }
    }
    URI uri = EcoreUtil.getURI (diagram);
    String editorName = uri.lastSegment () + "#" + diagram.eResource ().getContents ().indexOf (diagram);
    IEditorInput editorInput = new URIEditorInput (uri, editorName);
    return editorInput;
}


-----Function Pair=6=-----==

public void actionPerformed (ActionEvent arg0) {
    Vector < Integer > v = new Vector < Integer > ();
    int dim = 0;
    Vector < Integer > validCols = new Vector < Integer > ();
    validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Double.class));
    validCols.addAll (scatter2D.getDataSource ().getColumnIndicesMatching (Integer.class));
    Collections.sort (validCols);
    for (Integer in : vp.getSelectedIndices ()) {
        if (in > 0) dim ++;
        in --;
        v.add (validCols.get (in));
    }
    System.out.println ("v :");
    for (Integer vint : v) {
        System.out.print (vint + " ");
    }
    if (dim == 0) {
        JOptionPane.showMessageDialog (null, "Select at least one Variable please.");
    }
    else if (dim == 1) {
        scatter2D.clearPlot ();
        scatter2D.resetLegendEntries ();
        System.out.println ("1Dim : v.get(1) = " + v.get (1));
        scatter2D.setDataSource (scatter2D.getDataSource (), v.get (1));
        scatter2D.repaint ();
    }
    else if (dim == 2) {
        scatter2D.clearPlot ();
        scatter2D.resetLegendEntries ();
        System.out.println ("2Dim : v.get(0) = " + v.get (0) + "v.get(1) = " + v.get (1));
        scatter2D.setDataSource (scatter2D.getDataSource (), v.get (0), v.get (1));
        scatter2D.repaint ();
    }
}


protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
    Graph model = graph;
    attachModelToResource (model, diagramResource);
    Diagram diagram = ViewService.createDiagram (model, GraphEditPart.MODEL_ID, CallGraphDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
    if (diagram != null) {
        diagramResource.getContents ().add (diagram);
        diagram.setName (diagramName);
        diagram.setElement (model);
        CallGraphDiagramRegistry.getInstance ().addGraph (diagram, model);
    }
    try {
        diagramResource.save (it.unisannio.rcost.callgraphanalyzer.diagram.part.CallGraphDiagramEditorUtil.getSaveOptions ());
    } catch (IOException e) {
        CallGraphDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
    }
    return CommandResult.newOKCommandResult ();
}


-----Function Pair=7=-----==

public static void encryptFile (File in, File out, SecretKey key) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IOException {
    Cipher c = Cipher.getInstance ("AES");
    c.init (Cipher.ENCRYPT_MODE, key);
    FileInputStream fin = new FileInputStream (in);
    FileOutputStream fout = new FileOutputStream (out);
    CipherOutputStream cout = new CipherOutputStream (fout, c);
    int i;
    byte [] data = new byte [1024];
    while ((i = fin.read (data)) != - 1) cout.write (data, 0, i);
    fin.close ();
    cout.close ();
}


protected PaletteRoot getPaletteRoot () {
    PaletteRoot root = new PaletteRoot ();
    PaletteGroup group = new PaletteGroup ("Sélection d'éléments");
    SelectionToolEntry sel = new SelectionToolEntry ("Sélection simple", "Sélection d'un élément graphique");
    group.add (sel);
    MarqueeToolEntry mar = new MarqueeToolEntry ("Sélection multiple", "Sélection multiple d'éléments graphiques");
    mar.setToolProperty (MarqueeSelectionTool.PROPERTY_UNLOAD_WHEN_FINISHED, true);
    group.add (mar);
    root.add (group);
    root.add (new PaletteSeparator ());
    PaletteGroup creationGroup = new PaletteGroup ("Création d'éléments");
    CreationToolEntry com = new CreationToolEntry ("Commentaire", "Creation d'un commentaire", new CreationFactory () {
        public Object getNewObject () {
            return new CommentModel ("");
        } public Object getObjectType () {
            return CommentModel.class;
        }
    }
    , null, null);
    com.setToolProperty (CreationTool.PROPERTY_UNLOAD_WHEN_FINISHED, false);
    creationGroup.add (com);
    creationGroup.add (new ConnectionCreationToolEntry ("Tube", "Création d'un tube", new CreationFactory () {
        public Object getNewObject () {
            return null;
        } public Object getObjectType () {
            return PipeModel.class;
        }
    }
    , null, null));
    creationGroup.add (new ConnectionCreationToolEntry ("Précédence", "Création d'une précédence entre deux services", new CreationFactory () {
        public Object getNewObject () {
            return null;
        } public Object getObjectType () {
            return PrecedenceModel.class;
        }
    }
    , null, null));
    CreationToolEntry input = new CreationToolEntry ("Entrée de Chaine", "Création d'une entrée de chaine à partir d'une entrée de service", new CreationFactory () {
        public Object getNewObject () {
            return null;
        } public Object getObjectType () {
            return ChainInputModel.class;
        }
    }
    , null, null);
    input.setToolProperty (CreationTool.PROPERTY_UNLOAD_WHEN_FINISHED, false);
    creationGroup.add (input);
    CreationToolEntry output = new CreationToolEntry ("Sortie de Chaine", "Création d'une sortie de chaine à partir d'une sortie de service", new CreationFactory () {
        public Object getNewObject () {
            return null;
        } public Object getObjectType () {
            return ChainOutputModel.class;
        }
    }
    , null, null);
    output.setToolProperty (CreationTool.PROPERTY_UNLOAD_WHEN_FINISHED, false);
    creationGroup.add (output);
    root.add (creationGroup);
    root.setDefaultEntry (sel);
    return root;
}


-----Function Pair=8=-----==

public void actionPerformed (ActionEvent e) {
    Object src = e.getSource ();
    JButton b = (JButton) src;
    if (b.getText ().equals (answers [questno])) {
        try {
            InputStream in = new FileInputStream ("easyplay//word//sounds//win.wav");
            AudioStream out = new AudioStream (in);
            AudioPlayer.player.start (out);
        } catch (IOException err) {
        }
        score ++;
        qsanswered ++;
        graphics.displaywin ();
        newgame (difficulty, false);
    }
    else {
        try {
            InputStream in = new FileInputStream ("easyplay//word//sounds//lose.wav");
            AudioStream out = new AudioStream (in);
            AudioPlayer.player.start (out);
        } catch (IOException err) {
        }
        attempts ++;
        if ((attempts + difficulty) > 2) {
            graphics.displaylose (answers [questno]);
            qsanswered ++;
            newgame (difficulty, false);
        }
        else {
            b.setVisible (false);
            graphics.displaytryagain (3 - (attempts + difficulty));
        }
    }
}


public void run () throws ErrorException {
    if (! parametersSet) {
        throw new ErrorException ("Parameters not set.");
    }
    if (WTTypes != 0) {
        int zSize = WTZRegionEnd - WTZRegionStart + 1;
        int ySize = WTYRegionEnd - WTYRegionStart + 1;
        int xSize = WTXRegionEnd - WTXRegionStart + 1;
        switch (WTAxis) {
            case 0 :
                for (int z = 0; z < zSize; z ++) {
                    for (int y = 0; y < ySize; y ++) {
                        float currentLine [] = new float [xSize];
                        for (int x = 0; x < xSize; x ++) {
                            currentLine [x + WTXRegionStart] = imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart];
                        }
                        currentLine = filtering (currentLine, WTTypes, WTXRegionStart);
                        for (int x = 0; x < xSize; x ++) {
                            imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart] = currentLine [x + WTXRegionStart];
                        }
                    }
                }
                break;
            case 1 :
                for (int z = 0; z < zSize; z ++) {
                    for (int x = 0; x < xSize; x ++) {
                        float currentLine [] = new float [ySize];
                        for (int y = 0; y < ySize; y ++) {
                            currentLine [y + WTYRegionStart] = imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart];
                        }
                        currentLine = filtering (currentLine, WTTypes, WTYRegionStart);
                        for (int y = 0; y < ySize; y ++) {
                            imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart] = currentLine [y + WTYRegionStart];
                        }
                    }
                }
                break;
            case 2 :
                for (int y = 0; y < ySize; y ++) {
                    for (int x = 0; x < xSize; x ++) {
                        float currentLine [] = new float [zSize];
                        for (int z = 0; z < zSize; z ++) {
                            currentLine [z + WTZRegionStart] = imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart];
                        }
                        currentLine = filtering (currentLine, WTTypes, WTZRegionStart);
                        for (int z = 0; z < zSize; z ++) {
                            imageSamples [z + WTZRegionStart] [y + WTYRegionStart] [x + WTXRegionStart] = currentLine [z + WTZRegionStart];
                        }
                    }
                }
                break;
            default :
                throw new ErrorException ("Unimplemented Axis");
        }
    }
    parametersSet = false;
}


-----Function Pair=9=-----==

void amoeba (float [] [] p, float [] y, int ndim, float ftol, boolean lmObjective, int nfunk) {
    int i, ihi, ilo, inhi, j, mpts = ndim + 1;
    float rtol, sum, swap, ysave, ytry;
    float [] psum;
    psum = vector (1, ndim);
    nfunk = 0;
    for (j = 1; j <= ndim; j ++) {
        for (sum = 0.0f, i = 1; i <= mpts; i ++) sum += p [i] [j];
        psum [j] = sum;
    }
    for (;;) {
        ilo = 1;
        if (y [1] > y [2]) {
            ihi = 1;
            inhi = 2;
        }
        else {
            ihi = 2;
            inhi = 1;
        }
        for (i = 1; i <= mpts; i ++) {
            if (y [i] <= y [ilo]) ilo = i;
            if (y [i] > y [ihi]) {
                inhi = ihi;
                ihi = i;
            }
            else if (y [i] > y [inhi] && i != ihi) inhi = i;
        }
        rtol = (float) (2.0 * Math.abs (y [ihi] - y [ilo]) / (Math.abs (y [ihi]) + Math.abs (y [ilo]) + TINY));
        if (rtol < ftol || y [ilo] < 1.0e-6) {
            SWAP (y [1], y [ilo]);
            for (i = 1; i <= ndim; i ++) {
                SWAP (p [1] [i], p [ilo] [i]);
            }
            break;
        }
        if (nfunk >= NMAX) {
            SWAP (y [1], y [ilo]);
            for (i = 1; i <= ndim; i ++) {
                SWAP (p [1] [i], p [ilo] [i]);
            }
            break;
        }
        nfunk += 2;
        ytry = amotry (p, y, psum, ndim, lmObjective, ihi, - 1.0f);
        if (ytry <= y [ilo]) ytry = amotry (p, y, psum, ndim, lmObjective, ihi, 2.0f);
        else if (ytry >= y [inhi]) {
            ysave = y [ihi];
            ytry = amotry (p, y, psum, ndim, lmObjective, ihi, 0.5f);
            if (ytry >= ysave) {
                for (i = 1; i <= mpts; i ++) {
                    if (i != ilo) {
                        for (j = 1; j <= ndim; j ++) p [i] [j] = psum [j] = 0.5f * (p [i] [j] + p [ilo] [j]);
                        float [] tmpstore = copyOne (psum);
                        y [i] = funObjective (tmpstore, lmObjective);
                        tmpstore = null;
                    }
                }
                nfunk += ndim;
                for (j = 1; j <= ndim; j ++) {
                    for (sum = 0.0f, i = 1; i <= mpts; i ++) sum += p [i] [j];
                    psum [j] = sum;
                }
            }
        }
        else -- (nfunk);
    }
    free_vector (psum, 1, ndim);
}


public void model () {
    String lines [] = new String [maxInputLines];
    lines [0] = "HERE+SHE=COMES";
    int noLines = 1;
    if (filename != null) {
        try {
            BufferedReader in = new BufferedReader (new FileReader (filename));
            String str;
            while ((str = in.readLine ()) != null) if (! str.trim ().equals ("")) {
                int commentPosition = str.indexOf ("//");
                if (commentPosition == 0) continue;
                else str = str.substring (0, commentPosition);
                lines [noLines] = str;
                noLines ++;
            }
            in.close ();
        } catch (FileNotFoundException e) {
            System.err.println ("File " + filename + " could not be found");
        } catch (IOException e) {
            System.err.println ("Something is wrong with the file" + filename);
        }
    }
    else {
        System.out.println ("No input file was supplied, using standard HERE+SHE=COMES problem");
    }
    store = new Store ();
    ArrayList < ArrayList < String > > words = new ArrayList < ArrayList < String > > ();
    for (int i = 0; i < noLines; i ++) words.add (new ArrayList < String > ());
    HashMap < String, IntVar > letters = new HashMap < String, IntVar > ();
    for (int i = 0; i < noLines; i ++) {
        Pattern pat = Pattern.compile ("[=+]");
        String [] result = pat.split (lines [i]);
        for (int j = 0; j < result.length; j ++) words.get (i).add (result [j]);
    }
    vars = new ArrayList < Var > ();
    for (int i = 0; i < noLines; i ++) for (int j = words.get (i).size () - 1; j >= 0; j --) for (int z = words.get (i).get (j).length () - 1; z >= 0; z --) {
        char [] currentChar = {words.get (i).get (j).charAt (z)};
        if (letters.get (new String (currentChar)) == null) {
            IntVar currentLetter = new IntVar (store, new String (currentChar), 0, base - 1);
            vars.add (currentLetter);
            letters.put (new String (currentChar), currentLetter);
        }
    }
    if (letters.size () > base) {
        System.out.println ("Expressions contain more than letters than base of the number system used ");
        System.out.println ("Base " + base);
        System.out.println ("Letters " + letters);
        System.out.println ("There can not be any solution");
    }
    store.impose (new Alldistinct (vars.toArray (new IntVar [0])));
    for (int currentLine = 0; currentLine < noLines; currentLine ++) {
        int noWords = words.get (currentLine).size ();
        IntVar [] fdv4words = new IntVar [noWords];
        IntVar [] terms = new IntVar [noWords - 1];
        for (int j = 0; j < noWords; j ++) {
            String currentWord = words.get (currentLine).get (j);
            fdv4words [j] = new IntVar (store, currentWord, 0, IntDomain.MaxInt);
            if (j < noWords - 1) terms [j] = fdv4words [j];
            IntVar [] lettersWithinCurrentWord = new IntVar [currentWord.length ()];
            for (int i = 0; i < currentWord.length (); i ++) {
                char [] currentChar = {currentWord.charAt (i)};
                lettersWithinCurrentWord [i] = letters.get (new String (currentChar));
            }
            store.impose (new SumWeight (lettersWithinCurrentWord, createWeights (currentWord.length (), base), fdv4words [j]));
            store.impose (new XneqC (lettersWithinCurrentWord [0], 0));
        }
        store.impose (new Sum (terms, fdv4words [noWords - 1]));
    }
}


-----Function Pair=10=-----==

public void calcMeanPlot () {
    double thresh = signalthresh.getValue ();
    double noise = (double) noiseresult.getValue ();
    int sizeX = yvalues.length;
    double [] temp = new double [sizeX];
    double [] noNoise = new double [sizeX];
    for (int i = 0; i < sizeX; i ++) {
        noNoise [i] = yvalues [i] - noise;
        temp [i] = noNoise [i];
    }
    Arrays.sort (temp);
    max = temp [sizeX - 1];
    int count = 0;
    for (int i = 0; i < sizeX; i ++) {
        if (noNoise [i] > (thresh * max)) count ++;
    }
    currentyvalues = new double [count];
    xphase = new double [count];
    x1 = new double [count];
    double x;
    int j = 0;
    for (int i = 0; i < sizeX; i ++) {
        x = (double) (i + 1) * dx;
        if (noNoise [i] > (thresh * max)) {
            currentyvalues [j] = noNoise [i];
            x1 [j] = x;
            xphase [j] = x1 [j] + phi0;
            j ++;
        }
    }
}


void destroyItem (CoolItem item) {
    int index = indexOf (item);
    int count = items.length;
    if (count != 0) {
        int lastIndex = getLastIndexOfRow (index);
        if (index == lastIndex) {
            resizeToMaximumWidth (lastIndex - 1);
        }
    }
    Control control = item.control;
    boolean wasVisible = control != null && ! control.isDisposed () && control.getVisible ();
    CoolItem nextItem = null;
    if (item.getWrap ()) {
        if (index + 1 < count) {
            nextItem = getItem (index + 1);
            ignoreResize = ! nextItem.getWrap ();
        }
    }
    OS.destroyHandle (items [index].handle);
    items [item.id] = null;
    item.id = - 1;
    if (ignoreResize) {
        nextItem.setWrap (true);
        ignoreResize = false;
    }
    if (wasVisible) control.setVisible (true);
    index = 0;
    while (index < originalItems.length) {
        if (originalItems [index] == item) break;
        index ++;
    }
    int length = originalItems.length - 1;
    CoolItem [] newOriginals = new CoolItem [length];
    System.arraycopy (originalItems, 0, newOriginals, 0, index);
    System.arraycopy (originalItems, index + 1, newOriginals, index, length - index);
    originalItems = newOriginals;
}


-----Function Pair=11=-----==

private void deleteEventAt (int deleteIndex) {
    ScrEvent event = getEventAt (deleteIndex);
    if (deleteIndex == NO_SUCH_EVENT || deleteIndex == EMPTY_COLLECTION) return;
    if (isInGroup ()) postEdit (new UndoableDelete (event));
    deleteRoomAt (deleteIndex);
    args.clear ();
    args.addInt (deleteIndex);
    try {
        send (FtsSymbol.get ("remove_event"), args);
    } catch (IOException e) {
        System.err.println ("FtsObjectWithEditor: I/O Error sending remove_event Message!");
        e.printStackTrace ();
    }
    notifyObjectDeleted (event, deleteIndex);
}


public boolean AtribuicaoID (Simbolo token) {
    if (this.tabelaSimbolos.containsKey (token.getNome ())) {
        Simbolo simbolo = (Simbolo) this.tabelaSimbolos.get (token.getNome ());
        if (! simbolo.getDeclarado ()) {
            System.out.printf ("Erro no Semantico: Identificador " + token.getNome () + " nao foi declarado! \n");
            return false;
        }
        if (! simbolo.getCategoria ().equals (Simbolo.VARIAVEL)) {
            System.out.printf ("Erro no Semantico: Identificador " + token.getNome () + " nao eh uma variável! \n");
            return false;
        }
    }
    this.pilhaIDAtual.empilha (token.getNome ());
    return true;
}


-----Function Pair=12=-----==

void loadFile (String aName) {
    playString = "";
    URL theURL;
    BufferedReader in;
    boolean weregood = false;
    boolean malformed = false;
    try {
        theURL = new URL (aName);
        URLConnection conn = null;
        BufferedReader data = null;
        String line;
        StringBuffer buf = new StringBuffer ();
        try {
            conn = theURL.openConnection ();
            conn.connect ();
            data = new BufferedReader (new InputStreamReader (new BufferedInputStream (conn.getInputStream ())));
            while ((line = data.readLine ()) != null) {
                buf.append (line);
            }
            playString = buf.toString ();
            data.close ();
            weregood = true;
        } catch (IOException e) {
            System.out.println ("IO Error:" + e.getMessage ());
        }
    } catch (MalformedURLException e) {
        System.out.println ("Bad URL: " + aName);
        malformed = true;
    }
    if (malformed) {
        System.out.println ("trying file: " + aName);
        try {
            File file = new File (aName);
            if (file != null && file.exists ()) {
                long inlen = (file.length ());
                in = new BufferedReader (new FileReader ((File) file));
                if (in != null) {
                    try {
                        int linecount = 0;
                        while ((playString.length () + linecount) < inlen) {
                            playString = playString.concat (in.readLine ());
                            linecount ++;
                        }
                        weregood = true;
                    } catch (IOException io) {
                        weregood = false;
                    }
                }
            }
        } catch (SecurityException ex) {
            System.out.println (ex.toString ());
        } catch (Exception ex) {
            System.out.println (ex.toString ());
        }
    }
    if (weregood) {
    }
    else {
        playString = "[[BeginPlaybookFile 2.0 1~3000:260,100`3001:260,120`3002:260,140`3003:260,160`3004:260,180`3005:260,200`3006:260,220`3007:260,240`1000:260,260`1001:260,280`1002:260,300`1003:260,320`1004:260,340`1005:260,360`1006:260,380`2000:260,400`2001:260,420`2002:260,440`2003:260,460`2004:260,480`2005:260,500`2006:260,520`4000:260,540`~100~| EndPlaybookFile]]";
        System.out.println ("couldn't load url or file; using fallback example instead");
    }
}


private void processBitmapCache (RdpPacket_Localised data) throws RdesktopException {
    int bufsize, pad2, row_size, final_size, size;
    int pad1;
    bufsize = pad2 = row_size = final_size = size = 0;
    int cache_id = data.get8 ();
    pad1 = data.get8 ();
    int width = data.get8 ();
    int height = data.get8 ();
    int bpp = data.get8 ();
    int Bpp = (bpp + 7) / 8;
    bufsize = data.getLittleEndian16 ();
    int cache_idx = data.getLittleEndian16 ();
    if (Options.use_rdp5) {
        pad2 = data.getLittleEndian16 ();
        size = data.getLittleEndian16 ();
        row_size = data.getLittleEndian16 ();
        final_size = data.getLittleEndian16 ();
    }
    else {
        data.incrementPosition (2);
        size = data.getLittleEndian16 ();
        row_size = data.getLittleEndian16 ();
        final_size = data.getLittleEndian16 ();
    }
    if (Bpp == 1) {
        byte [] pixel = Bitmap.decompress (width, height, size, data, Bpp);
        if (pixel != null) cache.putBitmap (cache_id, cache_idx, new Bitmap (Bitmap.convertImage (pixel, Bpp), width, height, 0, 0), 0);
        else logger.warn ("Failed to decompress bitmap");
    }
    else {
        int [] pixel = Bitmap.decompressInt (width, height, size, data, Bpp);
        if (pixel != null) cache.putBitmap (cache_id, cache_idx, new Bitmap (pixel, width, height, 0, 0), 0);
        else logger.warn ("Failed to decompress bitmap");
    }
}


-----Function Pair=13=-----==

private String acceptKeystroke () {
    historyCursor = history.size ();
    load ("");
    byte keystroke = readKeystroke ();
    for (;;) {
        switch (keystroke) {
            case K_NOP :
            case K_TAB :
                break;
            case K_BSP :
                if (bufferCursor > 0) {
                    -- bufferCursor;
                    delete ();
                }
                else beep ();
                break;
            case K_ESC :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        log.println ("completion not found for: " + toComplete);
                        beep ();
                    }
                    else load (completed);
                    break;
                }
            case K_SPACE :
                {
                    String toComplete = new String (buffer, 0, bufferCursor);
                    String completed = CommandCompletion.complete (toComplete, user);
                    if (completed == null) {
                        if (CommandCompletion.moreSpaceKeyExpected (toComplete)) {
                            insert (keystroke);
                            ++ bufferCursor;
                        }
                        else {
                            beep ();
                        }
                    }
                    else load (completed);
                    break;
                }
            case K_ENTER :
                {
                    String string = new String (buffer);
                    if (string.length () != 0) {
                        history.removeElement (string);
                        history.addElement (string);
                    }
                    historyCursor = history.size ();
                    load ("");
                    return string;
                }
            case K_UP :
                up ();
                break;
            case K_DN :
                down ();
                break;
            case K_RT :
                right ();
                break;
            case K_LT :
                left ();
                break;
            case K_HOME :
                home ();
                break;
            case K_END :
                end ();
                break;
            case K_DEL :
                delete ();
                break;
            default :
                insert (keystroke);
                ++ bufferCursor;
        }
        keystroke = readKeystroke ();
    }
}


private int binarySearch (Comparable key) {
    if (keys == null) return - 1;
    int high = nKeys - 1;
    int low = 0;
    int cur;
    int cmp;
    while (low <= high) {
        cur = (low + high)>>> 1;
        Comparable obj = keys [cur];
        if (obj != null) {
            cmp = obj.compareTo (key);
            if (cmp > 0) {
                high = cur - 1;
            }
            else if (cmp < 0) {
                low = cur + 1;
            }
            else {
                return cur;
            }
        }
        else {
            return cur;
        }
    }
    return (- 1 * (low + 1));
}


-----Function Pair=14=-----==

public void run () {
    e2colorpattern temppattern;
    e2piece temppiece;
    System.out.println (" backtracker started");
    while (killed == false) {
        while (solved == false && stop == false && level <= levelmax) {
            if (piecelisttab [level] == null) {
                temppattern = maingame.get_pattern_at (collist [level], rowlist [level]);
                piecelisttab [level] = maingame.get_unplaced_matching_pieces (temppattern);
                Collections.shuffle (piecelisttab [level].list);
                piecelisttab [level].restart ();
                if (piecelisttab [level].hasNext ()) {
                    currentpiecetab [level] = piecelisttab [level].next ();
                    currentpiecetab [level].reset_rotation ();
                    rotation [level] = - 1;
                }
                else {
                    currentpiecetab [level] = null;
                }
            }
            temppattern = maingame.get_pattern_at (collist [level], rowlist [level]);
            rotationfound = false;
            rotation [level] ++;
            while (currentpiecetab [level] != null && rotation [level] < 4 && rotationfound == false) {
                if (currentpiecetab [level].is_matching_pattern_with_rotation (temppattern)) {
                    rotationfound = true;
                }
                else {
                    rotation [level] ++;
                    currentpiecetab [level].reset_rotation ();
                    if (rotation [level] < 4) {
                        currentpiecetab [level].rotate (rotation [level]);
                    }
                }
            }
            if (rotationfound == true) {
                maingame.place_piece_at (currentpiecetab [level].id, collist [level], rowlist [level], 0);
                level ++;
                if (level > levelmax) {
                    solved = true;
                    System.out.println (" solution found");
                }
                if (level > best_level) {
                    best_level = level;
                }
                if (level > count_bestlevel) {
                    count_bestlevel = level;
                }
                count_from_start ++;
                count_from_last ++;
                if (count_from_last == display_every_count_nb) {
                    temp_time = (long) (new Date ()).getTime ();
                    time_between_count = temp_time - last_time_count;
                    System.out.println (count_from_last + " pieces placed in " + time_between_count + " ms (time=" + temp_time + ") (count=" + count_from_start + ") (bestlevel=" + best_level + ") (incrbestlevel=" + count_bestlevel + ") (incrworstlevel=" + count_worstlevel + ")");
                    count_from_last = 0;
                    last_time_count = temp_time;
                    count_bestlevel = level;
                    count_worstlevel = level;
                }
            }
            else {
                if (piecelisttab [level].hasNext ()) {
                    currentpiecetab [level] = piecelisttab [level].next ();
                    currentpiecetab [level].reset_rotation ();
                    rotation [level] = - 1;
                }
                else {
                    piecelisttab [level] = null;
                    level --;
                    if (level < count_worstlevel) {
                        count_worstlevel = level;
                    }
                    if (level < levelmin) {
                        stop = true;
                        System.out.println (" NO SOLUTION");
                    }
                    else {
                        maingame.unplace_piece_at (collist [level], rowlist [level]);
                    }
                }
            }
            try {
                Thread.sleep (0000);
            } catch (InterruptedException ex) {
            }
        }
    }
    System.out.println (" backtracker finished");
}


public void removeValue (int field, int index) {
    synchronized (i2) {
        int i;
        checkForExceptions (field, - 1, true, index, false);
        int listType = getListType ();
        if (! isStructLoading && rechandle != - 1 && ((listType == PIM.CONTACT_LIST && field == Contact.UID) || (listType == PIM.TODO_LIST && field == ToDo.UID) || (listType == PIM.EVENT_LIST && field == Event.UID))) throw new IllegalArgumentException ("Cannot remove the UID to this item.");
        if (! isStructLoading && rechandle != - 1 && ((listType == PIM.CONTACT_LIST && field == Contact.REVISION) || (listType == PIM.TODO_LIST && field == ToDo.REVISION) || (listType == PIM.EVENT_LIST && field == Event.REVISION))) throw new IllegalArgumentException ("Cannot remove the revision date to this item.");
        loadPIMStruct ();
        switch (PIMListImpl.getFieldDataTypeS (listType, field)) {
            case PIMItem.STRING :
            case PIMItem.STRING_ARRAY :
                int arrayIndex = 0, valueIndex = 0;
                if (indexInStringArray (field, index)) {
                    arrayIndex = i2.int1;
                    valueIndex = i2.int2;
                    int numst = 1;
                    if (PIMListImpl.getFieldDataTypeS (getListType (), stringids [arrayIndex]) == PIMItem.STRING_ARRAY) numst = PIMListImpl.getStringArraySizeS (getListType (), stringids [arrayIndex]);
                    for (int j = valueIndex; j < stringvalues.length - numst; j ++) {
                        stringvalues [j] = stringvalues [j + numst];
                    }
                    for (int j = arrayIndex; j < stringids.length - 3; j ++) {
                        stringids [j] = stringids [j + 3];
                    }
                    stringids [0] --;
                    int numv = countValues (field);
                    for (int j = index + 1; j <= numv; j ++) {
                        int inde = indexInStringArrayI (field, j);
                        stringids [inde + 1] --;
                    }
                    modified = true;
                    checkToCompactStringArray ();
                }
                break;
            case PIMItem.BINARY :
                arrayIndex = 0;
                valueIndex = 0;
                if (indexInByteArray (field, index)) {
                    arrayIndex = i2.int1;
                    valueIndex = i2.int2;
                    for (int j = valueIndex; j < bytevalues.length - byteids [arrayIndex + 3]; j ++) {
                        bytevalues [j] = bytevalues [j + byteids [arrayIndex + 3]];
                    }
                    for (int j = arrayIndex; j < byteids.length - 4; j ++) {
                        byteids [j] = byteids [j + 4];
                    }
                    byteids [0] --;
                    int numv = countValues (field);
                    for (int j = index + 1; j < numv; j ++) {
                        int inde = indexInByteArrayI (field, j);
                        byteids [inde + 1] --;
                    }
                    modified = true;
                    checkToCompactByteArray ();
                }
                break;
            case PIMItem.DATE :
            case PIMItem.INT :
            case PIMItem.BOOLEAN :
                i = indexInLongArray (field, index);
                if (i != - 1) {
                    for (int j = i; j < longvalues.length - 4; j ++) {
                        longvalues [j] = longvalues [j + 4];
                    }
                    longvalues [0] --;
                    int numv = countValues (field);
                    for (int j = index + 1; j < numv; j ++) {
                        int inde = indexInLongArray (field, j);
                        longvalues [inde + 1] --;
                    }
                    modified = true;
                    checkToCompactLongArray ();
                }
                break;
        }
    }
}


-----Function Pair=15=-----==

public static Object financialPv (Object [] args, XelContext ctx) {
    double rate = CommonFns.toNumber (args [0]).doubleValue ();
    int nper = CommonFns.toNumber (args [1]).intValue ();
    double pmt = 0.0;
    if (args [2] != null) {
        pmt = CommonFns.toNumber (args [2]).doubleValue ();
    }
    double fv = 0.0;
    if (args.length > 3 && args [3] != null) {
        fv = CommonFns.toNumber (args [3]).doubleValue ();
    }
    int type = 0;
    if (args.length == 5) {
        type = CommonFns.toNumber (args [4]).intValue ();
    }
    return new Double (pv (rate, nper, pmt, fv, type));
}


public void run () {
    while (! progressDialog.isReady ()) {
        try {
            sleep (SLEEP_MILLI_SECS);
        } catch (InterruptedException ex) {
        }
    }
    try {
        DataManager.getInstance ().connectDatabase (driver, url, useLogin, username, password);
    } catch (ClassNotFoundException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, "Unsupported database driver", ex);
        progressDialog.setAborted (true);
        displayMessage ("Database driver not found.\nPlease choose a different database.", true);
    } catch (SQLException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        progressDialog.setAborted (true);
        if (ex.getSQLState ().equals ("XJ040")) {
            String msg = "Database is already connected to another application";
            displayMessage (msg, true);
        }
        else {
            displayMessage (ex.getMessage () + " (" + ex.getSQLState () + ")", true);
        }
    } catch (IOException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        progressDialog.setAborted (true);
        displayMessage ("Database files not accessible.\nPlease choose a different database.", true);
    } catch (InstantiationException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        progressDialog.setAborted (true);
        displayMessage ("Database driver broken.\nPlease choose a different database.", true);
    } catch (IllegalAccessException ex) {
        Logger.getLogger (GuiController.class.getName ()).log (Level.SEVERE, null, ex);
        progressDialog.setAborted (true);
        displayMessage ("Database rights deny access.\nPlease choose a different database.", true);
    } finally {
        progressDialog.finish ();
    }
    ConfigManager.pushRecentConnection (url);
    gui.setStausbarDBMode ("Database Mode: " + DataManager.getInstance ().getDatabaseMode ());
    Logger.getLogger (this.getClass ().getName ()).log (Level.INFO, "Connected to Database with url: " + url, url);
}


-----Function Pair=16=-----==

public static final void Compute_EFI (List D, int numIntervalos, int numClases, int numCortes, int [] [] acumulados) {
    int [] acum = new int [acumulados [0].length];
    for (int i = 0; i < acum.length; i ++) {
        for (int c = 0; c < numClases; c ++) acum [i] += acumulados [c] [i];
        if (i > 0) acum [i] += acum [i - 1];
    }
    long total = acum [acum.length - 1];
    int pos_act = 0;
    for (int vuelta = 1; vuelta < numIntervalos; vuelta ++) {
        double t;
        t = vuelta * ((double) total) / numIntervalos;
        long valor = (int) t;
        do {
            pos_act ++;
        }
        while (acum [pos_act] < valor);
        D.add (new Integer (pos_act + 1));
        pos_act --;
    }
}


public static void lineDiagrammErzeugen (Object [] [] auswertung, int startRunde, int endRunde, Typ cmd, File file, Dimension d) {
    if (auswertung != null) {
        Diagramm diagramm = new Diagramm (auswertung, cmd);
        startRunde --;
        if (endRunde > diagramm.m) {
            endRunde = diagramm.m;
        }
        if (startRunde < 0) {
            startRunde = 0;
        }
        if (startRunde >= endRunde) {
            startRunde = 0;
            endRunde = diagramm.m;
        }
        DefaultCategoryDataset dataset = new DefaultCategoryDataset ();
        for (int n = diagramm.n - 1; n >= 0; n --) {
            for (int m = startRunde; m < endRunde; m ++) {
                dataset.addValue ((Integer) diagramm.getAuswertung () [n] [m], diagramm.getDataLegends () [n], new Integer (m + 1));
            }
        }
        JFreeChart chart = ChartFactory.createLineChart ("Auswertung: " + auswertung [0] [0], diagramm.getXLegend (), diagramm.getYLegend (), dataset, PlotOrientation.VERTICAL, true, false, false);
        chart.setBackgroundPaint (new Color (255, 255, 255, 0));
        CategoryPlot plot = (CategoryPlot) chart.getPlot ();
        plot.setBackgroundPaint (Color.white);
        plot.setRangeGridlinePaint (Color.black);
        LineAndShapeRenderer renderer = (LineAndShapeRenderer) plot.getRenderer ();
        renderer.setShapesVisible (true);
        renderer.setDrawOutlines (true);
        NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis ();
        rangeAxis.setStandardTickUnits (NumberAxis.createIntegerTickUnits ());
        rangeAxis.setAutoRange (true);
        CategoryAxis timeAxis = plot.getDomainAxis ();
        timeAxis.setLowerMargin (0.00);
        timeAxis.setUpperMargin (0.00);
        timeAxis.setCategoryLabelPositions (CategoryLabelPositions.UP_45);
        if (file != null) {
            saveChart (file, chart, d);
        }
    }
}


-----Function Pair=17=-----==

public OrdersTO doTrade () throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    double preco = quote.getClose ();
    if (currTime < LONG_PERIOD) {
        novo_dia (preco, dias);
        return createOrdemTO (0, preco, true);
    }
    else {
        double shorter = media (dias, SHORT_PERIOD);
        double longer = media (dias, LONG_PERIOD);
        double osc = (shorter - longer) / shorter * 100;
        int v;
        if (last_osc < 0 && osc > 0) v = VOLUME;
        else if (last_osc > 0 && osc < 0) v = - 1 * VOLUME;
        else v = 0;
        last_osc = osc;
        novo_dia (preco, dias);
        return createOrdemTO (Math.abs (v), preco, true);
    }
}


private void centerPlacedRows () {
    double maxRowSizeInPixels = 0;
    int rows = getRows ();
    double rowLengths [] = new double [rows];
    for (int curRow = 0; curRow < rows; curRow ++) {
        double thisRowLength = 0;
        thisRowLength = getRowWidth (curRow);
        rowLengths [curRow] = thisRowLength;
        if (thisRowLength > maxRowSizeInPixels) maxRowSizeInPixels = thisRowLength;
    }
    int shiftRight = 0;
    for (int curRow = 0; curRow < rows; curRow ++) {
        shiftRight = (int) ((maxRowSizeInPixels - rowLengths [curRow]) / 2);
        BOTLObjectSourceDiagramNode [] rowObjects = getObjectsInRow (curRow);
        for (int i = 0; i < rowObjects.length; i ++) rowObjects [i].setLocation (new Point ((int) (rowObjects [i].getLocation ().getX () + shiftRight), (int) (rowObjects [i].getLocation ().getY ())));
    }
}


-----Function Pair=18=-----==

public void removeSegment (int location) {
    numSegments --;
    tempTransformGroups = new TransformGroup [numSegments];
    temp = new int [numSegments];
    ChromosomeSegment newSegments [] = new ChromosomeSegment [numSegments];
    TransformGroup newTransformGroups [] = new TransformGroup [numSegments];
    int newPos [] = new int [numSegments];
    int index = locationToIndex (location);
    int deleted = currentPos [index];
    for (int i = 0; i < index; i ++) newPos [i] = currentPos [i];
    for (int i = index; i < newPos.length; i ++) newPos [i] = currentPos [i + 1];
    for (int i = 0; i < newPos.length; i ++) if (newPos [i] > deleted) newPos [i] --;
    for (int i = 0; i < deleted; i ++) {
        newSegments [i] = segments [i];
        newTransformGroups [i] = transformGroups [i];
    }
    for (int i = deleted; i < newSegments.length; i ++) {
        newSegments [i] = segments [i + 1];
        newTransformGroups [i] = transformGroups [i + 1];
    }
    segments = newSegments;
    transformGroups = newTransformGroups;
    currentPos = newPos;
}


public void computeScore (int heights []) {
    this.distanceToSet = 0;
    int [] surface = new int [ranks.getStackWidth () - 1];
    int maxJump = ranks.getMaxJump ();
    int nbstep = 0;
    int correctedSteepStep = 0;
    int indexSteepStep = 0;
    boolean isCliff = true;
    for (int i = 0; i < ranks.getStackWidth () - 1; i ++) {
        int diff = heights [i + 1] - heights [i];
        if (diff > maxJump) {
            nbstep ++;
            this.distanceToSet += (diff - maxJump);
            diff = maxJump;
        }
        if (diff < - maxJump) {
            nbstep ++;
            distanceToSet -= (diff + maxJump);
            diff = - maxJump;
        }
        surface [i] = diff;
    }
    log.debug ("new surface =" + Arrays.toString (surface));
    int surfaceNb = ranks.encode (surface);
    this.rankStacking = ranks.getRankValue (surfaceNb);
    if ((MAX_PREVIEWS > 0) && (this.distanceToSet > 0)) {
        this.rankStacking = 0;
    }
}


-----Function Pair=19=-----==

protected static void findvels_edges_known (double [] v, double [] x, double [] t, int n, int method) throws JuggleExceptionInternal {
    if (n < 2) return;
    double [] Adiag = new double [n - 1];
    double [] Aoffd = new double [n - 1];
    double [] b = new double [n - 1];
    for (int i = 0; i < n - 1; i ++) {
        switch (method) {
            case rmsaccel :
            case continaccel :
                Adiag [i] = 2.0 / t [i + 1] + 2.0 / t [i];
                Aoffd [i] = 1.0 / t [i + 1];
                b [i] = 3.0 * (x [i + 2] - x [i + 1]) / (t [i + 1] * t [i + 1]) + 3.0 * (x [i + 1] - x [i]) / (t [i] * t [i]);
                if (i == 0) b [0] -= v [0] / t [0];
                if (i == (n - 2)) b [n - 2] -= v [n] / t [n - 1];
                break;
            case rmsvel :
                Adiag [i] = 4.0 * (t [i] + t [i + 1]);
                Aoffd [i] = - t [i + 1];
                b [i] = 3.0 * (x [i + 2] - x [i]);
                if (i == 0) b [0] += v [0] * t [0];
                if (i == (n - 2)) b [n - 2] += v [n] * t [n - 1];
                break;
        }
    }
    double [] vtemp = new double [n - 1];
    tridag (Aoffd, Adiag, Aoffd, b, vtemp, n - 1);
    for (int i = 0; i < n - 1; i ++) v [i + 1] = vtemp [i];
}


public void readEpifile () {
    try {
        sorter ();
        listEps.removeAll ();
        String inputLine1, inputLine2;
        String pluginDir = pluginInterface.getPluginDirectoryName ();
        String eplist_file = pluginDir + System.getProperty ("file.separator") + "EpisodeList.txt";
        File episodeList = new File (eplist_file);
        if (! episodeList.isFile ()) {
            episodeList.createNewFile ();
        }
        final BufferedReader in = new BufferedReader (new FileReader (episodeList));
        int lineCounter = 1;
        int temp1 = 0;
        int temp2 = 0;
        String [] [] epiTemp = new String [1000] [2];
        while ((inputLine1 = in.readLine ()) != null) {
            if ((inputLine2 = in.readLine ()) != null) {
                epiTemp [temp1] [0] = inputLine1;
                epiTemp [temp1] [1] = inputLine2;
                ++ temp1;
            }
        }
        in.close ();
        for (int i = 0; i < (temp1); i ++) {
            addTableElementDouble (listEpsTree, epiTemp [i] [0], epiTemp [i] [1]);
        }
    } catch (Exception e) {
    }
}


-----Function Pair=20=-----==

static void changeWindowProperty (Client c, Window w, int property, int type, short format, byte mode, int len, byte [] value, boolean sendevent) throws IOException {
    synchronized (w) {
        Property p;
        int totalSize = len * (format / 8);
        p = w.getProperty ();
        while (p != null) {
            if (p.propertyName == property) break;
            p = p.next;
        }
        if (p != null) {
            if ((format != p.format) && (mode != PropModeReplace)) {
                System.err.println ("error!");
                c.errorReason = 8;
                return;
            }
            if ((type != p.type) && (mode != PropModeReplace)) {
                System.err.println ("error!");
                c.errorReason = 8;
                return;
            }
            if (mode == PropModeReplace) {
                p.data = value;
                p.size = len;
                p.format = format;
                p.type = type;
            }
            else if (len == 0) {
            }
            else if (mode == PropModeAppend) {
                byte [] foo = new byte [(format / 8) * (len + p.size)];
                if (p.size > 0) System.arraycopy (p.data, 0, foo, 0, p.size);
                System.arraycopy (value, 0, foo, p.size, totalSize);
                p.size += len;
                p.data = foo;
            }
            else if (mode == PropModePrepend) {
                byte [] foo = new byte [(format / 8) * (len + p.size)];
                System.arraycopy (value, 0, foo, 0, totalSize);
                if (p.size > 0) System.arraycopy (p.data, 0, foo, totalSize, p.size);
                p.size += len;
                p.data = foo;
            }
        }
        else {
            p = new Property ();
            p.propertyName = property;
            p.type = type;
            p.format = (short) format;
            p.data = value;
            p.size = len;
            p.next = w.getProperty ();
            w.setProperty (p);
        }
        if (p != null) {
            if (p.propertyName == 9 && w == w.screen.root && p.size > 0) {
                CopyPaste.setString (new String (p.data, 0, p.size));
            }
            if (w.screen.windowmode != WeirdX.InBrowser && p.propertyName == 39 && p.type == 31 && p.size > 0 && w.ddxwindow != null) {
                java.awt.Window frame = w.getFrame ();
                if (frame != null && (frame instanceof java.awt.Frame)) {
                    ((java.awt.Frame) frame).setTitle (new String (p.data));
                }
            }
        }
    }
    if (sendevent) {
        c.cevent.mkPropertyNotify (w.id, property, (int) System.currentTimeMillis (), 0);
        w.sendEvent (c.cevent, 1, null);
    }
}


private void init (Object [] data) {
    if (data == null) {
        return;
    }
    if (! (data [0] instanceof String [])) {
        throw new IllegalArgumentException ("Data sets passed to DataSetForApps " + "must begin with String[], with the " + "length of the array equal to the " + "number of attribute arrays that follow");
    }
    attributeNames = (String []) data [0];
    aliases = new Map [attributeNames.length];
    dataSetFull = new Object [dataObjectOriginal.length + 1];
    dataSetFull [0] = attributeNames;
    int len = attributeNames.length;
    dataType = new int [len];
    numNumericAttributes = 0;
    for (int i = 0; i < len; i ++) {
        if (data [i] instanceof SpatialWeights) {
            spatialWeights = (SpatialWeights) data [i];
        }
        if (data [i + 1] instanceof String []) {
            String attrName = attributeNames [i].toLowerCase ();
            if (attrName.endsWith ("name")) {
                dataType [i] = DataSetForApps.TYPE_NAME;
                observationNames = (String []) data [i + 1];
            }
        }
        else if (data [i + 1] instanceof double []) {
            dataType [i] = DataSetForApps.TYPE_DOUBLE;
            numNumericAttributes ++;
        }
        else if (data [i + 1] instanceof int []) {
            dataType [i] = DataSetForApps.TYPE_INTEGER;
            numNumericAttributes ++;
        }
        else if (data [i + 1] instanceof boolean []) {
            dataType [i] = DataSetForApps.TYPE_BOOLEAN;
            numNumericAttributes ++;
        }
        else {
            dataType [i] = DataSetForApps.TYPE_NONE;
        }
        dataSetFull [i + 1] = data [i + 1];
    }
    for (Object element : data) {
        if (element instanceof Shape []) {
            Shape [] temp = ((Shape []) element);
            if (temp [0] instanceof GeneralPathLine) {
                spatialType = DataSetForApps.SPATIAL_TYPE_LINE;
            }
            else {
                spatialType = DataSetForApps.SPATIAL_TYPE_POLYGON;
                break;
            }
        }
        else if (element instanceof Point2D []) {
            spatialType = DataSetForApps.SPATIAL_TYPE_POINT;
            break;
        }
        else if (element instanceof Geometry []) {
            spatialType = DataSetForApps.SPATIAL_TYPE_GEOMETRY;
            break;
        }
        else if (element instanceof List < ? >) {
            spatialType = DataSetForApps.SPATIAL_TYPE_MULTIPOINT;
            break;
        }
    }
    for (Object element : data) {
        if (element instanceof SpatialWeights) {
            spatialWeights = (SpatialWeights) element;
        }
    }
    int otherInfo = data.length - 1 - len;
    dataSetNumericAndSpatial = new Object [numNumericAttributes + 2 + otherInfo];
    dataSetNumeric = new Object [numNumericAttributes];
    if (otherInfo > 0) {
        for (int i = 0; i < otherInfo; i ++) {
            dataSetNumericAndSpatial [numNumericAttributes + 2 + i] = data [len + 1 + i];
            dataSetFull [len + 2 + i] = data [len + 1 + i];
        }
    }
    attributeNamesNumeric = new String [numNumericAttributes];
    int dataTypeIndex = 0;
    for (int i = 0; i < numNumericAttributes; i ++) {
        while ((dataType [dataTypeIndex]) < 1) {
            dataTypeIndex ++;
        }
        dataSetNumericAndSpatial [i + 1] = data [dataTypeIndex + 1];
        dataSetNumeric [i] = data [dataTypeIndex + 1];
        attributeNamesNumeric [i] = attributeNames [dataTypeIndex];
        dataTypeIndex ++;
    }
    dataSetNumericAndSpatial [0] = attributeNamesNumeric;
    if (observationNames != null) {
        dataSetNumericAndSpatial [numNumericAttributes + 1] = observationNames;
        dataSetFull [len + 1] = observationNames;
    }
    else {
        dataSetNumericAndSpatial [numNumericAttributes + 1] = null;
        dataSetFull [len + 1] = observationNames;
    }
    if (dataType [0] == DataSetForApps.TYPE_NAME) {
        numObservations = ((String []) dataObjectOriginal [1]).length;
    }
    else if (dataType [0] == DataSetForApps.TYPE_DOUBLE) {
        numObservations = ((double []) dataSetNumericAndSpatial [1]).length;
    }
    else if (dataType [0] == DataSetForApps.TYPE_INTEGER) {
        numObservations = ((int []) dataSetNumericAndSpatial [1]).length;
    }
    else if (dataType [0] == DataSetForApps.TYPE_BOOLEAN) {
        numObservations = ((boolean []) dataSetNumericAndSpatial [1]).length;
    }
}


-----Function Pair=21=-----==

public void setVisibles (int nArgs, FtsAtom args []) {
    int i = 0;
    int oldSize = size;
    size = args [0].intValue;
    visibleSize = args [1].intValue;
    firstVisIndex = args [2].intValue;
    visibles = new double [visibleSize + 10];
    if (isIvec ()) {
        if (isInGroup ()) for (i = 0; i < nArgs - 3; i ++) {
            postEdit (new UndoableValueSet (this, i, visibles [i]));
            visibles [i] = (double) args [i + 3].intValue;
        }
        else for (i = 0; i < nArgs - 3; i ++) visibles [i] = (double) args [i + 3].intValue;
    }
    else {
        if (isInGroup ()) for (i = 0; i < nArgs - 3 && i < visibles.length; i ++) {
            postEdit (new UndoableValueSet (this, i, visibles [i]));
            visibles [i] = args [i + 3].doubleValue;
        }
        else for (i = 0; i < nArgs - 3 && i < visibles.length; i ++) visibles [i] = args [i + 3].doubleValue;
    }
    if (size != oldSize) notifySizeChanged (size, oldSize);
    notifySet ();
}


void setTextAndLines (ImageRegion imageRegion, Picture pic, Transform tr) {
    for (int i = 0; i < textPos.length; i ++) {
        tr.xyzPos (textPos [i]);
        imageRegion.setTextPos (i, tr.X, tr.Y, tr.Z);
    }
    int line = 0;
    for (int i = 0; i < 8; i ++) {
        tr.xyzPos (cornersRGB [i]);
        corner [i] [0] = tr.X;
        corner [i] [1] = tr.Y;
        corner [i] [2] = tr.Z;
        corner [i] [3] = 0;
    }
    int [] [] cor = new int [3] [];
    for (int i = 0; i < 4; i ++) {
        int k = 0;
        for (int j = 4; j < 8; j ++) {
            if (i + j != 7) cor [k ++] = corner [j];
        }
        if (corner [i] [2] >= corner [7 - i] [2] && Misc.inside (corner [i], cor [0], cor [1], cor [2])) corner [i] [3] = 1;
    }
    for (int j = 4; j < 8; j ++) {
        int k = 0;
        for (int i = 0; i < 4; i ++) {
            if (i + j != 7) cor [k ++] = corner [i];
        }
        if (corner [j] [2] >= corner [7 - j] [2] && Misc.inside (corner [j], cor [0], cor [1], cor [2])) corner [j] [3] = 1;
    }
    for (int i = 0; i < 4; i ++) for (int j = 4; j < 8; j ++) {
        if (i + j != 7) {
            if (corner [i] [3] == 1 || corner [j] [3] == 1) imageRegion.setLine (line, corner [i] [0], corner [i] [1], corner [j] [0], corner [j] [1], 1, backColor);
            else imageRegion.setLine (line, corner [i] [0], corner [i] [1], corner [j] [0], corner [j] [1], - 1, frontColor);
            line ++;
        }
    }
    cor = null;
}


-----Function Pair=22=-----==

protected void restoreFromSave (final TIntObjectHashMap _sauv, final boolean _structureChanged) {
    final TIntObjectIterator it = _sauv.iterator ();
    int idx;
    for (int i = _sauv.size (); i -- > 0;) {
        it.advance ();
        idx = it.key ();
        bcArray_ [idx].restoreEvolUsed ((H2dRefluxBoundaryCondition) it.value ());
        bcArray_ [idx] = (H2dRefluxBoundaryCondition) it.value ();
    }
    if (_structureChanged) {
        fireBcFrontierStructureChanged (this);
    }
    else {
        fireParametersForBoundaryPtsChange ();
    }
}


private void fill () throws IOException {
    if (! seenEOF) {
        if (pos > 0 && pos < limit) {
            System.arraycopy (inbuf, pos, inbuf, 0, limit - pos);
            limit = limit - pos;
            pos = 0;
        }
        else if (pos >= limit) {
            pos = 0;
            limit = 0;
        }
        int bsize = inbuf.length;
        while (limit < bsize) {
            int n = underlyingInputStream.read (inbuf, limit, bsize - limit);
            if (n <= 0) {
                seenEOF = true;
                break;
            }
            limit += n;
        }
    }
}


-----Function Pair=23=-----==

public int removePlayer (Player pl) {
    if (pl == null || num_players == 0 || num_filled == 0) {
        System.out.println ("ERROR: null player or no players in BattleGame.removePlayer");
        return BG_STATUS_NOADD;
    }
    int idx = getPlayerIndex (pl.getPlayerID ());
    if (idx >= 0 && idx < num_filled) {
        for (int i = idx; i < (num_filled - 1); i ++) {
            players [i] = players [i + 1];
        }
        players [num_filled - 1] = null;
        num_filled --;
    }
    status = BG_STATUS_AWAIT;
    return status;
}


public static byte [] toByteArray (final String data) {
    final String [] parts = data.split ("\\|");
    final byte [] bytes = new byte [parts.length];
    for (int i = 0; i < parts.length; ++ i) {
        if (parts [i].length () != 8) {
            throw new IllegalArgumentException ("Byte value doesn't contain 8 bit: " + parts [i]);
        }
        else {
            try {
                bytes [i] = (byte) Integer.parseInt (parts [i], 2);
            } catch (NumberFormatException e) {
                throw new IllegalArgumentException (e);
            }
        }
    }
    return bytes;
}


-----Function Pair=24=-----==

private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


void buildCondRegion (Vector region) throws IOException {
    Vector intern = new Vector ();
    for (;;) {
        String inLine = readLine ();
        if (inLine == null) throw new IOException ("Unexpected end of file");
        if (isTemplateLine (inLine)) {
            int command = getTemplateCommand (inLine);
            if (command == END) {
                region.addElement (intern);
                break;
            }
            else if (command == ELSE) {
                region.addElement (intern);
                intern = new Vector ();
            }
            else {
                intern.addElement (buildTemplateRegion (inLine));
            }
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            intern.addElement (inLine);
        }
    }
}


-----Function Pair=25=-----==

private void update () {
    char [] sID = g.getSpecialID ().toCharArray ();
    for (int i = 0; i < 20; i ++) {
        if (sID [i] != '#') {
            switch (sID [i]) {
                case 'a' :
                    sID [i + 1] = sID [i + 4] = sID [i + 5] = '#';
                    ImageIcon a1 = new ImageIcon ("images/a.gif");
                    pieces [i].setName ("a");
                    pieces [i + 1].setName ("a");
                    pieces [i + 4].setName ("a");
                    pieces [i + 5].setName ("a");
                    pieces [i].setBackground (chooseColor ("a"));
                    pieces [i + 1].setBackground (chooseColor ("a"));
                    pieces [i + 4].setBackground (chooseColor ("a"));
                    pieces [i + 5].setBackground (chooseColor ("a"));
                    pieces [i].setIcon (a1);
                    pieces [i + 1].setIcon (a1);
                    pieces [i + 4].setIcon (a1);
                    pieces [i + 5].setIcon (a1);
                    break;
                case 'b' :
                case 'c' :
                case 'd' :
                case 'e' :
                case 'f' :
                    sID [i + 4] = '#';
                    ImageIcon b1 = new ImageIcon ("images/b1.gif");
                    ImageIcon b2 = new ImageIcon ("images/b2.gif");
                    pieces [i].setName ("" + sID [i]);
                    pieces [i].setBackground (chooseColor ("" + sID [i]));
                    pieces [i].setIcon (b1);
                    pieces [i + 4].setName ("" + sID [i]);
                    pieces [i + 4].setBackground (chooseColor ("" + sID [i]));
                    pieces [i + 4].setIcon (b2);
                    break;
                case 'B' :
                case 'C' :
                case 'D' :
                case 'E' :
                case 'F' :
                    sID [i + 1] = '#';
                    ImageIcon e1 = new ImageIcon ("images/e1.gif");
                    ImageIcon e2 = new ImageIcon ("images/e2.gif");
                    pieces [i].setName ("" + sID [i]);
                    pieces [i].setBackground (chooseColor ("" + sID [i]));
                    pieces [i].setIcon (e1);
                    pieces [i + 1].setName ("" + sID [i]);
                    pieces [i + 1].setBackground (chooseColor ("" + sID [i]));
                    pieces [i + 1].setIcon (e2);
                    break;
                case 'g' :
                case 'h' :
                case 'i' :
                case 'j' :
                    ImageIcon g = new ImageIcon ("images/g.gif");
                    pieces [i].setName ("" + sID [i]);
                    pieces [i].setBackground (chooseColor ("" + sID [i]));
                    pieces [i].setIcon (g);
                    break;
                default :
                    pieces [i].setIcon (null);
                    pieces [i].setName (" ");
                    pieces [i].setBackground (chooseColor (" "));
            }
            pieces [i].setName ("" + sID [i]);
            pieces [i].setBackground (chooseColor ("" + g.getSpecialID ().charAt (i)));
        }
    }
}


public FileNameGroup (String line) {
    executable_ = false;
    recursive_ = true;
    if (line.startsWith ("(E)")) {
        line = line.substring (3);
        executable_ = true;
    }
    if (line.startsWith ("(N)")) {
        line = line.substring (3);
        recursive_ = false;
    }
    StringTokenizer tok = new StringTokenizer (new String (line), "|", true);
    originBase_ = tok.nextToken ();
    if (originBase_.endsWith ("/")) originBase_ = originBase_.substring (0, originBase_.length () - 1);
    tok.nextToken ();
    destBase_ = tok.nextToken ();
    if (destBase_.equals ("|")) destBase_ = null;
    else {
        if (destBase_.endsWith ("/")) destBase_ = destBase_.substring (0, destBase_.length () - 1);
        tok.nextToken ();
    }
    extensions_ = null;
    commonPath_ = null;
    if (tok.hasMoreTokens ()) {
        commonPath_ = tok.nextToken ();
        if (commonPath_.equals ("|")) commonPath_ = null;
        if (tok.hasMoreTokens ()) {
            if (commonPath_ != null) tok.nextToken ();
            if (tok.hasMoreTokens ()) extensions_ = tok.nextToken ();
        }
    }
}


-----Function Pair=26=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


public String oblicz (String type) {
    for (int i = 0; i < inArt; i ++) {
        boolean operFound = false;
        String temp = art [i];
        if (! temp.equalsIgnoreCase ("-")) {
            temp = ujemne (temp);
        }
        int len1 = temp.length ();
        if (len1 > 0) {
            if ((temp.charAt (0) == 40) && (temp.charAt (len1 - 1) == 41)) {
                temp = temp.substring (1, len1 - 1);
            }
        }
        String arg1 = "";
        String arg2 = "";
        String oper = "";
        int len = temp.length ();
        boolean olej = false;
        for (int k = 0; k < len; k ++) {
            if (operFound) {
                arg2 = arg2 + temp.charAt (k);
            }
            if ((isAryt (temp.charAt (k) + "")) && (k != 0)) {
                if (k == 0) {
                    if ((temp.charAt (k) + "").equals ("-")) {
                        olej = true;
                    }
                }
                if (k >= 1) {
                    if (isAryt (temp.charAt (k - 1) + "")) {
                        olej = true;
                    }
                    if ((temp.charAt (k - 1) + "").equals ("(")) {
                        olej = true;
                    }
                }
                if (! olej) {
                    operFound = true;
                    oper = temp.charAt (k) + "";
                }
                olej = false;
            }
            if (! operFound) {
                arg1 = arg1 + temp.charAt (k);
            }
        }
        String wynik = licz (arg1, arg2, oper, type);
        if (wynik.length () > 0) {
            art [i] = wynik;
        }
        oper = "";
        arg1 = "";
        arg2 = "";
    }
    return "aaa";
}


-----Function Pair=27=-----==

private String [] toArgs (String line) {
    String lineargs [];
    String str = new String (line);
    Vector vec = new Vector ();
    for (;;) {
        while (str.startsWith (" ")) str = str.substring (1);
        if (str.length () == 0) break;
        int end = str.indexOf (" ");
        if (end == - 1) {
            vec.addElement (str);
            str = "";
        }
        else {
            vec.addElement (str.substring (0, end));
            str = str.substring (end);
        }
    }
    if (vec.size () != 0) {
        lineargs = new String [vec.size ()];
        for (int i = 0; i < lineargs.length; ++ i) lineargs [i] = (String) vec.elementAt (i);
        return lineargs;
    }
    return null;
}


public static < T1, T2 extends T1 > T1 [] mergeExclusive (Class < T1 > type, T2 []...arrays) {
    if (arrays.length == 0) return (T1 []) Array.newInstance (type, 0);
    java.util.ArrayList < Object > retSet = new java.util.ArrayList < Object > ();
    int i, j, k;
    for (j = 0; j < arrays [0].length; j ++) retSet.add (arrays [0] [j]);
    for (i = 1; i < arrays.length; i ++) {
        for (j = 0; j < retSet.size (); j ++) {
            boolean hasEl = false;
            for (k = 0; k < arrays [i].length; k ++) if (equalsUnordered (retSet.get (j), arrays [i] [k])) {
                hasEl = true;
                break;
            }
            if (! hasEl) {
                retSet.remove (j);
                j --;
            }
        }
    }
    return retSet.toArray ((T1 []) Array.newInstance (type, retSet.size ()));
}


-----Function Pair=28=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


-----Function Pair=29=-----==

private edu.cmu.sphinx.decoder.linguist.SentenceHMMState expandHMMTree (ParallelHMMStateState hmmStateState, String modelName, Map expandedStates) {
    edu.cmu.sphinx.decoder.linguist.SentenceHMMState lastState = hmmStateState;
    HMMState hmmState = hmmStateState.getHMMState ();
    HMMStateArc [] arcs = hmmState.getSuccessors ();
    for (int i = 0; i < arcs.length; i ++) {
        HMMState nextHmmState = arcs [i].getHMMState ();
        if (nextHmmState == hmmState) {
            attachState (hmmStateState, hmmStateState, logMath.linearToLog (arcs [i].getProbability ()), logMath.getLogOne (), logMath.getLogOne ());
            lastState = hmmStateState;
        }
        else {
            ParallelHMMStateState nextState = null;
            if (expandedStates.containsKey (nextHmmState)) {
                nextState = (ParallelHMMStateState) expandedStates.get (nextHmmState);
            }
            else {
                nextState = new ParallelHMMStateState (hmmStateState.getParent (), modelName, nextHmmState, tokenStackCapacity);
                expandedStates.put (nextHmmState, nextState);
            }
            nextState.setColor (Color.GREEN);
            attachState (hmmStateState, nextState, logMath.linearToLog (arcs [i].getProbability ()), logMath.getLogOne (), logMath.getLogOne ());
            lastState = expandHMMTree (nextState, modelName, expandedStates);
        }
    }
    return lastState;
}


public static String [] varParseField (String name) {
    String remain;
    String thisfield = name;
    int dot1, dot2, bracket;
    int numfield = varCountField (name);
    String fields [] = new String [numfield];
    remain = name;
    if (numfield == 0) {
        return null;
    }
    for (int i = 0; i < numfield; i ++) {
        dot1 = remain.indexOf ('.');
        dot2 = remain.indexOf ('.', dot1 + 1);
        if (dot1 != - 1 && dot2 != - 1) {
            thisfield = remain.substring (dot1 + 1, dot2);
            remain = remain.substring (dot1 + 1);
        }
        else if (dot1 != - 1 && dot2 == - 1) {
            thisfield = remain.substring (dot1 + 1);
        }
        else {
            System.out.println ("ERROR: parsing " + name);
        }
        bracket = thisfield.indexOf ('[');
        if (bracket != - 1) {
            fields [i] = thisfield.substring (0, bracket);
        }
        else {
            fields [i] = thisfield;
        }
    }
    return fields;
}


-----Function Pair=30=-----==

protected boolean readEphCoeff (double jultime) {
    boolean result = false;
    if ((jultime < this.startepoch) || (jultime >= this.finalepoch)) {
        return result;
    }
    if ((jultime < this.ephemerisdates [1]) || (jultime >= this.ephemerisdates [2])) {
        int i = 0;
        int records = 0;
        int j = 0;
        String filename = " ";
        char [] cline = new char [80];
        try {
            for (i = 0; i < startfiledates.length - 1; i ++) {
                if ((jultime >= startfiledates [i]) && (jultime < startfiledates [i + 1])) {
                    ephemerisdates [1] = startfiledates [i];
                    ephemerisdates [2] = startfiledates [i + 1];
                    filename = filenames [i];
                    records = (int) ((ephemerisdates [2] - ephemerisdates [1]) / intervalduration);
                }
            }
            filename = this.patheph + filename;
            FileReader file = new FileReader (filename);
            for (j = 1; j <= records; j ++) {
                file.read (cline, 0, 13);
                for (i = 2; i <= 341; i ++) {
                    file.read (cline, 0, 79);
                    cline [22] = 'e';
                    cline [48] = 'e';
                    cline [74] = 'e';
                    if (i > 2) {
                        ephemeriscoefficients [(j - 1) * numbersperinterval + (3 * (i - 2) - 1)] = Double.parseDouble (String.valueOf (cline, 1, 25));
                    }
                    if ((i > 2) & (i < 341)) {
                        ephemeriscoefficients [(j - 1) * numbersperinterval + 3 * (i - 2)] = Double.parseDouble (String.valueOf (cline, 27, 25));
                    }
                    if (i < 341) {
                        ephemeriscoefficients [(j - 1) * numbersperinterval + (3 * (i - 2) + 1)] = Double.parseDouble (String.valueOf (cline, 53, 25));
                    }
                }
            }
            file.close ();
            result = true;
        } catch (IOException e) {
            System.out.println ("Error = " + e.toString ());
        } catch (StringIndexOutOfBoundsException e) {
            System.out.println ("Error = " + e.toString ());
        }
    }
    else {
        result = true;
    }
    return result;
}


private void insertChildInternal (int index) {
    int oldCount = this.realChildCount;
    int newCount = (index > oldCount ? index : oldCount) + 1;
    if (this.children == null || newCount > this.children.length) {
        int length = this.children == null ? CHILDREN_START_LENGTH : this.children.length;
        while (length < newCount) {
            length <<= 1;
        }
        RAMObject [] newChildren = new RAMObject [length];
        int i;
        for (i = 0; i < index && i < oldCount; i ++) {
            newChildren [i] = this.children [i];
        }
        for (; i < oldCount; i ++) {
            newChildren [i + 1] = this.children [i];
        }
        this.children = newChildren;
    }
    else {
        for (int i = oldCount; i > index; i --) {
            this.children [i] = this.children [i - 1];
        }
        this.children [index] = null;
    }
    this.realChildCount = newCount;
}


-----Function Pair=31=-----==

public static Collection combineOverlappingFeatures (Collection features, FeatureSchema featureSchema) {
    ArrayList < Geometry > noLineStrings = new ArrayList < Geometry > ();
    boolean hasASHS_ID = featureSchema.hasAttribute ("ASHS_ID");
    for (Iterator j = features.iterator (); j.hasNext ();) {
        Feature f1 = (Feature) j.next ();
        Geometry geo1 = makeClosedLineStringsPolygons (f1.getGeometry ());
        if (! (geo1 instanceof LineString)) {
            if (hasASHS_ID) {
                try {
                    String id = f1.getString ("ASHS_ID");
                    if (id != "") geo1.setUserData (id);
                } catch (Exception ex) {
                }
            }
            noLineStrings.add (geo1);
        }
    }
    GeometryFactory geometryFactory = new GeometryFactory ();
    ArrayList < Geometry > alreadyProcessed = new ArrayList < Geometry > ();
    ArrayList < Feature > combinedFeatures = new ArrayList < Feature > ();
    for (Iterator j = noLineStrings.iterator (); j.hasNext ();) {
        Geometry geo1 = (Geometry) j.next ();
        if (alreadyProcessed.contains (geo1)) continue;
        ArrayList < Geometry > overlappingGeometries = new ArrayList < Geometry > ();
        overlappingGeometries.add (geo1);
        for (Iterator i = noLineStrings.iterator (); i.hasNext ();) {
            Geometry geo2 = (Geometry) i.next ();
            if (geo1 == geo2 || alreadyProcessed.contains (geo2)) continue;
            if (geo1.intersects (geo2)) {
                overlappingGeometries.add (geo2);
                alreadyProcessed.add (geo2);
            }
        }
        Geometry geo3 = geometryFactory.buildGeometry (overlappingGeometries);
        String id = "";
        if (hasASHS_ID) {
            for (Iterator i = overlappingGeometries.iterator (); i.hasNext ();) {
                Geometry geo = (Geometry) i.next ();
                String id2 = (String) geo.getUserData ();
                if (id2 != null && ! id2.isEmpty ()) {
                    id = id2;
                    break;
                }
            }
        }
        Feature newFeature = new BasicFeature (featureSchema);
        newFeature.setGeometry (geo3);
        if (hasASHS_ID && ! id.isEmpty ()) {
            newFeature.setAttribute ("ASHS_ID", id);
        }
        combinedFeatures.add (newFeature);
    }
    return combinedFeatures;
}


public static BigInteger [] mulCiphertexts (BigInteger [] a, BigInteger [] b, FHEParams fheparams, BigInteger det, BigInteger root, BigInteger [] pkBlocksX, BigInteger [] ctxts, GHKeyPair key, IProgressMonitor monitor, int work) {
    int max = Math.max (a.length, b.length);
    BigInteger [] aTemp = new BigInteger [a.length];
    BigInteger [] bTemp = new BigInteger [b.length];
    for (int i = 0; i < a.length; i ++) aTemp [i] = a [i];
    for (int i = 0; i < b.length; i ++) bTemp [i] = b [i];
    BigInteger [] temp = new BigInteger [max];
    BigInteger [] temp2 = new BigInteger [max];
    for (int i = 0; i < max; i ++) {
        temp [i] = GHEncrypt.encrypt (fheparams, key, 0);
    }
    for (int i = 0; i < aTemp.length; i ++) {
        for (int j = 0; j < bTemp.length; j ++) {
            temp2 [j] = GHReCrypt.recrypt (fheparams, bTemp [j].multiply (aTemp [0]).mod (det), det, root, pkBlocksX, ctxts);
        }
        SubProgressMonitor sm = new SubProgressMonitor (monitor, work / aTemp.length);
        sm.beginTask ("", work / aTemp.length);
        temp = addCiphertexts (temp, temp2, fheparams, det, root, pkBlocksX, ctxts, sm, work / aTemp.length);
        if (sm.isCanceled ()) return null;
        sm.done ();
        for (int k = 0; k < aTemp.length - 1; k ++) {
            aTemp [k] = aTemp [k + 1];
        }
        aTemp [aTemp.length - 1] = temp [0];
        for (int k = 0; k < temp.length - 1; k ++) {
            temp [k] = temp [k + 1];
        }
        if (monitor.isCanceled ()) {
            return null;
        }
    }
    return aTemp;
}


-----Function Pair=32=-----==

boolean is3ByteRGB (RenderedImage ri) {
    boolean value = false;
    int i;
    ColorModel cm = ri.getColorModel ();
    ColorSpace cs = cm.getColorSpace ();
    SampleModel sm = ri.getSampleModel ();
    boolean isAlphaPre = cm.isAlphaPremultiplied ();
    int csType = cs.getType ();
    if (csType == ColorSpace.TYPE_RGB) {
        int numBands = sm.getNumBands ();
        if ((numBands == 3) && (sm.getDataType () == DataBuffer.TYPE_BYTE)) {
            if (cm instanceof ComponentColorModel && sm instanceof PixelInterleavedSampleModel) {
                PixelInterleavedSampleModel csm = (PixelInterleavedSampleModel) sm;
                int [] offs = csm.getBandOffsets ();
                ComponentColorModel ccm = (ComponentColorModel) cm;
                int [] nBits = ccm.getComponentSize ();
                boolean is8Bit = true;
                for (i = 0; i < numBands; i ++) {
                    if (nBits [i] != 8) {
                        is8Bit = false;
                        break;
                    }
                }
                if (is8Bit && offs [0] == 0 && offs [1] == 1 && offs [2] == 2) {
                    value = true;
                }
            }
        }
    }
    return value;
}


private void calculateMultipleArrayGradient (Color [] loColors, Color [] hiColors) {
    isSimpleLookup = false;
    int rgb1;
    int rgb2;
    int aveA = 0x008000;
    int aveR = 0x008000;
    int aveG = 0x008000;
    int aveB = 0x008000;
    for (int i = 0; i < gradients.length; i ++) {
        if (normalizedIntervals [i] == 0) continue;
        gradients [i] = new int [GRADIENT_SIZE];
        rgb1 = loColors [i].getRGB ();
        rgb2 = hiColors [i].getRGB ();
        interpolate (rgb1, rgb2, gradients [i]);
        int argb = gradients [i] [GRADIENT_SIZE / 2];
        float norm = normalizedIntervals [i];
        aveA += (int) (((argb>> 8) & 0xFF0000) * norm);
        aveR += (int) (((argb) & 0xFF0000) * norm);
        aveG += (int) (((argb << 8) & 0xFF0000) * norm);
        aveB += (int) (((argb << 16) & 0xFF0000) * norm);
        transparencyTest &= rgb1;
        transparencyTest &= rgb2;
    }
    gradientAverage = (((aveA & 0xFF0000) << 8) | ((aveR & 0xFF0000)) | ((aveG & 0xFF0000)>> 8) | ((aveB & 0xFF0000)>> 16));
    if (colorSpace == LinearGradientPaint.LINEAR_RGB) {
        if (dataModel.getColorSpace () == ColorSpace.getInstance (ColorSpace.CS_sRGB)) {
            for (int j = 0; j < gradients.length; j ++) {
                for (int i = 0; i < gradients [j].length; i ++) {
                    gradients [j] [i] = convertEntireColorLinearRGBtoSRGB (gradients [j] [i]);
                }
            }
            gradientAverage = convertEntireColorLinearRGBtoSRGB (gradientAverage);
        }
    }
    else {
        if (dataModel.getColorSpace () == ColorSpace.getInstance (ColorSpace.CS_LINEAR_RGB)) {
            for (int j = 0; j < gradients.length; j ++) {
                for (int i = 0; i < gradients [j].length; i ++) {
                    gradients [j] [i] = convertEntireColorSRGBtoLinearRGB (gradients [j] [i]);
                }
            }
            gradientAverage = convertEntireColorSRGBtoLinearRGB (gradientAverage);
        }
    }
}


-----Function Pair=33=-----==

public synchronized void drawLink (Graphics2D g, Element param) {
    for (int i = 0; i < layerSize; i ++) {
        Hashtable < String, ElementWithStlength > table = param.groupTable.get (params [i]);
        if (table != null) {
            for (final Enumeration < ElementWithStlength > en = table.elements (); en.hasMoreElements ();) {
                Element child = en.nextElement ().element;
                line.x1 = param.x;
                line.y1 = param.y;
                line.x2 = child.x;
                line.y2 = child.y;
                g.draw (line);
            }
        }
    }
}


public static IProject CreateJavaProject (String name, IPath classpath) throws CoreException {
    IWorkspace workspace = ResourcesPlugin.getWorkspace ();
    IWorkspaceRoot root = workspace.getRoot ();
    IProject project = root.getProject (name);
    project.create (null);
    project.open (null);
    IProjectDescription desc = project.getDescription ();
    desc.setNatureIds (new String [] {JavaCore.NATURE_ID});
    project.setDescription (desc, null);
    IJavaProject javaProj = JavaCore.create (project);
    IFolder binDir = project.getFolder ("bin");
    IPath binPath = binDir.getFullPath ();
    javaProj.setOutputLocation (binPath, null);
    IClasspathEntry cpe = JavaCore.newLibraryEntry (classpath, null, null);
    javaProj.setRawClasspath (new IClasspathEntry [] {cpe}, null);
    return project;
}


-----Function Pair=34=-----==

void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processLoopRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in LOOP");
    String var_name = pst.nextToken ();
    Vector valvec = new Vector ();
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) valvec.addElement (Integer.toString (j));
        }
        else valvec.addElement (v_i);
    }
    String [] values = new String [valvec.size ()];
    for (int i = 0; i < values.length; i ++) values [i] = (String) valvec.elementAt (i);
    if (DEBUG) System.out.println ("doing loop with varname " + var_name + " on values :" + params.substring (var_name.length () + 1));
    for (int curValue = 0; curValue < values.length; curValue ++) {
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name + "." + indexField, Integer.toString (curValue));
                result = substitute (result, var_name, values [curValue]);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name + "." + indexField, Integer.toString (curValue));
                newRegion = substituteInRegion (newRegion, var_name, values [curValue]);
                processTemplateRegion (newRegion);
            }
        }
    }
}


-----Function Pair=35=-----==

void processJoinRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in JOIN");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing separators in JOIN");
    String sep = pst.nextToken ();
    int numValues = pst.countTokens ();
    String value = "";
    if (pst.hasMoreTokens ()) {
        value = pst.nextToken ();
        for (int i = 1; i < numValues; i ++) value += sep + pst.nextToken ();
    }
    if (DEBUG) System.out.println ("doing join with varname " + var_name + " and value=\"" + value + "\"");
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


-----Function Pair=36=-----==

private void processAuto (final String [] part) {
    if (part.length < AUTO_PARTS) {
        usage (AUTO);
        return;
    }
    String name = part [1];
    String autoSettingStr = part [2];
    boolean autoSetting;
    if (autoSettingStr.equalsIgnoreCase ("true")) {
        autoSetting = true;
    }
    else if (autoSettingStr.equalsIgnoreCase ("false")) {
        autoSetting = false;
    }
    else {
        usage (AUTO);
        return;
    }
    if (name.equalsIgnoreCase (ALL)) {
        cp.autoAll (autoSetting);
    }
    else {
        Agent person;
        try {
            person = (Agent) control.getWorld ().getPersonByName (name);
        } catch (AgentNotFoundException e) {
            sendError ("Who's " + name + "?");
            return;
        }
        cp.auto (person, autoSetting);
    }
    sendOk ();
}


public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
        Platform.printbp ();
    }
}


-----Function Pair=37=-----==

public void setCodesets (int tcsc, int tcsw) {
    if (tcsc != 0) {
        m_char_enc = CodeSetDatabase.getNameFromId (tcsc);
        if (CodeSetDatabase.getAlignmentFromId (tcsc) > 1) {
            throw new org.omg.CORBA.CODESET_INCOMPATIBLE (0, org.omg.CORBA.CompletionStatus.COMPLETED_NO);
        }
    }
    if (tcsw == 0) {
        m_wchar_enc = null;
    }
    else {
        m_wchar_enc = CodeSetDatabase.getNameFromId (tcsw);
        if (m_wchar_enc.equals ("UnicodeBigUnmarked")) {
            m_wchar_enc = "UnicodeBig";
        }
        m_wchar_align = CodeSetDatabase.getAlignmentFromId (tcsw);
        if (m_version.minor == 1 && m_wchar_align != 2) {
            throw new org.omg.CORBA.CODESET_INCOMPATIBLE (0, org.omg.CORBA.CompletionStatus.COMPLETED_NO);
        }
        if (m_swap && m_wchar_align > 1) {
            String canonical = CodeSetDatabase.getCanonicalNameFromId (tcsw);
            if (canonical.startsWith ("Unicode")) {
                if (m_version.minor == 1) {
                    m_wchar_enc = "UnicodeLittle";
                }
            }
            else {
                m_wchar_reverse = true;
            }
        }
    }
    if (getLogger ().isDebugEnabled () && Trace.isHigh ()) {
        getLogger ().debug ("New codesets for input stream set to [" + m_char_enc + "] and [" + m_wchar_enc + "].");
    }
}


private void load (String fileName, HashMap < Integer, List < Integer > > map) {
    try {
        java.io.File f = new java.io.File (basePath + fileName + ".ser");
        if (f.exists ()) {
            InputStream file = new FileInputStream (basePath + fileName + ".ser");
            InputStream buffer = new BufferedInputStream (file);
            ObjectInputStream in = new ObjectInputStream (buffer);
            map.putAll ((HashMap < Integer, List < Integer > >) in.readObject ());
            in.close ();
        }
        else {
            loadData (fileName, map);
            log.debug ("Loaded file:" + fileName);
            try {
                OutputStream file = new FileOutputStream (basePath + fileName + ".ser");
                OutputStream buffer = new BufferedOutputStream (file);
                ObjectOutputStream out = new ObjectOutputStream (buffer);
                out.writeObject (map);
                out.close ();
            } catch (IOException ex) {
                ex.printStackTrace ();
            }
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=38=-----==

Vector substituteInRegion (Vector region, String var, String [] fields, String [] fieldData) throws IOException {
    Vector newRegion = new Vector (region.size ());
    for (int i = 0; i < region.size (); i ++) {
        Object el = region.elementAt (i);
        try {
            String s = (String) el;
            String r = substitute (s, var, fields, fieldData);
            newRegion.addElement (r);
        } catch (ClassCastException e) {
            Vector s = (Vector) el;
            Vector r = substituteInRegion (s, var, fields, fieldData);
            newRegion.addElement (r);
        }
    }
    return newRegion;
}


public static BufferedImage convertToRGB (BufferedImage image, boolean keepAlpha) {
    if (! isRGB (image) || isIndexed (image) || (! keepAlpha && hasAlpha (image))) {
        ColorModel cm = (keepAlpha && hasAlpha (image)) ? aRGB : RGB;
        BufferedImage temp = convert.createCompatibleDestImage (image, cm);
        temp = convert.filter (image, temp);
        BufferedImage result = temp;
        if (isIndexed (image)) {
            IndexColorModel icm = (IndexColorModel) image.getColorModel ();
            int trans = icm.getTransparentPixel ();
            if (trans >= 0) {
                result = convert.createCompatibleDestImage (image, cm);
                Graphics2D g2d = result.createGraphics ();
                Color c = new Color (icm.getRGB (trans));
                g2d.setColor (c);
                g2d.fillRect (0, 0, image.getWidth (), image.getHeight ());
                g2d.drawImage (temp, 0, 0, null);
                g2d.dispose ();
            }
        }
        image.flush ();
        temp.flush ();
        return result;
    }
    return image;
}


-----Function Pair=39=-----==

public void visitSwitch (JCSwitch tree) {
    int limit = code.nextreg;
    assert tree.selector.type.tag != CLASS;
    int startpcCrt = genCrt ? code.curPc () : 0;
    Item sel = genExpr (tree.selector, syms.intType);
    List < JCCase > cases = tree.cases;
    if (cases.isEmpty ()) {
        sel.load ().drop ();
        if (genCrt) code.crt.put (TreeInfo.skipParens (tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc ());
    }
    else {
        sel.load ();
        if (genCrt) code.crt.put (TreeInfo.skipParens (tree.selector), CRT_FLOW_CONTROLLER, startpcCrt, code.curPc ());
        Env < GenContext > switchEnv = env.dup (tree, new GenContext ());
        switchEnv.info.isSwitch = true;
        int lo = Integer.MAX_VALUE;
        int hi = Integer.MIN_VALUE;
        int nlabels = 0;
        int [] labels = new int [cases.length ()];
        int defaultIndex = - 1;
        List < JCCase > l = cases;
        for (int i = 0; i < labels.length; i ++) {
            if (l.head.pat != null) {
                int val = ((Number) l.head.pat.type.constValue ()).intValue ();
                labels [i] = val;
                if (val < lo) lo = val;
                if (hi < val) hi = val;
                nlabels ++;
            }
            else {
                assert defaultIndex == - 1;
                defaultIndex = i;
            }
            l = l.tail;
        }
        long table_space_cost = 4 + ((long) hi - lo + 1);
        long table_time_cost = 3;
        long lookup_space_cost = 3 + 2 * (long) nlabels;
        long lookup_time_cost = nlabels;
        int opcode = nlabels > 0 && table_space_cost + 3 * table_time_cost <= lookup_space_cost + 3 * lookup_time_cost ? tableswitch : lookupswitch;
        int startpc = code.curPc ();
        code.emitop0 (opcode);
        code.align (4);
        int tableBase = code.curPc ();
        int [] offsets = null;
        code.emit4 (- 1);
        if (opcode == tableswitch) {
            code.emit4 (lo);
            code.emit4 (hi);
            for (long i = lo; i <= hi; i ++) {
                code.emit4 (- 1);
            }
        }
        else {
            code.emit4 (nlabels);
            for (int i = 0; i < nlabels; i ++) {
                code.emit4 (- 1);
                code.emit4 (- 1);
            }
            offsets = new int [labels.length];
        }
        Code.State stateSwitch = code.state.dup ();
        code.markDead ();
        l = cases;
        for (int i = 0; i < labels.length; i ++) {
            JCCase c = l.head;
            l = l.tail;
            int pc = code.entryPoint (stateSwitch);
            if (i != defaultIndex) {
                if (opcode == tableswitch) {
                    code.put4 (tableBase + 4 * (labels [i] - lo + 3), pc - startpc);
                }
                else {
                    offsets [i] = pc - startpc;
                }
            }
            else {
                code.put4 (tableBase, pc - startpc);
            }
            genStats (c.stats, switchEnv, CRT_FLOW_TARGET);
        }
        code.resolve (switchEnv.info.exit);
        if (code.get4 (tableBase) == - 1) {
            code.put4 (tableBase, code.entryPoint (stateSwitch) - startpc);
        }
        if (opcode == tableswitch) {
            int defaultOffset = code.get4 (tableBase);
            for (long i = lo; i <= hi; i ++) {
                int t = (int) (tableBase + 4 * (i - lo + 3));
                if (code.get4 (t) == - 1) code.put4 (t, defaultOffset);
            }
        }
        else {
            if (defaultIndex >= 0) for (int i = defaultIndex; i < labels.length - 1; i ++) {
                labels [i] = labels [i + 1];
                offsets [i] = offsets [i + 1];
            }
            if (nlabels > 0) qsort2 (labels, offsets, 0, nlabels - 1);
            for (int i = 0; i < nlabels; i ++) {
                int caseidx = tableBase + 8 * (i + 1);
                code.put4 (caseidx, labels [i]);
                code.put4 (caseidx + 4, offsets [i]);
            }
        }
    }
    code.endScopes (limit);
}


public SOCTradeOffer makeCounterOffer (SOCTradeOffer originalOffer) {
    D.ebugPrintln ("***** MAKE COUNTER OFFER *****");
    SOCTradeOffer counterOffer = null;
    SOCPossiblePiece targetPiece = targetPieces [ourPlayerData.getPlayerNumber ()];
    if (targetPiece == null) {
        Stack ourBuildingPlan = buildingPlan;
        if (ourBuildingPlan.empty ()) {
            SOCRobotDM simulator;
            D.ebugPrintln ("**** our building plan is empty ****");
            simulator = new SOCRobotDM (brain.getRobotParameters (), playerTrackers, ourPlayerTracker, ourPlayerData, ourBuildingPlan);
            simulator.planStuff (strategyType);
        }
        if (ourBuildingPlan.empty ()) {
            return counterOffer;
        }
        targetPiece = (SOCPossiblePiece) ourBuildingPlan.peek ();
        targetPieces [ourPlayerData.getPlayerNumber ()] = targetPiece;
    }
    SOCResourceSet targetResources = null;
    switch (targetPiece.getType ()) {
        case SOCPossiblePiece.CARD :
            targetResources = SOCGame.CARD_SET;
            break;
        case SOCPossiblePiece.ROAD :
            targetResources = SOCGame.ROAD_SET;
            break;
        case SOCPossiblePiece.SETTLEMENT :
            targetResources = SOCGame.SETTLEMENT_SET;
            break;
        case SOCPossiblePiece.CITY :
            targetResources = SOCGame.CITY_SET;
            break;
    }
    SOCResourceSet ourResources = ourPlayerData.getResources ();
    D.ebugPrintln ("*** targetResources = " + targetResources);
    D.ebugPrintln ("*** ourResources = " + ourResources);
    if (ourResources.contains (targetResources)) {
        return counterOffer;
    }
    if (ourResources.getAmount (SOCResourceConstants.UNKNOWN) > 0) {
        D.ebugPrintln ("AGG WE HAVE UNKNOWN RESOURCES !!!! %%%%%%%%%%%%%%%%%%%%%%%%%%%%");
        return counterOffer;
    }
    SOCTradeOffer batna = getOfferToBank (targetResources);
    D.ebugPrintln ("*** BATNA = " + batna);
    SOCBuildingSpeedEstimate estimate = new SOCBuildingSpeedEstimate (ourPlayerData.getNumbers ());
    SOCResourceSet giveResourceSet = new SOCResourceSet ();
    SOCResourceSet getResourceSet = new SOCResourceSet ();
    int batnaBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
    if (batna != null) {
        batnaBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, batna.getGiveSet (), batna.getGetSet (), estimate);
    }
    D.ebugPrintln ("*** batnaBuildingTime = " + batnaBuildingTime);
    int [] rollsPerResource = estimate.getRollsPerResource ();
    int [] neededRsrc = new int [5];
    int [] notNeededRsrc = new int [5];
    int neededRsrcCount = 0;
    int notNeededRsrcCount = 0;
    for (int rsrcType = SOCResourceConstants.CLAY; rsrcType <= SOCResourceConstants.WOOD; rsrcType ++) {
        if (targetResources.getAmount (rsrcType) > 0) {
            neededRsrc [neededRsrcCount] = rsrcType;
            neededRsrcCount ++;
        }
        else {
            notNeededRsrc [notNeededRsrcCount] = rsrcType;
            notNeededRsrcCount ++;
        }
    }
    for (int j = neededRsrcCount - 1; j >= 0; j --) {
        for (int i = 0; i < j; i ++) {
            if (rollsPerResource [neededRsrc [i]] > rollsPerResource [neededRsrc [i + 1]]) {
                int tmp = neededRsrc [i];
                neededRsrc [i] = neededRsrc [i + 1];
                neededRsrc [i + 1] = tmp;
            }
        }
    }
    if (D.ebugOn) {
        for (int i = 0; i < neededRsrcCount; i ++) {
            D.ebugPrintln ("NEEDED RSRC: " + neededRsrc [i] + " : " + rollsPerResource [neededRsrc [i]]);
        }
    }
    for (int j = notNeededRsrcCount - 1; j >= 0; j --) {
        for (int i = 0; i < j; i ++) {
            if (rollsPerResource [notNeededRsrc [i]] > rollsPerResource [notNeededRsrc [i + 1]]) {
                int tmp = notNeededRsrc [i];
                notNeededRsrc [i] = notNeededRsrc [i + 1];
                notNeededRsrc [i + 1] = tmp;
            }
        }
    }
    if (D.ebugOn) {
        for (int i = 0; i < notNeededRsrcCount; i ++) {
            D.ebugPrintln ("NOT-NEEDED RSRC: " + notNeededRsrc [i] + " : " + rollsPerResource [notNeededRsrc [i]]);
        }
    }
    int getRsrcIdx = neededRsrcCount - 1;
    while ((getRsrcIdx >= 0) && ((ourResources.getAmount (neededRsrc [getRsrcIdx]) >= targetResources.getAmount (neededRsrc [getRsrcIdx])) || (originalOffer.getGiveSet ().getAmount (neededRsrc [getRsrcIdx]) == 0))) {
        getRsrcIdx --;
    }
    if (getRsrcIdx >= 0) {
        D.ebugPrintln ("*** getRsrc = " + neededRsrc [getRsrcIdx]);
        getResourceSet.add (1, neededRsrc [getRsrcIdx]);
        D.ebugPrintln ("*** counterOffer should be null : counterOffer = " + counterOffer);
        int giveRsrcIdx = 0;
        while ((giveRsrcIdx < notNeededRsrcCount) && (counterOffer == null)) {
            D.ebugPrintln ("*** ourResources.getAmount(" + notNeededRsrc [giveRsrcIdx] + ") = " + ourResources.getAmount (notNeededRsrc [giveRsrcIdx]));
            if (ourResources.getAmount (notNeededRsrc [giveRsrcIdx]) > 0) {
                giveResourceSet.clear ();
                giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx]);
                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                D.ebugPrintln ("*** counterOffer = " + counterOffer);
            }
            giveRsrcIdx ++;
        }
        D.ebugPrintln ("*** ourResources = " + ourResources);
        if (counterOffer == null) {
            int giveRsrcIdx1 = 0;
            while ((giveRsrcIdx1 < neededRsrcCount) && (counterOffer == null)) {
                D.ebugPrintln ("*** ourResources.getAmount(" + neededRsrc [giveRsrcIdx1] + ") = " + ourResources.getAmount (neededRsrc [giveRsrcIdx1]));
                D.ebugPrintln ("*** targetResources.getAmount(" + neededRsrc [giveRsrcIdx1] + ") = " + targetResources.getAmount (neededRsrc [giveRsrcIdx1]));
                if ((ourResources.getAmount (neededRsrc [giveRsrcIdx1]) > targetResources.getAmount (neededRsrc [giveRsrcIdx1])) && (neededRsrc [giveRsrcIdx1] != neededRsrc [getRsrcIdx])) {
                    giveResourceSet.clear ();
                    giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                    int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                    if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal () < batna.getGiveSet ().getTotal ()))) {
                        counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                        D.ebugPrintln ("*** counterOffer = " + counterOffer);
                        D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                    }
                }
                giveRsrcIdx1 ++;
            }
        }
        D.ebugPrintln ("*** ourResources = " + ourResources);
        SOCResourceSet leftovers = ourResources.copy ();
        leftovers.subtract (targetResources);
        D.ebugPrintln ("*** leftovers = " + leftovers);
        if (counterOffer == null) {
            int giveRsrcIdx1 = 0;
            int giveRsrcIdx2 = 0;
            while ((giveRsrcIdx1 < notNeededRsrcCount) && (counterOffer == null)) {
                if (ourResources.getAmount (notNeededRsrc [giveRsrcIdx1]) > 0) {
                    while ((giveRsrcIdx2 < notNeededRsrcCount) && (counterOffer == null)) {
                        giveResourceSet.clear ();
                        giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx1]);
                        giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx2]);
                        if (ourResources.contains (giveResourceSet)) {
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal () < batna.getGiveSet ().getTotal ()))) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                            }
                        }
                        giveRsrcIdx2 ++;
                    }
                    giveRsrcIdx2 = 0;
                    while ((giveRsrcIdx2 < neededRsrcCount) && (counterOffer == null)) {
                        if (neededRsrc [giveRsrcIdx2] != neededRsrc [getRsrcIdx]) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx1]);
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx2]);
                            if (leftovers.contains (giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal () < batna.getGiveSet ().getTotal ()))) {
                                    counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                                    D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                    D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                        }
                        giveRsrcIdx2 ++;
                    }
                }
                giveRsrcIdx1 ++;
            }
            giveRsrcIdx1 = 0;
            giveRsrcIdx2 = 0;
            while ((giveRsrcIdx1 < neededRsrcCount) && (counterOffer == null)) {
                if ((leftovers.getAmount (neededRsrc [giveRsrcIdx1]) > 0) && (neededRsrc [giveRsrcIdx1] != neededRsrc [getRsrcIdx])) {
                    while ((giveRsrcIdx2 < notNeededRsrcCount) && (counterOffer == null)) {
                        giveResourceSet.clear ();
                        giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                        giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx2]);
                        if (leftovers.contains (giveResourceSet)) {
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal () < batna.getGiveSet ().getTotal ()))) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                            }
                        }
                        giveRsrcIdx2 ++;
                    }
                    giveRsrcIdx2 = 0;
                    while ((giveRsrcIdx2 < neededRsrcCount) && (counterOffer == null)) {
                        if (neededRsrc [giveRsrcIdx2] != neededRsrc [getRsrcIdx]) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx2]);
                            if (leftovers.contains (giveResourceSet)) {
                                int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                                if ((offerBuildingTime < batnaBuildingTime) || ((batna != null) && (offerBuildingTime == batnaBuildingTime) && (giveResourceSet.getTotal () < batna.getGiveSet ().getTotal ()))) {
                                    counterOffer = makeOfferAux (giveResourceSet, getResourceSet, neededRsrc [getRsrcIdx]);
                                    D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                    D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                                }
                            }
                        }
                        giveRsrcIdx2 ++;
                    }
                }
                giveRsrcIdx1 ++;
            }
        }
    }
    if (counterOffer == null) {
        SOCResourceSet leftovers = ourResources.copy ();
        leftovers.subtract (targetResources);
        D.ebugPrintln ("*** leftovers = " + leftovers);
        int getRsrcIdx2 = notNeededRsrcCount - 1;
        while ((getRsrcIdx2 >= 0) && (originalOffer.getGiveSet ().getAmount (notNeededRsrc [getRsrcIdx2]) == 0)) {
            getRsrcIdx2 --;
        }
        while ((getRsrcIdx2 >= 0) && (counterOffer == null)) {
            getResourceSet.clear ();
            getResourceSet.add (1, notNeededRsrc [getRsrcIdx2]);
            leftovers.add (1, notNeededRsrc [getRsrcIdx2]);
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (counterOffer == null)) {
                    if ((leftovers.getAmount (notNeededRsrc [giveRsrcIdx1]) > 0) && (notNeededRsrc [giveRsrcIdx1] != notNeededRsrc [getRsrcIdx2])) {
                        leftovers.subtract (1, notNeededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                            }
                        }
                        leftovers.add (1, notNeededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (counterOffer == null)) {
                    if (leftovers.getAmount (neededRsrc [giveRsrcIdx1]) > 0) {
                        leftovers.subtract (1, neededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                            }
                        }
                        leftovers.add (1, neededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            leftovers.subtract (1, notNeededRsrc [getRsrcIdx2]);
            getRsrcIdx2 --;
        }
    }
    if (counterOffer == null) {
        SOCResourceSet leftovers = ourResources.copy ();
        leftovers.subtract (targetResources);
        D.ebugPrintln ("*** leftovers = " + leftovers);
        int getRsrcIdx2 = notNeededRsrcCount - 1;
        while ((getRsrcIdx2 >= 0) && (originalOffer.getGiveSet ().getAmount (notNeededRsrc [getRsrcIdx2]) == 0)) {
            getRsrcIdx2 --;
        }
        while ((getRsrcIdx2 >= 0) && (counterOffer == null)) {
            getResourceSet.clear ();
            getResourceSet.add (2, notNeededRsrc [getRsrcIdx2]);
            leftovers.add (2, notNeededRsrc [getRsrcIdx2]);
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (counterOffer == null)) {
                    if ((leftovers.getAmount (notNeededRsrc [giveRsrcIdx1]) > 0) && (notNeededRsrc [giveRsrcIdx1] != notNeededRsrc [getRsrcIdx2])) {
                        leftovers.subtract (1, notNeededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                            }
                        }
                        leftovers.add (1, notNeededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (counterOffer == null)) {
                    if (leftovers.getAmount (neededRsrc [giveRsrcIdx1]) > 0) {
                        leftovers.subtract (1, neededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                            }
                        }
                        leftovers.add (1, neededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            leftovers.subtract (2, notNeededRsrc [getRsrcIdx2]);
            getRsrcIdx2 --;
        }
    }
    if (counterOffer == null) {
        SOCResourceSet leftovers = ourResources.copy ();
        leftovers.subtract (targetResources);
        D.ebugPrintln ("*** leftovers = " + leftovers);
        int getRsrcIdx2 = notNeededRsrcCount - 1;
        while ((getRsrcIdx2 >= 0) && (originalOffer.getGiveSet ().getAmount (notNeededRsrc [getRsrcIdx2]) == 0)) {
            getRsrcIdx2 --;
        }
        while ((getRsrcIdx2 >= 0) && (counterOffer == null)) {
            getResourceSet.clear ();
            getResourceSet.add (3, notNeededRsrc [getRsrcIdx2]);
            leftovers.add (3, notNeededRsrc [getRsrcIdx2]);
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < notNeededRsrcCount) && (counterOffer == null)) {
                    if ((leftovers.getAmount (notNeededRsrc [giveRsrcIdx1]) > 0) && (notNeededRsrc [giveRsrcIdx1] != notNeededRsrc [getRsrcIdx2])) {
                        leftovers.subtract (1, notNeededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, notNeededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                                D.ebugPrintln ("*** offerBuildingTime = " + offerBuildingTime);
                            }
                        }
                        leftovers.add (1, notNeededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            if (counterOffer == null) {
                int giveRsrcIdx1 = 0;
                while ((giveRsrcIdx1 < neededRsrcCount) && (counterOffer == null)) {
                    if (leftovers.getAmount (neededRsrc [giveRsrcIdx1]) > 0) {
                        leftovers.subtract (1, neededRsrc [giveRsrcIdx1]);
                        if (getOfferToBank (targetResources, leftovers) != null) {
                            giveResourceSet.clear ();
                            giveResourceSet.add (1, neededRsrc [giveRsrcIdx1]);
                            int offerBuildingTime = getETAToTargetResources (ourPlayerData, targetResources, giveResourceSet, getResourceSet, estimate);
                            if (offerBuildingTime < batnaBuildingTime) {
                                counterOffer = makeOfferAux (giveResourceSet, getResourceSet, notNeededRsrc [getRsrcIdx2]);
                                D.ebugPrintln ("*** counterOffer = " + counterOffer);
                            }
                        }
                        leftovers.add (1, neededRsrc [giveRsrcIdx1]);
                    }
                    giveRsrcIdx1 ++;
                }
            }
            leftovers.subtract (3, notNeededRsrc [getRsrcIdx2]);
            getRsrcIdx2 --;
        }
    }
    return counterOffer;
}


-----Function Pair=40=-----==

void genTry (JCTree body, List < JCCatch > catchers, Env < GenContext > env) {
    int limit = code.nextreg;
    int startpc = code.curPc ();
    Code.State stateTry = code.state.dup ();
    genStat (body, env, CRT_BLOCK);
    int endpc = code.curPc ();
    boolean hasFinalizer = env.info.finalize != null && env.info.finalize.hasFinalizer ();
    List < Integer > gaps = env.info.gaps.toList ();
    code.statBegin (TreeInfo.endPos (body));
    genFinalizer (env);
    code.statBegin (TreeInfo.endPos (env.tree));
    Chain exitChain = code.branch (goto_);
    endFinalizerGap (env);
    if (startpc != endpc) for (List < JCCatch > l = catchers; l.nonEmpty (); l = l.tail) {
        code.entryPoint (stateTry, l.head.param.sym.type);
        genCatch (l.head, env, startpc, endpc, gaps);
        genFinalizer (env);
        if (hasFinalizer || l.tail.nonEmpty ()) {
            code.statBegin (TreeInfo.endPos (env.tree));
            exitChain = code.mergeChains (exitChain, code.branch (goto_));
        }
        endFinalizerGap (env);
    }
    if (hasFinalizer) {
        code.newRegSegment ();
        int catchallpc = code.entryPoint (stateTry, syms.throwableType);
        int startseg = startpc;
        while (env.info.gaps.nonEmpty ()) {
            int endseg = env.info.gaps.next ().intValue ();
            registerCatch (body.pos (), startseg, endseg, catchallpc, 0);
            startseg = env.info.gaps.next ().intValue ();
        }
        code.statBegin (TreeInfo.finalizerPos (env.tree));
        code.markStatBegin ();
        Item excVar = makeTemp (syms.throwableType);
        excVar.store ();
        genFinalizer (env);
        excVar.load ();
        registerCatch (body.pos (), startseg, env.info.gaps.next ().intValue (), catchallpc, 0);
        code.emitop0 (athrow);
        code.markDead ();
        if (env.info.cont != null) {
            code.resolve (env.info.cont);
            code.statBegin (TreeInfo.finalizerPos (env.tree));
            code.markStatBegin ();
            LocalItem retVar = makeTemp (syms.throwableType);
            retVar.store ();
            env.info.finalize.genLast ();
            code.emitop1w (ret, retVar.reg);
            code.markDead ();
        }
    }
    code.resolve (exitChain);
    code.endScopes (limit);
}


public void processEvent (Event ev) {
    String name = ev.getName ();
    ConstField eventValue = ev.getValue ();
    double timestamp = ev.getTimeStamp ();
    if (name.equals ("set_string")) {
        changeTime = timestamp;
        if (autoHide) {
            show.setValue (timestamp);
        }
        if (! active) {
            x = posx;
            y = posy;
            z = posz;
            speed = 1;
            translate (timestamp);
            active = true;
        }
    }
    else if (name.equals ("movement")) {
        if (active && autoHide) {
            posx = oldx;
            posy = oldy;
            posz = oldz;
            x = (float) - .25;
            y = (float) - .17;
            z = (float) - .35;
            speed = 1;
            translate (timestamp);
            active = false;
        }
    }
    else if (name.equals ("writeln")) {
        writeln (((ConstSFString) eventValue).getValue ());
    }
    else if (name.equals ("pos")) {
        float [] pos = {0, 0};
        ((ConstSFVec2f) eventValue).getValue (pos);
        pos (new Float (pos [0]).intValue (), new Float (pos [1]).intValue ());
    }
    else if (name.equals ("write")) {
        write (((ConstSFString) eventValue).getValue ());
    }
    else if (name.equals ("clear")) {
        clear ();
    }
    else if (name.equals ("autoHide")) {
        autoHide = ((ConstSFBool) eventValue).getValue ();
    }
    else {
        processMovement (name, eventValue, timestamp);
        if (name.equals ("set_xyzgo")) {
            posx = x;
            posy = y;
            posz = z;
            active = true;
        }
    }
}


-----Function Pair=41=-----==

public Frame newTailCallFrame (Method method, MethodCode code) {
    assert mutable;
    Frame frame = new Frame (parent, ret, method, code);
    boolean isSynchronized = Modifier.isSynchronized (method.getModifiers ());
    boolean isStatic = Modifier.isStatic (method.getModifiers ());
    Class < ? > [] types = method.getParameterTypes ();
    int i = types.length + (isStatic ? 0 : 1);
    for (Class < ? > type : types) if (type == long.class || type == double.class) i ++;
    for (int j = types.length; j -- > 0;) {
        Class < ? > type = types [j];
        if (type == long.class || type == double.class) {
            frame.stack [i -= 2] = popBigObject ();
        }
        else {
            frame.stack [i -= 1] = popObject ();
        }
    }
    Object target;
    if (isStatic) target = method.getDeclaringClass ();
    else {
        target = popObject ();
        if (target == null) throw new NullPointerException ();
        frame.stack [i -= 1] = target;
    }
    if (isSynchronized) Monitor.enter (target);
    return frame;
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) {
        if (value.length > 0) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
        else System.out.println ("doing conditional " + arg + " " + op + " <NO ARGUMENT TOKEN FOUND>");
    }
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=42=-----==

private void out7ffd (int v) {
    if (mode == Qaop.MODE_48K || lock48k) return;
    int ram_bank = v & 0x7;
    ram48k [2] = whole_ram [ram_bank];
    if ((v & 0x08) == 0x08) {
        vram = whole_ram [7];
    }
    else {
        vram = whole_ram [5];
    }
    if ((v & 0x10) == 0x10) {
        rom = rom48k;
    }
    else {
        rom = rom128k;
    }
    if ((v & 0x20) == 0x20) {
        lock48k = true;
    }
}


private int readEOL (boolean isFirstEOL) {
    if (fillBits == 0) {
        int next12Bits = nextNBits (12);
        if (isFirstEOL && next12Bits == 0) {
            if (nextNBits (4) == 1) {
                fillBits = 1;
                return 1;
            }
        }
        if (next12Bits != 1) {
            throw new RuntimeException ("Scanline must begin with EOL code word.");
        }
    }
    else if (fillBits == 1) {
        int bitsLeft = 8 - bitPointer;
        if (nextNBits (bitsLeft) != 0) {
            throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
        }
        if (bitsLeft < 4) {
            if (nextNBits (8) != 0) {
                throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
            }
        }
        int n;
        while ((n = nextNBits (8)) != 1) {
            if (n != 0) {
                throw new RuntimeException ("All fill bits preceding EOL code must be 0.");
            }
        }
    }
    if (oneD == 0) {
        return 1;
    }
    else {
        return nextLesserThan8Bits (1);
    }
}


-----Function Pair=43=-----==

public boolean usunElementZnak (String key) {
    boolean zmien = false;
    String line1 = makeLine ();
    podzielNaWszystkieNawiasy (line1);
    for (int i = 0; i < inArt; i ++) {
        if (art [i].equalsIgnoreCase (key)) {
            zmien = true;
        }
        if (zmien) {
            art [i] = art [i + 1];
        }
    }
    if (zmien) {
        inArt --;
    }
    return zmien;
}


void bubbleSort (int [] a) {
    int i = 0;
    int j = a.length - 1;
    int aux = 0;
    int stop = 0;
    while (stop == 0) {
        stop = 1;
        i = 0;
        while (i < j) {
            if (a [i] > a [i + 1]) {
                aux = a [i];
                a [i] = a [i + 1];
                a [i + 1] = aux;
                stop = 0;
            }
            i = i + 1;
        }
        j = j - 1;
    }
}


-----Function Pair=44=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


public void decodeNextScanline (byte [] buffer, int lineOffset, int bitOffset) throws Exception {
    int bits = 0, code = 0, isT = 0;
    int current, entry, twoBits;
    boolean isWhite = true;
    int dstEnd = 0;
    changingElemSize = 0;
    while (bitOffset < w) {
        while (isWhite) {
            current = nextNBits (10);
            entry = white [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x0f;
            if (bits == 12) {
                twoBits = nextLesserThan8Bits (2);
                current = ((current << 2) & 0x000c) | twoBits;
                entry = additionalMakeup [current];
                bits = (entry>>> 1) & 0x07;
                code = (entry>>> 4) & 0x0fff;
                bitOffset += code;
                updatePointer (4 - bits);
            }
            else if (bits == 0) {
                throw new Exception (("TIFFFaxDecoder0"));
            }
            else if (bits == 15) {
                throw new Exception (("TIFFFaxDecoder1"));
            }
            else {
                code = (entry>>> 5) & 0x07ff;
                bitOffset += code;
                updatePointer (10 - bits);
                if (isT == 0) {
                    isWhite = false;
                    currChangingElems [changingElemSize ++] = bitOffset;
                }
            }
        }
        if (bitOffset == w) {
            if (compression == 2) advancePointer ();
            break;
        }
        while (isWhite == false) {
            current = nextLesserThan8Bits (4);
            entry = initBlack [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x000f;
            code = (entry>>> 5) & 0x07ff;
            if (code == 100) {
                current = nextNBits (9);
                entry = black [current];
                isT = entry & 0x0001;
                bits = (entry>>> 1) & 0x000f;
                code = (entry>>> 5) & 0x07ff;
                if (bits == 12) {
                    updatePointer (5);
                    current = nextLesserThan8Bits (4);
                    entry = additionalMakeup [current];
                    bits = (entry>>> 1) & 0x07;
                    code = (entry>>> 4) & 0x0fff;
                    setToBlack (buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer (4 - bits);
                }
                else if (bits == 15) throw new PdfException (("TIFFFaxDecoder2"));
                else {
                    setToBlack (buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer (9 - bits);
                    if (isT == 0) {
                        isWhite = true;
                        currChangingElems [changingElemSize ++] = bitOffset;
                    }
                }
            }
            else if (code == 200) {
                current = nextLesserThan8Bits (2);
                entry = twoBitBlack [current];
                code = (entry>>> 5) & 0x07ff;
                bits = (entry>>> 1) & 0x0f;
                setToBlack (buffer, lineOffset, bitOffset, code);
                bitOffset += code;
                updatePointer (2 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
            else {
                setToBlack (buffer, lineOffset, bitOffset, code);
                bitOffset += code;
                updatePointer (4 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
        }
        if (bitOffset == w) {
            if (compression == 2) advancePointer ();
            break;
        }
    }
    currChangingElems [changingElemSize ++] = bitOffset;
}


-----Function Pair=45=-----==

public Dfp divide (int divisor) {
    if (nans != FINITE) {
        if (isNaN ()) {
            return this;
        }
        if (nans == INFINITE) {
            return newInstance (this);
        }
    }
    if (divisor == 0) {
        field.setIEEEFlagsBits (DfpField.FLAG_DIV_ZERO);
        Dfp result = newInstance (getZero ());
        result.sign = sign;
        result.nans = INFINITE;
        result = dotrap (DfpField.FLAG_DIV_ZERO, DIVIDE_TRAP, getZero (), result);
        return result;
    }
    if (divisor < 0 || divisor >= RADIX) {
        field.setIEEEFlagsBits (DfpField.FLAG_INVALID);
        Dfp result = newInstance (getZero ());
        result.nans = QNAN;
        result = dotrap (DfpField.FLAG_INVALID, DIVIDE_TRAP, result, result);
        return result;
    }
    Dfp result = newInstance (this);
    int rl = 0;
    for (int i = mant.length - 1; i >= 0; i --) {
        final int r = rl * RADIX + result.mant [i];
        final int rh = r / divisor;
        rl = r - rh * divisor;
        result.mant [i] = rh;
    }
    if (result.mant [mant.length - 1] == 0) {
        result.shiftLeft ();
        final int r = rl * RADIX;
        final int rh = r / divisor;
        rl = r - rh * divisor;
        result.mant [0] = rh;
    }
    final int excp = result.round (rl * RADIX / divisor);
    if (excp != 0) {
        result = dotrap (excp, DIVIDE_TRAP, result, result);
    }
    return result;
}


private void compileBootImage (String args []) {
    String bi_args [] = new String [args.length - 1];
    String bi_name = args [args.length - 1];
    Class pub_cl;
    Object pub_obj;
    java.lang.reflect.Method pub_methods [];
    jdp_console.writeOutput ("Compiling Boot Image for " + bi_name + " . . . ");
    for (int i = 0; i < bi_args.length; i ++) {
        bi_args [i] = args [i + 1];
    }
    try {
        pub_cl = Class.forName (args [0]);
        pub_obj = pub_cl.newInstance ();
        pub_methods = pub_cl.getMethods ();
        for (int n = 0; n < pub_methods.length; n ++) {
            if (pub_methods [n].getName ().equals ("main")) {
                Object invoke_args [] = {bi_args};
                pub_methods [n].invoke (pub_obj, invoke_args);
                return;
            }
        }
    } catch (ClassNotFoundException e) {
        jdp_console.writeOutput ("cannot compile, publicizing class loader not found: " + args [0]);
        System.exit (1);
    } catch (InstantiationException e1) {
        jdp_console.writeOutput ("cannot compile, problem instantiating class");
        System.exit (1);
    } catch (IllegalAccessException e2) {
        jdp_console.writeOutput ("cannot compile, illegal access to class");
        System.exit (1);
    } catch (InvocationTargetException e3) {
        jdp_console.writeOutput ("cannot compile, Invocation Target Exception:");
        jdp_console.writeOutput (e3.getMessage ());
        System.exit (1);
    }
}


-----Function Pair=46=-----==

public static byte [] setBit (final byte [] data, final int index, final boolean value) {
    if (data.length == 0) {
        return data;
    }
    final int max = data.length * 8;
    if (index >= max || index < 0) {
        throw new IndexOutOfBoundsException ("Index out of bounds: " + index);
    }
    final int pos = data.length - index / 8 - 1;
    final int bitPos = index % 8;
    int d = data [pos] & 0xFF;
    if (value) {
        d = d | (1 << bitPos);
    }
    else {
        d = d & ~ (1 << bitPos);
    }
    data [pos] = (byte) d;
    return data;
}


public static boolean alreadyExistsSameName (BinMethod method, String name, int idx, boolean global) {
    BinParameter [] params = getNewParameters (method.getParameters (), idx);
    if (global) {
        List hierarchy = method.findAllOverridesOverriddenInHierarchy ();
        hierarchy.add (method);
        for (int i = 0; i < hierarchy.size (); i ++) {
            if (((BinMethod) hierarchy.get (i)).getOwner ().getBinCIType ().getDeclaredMethod (name, params) != null) return true;
        }
        return false;
    }
    else {
        if (method.getOwner ().getBinCIType ().getDeclaredMethod (name, params) != null) {
            return true;
        }
        else {
            return false;
        }
    }
}


-----Function Pair=47=-----==

public static HexCommand fromByteArray (byte [] data) throws RFIDException {
    int actual_size = data.length;
    int data_size = ByteUtils.unsignedByteToInt (data [0]);
    byte [] crc = ByteUtils.range (actual_size - 2, - 1, data);
    data = ByteUtils.range (0, actual_size - 3, data);
    if (actual_size > 0xFF) {
        byte [] data_size_bytes = new byte [data_size];
        for (int i = 0; i < data_size; i ++) data_size_bytes [i] = data [i + 1];
        data_size = ByteUtils.mergeBytes (data_size_bytes);
    }
    data = ByteUtils.range (1, - 1, data);
    if (data_size != actual_size) throw new CommandException ("size mismatch, given: " + data_size + ", string was: " + actual_size);
    HexCommand hc = new HexCommand (data);
    byte [] calc_crc = hc.crc16 ();
    if (! (ByteUtils.sameContents (crc, calc_crc))) throw new CRCException ("checksum (crc16) mismatch, given: " + ByteUtils.byteArrayToHex (crc) + ", calculated: " + ByteUtils.byteArrayToHex (calc_crc));
    return hc;
}


private void select (int cx, int cy) {
    int [] viewport = new int [4];
    IntBuffer selectBuf = Buffers.newDirectIntBuffer (selectBufLen);
    gl.glSelectBuffer (selectBufLen, selectBuf);
    gl.glGetIntegerv (GL2.GL_VIEWPORT, viewport, 0);
    gl.glMatrixMode (GL2.GL_PROJECTION);
    gl.glPushMatrix ();
    gl.glRenderMode (GL2.GL_SELECT);
    gl.glLoadIdentity ();
    glu.gluPickMatrix (cx, viewport [3] - cy + viewport [1], 2, 2, viewport, 0);
    glu.gluPerspective (fov, aspect, near, far);
    drawWorld ();
    int hits = gl.glRenderMode (GL2.GL_RENDER);
    if (hits > 0) {
        int [] sb = new int [selectBufLen];
        selectBuf.get (sb, 0, hits * 4);
        processHits (hits, sb);
    }
    else {
        if (selection) {
            selected = - 1;
            selectedExit = null;
        }
    }
    gl.glMatrixMode (GL2.GL_PROJECTION);
    gl.glPopMatrix ();
    gl.glMatrixMode (GL2.GL_MODELVIEW);
}


-----Function Pair=48=-----==

void convertArgsToSQL (Session session, Object [] callArguments, Object [] data) {
    int extraArg = javaMethodWithConnection ? 1 : 0;
    Type [] types = getParameterTypes ();
    int i = 0;
    for (; i < types.length; i ++) {
        Object value = data [i + extraArg];
        ColumnSchema param = getParameter (i);
        if (param.parameterMode != SchemaObject.ParameterModes.PARAM_IN) {
            value = java.lang.reflect.Array.get (value, 0);
        }
        callArguments [i] = types [i].convertJavaToSQL (session, value);
    }
    for (; i + extraArg < data.length; i ++) {
        ResultSet rs = ((ResultSet []) data [i]) [0];
        if (rs != null) {
            if (rs instanceof JDBCResultSet) {
                Result head = (Result) callArguments [i - extraArg];
                Result r = ((JDBCResultSet) rs).result;
                if (head == null) {
                    callArguments [i - extraArg] = r;
                }
                else {
                    head.addChainedResult (r);
                }
            }
            else {
                Error.error (ErrorCode.X_46000);
            }
        }
    }
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=49=-----==

static void evaluation (BsplineKnotVector knotData, double [] [] controlPoints, double param, double [] d0D, double [] d1D, double [] d2D, double [] d3D) {
    int dimension = getDimension (controlPoints);
    int degree = knotData.degree ();
    int isckt;
    double [] [] auxpnts;
    double [] [] auxv1s = null;
    double [] [] auxv2s = null;
    double [] [] auxv3s = null;
    double denom, scale;
    int i, j;
    if ((isckt = knotData.segmentIndex (param)) < 0) {
        throw new ExceptionGeometryFatal ();
    }
    auxpnts = new double [degree + 1] [dimension];
    if (d1D != null || d2D != null) {
        auxv1s = new double [degree] [dimension];
    }
    if (d2D != null) {
        if (degree > 1) {
            auxv2s = new double [degree - 1] [dimension];
        }
    }
    if (d3D != null) {
        if (degree > 2) {
            auxv3s = new double [degree - 2] [dimension];
        }
    }
    if (knotData.isNonPeriodic ()) {
        for (j = degree; j >= 0; j --) for (i = 0; i < dimension; i ++) auxpnts [j] [i] = controlPoints [isckt + j] [i];
    }
    else {
        int k;
        for (j = degree; j >= 0; j --) {
            k = (isckt + j) % controlPoints.length;
            for (i = 0; i < dimension; i ++) auxpnts [j] [i] = controlPoints [k] [i];
        }
    }
    for (j = degree - 1; j >= 0; j --) {
        if (d1D != null || d2D != null) {
            for (i = 0; i < dimension; i ++) auxv1s [j] [i] = auxpnts [j + 1] [i] - auxpnts [j] [i];
            denom = knotData.knotValueAt (degree + isckt + j + 1) - knotData.knotValueAt (isckt + j + 1);
            for (i = 0; i < dimension; i ++) auxv1s [j] [i] /= denom;
            if (d2D != null && (degree > 1) && (j < (degree - 1))) {
                for (i = 0; i < dimension; i ++) auxv2s [j] [i] = auxv1s [j + 1] [i] - auxv1s [j] [i];
                denom = knotData.knotValueAt (degree + isckt + j + 1) - knotData.knotValueAt (isckt + j + 2);
                for (i = 0; i < dimension; i ++) auxv2s [j] [i] /= denom;
                if (d3D != null && (degree > 2) && (j < (degree - 2))) {
                    for (i = 0; i < dimension; i ++) auxv3s [j] [i] = auxv2s [j + 1] [i] - auxv2s [j] [i];
                    denom = knotData.knotValueAt (degree + isckt + j + 1) - knotData.knotValueAt (isckt + j + 3);
                    for (i = 0; i < dimension; i ++) auxv3s [j] [i] /= denom;
                }
            }
        }
    }
    if (d0D != null) {
        deboorProc (knotData, dimension, degree, (isckt + degree), param, auxpnts);
        for (i = 0; i < dimension; i ++) d0D [i] = auxpnts [degree] [i];
    }
    if (d1D != null) {
        deboorProc (knotData, dimension, (degree - 1), (isckt + degree), param, auxv1s);
        for (i = 0; i < dimension; i ++) d1D [i] = auxv1s [degree - 1] [i] * degree;
    }
    if (d2D != null) {
        if (degree > 1) {
            deboorProc (knotData, dimension, (degree - 2), (isckt + degree), param, auxv2s);
            scale = degree * (degree - 1);
            for (i = 0; i < dimension; i ++) d2D [i] = auxv2s [degree - 2] [i] * scale;
        }
        else {
            for (i = 0; i < dimension; i ++) d2D [i] = 0.0;
        }
    }
    if (d3D != null) {
        if (degree > 2) {
            deboorProc (knotData, dimension, (degree - 3), (isckt + degree), param, auxv3s);
            scale = degree * (degree - 1) * (degree - 2);
            for (i = 0; i < dimension; i ++) d3D [i] = auxv3s [degree - 3] [i] * scale;
        }
        else {
            for (i = 0; i < dimension; i ++) d3D [i] = 0.0;
        }
    }
}


protected int contest (int b, int g, int r) {
    int i, dist, a, biasdist, betafreq;
    int bestpos, bestbiaspos, bestd, bestbiasd;
    int [] n;
    bestd = ~ (((int) 1) << 31);
    bestbiasd = bestd;
    bestpos = - 1;
    bestbiaspos = bestpos;
    for (i = 0; i < netsize; i ++) {
        n = network [i];
        dist = n [0] - b;
        if (dist < 0) dist = - dist;
        a = n [1] - g;
        if (a < 0) a = - a;
        dist += a;
        a = n [2] - r;
        if (a < 0) a = - a;
        dist += a;
        if (dist < bestd) {
            bestd = dist;
            bestpos = i;
        }
        biasdist = dist - ((bias [i])>> (intbiasshift - netbiasshift));
        if (biasdist < bestbiasd) {
            bestbiasd = biasdist;
            bestbiaspos = i;
        }
        betafreq = (freq [i]>> betashift);
        freq [i] -= betafreq;
        bias [i] += (betafreq << gammashift);
    }
    freq [bestpos] += beta;
    bias [bestpos] -= betagamma;
    return (bestbiaspos);
}


-----Function Pair=50=-----==

void processForeachRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variable in FOREACH");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in FOREACH");
    String file_name = pst.nextToken ();
    String select = null;
    String start = null;
    String end = null;
    boolean inRange = false;
    if (pst.hasMoreTokens ()) {
        select = pst.nextToken ();
        if (! pst.hasMoreTokens ()) throw new IOException ("Missing field value in FOREACH");
        String fval = pst.nextToken ();
        int dotdot = fval.indexOf ("..");
        if (dotdot != - 1 && dotdot == fval.lastIndexOf ("..")) {
            start = fval.substring (0, dotdot);
            end = fval.substring (dotdot + 2);
        }
        else {
            start = fval;
        }
    }
    if (DEBUG) System.out.println ("doing foreach with varname " + var_name + " on data file :" + file_name);
    if (DEBUG && select != null) {
        System.out.print ("   selecting records with " + select);
        if (end == null) System.out.println (" equal to \"" + start + "\"");
        else System.out.println (" between \"" + start + "\" and \"" + end + "\"");
    }
    BufferedReader data = new BufferedReader (new FileReader (file_name));
    Vector fields_v = new Vector ();
    Vector fpl_v = new Vector ();
    for (String inLine = getNextLine (data); (inLine != null && inLine.length () != 0); inLine = getNextLine (data)) {
        StringTokenizer st = new StringTokenizer (inLine);
        fpl_v.addElement (new Integer (st.countTokens ()));
        while (st.hasMoreTokens ()) {
            String tok = st.nextToken ();
            if (DEBUG) System.out.println ("read field " + fields_v.size () + " :" + tok);
            fields_v.addElement (tok);
        }
    }
    fields_v.addElement (indexField);
    int [] fieldsPerLine = new int [fpl_v.size ()];
    for (int i = 0; i < fieldsPerLine.length; i ++) fieldsPerLine [i] = ((Integer) fpl_v.elementAt (i)).intValue ();
    String [] fields = new String [fields_v.size ()];
    for (int i = 0; i < fields.length; i ++) fields [i] = (String) fields_v.elementAt (i);
    dataFileLoop : for (int curField = 0;; curField ++) {
        int i = 0;
        String [] fieldData = new String [fields.length];
        for (int j = 0; j < fieldsPerLine.length; j ++) {
            String line = getNextLine (data);
            if (line == null) break dataFileLoop;
            if (fieldsPerLine [j] == 1) {
                if (DEBUG) System.out.println ("read field " + fields [i] + " :" + line);
                fieldData [i ++] = line;
            }
            else {
                if (DEBUG) System.out.println ("reading " + fieldsPerLine [j] + " fields");
                StringTokenizer st = new StringTokenizer (line);
                try {
                    for (int k = 0; k < fieldsPerLine [j]; k ++) {
                        String tok = st.nextToken ();
                        if (DEBUG) System.out.println ("read field " + fields [i] + ": " + tok);
                        fieldData [i ++] = tok;
                    }
                } catch (NoSuchElementException x) {
                    throw new IOException ("Missing field " + fields [i]);
                }
            }
        }
        if (fieldsPerLine.length != 1) getNextLine (data);
        fieldData [i ++] = Integer.toString (curField);
        if (select != null) {
            for (int j = 0; j < fields.length; j ++) {
                if (DEBUG) System.out.println ("checking if select is field " + fields [j]);
                if (select.equals (fields [j])) {
                    String value = fieldData [j];
                    if (value.equals (start)) inRange = true;
                    else if (end == null) inRange = false;
                    else if (value.equals (end)) end = null;
                    if (DEBUG) System.out.println ("record in range; including");
                    break;
                }
            }
            if (! inRange) break dataFileLoop;
        }
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name, fields, fieldData);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name, fields, fieldData);
                processTemplateRegion (newRegion);
            }
        }
    }
    data.close ();
}


void processForeachRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing variable in FOREACH");
    String var_name = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in FOREACH");
    String file_name = pst.nextToken ();
    String select = null;
    String start = null;
    String end = null;
    boolean inRange = false;
    if (pst.hasMoreTokens ()) {
        select = pst.nextToken ();
        if (! pst.hasMoreTokens ()) throw new IOException ("Missing field value in FOREACH");
        String fval = pst.nextToken ();
        int dotdot = fval.indexOf ("..");
        if (dotdot != - 1 && dotdot == fval.lastIndexOf ("..")) {
            start = fval.substring (0, dotdot);
            end = fval.substring (dotdot + 2);
        }
        else {
            start = fval;
        }
    }
    if (DEBUG) System.out.println ("doing foreach with varname " + var_name + " on data file :" + file_name);
    if (DEBUG && select != null) {
        System.out.print ("   selecting records with " + select);
        if (end == null) System.out.println (" equal to \"" + start + "\"");
        else System.out.println (" between \"" + start + "\" and \"" + end + "\"");
    }
    BufferedReader data;
    try {
        data = new BufferedReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        data = new BufferedReader (new FileReader (inDir + file_name));
    }
    Vector fields_v = new Vector ();
    Vector fpl_v = new Vector ();
    for (String inLine = getNextLine (data); (inLine != null && inLine.length () != 0); inLine = getNextLine (data)) {
        StringTokenizer st = new StringTokenizer (inLine);
        fpl_v.addElement (new Integer (st.countTokens ()));
        while (st.hasMoreTokens ()) {
            String tok = st.nextToken ();
            if (DEBUG) System.out.println ("read field " + fields_v.size () + " :" + tok);
            fields_v.addElement (tok);
        }
    }
    fields_v.addElement (indexField);
    int [] fieldsPerLine = new int [fpl_v.size ()];
    for (int i = 0; i < fieldsPerLine.length; i ++) fieldsPerLine [i] = ((Integer) fpl_v.elementAt (i)).intValue ();
    String [] fields = new String [fields_v.size ()];
    for (int i = 0; i < fields.length; i ++) fields [i] = (String) fields_v.elementAt (i);
    dataFileLoop : for (int curField = 0;; curField ++) {
        int i = 0;
        String [] fieldData = new String [fields.length];
        for (int j = 0; j < fieldsPerLine.length; j ++) {
            String line = getNextLine (data);
            if (line == null) break dataFileLoop;
            if (fieldsPerLine [j] == 1) {
                if (DEBUG) System.out.println ("read field " + fields [i] + " :" + line);
                fieldData [i ++] = line;
            }
            else {
                if (DEBUG) System.out.println ("reading " + fieldsPerLine [j] + " fields");
                StringTokenizer st = new StringTokenizer (line);
                try {
                    for (int k = 0; k < fieldsPerLine [j]; k ++) {
                        String tok = st.nextToken ();
                        if (DEBUG) System.out.println ("read field " + fields [i] + ": " + tok);
                        fieldData [i ++] = tok;
                    }
                } catch (NoSuchElementException x) {
                    throw new IOException ("Missing field " + fields [i]);
                }
            }
        }
        if (fieldsPerLine.length != 1) getNextLine (data);
        fieldData [i ++] = Integer.toString (curField);
        if (select != null) {
            for (int j = 0; j < fields.length; j ++) {
                if (DEBUG) System.out.println ("checking if select is field " + fields [j]);
                if (select.equals (fields [j])) {
                    String value = fieldData [j];
                    if (value.equals (start)) inRange = true;
                    else if (end == null) inRange = false;
                    else if (value.equals (end)) end = null;
                    if (DEBUG) System.out.println ("record in range; including");
                    break;
                }
            }
            if (! inRange) break dataFileLoop;
        }
        for (int j = 1; j < region.size (); j ++) {
            try {
                String currentLine = (String) region.elementAt (j);
                String result = substitute (currentLine, var_name, fields, fieldData);
                out.print (result + "\n");
            } catch (ClassCastException e) {
                Vector oldRegion = (Vector) region.elementAt (j);
                Vector newRegion = substituteInRegion (oldRegion, var_name, fields, fieldData);
                processTemplateRegion (newRegion);
            }
        }
    }
    data.close ();
}


-----Function Pair=51=-----==

void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


private byte [] sendEvidence (byte [] input) throws SaslException {
    cat.debug ("==> sendEvidence()");
    cat.debug ("challenge: " + SaslUtil.dumpString (input));
    InputBuffer frameIn = new InputBuffer (input);
    BigInteger B;
    try {
        B = frameIn.getMPI ();
        cat.debug ("Got B (server's ephermeral public key): " + SaslUtil.dump (B));
    } catch (IOException x) {
        if (x instanceof SaslException) throw (SaslException) x;
        throw new SaslException ("sendEvidence()", x);
    }
    MessageDigest ctxt = srp.newDigest ();
    ctxt.update (salt);
    ctxt.update (srp.userHash (U, new String (password)));
    BigInteger _x = new BigInteger (1, ctxt.digest ());
    cat.debug ("x: " + SaslUtil.dump (_x));
    K = srp.generateClientSecretKey (kp, B, _x);
    byte [] k = K.getEncoded ();
    M1 = srp.generateClientEvidence (N, g, U, salt, A, B, k, L);
    cat.debug ("Encoding M1 (client's evidence): " + SaslUtil.dumpString (M1));
    OutputBuffer frameOut = new OutputBuffer ();
    try {
        frameOut.setOS (M1);
    } catch (IOException x) {
        if (x instanceof SaslException) throw (SaslException) x;
        throw new SaslException ("sendEvidence()", x);
    }
    byte [] result = frameOut.encode ();
    if (chosenConfidentialityAlgorithm != null) setupSecurityServices ();
    cat.debug ("<== sendEvidence() --> " + SaslUtil.dumpString (result));
    cat.info ("C: " + Base64.encode (result));
    return result;
}


-----Function Pair=52=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


private int nextLesserThan8Bits (int bitsToGet) {
    byte b, next;
    int l = data.length - 1;
    int bp = this.bytePointer;
    if (fillOrder == 1) {
        b = data [bp];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = data [bp + 1];
        }
    }
    else if (fillOrder == 2) {
        b = flipTable [data [bp] & 0xff];
        if (bp == l) {
            next = 0x00;
        }
        else {
            next = flipTable [data [bp + 1] & 0xff];
        }
    }
    else {
        throw new RuntimeException ("Invalid FillOrder");
    }
    int bitsLeft = 8 - bitPointer;
    int bitsFromNextByte = bitsToGet - bitsLeft;
    int shift = bitsLeft - bitsToGet;
    int i1, i2;
    if (shift >= 0) {
        i1 = (b & table1 [bitsLeft])>>> shift;
        bitPointer += bitsToGet;
        if (bitPointer == 8) {
            bitPointer = 0;
            bytePointer ++;
        }
    }
    else {
        i1 = (b & table1 [bitsLeft]) << (- shift);
        i2 = (next & table2 [bitsFromNextByte])>>> (8 - bitsFromNextByte);
        i1 |= i2;
        bytePointer ++;
        bitPointer = bitsFromNextByte;
    }
    return i1;
}


-----Function Pair=53=-----==

public static Range [] findGroupRangesWithLessOrEqualMeanGrowth (final int [] population) {
    final double firstDifferenceMean = getMean (getFirstDifference (population));
    final double maxJump = Math.ceil (firstDifferenceMean);
    final List < Range > ranges = new ArrayList < Range > ();
    boolean scanning = true;
    int index = 0;
    while (scanning) {
        final Range range = getNextRangeWithLessOrEqualGrowth (population, index, maxJump);
        if (range != null) {
            index = range.end;
            ranges.add (range);
        }
        else {
            scanning = false;
        }
    }
    return ranges.toArray (new Range [0]);
}


public static byte [] agentOptionToRaw (Map < Byte, String > map) {
    if (map == null) return null;
    ByteArrayOutputStream buf = new ByteArrayOutputStream (64);
    DataOutputStream out = new DataOutputStream (buf);
    try {
        for (Byte key : map.keySet ()) {
            String s = map.get (key);
            byte [] bufTemp = stringToBytes (s);
            int size = bufTemp.length;
            if (size > 255) size = 255;
            out.writeByte (key.byteValue ());
            out.writeByte (size);
            out.write (bufTemp, 0, size);
        }
        return buf.toByteArray ();
    } catch (IOException e) {
        logger.log (Level.SEVERE, "Unexpected IOException", e);
        return buf.toByteArray ();
    }
}


-----Function Pair=54=-----==

private void testSearch (XMPPConnection connection, BundleContext context) throws InterruptedException, XMPPException {
    Thread.sleep (8 * 1000);
    searchManagerServiceTracker = new ServiceTracker (context, SearchManager.class.getName (), null);
    searchManagerServiceTracker.open ();
    SearchManager searchManager = (SearchManager) searchManagerServiceTracker.getService ();
    boolean b = searchManager.isSupportSearch (connection, new JID ("users.szsport.org"));
    System.out.println (b);
    SearchExtension ex = searchManager.getSearchExtension (connection, new JID ("users.szsport.org"));
    System.out.println (ex.toXML ());
    SearchExtension extension = new SearchExtension ();
    extension.getFields ().put ("nick", "how");
    SearchExtension extensionResult = searchManager.search (connection, extension, new JID ("users.szsport.org"));
    for (SearchExtension.Item item : extensionResult.getItems ()) {
        System.out.println (item);
        System.out.println (item.getJid ());
        System.out.println (item.getFields ());
    }
}


public void synchronize (String local, String remote) {
    log.debug ("synchronize " + local + " to " + remote);
    File f = new File (local);
    if (f.exists () && f.isDirectory ()) {
        int count = countFiles (f.getPath ());
        ftpe.setType (FTPEvent.RSYNC_START);
        ftpe.setRsyncCount (count);
        ftpe.setRsyncValue (0);
        rsyncValue = 0;
        fireFTPEvent (ftpe);
        this.localfile = local;
        this.remotefile = remote;
        this.filecommand = RSYNC;
        Thread t = new Thread (this);
        t.start ();
    }
    else {
        if (! f.exists ()) {
            log.error (local + " not exists");
        }
        if (! f.isDirectory ()) {
            log.error (local + " is not a  directory");
        }
    }
}


-----Function Pair=55=-----==

public void processMessage (final Chat chat, final Message message) {
    if (logger.isDebugEnabled ()) {
        logger.debug ("Recv message from " + message.getFrom () + " to " + message.getTo ());
    }
    if (message.getType ().equals (Type.chat)) {
        String jid = message.getFrom ();
        String content = message.getBody ();
        byte [] raw = Base64.decodeFast (content);
        ChannelDataBuffer buffer = ChannelDataBuffer.wrap (raw);
        RpcChannelData recv = new RpcChannelData (buffer, new XmppAddress (jid));
        synchronized (recvList) {
            recvList.add (recv);
            recvList.notify ();
        }
    }
    else {
        logger.error ("Receive message:" + message.getType () + ", error" + message.getError ());
        resendService.schedule (new Runnable () {
            @Override
            public void run () {
                try {
                    chat.sendMessage (message.getBody ());
                } catch (XMPPException e) {
                    logger.error ("Failed to send XMPP message", e);
                }
            }
        }
        , 5000, TimeUnit.MICROSECONDS);
    }
}


private FTPClient getFTPConnection (String strUser, String strPassword, String strServer, boolean binaryTransfer, String connectionNote) {
    FTPClient ftp = new FTPClient ();
    try {
        int reply;
        ftp.connect (strServer);
        ResourcePool.LogMessage (this, ResourcePool.INFO_MESSAGE, "Connected to " + strServer + ", " + connectionNote);
        reply = ftp.getReplyCode ();
        if (! FTPReply.isPositiveCompletion (reply)) {
            ftp.disconnect ();
            ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP server refused connection.");
            return null;
        }
    } catch (IOException e) {
        if (ftp.isConnected ()) {
            try {
                ftp.disconnect ();
            } catch (IOException f) {
                return null;
            }
        }
        ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP Could not connect to server.");
        ResourcePool.LogException (e, this);
        return null;
    }
    try {
        if (! ftp.login (strUser, strPassword)) {
            ftp.logout ();
            ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "FTP login failed.");
            return null;
        }
        ResourcePool.LogMessage (this, ResourcePool.INFO_MESSAGE, "Remote system is " + ftp.getSystemName () + ", " + connectionNote);
        if (binaryTransfer) {
            ftp.setFileType (FTP.BINARY_FILE_TYPE);
        }
        else {
            ftp.setFileType (FTP.ASCII_FILE_TYPE);
        }
        ftp.enterLocalPassiveMode ();
    } catch (FTPConnectionClosedException e) {
        ResourcePool.LogMessage (this, ResourcePool.ERROR_MESSAGE, "Server closed connection.");
        ResourcePool.LogException (e, this);
        return null;
    } catch (IOException e) {
        ResourcePool.LogException (e, this);
        return null;
    }
    return ftp;
}


-----Function Pair=56=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=57=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=58=-----==

public static File createGzip (File inputFile) {
    File targetFile = new File (inputFile.getParentFile (), inputFile.getName () + ".gz");
    if (targetFile.exists ()) {
        log.warn ("The target file '" + targetFile + "' already exists. Will overwrite");
    }
    FileInputStream in = null;
    GZIPOutputStream out = null;
    try {
        int read = 0;
        byte [] data = new byte [BUFFER_SIZE];
        in = new FileInputStream (inputFile);
        out = new GZIPOutputStream (new FileOutputStream (targetFile));
        while ((read = in.read (data, 0, BUFFER_SIZE)) != - 1) {
            out.write (data, 0, read);
        }
        in.close ();
        out.close ();
        boolean deleteSuccess = inputFile.delete ();
        if (! deleteSuccess) {
            log.warn ("Could not delete file '" + inputFile + "'");
        }
        log.info ("Successfully created gzip file '" + targetFile + "'.");
    } catch (Exception e) {
        log.error ("Exception while creating GZIP.", e);
    } finally {
        StreamUtil.tryCloseStream (in);
        StreamUtil.tryCloseStream (out);
    }
    return targetFile;
}


public static String createOutputsZip (SZGWorkflow wf) {
    System.out.println ("MiscUtils.createOutputsZip(" + wf.getUserId () + ", " + wf.getId () + ")");
    String prefix = PropertyLoader.getPrefixDir ();
    File outputsZipDir = null;
    try {
        outputsZipDir = new File (PropertyLoader.getPrefixDir () + "/tmp/" + wf.getUserId () + "/" + wf.getId ());
        if (! outputsZipDir.exists ()) {
            outputsZipDir.mkdirs ();
        }
        List < String > filesToInclude = MiscUtils.getOutputFilesList (wf.getUserId ().toString (), wf.getId ().toString ());
        if (filesToInclude == null) return null;
        File zipToCreate = File.createTempFile ("wf_out", ".zip", outputsZipDir);
        File toBeZipped = new File (prefix + "/users/" + wf.getUserId () + "/" + wf.getId () + "_files");
        boolean success = MiscUtils.zipRecursively (toBeZipped, zipToCreate, filesToInclude);
        if (success) {
            return zipToCreate.getAbsolutePath ();
        }
        else {
            return null;
        }
    } catch (Exception ex) {
        System.out.println ("ex = " + ex);
        return null;
    }
}


-----Function Pair=59=-----==

private void manageJsonException (Req req, HttpServletRequest request, AdvOgnlscriptContext context, AdvResponse response, Throwable e, String phrase) {
    if (e instanceof RuntimeException) {
        e = new RuntimeGameException (e.getCause () != null ? e.getCause () : e);
    }
    try {
        req.putLastExceptionInSession (e);
        response.printStdErr ("<div class='error'><pre>" + TextUtil.escapeHTML (TextTools.printStackTrace (e)) + "</pre></div>\n");
        List < Throwable > causeList = TextTools.getStackList (e);
        Throwable cause = causeList.get (causeList.size () - 1);
        response.printStdOut ("<pre class='error'>\n");
        response.printStdOut (e.getClass ().getName () + ": " + cause.getClass ().getName () + "\n");
        Set < String > trace = new LinkedHashSet < String > ();
        for (Throwable innerCause : causeList) {
            if (innerCause.getMessage () != null) {
                trace.add (innerCause.getMessage ());
            }
        }
        for (String message : trace) {
            response.printStdOut (TextUtil.escapeHTML (message) + "\n");
        }
        if (context.getStackTraceError () != null) {
            ListIterator < OgnlscriptTraceableException > rev = context.getStackTraceError ().listIterator (context.getStackTraceError ().size ());
            while (rev.hasPrevious ()) {
                OgnlscriptTraceableException pre = rev.previous ();
                response.printStdOut ("    en " + TextUtil.escapeHTML (pre.toString ()) + "\n");
            }
        }
        response.printStdOut ("</pre>\n");
        if (e instanceof RuntimeGameException) {
            SessionMng.getInstance ().logException (context, request, e, phrase);
        }
    } catch (Exception e2) {
        e2.printStackTrace ();
    }
}


public void actionPerformed (ActionEvent e) {
    JFrame frame = (JFrame) config_frames.get (local_dest_name);
    HashMap ps = (HashMap) parameters.get (local_dest_name);
    JTextField local_store_name = (JTextField) ps.get ("local_store_name");
    if (local_store_name.getText ().length () == 0) {
        QBrowserUtil.popupErrorMessageDialog (new Exception (resources.getString ("qkey.msg.msg295")), frame.getRootPane ());
        return;
    }
    JTextField local_store_dir_path = (JTextField) ps.get ("local_store_dir_path");
    File ifile = new File (local_store_dir_path.getText ());
    if (ifile.exists () && ifile.isDirectory ()) {
    }
    else {
        QBrowserUtil.popupErrorMessageDialog (new Exception (resources.getString ("qkey.msg.msg294")), frame.getRootPane ());
        return;
    }
    JCheckBox local_store_valid = (JCheckBox) ps.get ("local_store_valid");
    JCheckBox auto_migration = (JCheckBox) ps.get ("auto_migration");
    LocalStoreProperty lsp = lsm.getLocalStoreProperty (local_dest_name);
    File from = new File (lsp.getReal_file_directory ());
    if (! ifile.getAbsolutePath ().equals (from.getAbsolutePath ()) && auto_migration.getSelectedObjects () != null) {
        File [] fromfiles = from.listFiles ();
        StringBuffer sb = new StringBuffer ();
        for (int i = 0; i < fromfiles.length; i ++) {
            if (fromfiles [i].isFile () && fromfiles [i].getName ().endsWith ("Message.zip")) {
                try {
                    QBrowserUtil.copy (fromfiles [i], new File (ifile.getAbsolutePath () + File.separator + fromfiles [i].getName ()));
                } catch (Throwable thex) {
                    sb.append (thex.getMessage ()).append ("\n");
                }
            }
        }
        if (sb.length () != 0) {
            QBrowserUtil.popupErrorMessageDialog (new Exception (sb.toString ()), frame.getRootPane ());
        }
    }
    if (! lsp.getDestName ().equals (local_store_name.getText ())) {
        vqb2.removeNamedTabbedPane (lsp.getDestNameWithSuffix ());
        lsm.removeLocalStoreProperty (lsp);
    }
    lsp.setDestName (local_store_name.getText ());
    lsp.setReal_file_directory (ifile.getAbsolutePath ());
    if (local_store_valid.getSelectedObjects () != null) {
        lsp.setValid (true);
    }
    else {
        lsp.setValid (false);
    }
    try {
        lsm.updateAndSaveLocalStoreProperty (lsp);
    } catch (Exception lspe) {
        QBrowserUtil.popupErrorMessageDialog (lspe, frame.getRootPane ());
    }
    frame.setVisible (false);
    if (lsp.isValid ()) {
        try {
            vqb2.collectDestination ();
        } catch (Exception iie) {
            iie.printStackTrace ();
        }
    }
    vqb2.setMainDestComboBox (lsp.getDestNameWithSuffix ());
    vqb2.initLocalStoreManager ();
    vqb2.refreshLocalStoreMsgTableWithFileReloading (lsp.getDestNameWithSuffix ());
    vqb2.initTreePane ();
}


-----Function Pair=60=-----==

private InputStream getEnclosingJar () throws IOException {
    String fileName = "/" + this.getClass ().getName ().replace (".", "/") + ".class";
    URL url = this.getClass ().getResource (fileName);
    String urlFile = url.toString ();
    String delim = "!/";
    int index;
    if (! urlFile.startsWith ("jar:")) {
        throw new RuntimeException ("The protocol doesn't start with jar:");
    }
    else if ((index = urlFile.indexOf (delim)) == - 1) {
        throw new RuntimeException ("Can't find the enclosing JAR");
    }
    if (urlFile.startsWith (JAR_FILE)) {
        String jarPath = urlFile.substring (JAR_FILE.length (), index);
        jarPath = URLDecoder.decode (jarPath, "UTF-8");
        File jar = new File (jarPath);
        if (! jar.exists ()) {
            throw new RuntimeException ("The jar file : " + jarPath + " doesn't exist");
        }
        return new FileInputStream (jar);
    }
    else if (urlFile.startsWith (JAR_HTTP)) {
        String jarPath = urlFile.substring ("jar:".length (), index);
        jarPath = URLDecoder.decode (jarPath, "UTF-8");
        URL jarUrl = new URL (jarPath);
        return jarUrl.openStream ();
    }
    else {
        throw new RuntimeException ("Could not process JAR url: " + urlFile);
    }
}


private static String [] loadSqlScripts (String xmlDir) {
    String [] SQLscripts = new String [100];
    Document doc = getDocument (xmlDir + "\\SQLscripts.xml");
    Element root = doc.getDocumentElement ();
    Element sqlScript = (Element) root.getFirstChild ();
    while (sqlScript != null) {
        try {
            String sqlVersion = sqlScript.getFirstChild ().getFirstChild ().getNodeValue ();
            int version = Integer.parseInt (sqlVersion);
            String SQL = sqlScript.getFirstChild ().getNextSibling ().getFirstChild ().getNodeValue ();
            if (version < 100) {
                SQLscripts [version] = SQL;
            }
            else {
                System.out.println ("Script version " + sqlVersion + " will be excluded.");
                System.out.println ("Script version number expected to be integer between 0 and 99.");
            }
        } catch (NumberFormatException e) {
            System.out.println ("Script version expected to be a number! SqlParallelExecuter stops.");
            System.exit (0);
        }
        sqlScript = (Element) sqlScript.getNextSibling ();
    }
    return SQLscripts;
}


-----Function Pair=61=-----==

public void valueChanged (ListSelectionEvent e) {
    if (! e.getValueIsAdjusting ()) {
        VFSJFileChooser chooser = getFileChooser ();
        VFSFileSystemView fsv = chooser.getFileSystemView ();
        JList list = (JList) e.getSource ();
        if (chooser.isMultiSelectionEnabled ()) {
            FileObject [] files = null;
            Object [] objects = list.getSelectedValues ();
            if (objects != null) {
                if ((objects.length == 1) && (VFSUtils.isDirectory ((FileObject) objects [0])) && chooser.isTraversable (((FileObject) objects [0])) && ((chooser.getFileSelectionMode () == chooser.FILES_ONLY) || ! fsv.isFileSystem (((FileObject) objects [0])))) {
                    setDirectorySelected (true);
                    setDirectory (((FileObject) objects [0]));
                }
                else {
                    files = new FileObject [objects.length];
                    int j = 0;
                    for (int i = 0; i < objects.length; i ++) {
                        FileObject f = (FileObject) objects [i];
                        boolean isDir = VFSUtils.isDirectory (f);
                        boolean isFile = ! isDir;
                        if ((chooser.isFileSelectionEnabled () && isFile) || (chooser.isDirectorySelectionEnabled () && fsv.isFileSystem (f) && isDir)) {
                            files [j ++] = f;
                        }
                    }
                    if (j == 0) {
                        files = null;
                    }
                    else if (j < objects.length) {
                        FileObject [] tmpFiles = new FileObject [j];
                        System.arraycopy (files, 0, tmpFiles, 0, j);
                        files = tmpFiles;
                    }
                    setDirectorySelected (false);
                }
            }
            chooser.setSelectedFiles (files);
        }
        else {
            FileObject file = (FileObject) list.getSelectedValue ();
            if ((file != null) && VFSUtils.isDirectory (file) && chooser.isTraversable (file) && ((chooser.getFileSelectionMode () == chooser.FILES_ONLY) || ! fsv.isFileSystem (file))) {
                setDirectorySelected (true);
                setDirectory (file);
                chooser.setSelectedFile (null);
            }
            else {
                setDirectorySelected (false);
                if (file != null) {
                    chooser.setSelectedFile (file);
                }
            }
        }
    }
}


public static boolean copyTree (String sourceDir, String targetRoot) {
    boolean result;
    try {
        File source = new File (sourceDir);
        File root = new File (targetRoot);
        if (source.exists () == false || source.isDirectory () == false) {
            log.error ("Source path dosn't exsist (\"" + source.getCanonicalPath () + "\"). Can't copy files.");
            return false;
        }
        if (root.exists () == false || root.isDirectory () == false) {
            log.error ("Destination path dosn't exsist (\"" + root.getCanonicalPath () + "\"). Can't copy files.");
            return false;
        }
        String targetRootName = root.getCanonicalPath () + File.separator;
        ArrayList < File > fileNames = listAllFiles (source, true);
        result = true;
        File target;
        for (File f : fileNames) {
            String fullName = f.getCanonicalPath ();
            int pos = fullName.indexOf (sourceDir);
            String subName = null;
            if (sourceDir.endsWith ("/")) subName = fullName.substring (pos + sourceDir.length ());
            else subName = fullName.substring (pos + sourceDir.length () + 1);
            String targetName = targetRootName + subName;
            target = new File (targetName);
            if (f.isDirectory ()) {
                if (target.exists () == false) {
                    boolean st = target.mkdir ();
                    if (st == false) result = false;
                }
                continue;
            }
            boolean st = fileCopy (f, target);
            if (st == false) result = false;
        }
    } catch (Exception e) {
        e.printStackTrace ();
        result = false;
    }
    return result;
}


-----Function Pair=62=-----==

private String create (DocumentCBF doc) throws Exception {
    try {
        DocType docType = (DocType) TreeNode.getInstance (doc.getDoctypePath ());
        if (docType == null) {
            throw new Exception ("û���ҵ�path=" + doc.getDoctypePath () + "���ĵ�����!");
        }
        String sCreater = "1";
        if (doc.getCreater () != 0) {
            sCreater = "" + doc.getCreater ();
        }
        WAPI wapi = WFFactory.createWAPI (sCreater);
        int activityId = new IpWfControl ().getStartActivity (docType.getProcessId ());
        Task task = wapi.startProcessInstance (docType.getProcessId (), String.valueOf (activityId), "�������");
        String processInstId = String.valueOf (task.getProsInstId ());
        return processInstId;
    } catch (Exception e) {
        e.printStackTrace ();
        throw new Exception ("û���ҵ�path=" + doc.getDoctypePath () + "���ĵ�����!");
    }
}


public static String createOutputsZip (SZGWorkflow wf) {
    System.out.println ("MiscUtils.createOutputsZip(" + wf.getUserId () + ", " + wf.getId () + ")");
    String prefix = PropertyLoader.getPrefixDir ();
    File outputsZipDir = null;
    try {
        outputsZipDir = new File (PropertyLoader.getPrefixDir () + "/tmp/" + wf.getUserId () + "/" + wf.getId ());
        if (! outputsZipDir.exists ()) {
            outputsZipDir.mkdirs ();
        }
        List < String > filesToInclude = MiscUtils.getOutputFilesList (wf.getUserId ().toString (), wf.getId ().toString ());
        if (filesToInclude == null) return null;
        File zipToCreate = File.createTempFile ("wf_out", ".zip", outputsZipDir);
        File toBeZipped = new File (prefix + "/users/" + wf.getUserId () + "/" + wf.getId () + "_files");
        boolean success = MiscUtils.zipRecursively (toBeZipped, zipToCreate, filesToInclude);
        if (success) {
            return zipToCreate.getAbsolutePath ();
        }
        else {
            return null;
        }
    } catch (Exception ex) {
        System.out.println ("ex = " + ex);
        return null;
    }
}


-----Function Pair=63=-----==

public static void copyFile1 (File srcFile, File destFile) throws IOException {
    if (! destFile.exists ()) {
        destFile.createNewFile ();
    }
    FileInputStream fis = new FileInputStream (srcFile);
    FileOutputStream fos = new FileOutputStream (destFile);
    FileChannel source = fis.getChannel ();
    FileChannel destination = fos.getChannel ();
    destination.transferFrom (source, 0, source.size ());
    source.close ();
    destination.close ();
    fis.close ();
    fos.close ();
}


public static void writeObject (String f, Object o, int bufferSize) throws IOException {
    FileOutputStream fos = null;
    BufferedOutputStream bos = null;
    ObjectOutputStream oos = null;
    try {
        fos = new FileOutputStream (f);
        bos = new BufferedOutputStream (fos, bufferSize);
        oos = new ObjectOutputStream (bos);
        oos.writeObject (o);
    } finally {
        if (oos != null) {
            oos.close ();
            bos = null;
            fos = null;
        }
        if (bos != null) {
            bos.close ();
            fos = null;
        }
        if (fos != null) {
            fos.close ();
        }
    }
}


-----Function Pair=64=-----==

public static File extractTempFile (File file) throws IOException {
    if (file == null || ! file.exists ()) {
        throw new IllegalArgumentException ("File to unzip must be valid gzip file");
    }
    GZIPInputStream gzipInputStream = null;
    OutputStream outputStream = null;
    File outFile;
    try {
        String tempFileName = "tmp.file";
        int ndx = file.getName ().lastIndexOf (FileUtils.gz);
        if (ndx > 0) {
            tempFileName = file.getName ().substring (0, ndx);
        }
        gzipInputStream = new GZIPInputStream (new FileInputStream (file));
        String outFileName = TEMP_DIR + FILE_SEPARATOR + tempFileName;
        outFile = new File (outFileName);
        outFile.deleteOnExit ();
        outputStream = new FileOutputStream (outFile);
        byte [] buf = new byte [4096];
        int len;
        while ((len = gzipInputStream.read (buf)) > 0) {
            outputStream.write (buf, 0, len);
        }
    } finally {
        if (gzipInputStream != null) {
            gzipInputStream.close ();
        }
        if (outputStream != null) {
            outputStream.close ();
        }
    }
    return outFile;
}


public static final void sendEmail (String from, String to, String subject, String body) throws AddressException, MessagingException {
    Properties props = new Properties ();
    GlobalConfiguration globalConfig = CompoteContext.getSystemConfiguration ().getGlobalConfig ();
    props.put ("mail.smtp.host", globalConfig.getSmtpHost ());
    Session session = Session.getInstance (props, null);
    session.setDebug (true);
    Message msg = new MimeMessage (session);
    msg.setFrom (new InternetAddress (from));
    InternetAddress [] address = {new InternetAddress (to)};
    msg.setRecipients (Message.RecipientType.TO, address);
    msg.setSubject (subject);
    msg.setSentDate (new Date ());
    msg.setText (body);
    Transport.send (msg);
}


-----Function Pair=65=-----==

protected void run (DocumentFragment docFrag, int tokenKind, String tokenImage) {
    Document document = docFrag.getOwnerDocument ();
    XPathFactory factory = XPathFactory.newInstance ();
    XPath xpath = factory.newXPath ();
    NodeList nodeList = null;
    try {
        XPathExpression expr = xpath.compile ("//text()");
        nodeList = (NodeList) expr.evaluate (docFrag, XPathConstants.NODESET);
    } catch (XPathExpressionException e) {
        throw new RuntimeException ("Node list cannot be obtained.", e);
    }
    Pattern pattern = Pattern.compile (regex);
    for (int i = 0; i < nodeList.getLength (); i ++) {
        Text text = (Text) nodeList.item (i);
        Node parent = text.getParentNode ();
        String input = text.getTextContent ();
        Matcher matcher = pattern.matcher (input);
        int prevEnd = 0;
        while (matcher.find ()) {
            if (prevEnd != matcher.start ()) {
                parent.insertBefore (document.createTextNode (input.substring (prevEnd, matcher.start ())), text);
            }
            Element span = document.createElement ("span");
            span.setAttribute ("class", tagClass);
            span.setAttribute ("style", tagStyle);
            span.appendChild (document.createTextNode (matcher.group ()));
            parent.insertBefore (span, text);
            prevEnd = matcher.end ();
        }
        if (prevEnd < input.length ()) {
            parent.insertBefore (document.createTextNode (input.substring (prevEnd)), text);
        }
        text.getParentNode ().removeChild (text);
    }
}


public void compile (ProtoModule module, Proto proto) throws IOException {
    StringTemplateGroup group = getSTG ("proto_to_proto");
    String src = module.getSource ().getAbsolutePath ();
    String path = proto.getFile ().getAbsolutePath ().replace (src, "").replace (proto.getFile ().getName (), "");
    Writer writer = CompilerUtil.newWriter (module, path, proto.getFile ().getName ());
    StringBuilder builder = new StringBuilder ();
    BufferedReader reader = new BufferedReader (new FileReader (proto.getFile ()));
    String line = reader.readLine ();
    while (line != null) {
        builder.append (line);
        builder.append (LINE_SEPARATOR);
        line = reader.readLine ();
    }
    reader.close ();
    String data = builder.toString ();
    for (Message message : proto.getMessages ()) {
        Annotation annotation = message.getAnnotation ("Extend");
        if (annotation != null) {
            Object byMessageRef = annotation.getValue ("by");
            if (byMessageRef == null) throw new IllegalArgumentException ("By parameter of attribute @Extend is not specified");
            if (! (byMessageRef instanceof Message)) throw new IllegalArgumentException ("By parameter have a non Message reference in your @Extend annotation");
            Message base = (Message) byMessageRef;
            String result = extendBy (group, message, base);
            if (result != null && result.length () > 0) data = injectAfterAnnotation (message, base, data, result);
        }
        Object extOpt = message.getExtraOption ("extends");
        if (extOpt != null) {
            if (! (extOpt instanceof Message)) throw new IllegalArgumentException ("Option extends specified not a message reference");
            Message base = (Message) extOpt;
            String result = extendBy (group, message, base);
            if (result != null && result.length () > 0) data = injectAfterOption (message, base, data, result);
        }
    }
    writer.write (data);
    writer.close ();
}


-----Function Pair=66=-----==

private String fixUnicode (String s) {
    String s2 = "";
    String patron = "(\\\\[U][+])([0-9A-Fa-f]{4})";
    Pattern compiledPatron = Pattern.compile (patron);
    Matcher matcher = compiledPatron.matcher (s);
    int lastEnd = 0;
    while (matcher.find ()) {
        int start = matcher.start ();
        int end = matcher.end ();
        String code = matcher.group (2);
        String hexa = "0x" + code;
        int caracter = Integer.decode (hexa).intValue ();
        s2 = s2 + s.substring (lastEnd, start) + (char) caracter;
        lastEnd = end;
    }
    s2 = s2 + s.substring (lastEnd);
    return s2;
}


private ArrayList < ODIE_IndexFinderAnnotation > genericallyWrapTokenAnnotations (Document doc, Iterator < Annotation > tokenAnnotationsIterator) {
    ArrayList < ODIE_IndexFinderAnnotation > result = new ArrayList < ODIE_IndexFinderAnnotation > ();
    for (; tokenAnnotationsIterator.hasNext ();) {
        Annotation token = tokenAnnotationsIterator.next ();
        ODIE_IndexFinderAnnotation odieAnnot = new ODIE_IndexFinderAnnotation ();
        ODIE_IndexFinderNode odieAnnotSNode = new ODIE_IndexFinderNode ();
        ODIE_IndexFinderNode odieAnnotENode = new ODIE_IndexFinderNode ();
        String tokenKind = "word";
        String tokenString = CaTIES_Utilities.spanStrings (doc, token);
        tokenString = (tokenString != null) ? tokenString.toLowerCase () : null;
        if (tokenString == null) {
            continue;
        }
        odieAnnotSNode.setOffset (token.getStartNode ().getOffset ());
        odieAnnotENode.setOffset (token.getStartNode ().getOffset ());
        odieAnnot.setStartNode (odieAnnotSNode);
        odieAnnot.setEndNode (odieAnnotENode);
        odieAnnot.setAnnotationSetName ("Default");
        odieAnnot.setAnnotationTypeName ("Token");
        odieAnnot.getFeatures ().put ("kind", tokenKind);
        odieAnnot.getFeatures ().put ("string", tokenString);
        if (this.stemmer != null) {
            this.stemmer.add (tokenString);
            this.stemmer.stem ();
            String normalizedForm = this.stemmer.getResultString ();
            odieAnnot.getFeatures ().put ("normalizedForm", normalizedForm);
        }
        result.add (odieAnnot);
    }
    return result;
}


-----Function Pair=67=-----==

public void setMethod (String name, String content) {
    content = modContentForIds (content);
    boolean found = false;
    for (Method m : methods) {
        if (m.name.equals (name)) {
            m.content = content;
            found = true;
        }
    }
    if (! found) {
        Method m = new Method ();
        m.name = name;
        m.content = content;
        methods.add (m);
        int idx = 1;
        for (Method d : methods) {
            d.id = idx;
            idx ++;
        }
        setMethod ("start", getDefaultRunner ());
    }
}


protected VersionInfo getVersionInfo (Element versionInfoElem) {
    if (versionInfoElem != null) {
        String Organization = versionInfoElem.getAttributeValue ("Organization");
        String Version = versionInfoElem.getAttributeValue ("Version");
        String Author = versionInfoElem.getAttributeValue ("Author");
        String Date = versionInfoElem.getAttributeValue ("Date");
        String Remarks = versionInfoElem.getAttributeValue ("Remarks");
        VersionInfo versionInfo = new VersionInfo (Organization, Version, Author, Date, Remarks);
        return versionInfo;
    }
    else {
        System.err.println ("Invalid element input in getVersionInfo()");
        if (this.console != null) {
            console.setText ("Invalid element input in getVersionInfo()");
        }
        return null;
    }
}


-----Function Pair=68=-----==

private void highlightSyntax (String text) {
    IGrammar grammar = fGrammar;
    if (grammar == null) return;
    StyledText styledText = getTextWidget ();
    IModelElement [] literals = ModelElementQuery.collectLiterals (grammar);
    if (literals != null && literals.length > 0) {
        Pattern pattern = Pattern.compile ("(\\w(\\w|\\d)*)|(\\S)");
        Matcher matcher = pattern.matcher (text);
        List < StyleRange > styleRanges = new ArrayList < StyleRange > ();
        while (matcher.find ()) {
            String word = matcher.group ();
            if (word.length () > 1) {
                for (IModelElement literal : literals) {
                    String elementName = literal.getElementName ().substring (1, literal.getElementName ().length () - 1);
                    if (elementName.equals (word)) {
                        int start = matcher.start ();
                        int length = matcher.end () - matcher.start ();
                        styleRanges.add (createStyleRange (start, length));
                        break;
                    }
                }
            }
        }
        styledText.setStyleRanges (styleRanges.toArray (new StyleRange [styleRanges.size ()]));
    }
}


protected FBInterfaceList getInterfaceList (Element interfaceListElem) {
    if (interfaceListElem != null) {
        Element eventInputsElem = interfaceListElem.getChild ("EventInputs");
        Element eventOutputsElem = interfaceListElem.getChild ("EventOutputs");
        Element inputVarsElem = interfaceListElem.getChild ("InputVars");
        Element outputVarsElem = interfaceListElem.getChild ("OutputVars");
        Element socketsElem = interfaceListElem.getChild ("Sockets");
        Element plugsElem = interfaceListElem.getChild ("Plugs");
        FBEventInputs eventInputs = null;
        FBEventOutputs eventOutputs = null;
        FBInputVars inputVars = null;
        FBOutputVars outputVars = null;
        Sockets sockets = null;
        Plugs plugs = null;
        if (eventInputsElem != null) eventInputs = getEventInputs (eventInputsElem);
        if (eventOutputsElem != null) eventOutputs = getEventOutputs (eventOutputsElem);
        if (inputVarsElem != null) inputVars = getInputVars (inputVarsElem);
        if (outputVarsElem != null) outputVars = getOutputVars (outputVarsElem);
        if (socketsElem != null) sockets = getSockets (socketsElem);
        if (plugsElem != null) plugs = getPlugs (plugsElem);
        return new FBInterfaceList (eventInputs, eventOutputs, inputVars, outputVars, sockets, plugs);
    }
    else {
        System.err.println ("Invalid element input in getInterfaceList()");
        if (this.console != null) {
            console.setText ("Invalid element input in getInterfaceList()");
        }
        return null;
    }
}


-----Function Pair=69=-----==

private void zoomOutLittle () {
    double midX = (zoomMinComp1 + zoomMaxComp1) / (double) 2.0;
    double midY = (zoomMinComp2 + zoomMaxComp2) / (double) 2.0;
    double tmpMinX, tmpMaxX;
    double tmpMinY, tmpMaxY;
    if (((midX - zoomMinComp1) > 0) && ((zoomMaxComp1 - midX) > 0)) {
        tmpMinX = (int) (java.lang.Math.round (midX - (midX - zoomMinComp1) * 1.5));
        tmpMaxX = (int) (java.lang.Math.round (midX + (zoomMaxComp1 - midX) * 1.5));
    }
    else {
        tmpMinX = zoomMinComp1 - 1;
        tmpMaxX = zoomMaxComp1 + 1;
    }
    if (((midY - zoomMinComp2) > 0) && ((zoomMaxComp2 - midY) > 0)) {
        tmpMinY = midY - (midY - zoomMinComp2) * (double) 1.5;
        tmpMaxY = midY + (zoomMaxComp2 - midY) * (double) 1.5;
    }
    else {
        tmpMinY = zoomMinComp2 - 1;
        tmpMaxY = zoomMaxComp2 + 1;
    }
    if (tmpMinX < minComp1) {
        tmpMinX = minComp1;
    }
    if (tmpMaxX > maxComp1) {
        tmpMaxX = maxComp1;
    }
    if (tmpMinY < minComp2) {
        tmpMinY = minComp2;
    }
    if (tmpMaxY > maxComp2) {
        tmpMaxY = maxComp2;
    }
    zoomMinComp1 = tmpMinX;
    zoomMaxComp1 = tmpMaxX;
    zoomMinComp2 = tmpMinY;
    zoomMaxComp2 = tmpMaxY;
}


public void mouseClicked (MouseEvent evt) {
    Object src = evt.getSource ();
    boolean rightClick = (evt.getModifiers () & InputEvent.BUTTON1_MASK) != 0;
    boolean ctrlPressed = (evt.getModifiers () & InputEvent.CTRL_MASK) != 0;
    boolean popupTrigger = ! rightClick || ctrlPressed;
    if (src instanceof ItemView) {
        if (! popupTrigger) {
            ActionEvent actionEvt = new ActionEvent (this.coords, - 1, "ItemView:setItemValue");
            valActionListener.actionPerformed (actionEvt);
        }
        else {
            ItemView item = (ItemView) src;
            Integer [] candidates = null;
            ItemPopupMenu popup = view.getItemPopupMenu ();
            if (play.getOptions ().isAutoCandidate ()) {
                PlateCoords coords = getCoordinates (item);
                candidates = model.getCandidates (coords);
            }
            else {
                candidates = new Integer [ItemModel.INITIAL_CANDIDATES.length];
                for (int i = 0; i < candidates.length; i ++) {
                    candidates [i] = new Integer (ItemModel.INITIAL_CANDIDATES [i]);
                }
            }
            view.showItemPopupMenu (item, evt.getX (), evt.getY ());
            popup.setCandidates (candidates);
        }
    }
    if (! popupTrigger) {
        view.hideItemPopupMenu ();
    }
}


-----Function Pair=70=-----==

public static void main (String [] args) {
    int sizei = 2, sizej = 3;
    Random rand = new Random ();
    double [] [] links = new double [sizei] [];
    double [] [] links1 = new double [sizej] [sizei];
    for (int i = 0; i < sizei; i ++) {
        links [i] = new double [sizej];
        for (int j = 0; j < sizej; j ++) {
            links [i] [j] = rand.nextDouble () * 50;
            links1 [j] [i] = links [i] [j];
        }
    }
    printArray (links);
    System.out.println ();
    AssignmentProblem ap = new AssignmentProblem (links);
    int [] [] solution = ap.solve (new HungarianAlgorithm ());
    printArray (solution);
    System.out.println ("====");
    AssignmentProblem ap1 = new AssignmentProblem (links1);
    int [] [] solution1 = ap1.solve (new HungarianAlgorithm ());
    printArray (solution1);
    double cost = 0, rcost = 0;
    for (int i = 0; i < solution.length; i ++) {
        if (solution [i] [0] >= 0) {
            cost += links [solution [i] [0]] [i];
        }
    }
    for (int i = 0; i < solution1.length; i ++) {
        if (solution1 [i] [0] >= 0) {
            rcost += links1 [solution1 [i] [0]] [i];
        }
    }
    System.out.println ("\ncost is " + cost + " reverse cost is " + rcost);
}


public static void main (String [] args) throws FailedGenerationException, IOException {
    Logger.getLogger ("").getHandlers () [0].setLevel (Level.FINE);
    final int x = Integer.valueOf (args [0]);
    final int y = Integer.valueOf (args [1]);
    final Problem problem = new Problem ("Crossword-" + x + "x" + y);
    final Variable [] [] variables = new Variable [x] [y];
    final Domain domain = new IntervalDomain ("letters", 0, 25);
    for (int i = x; -- i >= 0;) {
        for (int j = y; -- j >= 0;) {
            problem.addVariable (variables [i] [j] = new Variable (("x" + i) + j, domain));
        }
    }
    final List < Number [] > tuples = new ArrayList < Number [] > ();
    for (String s : getDict ("crossword/french", x)) {
        Number [] tuple = new Number [s.length ()];
        for (int i = s.length (); -- i >= 0;) {
            tuple [i] = s.charAt (i) - 65;
        }
        tuples.add (tuple);
    }
    final Extension relX = new Extension ("dict-" + x, x, tuples.size (), true, tuples.toArray (new Number [tuples.size ()] []));
    tuples.clear ();
    for (String s : getDict ("crossword/french", y)) {
        Number [] tuple = new Number [s.length ()];
        for (int i = s.length (); -- i >= 0;) {
            tuple [i] = s.charAt (i) - 65;
        }
        tuples.add (tuple);
    }
    final Extension relY = new Extension ("dict-" + y, y, tuples.size (), true, tuples.toArray (new Number [tuples.size ()] []));
    for (Variable [] v : variables) {
        problem.addConstraint (new ExtensionConstraint ("", Arrays.asList (v), relY));
    }
    for (Variable [] v : transpose (variables, new Variable [y] [x])) {
        problem.addConstraint (new ExtensionConstraint ("", Arrays.asList (v), relX));
    }
    final cspfj.problem.Problem cspfjProblem = cspfj.problem.Problem.load (new CspOM (problem, 0));
    final Solver solver = new MGACIter (cspfjProblem, new ResultDisplayer (x, y, cspfjProblem.getVariables ()));
    if (! solver.runSolver ()) {
        System.out.println ("No crossword found");
    }
}


-----Function Pair=71=-----==

public DoubleMatrix add (final DoubleMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawAdd (m);
        default :
            if (numRows == m.rows () && numCols == m.columns ()) {
                final double array [] [] = new double [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    array [i] [0] = matrix [i] [0] + m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) array [i] [j] = matrix [i] [j] + m.getElement (i, j);
                }
                return new DoubleMatrix (array);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


private Instances setOutputFormatOriginal () throws Exception {
    FastVector attributes = new FastVector ();
    for (int i = 0; i < m_numAttribs; i ++) {
        String att = m_trainInstances.attribute (i).name ();
        attributes.addElement (new Attribute (att));
    }
    if (m_hasClass) {
        attributes.addElement (m_trainCopy.classAttribute ().copy ());
    }
    Instances outputFormat = new Instances (m_trainCopy.relationName () + "->PC->original space", attributes, 0);
    if (m_hasClass) {
        outputFormat.setClassIndex (outputFormat.numAttributes () - 1);
    }
    return outputFormat;
}


-----Function Pair=72=-----==

public void Recombine () {
    int NumRecParentCnt, FirstParent, SecondParent, RecIndex, LineInChildrenMatrix, ReadIndex, WriteIndex, VectorNodeValue;
    int l;
    boolean ExistFlag;
    Random r = new Random ();
    NumRecParentCnt = 0;
    RecIndex = 0;
    WriteIndex = 0;
    LineInChildrenMatrix = 0;
    ReadIndex = 0;
    l = 0;
    ExistFlag = true;
    this.NumRecParent = (int) Math.floor (Math.sqrt (NumVertices)) - this.NumMutParent;
    while (NumRecParentCnt < this.NumRecParent) {
        FirstParent = Math.abs (r.nextInt ()) % (int) Math.floor (Math.sqrt (NumVertices));
        SecondParent = Math.abs (r.nextInt ()) % (int) Math.floor (Math.sqrt (NumVertices));
        while (FirstParent == SecondParent) {
            SecondParent = Math.abs (r.nextInt ()) % (int) Math.floor (Math.sqrt (NumVertices));
        }
        RecIndex = Math.abs (r.nextInt ()) % NumVertices;
        for (int i = 0; i < RecIndex; i ++) {
            LineInChildrenMatrix = NumRecParentCnt + this.NumMutParent;
            ChildrenMatrix [i] [LineInChildrenMatrix] = ParentMatrix [i] [FirstParent];
        }
        WriteIndex = RecIndex;
        for (int i = RecIndex; i < NumVertices; i ++) {
            l = 0;
            ExistFlag = true;
            while (ExistFlag == true) {
                ReadIndex = (l + WriteIndex) % NumVertices;
                VectorNodeValue = ParentMatrix [ReadIndex] [SecondParent];
                ExistFlag = false;
                for (int k = 0; k < WriteIndex; k ++) {
                    if (ChildrenMatrix [k] [LineInChildrenMatrix] == VectorNodeValue) {
                        ExistFlag = true;
                        break;
                    }
                }
                l ++;
            }
            ChildrenMatrix [WriteIndex] [LineInChildrenMatrix] = ParentMatrix [ReadIndex] [SecondParent];
            WriteIndex ++;
        }
        NumRecParentCnt ++;
    }
    NumRecParentCnt = 0;
}


private void initControlNumberGroups () {
    NumberGroup one = new NumberGroup ();
    NumberGroup two = new NumberGroup ();
    NumberGroup three = new NumberGroup ();
    NumberGroup four = new NumberGroup ();
    NumberGroup five = new NumberGroup ();
    NumberGroup six = new NumberGroup ();
    NumberGroup seven = new NumberGroup ();
    NumberGroup eight = new NumberGroup ();
    NumberGroup nine = new NumberGroup ();
    NumberGroup ten = new NumberGroup ();
    one.length = 3;
    one.numbers.add (ss [0] [0]);
    one.numbers.add (ss [1] [0]);
    one.numbers.add (ss [2] [0]);
    one.isVertical = true;
    createInventoryControlNumberGroups.add (one);
    two.length = 3;
    two.numbers.add (ss [2] [1]);
    two.numbers.add (ss [3] [1]);
    two.numbers.add (ss [4] [1]);
    two.isVertical = true;
    createInventoryControlNumberGroups.add (two);
    three.length = 3;
    three.numbers.add (ss [1] [4]);
    three.numbers.add (ss [2] [4]);
    three.numbers.add (ss [3] [4]);
    three.isVertical = true;
    createInventoryControlNumberGroups.add (three);
    four.length = 3;
    four.numbers.add (ss [1] [1]);
    four.numbers.add (ss [1] [2]);
    four.numbers.add (ss [1] [3]);
    four.isHorizontal = true;
    createInventoryControlNumberGroups.add (four);
    five.length = 3;
    five.numbers.add (ss [4] [2]);
    five.numbers.add (ss [4] [3]);
    five.numbers.add (ss [4] [4]);
    five.isHorizontal = true;
    createInventoryControlNumberGroups.add (five);
    six.length = 2;
    six.numbers.add (ss [3] [0]);
    six.numbers.add (ss [4] [0]);
    six.isVertical = true;
    createInventoryControlNumberGroups.add (six);
    seven.length = 2;
    seven.numbers.add (ss [2] [2]);
    seven.numbers.add (ss [3] [2]);
    seven.isVertical = true;
    createInventoryControlNumberGroups.add (seven);
    eight.length = 2;
    eight.numbers.add (ss [2] [3]);
    eight.numbers.add (ss [3] [3]);
    eight.isVertical = true;
    createInventoryControlNumberGroups.add (eight);
    nine.length = 2;
    nine.numbers.add (ss [0] [1]);
    nine.numbers.add (ss [0] [2]);
    nine.isHorizontal = true;
    createInventoryControlNumberGroups.add (nine);
    ten.length = 2;
    ten.numbers.add (ss [0] [3]);
    ten.numbers.add (ss [0] [4]);
    ten.isHorizontal = true;
    createInventoryControlNumberGroups.add (ten);
}


-----Function Pair=73=-----==

public static int [] [] derivateIntArrays (String xDParam) {
    String tempStr = new String (xDParam);
    Vector tempVec = new Vector ();
    Vector resultVec = new Vector ();
    tempVec = split1 (xDParam);
    for (int i = 0; i < tempVec.size (); i ++) {
        resultVec.add (split2 ((String) tempVec.get (i), ','));
    }
    int [] [] resultInts;
    resultInts = new int [resultVec.size ()] [((Vector) resultVec.get (0)).size ()];
    for (int i = 0; i < resultVec.size (); i ++) {
        for (int j = 0; j < ((Vector) resultVec.get (0)).size (); j ++) {
            resultInts [i] [j] = Integer.parseInt (((String) ((Vector) (resultVec.get (i))).get (j)).trim ());
        }
    }
    return resultInts;
}


public static RealSquareMatrix fromUpperTriangle (RealArray f) {
    int n = f.size ();
    int rows = (int) Math.round ((Math.sqrt (8 * n + 1) - 1 + 0.001) / 2.);
    if ((rows * (rows + 1)) / 2 != n) {
        throw new RuntimeException ("band number of values (" + n + ") for lower Triangle");
    }
    RealSquareMatrix temp = new RealSquareMatrix (rows);
    int count = 0;
    for (int i = 0; i < rows; i ++) {
        for (int j = i; j < rows; j ++) {
            temp.flmat [i] [j] = f.elementAt (count);
            if (i != j) {
                temp.flmat [j] [i] = 0.0;
            }
            count ++;
        }
    }
    return temp;
}


-----Function Pair=74=-----==

public double [] [] distanceMatrix (final AISNonDominatedSolutionList visSolutionSet) {
    VISSolution solutionI, solutionJ;
    final double [] [] limits_ = visSolutionSet.getObjectiveBounds ();
    double [] [] distance = new double [visSolutionSet.size ()] [visSolutionSet.size ()];
    for (int i = 0; i < visSolutionSet.size (); i ++) {
        distance [i] [i] = 0.0;
        solutionI = (VISSolution) visSolutionSet.get (i);
        for (int j = i + 1; j < visSolutionSet.size (); j ++) {
            solutionJ = (VISSolution) visSolutionSet.get (j);
            distance [i] [j] = distanceBetweenObjectives (solutionI, solutionJ, limits_);
            distance [j] [i] = distance [i] [j];
        }
    }
    return distance;
}


public static ViterbiElement [] getLogViterbi (ViterbiElement [] logV, double [] [] logA) {
    YeriDebug.ASSERT (logV.length != 0, "Null Vector");
    YeriDebug.ASSERT (logA.length != 0, "Null Matrix");
    YeriDebug.ASSERT (CollectionsToolkit.isRectangular (logA), "Matrix is not rectangular!");
    YeriDebug.ASSERT_compareInteger (logV.length, logA.length);
    ViterbiElement [] logResult = new ViterbiElement [logV.length];
    for (int j = 0; j < logA [0].length; j ++) {
        double [] pathScoreArray = new double [logV.length];
        for (int i = 0; i < logV.length; i ++) {
            pathScoreArray [i] = StatisticsToolkit.logMultiply (logV [i].getScore (), logA [i] [j]);
        }
        ViterbiElement viterbiElement = StatisticsToolkit.getViterbiMax (pathScoreArray);
        logResult [j] = viterbiElement;
    }
    return logResult;
}


-----Function Pair=75=-----==

private Matrix ParMultiplyMatrix (Matrix Mb, int granX, int granY) throws Exception {
    float [] [] b = Mb.getMatrix ();
    float [] [] a = this.matrix;
    if (a [0].length != b.length) throw new Exception ("Matrices incompatible for multiplication");
    float matrix [] [] = new float [a.length] [b [0].length];
    for (int i = 0; i < a.length; i = i + granX) for (int j = 0; j < b [i].length; j = j + granY) matrix [i] [j] = 0;
    Matrix res = new Matrix (matrix);
    Semaphore s = new Semaphore (matrix.length);
    for (int i = 0; i < matrix.length / granX; i ++) {
        for (int j = 0; j < matrix [0].length / granY; j ++) {
            Thread f = new Product (a, i * granX, b, j * granY, res, s, granX, granY);
            f.start ();
        }
    }
    s.acquire (matrix.length);
    return new Matrix (matrix);
}


public static SRPGAnimation makeObject (String fileName, int row, int col, int tileWidth, int tileHeight) {
    String key = fileName.trim ().toLowerCase ();
    SRPGAnimation animation = (SRPGAnimation) animations.get (key);
    if (animation == null) {
        Image [] [] images = GraphicsUtils.getSplit2Images (fileName, tileWidth, tileHeight);
        Image [] [] result = new Image [row] [col];
        for (int y = 0; y < col; y ++) {
            for (int x = 0; x < row; x ++) {
                result [x] [y] = images [y] [x];
            }
        }
        images = null;
        animations.put (key, animation = makeObject (result [0], result [1], result [2], result [3]));
    }
    return animation;
}


-----Function Pair=76=-----==

Message generateReply (Message query, byte [] in, Socket s) {
    boolean badversion;
    int maxLength;
    boolean sigonly;
    SetResponse sr;
    if (query.getHeader ().getOpcode () != Opcode.QUERY) return errorMessage (query, Rcode.NOTIMPL);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (! tsig.verify (query, in, null)) return formerrMessage (in);
    }
    OPTRecord queryOPT = query.getOPT ();
    if (queryOPT != null && queryOPT.getVersion () > 0) badversion = true;
    if (s != null) maxLength = 65535;
    else if (queryOPT != null) maxLength = queryOPT.getPayloadSize ();
    else maxLength = 512;
    Message response = new Message ();
    response.getHeader ().setID (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.QR);
    if (query.getHeader ().getFlag (Flags.RD));
    response.getHeader ().setFlag (Flags.RD);
    response.addRecord (queryRecord, Section.QUESTION);
    Name name = queryRecord.getName ();
    short type = queryRecord.getType ();
    short dclass = queryRecord.getDClass ();
    if (type == Type.AXFR && s != null) return doAXFR (name, query, s);
    if (! Type.isRR (type) && type != Type.ANY) return errorMessage (query, Rcode.NOTIMPL);
    byte rcode = addAnswer (response, name, type, dclass, 0);
    if (rcode != Rcode.NOERROR && rcode != Rcode.NXDOMAIN) return errorMessage (query, rcode);
    addAdditional (response);
    if (queryTSIG != null) {
        try {
            if (tsig != null) tsig.apply (response, queryTSIG);
        } catch (IOException e) {
        }
    }
    try {
        response.freeze ();
        byte [] out = response.toWire ();
        if (out.length > maxLength) {
            response.thaw ();
            truncate (response, out.length, maxLength);
            if (tsig != null) tsig.apply (response, queryTSIG);
        }
    } catch (IOException e) {
    }
    return response;
}


Message generateReply (Message query, byte [] in, int maxLength) {
    if (query.getHeader ().getOpcode () != Opcode.QUERY) return notimplMessage (query);
    Record queryRecord = query.getQuestion ();
    TSIGRecord queryTSIG = query.getTSIG ();
    TSIG tsig = null;
    if (queryTSIG != null) {
        tsig = findTSIG (queryTSIG.getName ());
        if (! tsig.verify (query, in, null)) return formerrMessage (in);
    }
    Message response = new Message ();
    response.getHeader ().setID (query.getHeader ().getID ());
    response.getHeader ().setFlag (Flags.AA);
    response.getHeader ().setFlag (Flags.QR);
    response.addRecord (queryRecord, Section.QUESTION);
    Name name = queryRecord.getName ();
    short type = queryRecord.getType ();
    short dclass = queryRecord.getDClass ();
    Zone zone = findBestZone (name);
    if (zone != null) {
        SetResponse zr = zone.findRecords (name, type);
        if (zr.isNXDOMAIN ()) response.getHeader ().setRcode (Rcode.NXDOMAIN);
        Vector backtrace = zr.backtrace ();
        if (backtrace != null) {
            Enumeration e = backtrace.elements ();
            while (e.hasMoreElements ()) {
                Record cname = (Record) e.nextElement ();
                response.addRecord (cname, Section.ANSWER);
            }
        }
        if (zr.isSuccessful ()) {
            RRset [] rrsets = zr.answers ();
            for (int i = 0; i < rrsets.length; i ++) addRRset (response, rrsets [i]);
        }
    }
    else {
        SetResponse cr;
        cr = cache.lookupRecords (name, type, dclass, Credibility.NONAUTH_ANSWER);
        Vector backtrace = cr.backtrace ();
        if (backtrace != null) {
            Enumeration e = backtrace.elements ();
            while (e.hasMoreElements ()) {
                Record cname = (Record) e.nextElement ();
                response.addRecord (cname, Section.ANSWER);
            }
            if (! cr.isSuccessful ()) response.getHeader ().setRcode (Rcode.NXDOMAIN);
        }
        if (cr.isSuccessful ()) {
            RRset [] rrsets = cr.answers ();
            for (int i = 0; i < rrsets.length; i ++) addRRset (response, rrsets [i]);
        }
    }
    addAuthority (response, name, zone);
    addAdditional (response);
    if (queryTSIG != null) {
        try {
            if (tsig != null) tsig.apply (response, queryTSIG);
        } catch (IOException e) {
        }
    }
    try {
        byte [] out = response.toWire ();
        if (out.length > maxLength) {
            truncate (response, out.length, maxLength);
            if (tsig != null) tsig.apply (response, queryTSIG);
        }
    } catch (IOException e) {
    }
    return response;
}


-----Function Pair=77=-----==

private void loadServiceNames () {
    try {
        java.io.InputStream inStr = null;
        ClassLoader cl = null;
        try {
            cl = ClassLoader.getSystemClassLoader ();
        } catch (java.lang.NoClassDefFoundError e) {
        } catch (java.lang.NoSuchMethodError e) {
        }
        if (cl != null) {
            inStr = cl.getResourceAsStream ("nmap-services");
        }
        if (inStr == null) {
            String classpath = System.getProperty ("java.class.path");
            if (classpath == null) {
                classpath = new String ("");
            }
            java.util.StringTokenizer st = new java.util.StringTokenizer (classpath, ":");
            String path;
            java.io.File file;
            while (st.hasMoreTokens ()) {
                path = st.nextToken ();
                file = new java.io.File (path, "/nmap-services");
                if (file.exists ()) {
                    inStr = new java.io.FileInputStream (file);
                    break;
                }
            }
            if (inStr == null) {
                file = new java.io.File (".", "/nmap-services");
                if (file.exists ()) {
                    inStr = new java.io.FileInputStream (file);
                }
            }
        }
        if (inStr != null) {
            java.io.InputStreamReader inStrReader = new java.io.InputStreamReader (inStr);
            java.io.BufferedReader bRead = new java.io.BufferedReader (inStrReader);
            String line;
            while ((line = bRead.readLine ()) != null) {
                int idx;
                line = line.trim ();
                if ((line.length () == 0) || (line.charAt (0) == '#')) {
                    continue;
                }
                String [] toks = line.split ("\\s+");
                if (toks.length < 2) {
                    continue;
                }
                String serviceName = toks [0];
                Integer port = new Integer (0);
                String protocol = "";
                String [] portAndProtocol = toks [1].split ("/");
                if (portAndProtocol.length != 2) {
                    continue;
                }
                try {
                    port = Integer.decode (portAndProtocol [0]);
                } catch (NumberFormatException nfe) {
                    System.err.println ("Unparsable port: " + portAndProtocol [0]);
                    continue;
                }
                protocol = portAndProtocol [1].trim ();
                if (protocol.equalsIgnoreCase ("tcp")) {
                    tcpServices.put (port, serviceName);
                }
                else if (protocol.equalsIgnoreCase ("udp")) {
                    udpServices.put (port, serviceName);
                }
                else {
                    System.err.println ("Unrecognized protocol in line: \"" + line + "\"");
                }
            }
            if (inStr instanceof java.io.FileInputStream) {
                inStr.close ();
            }
        }
    } catch (java.lang.Exception e) {
    } catch (java.lang.Error e) {
    }
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new HashMap ();
    znames = new HashMap ();
    TSIGs = new HashMap ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) ports.add (Short.valueOf (st.nextToken ()));
        else if (keyword.equals ("address")) {
            String addr = st.nextToken ();
            addresses.add (InetAddress.getByName (addr));
        }
        else {
            System.out.println ("ignoring invalid keyword: " + keyword);
        }
    }
    if (ports.size () == 0) ports.add (new Short ((short) 53));
    if (addresses.size () == 0) addresses.add (null);
    Iterator iaddr = addresses.iterator ();
    while (iaddr.hasNext ()) {
        InetAddress addr = (InetAddress) iaddr.next ();
        Iterator iport = ports.iterator ();
        while (iport.hasNext ()) {
            short port = ((Short) iport.next ()).shortValue ();
            String addrString;
            addUDP (addr, port);
            addTCP (addr, port);
            if (addr == null) addrString = "0.0.0.0";
            else addrString = addr.getHostAddress ();
            System.out.println ("jnamed: listening on " + addrString + "#" + port);
        }
    }
    System.out.println ("jnamed: running");
}


-----Function Pair=78=-----==

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new HashMap ();
    znames = new HashMap ();
    TSIGs = new HashMap ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) ports.add (Short.valueOf (st.nextToken ()));
        else if (keyword.equals ("address")) {
            String addr = st.nextToken ();
            addresses.add (InetAddress.getByName (addr));
        }
        else {
            System.out.println ("ignoring invalid keyword: " + keyword);
        }
    }
    if (ports.size () == 0) ports.add (new Short ((short) 53));
    if (addresses.size () == 0) addresses.add (null);
    Iterator iaddr = addresses.iterator ();
    while (iaddr.hasNext ()) {
        InetAddress addr = (InetAddress) iaddr.next ();
        Iterator iport = ports.iterator ();
        while (iport.hasNext ()) {
            short port = ((Short) iport.next ()).shortValue ();
            String addrString;
            addUDP (addr, port);
            addTCP (addr, port);
            if (addr == null) addrString = "0.0.0.0";
            else addrString = addr.getHostAddress ();
            System.out.println ("jnamed: listening on " + addrString + "#" + port);
        }
    }
    System.out.println ("jnamed: running");
}


byte addAnswer (Message response, Name name, short type, short dclass, int iterations) {
    SetResponse sr;
    boolean sigonly;
    byte rcode = Rcode.NOERROR;
    if (iterations > 6) return Rcode.NOERROR;
    if (type == Type.SIG) {
        type = Type.ANY;
        sigonly = true;
    }
    else sigonly = false;
    Zone zone = findBestZone (name);
    if (zone != null) sr = zone.findRecords (name, type);
    else {
        Cache cache = getCache (dclass);
        sr = cache.lookupRecords (name, type, Credibility.NONAUTH_ANSWER);
    }
    if (sr.isUnknown ()) {
        addCacheNS (response, getCache (dclass), name);
    }
    if (sr.isNXDOMAIN ()) {
        response.getHeader ().setRcode (Rcode.NXDOMAIN);
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        rcode = Rcode.NXDOMAIN;
    }
    else if (sr.isNXRRSET ()) {
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
    }
    else if (sr.isDelegation ()) {
        RRset nsRecords = sr.getNS ();
        addRRset (nsRecords.getName (), response, nsRecords, Section.AUTHORITY, false);
    }
    else if (sr.isCNAME ()) {
        RRset rrset = new RRset ();
        CNAMERecord cname = sr.getCNAME ();
        rrset.addRR (cname);
        addRRset (name, response, rrset, Section.ANSWER, false);
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, cname.getTarget (), type, dclass, iterations + 1);
    }
    else if (sr.isDNAME ()) {
        RRset rrset = new RRset ();
        DNAMERecord dname = sr.getDNAME ();
        rrset.addRR (dname);
        addRRset (name, response, rrset, Section.ANSWER, false);
        Name newname = name.fromDNAME (dname);
        if (newname == null) return Rcode.SERVFAIL;
        try {
            rrset = new RRset ();
            rrset.addRR (new CNAMERecord (name, dclass, 0, newname));
            addRRset (name, response, rrset, Section.ANSWER, false);
        } catch (IOException e) {
        }
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, newname, type, dclass, iterations + 1);
    }
    else if (sr.isSuccessful ()) {
        RRset [] rrsets = sr.answers ();
        for (int i = 0; i < rrsets.length; i ++) addRRset (name, response, rrsets [i], Section.ANSWER, sigonly);
        if (zone != null) {
            addNS (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        else addCacheNS (response, getCache (dclass), name);
    }
    return rcode;
}


-----Function Pair=79=-----==

private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=80=-----==

public static void parseMimeTypes (String file, Map mimeTypes) {
    BufferedReader mimefile = null;
    try {
        if (new File (file).exists () == true) {
            mimefile = new BufferedReader (new FileReader (file));
            String aLine, Mime, value;
            while (mimefile.ready ()) {
                aLine = mimefile.readLine ();
                if (aLine != null && aLine.length () > 0) {
                    aLine = aLine.trim ().replace ('\t', ' ');
                    if (aLine.length () > 0 && aLine.charAt (0) != '#') {
                        int positionOfSpace = aLine.indexOf (' ');
                        if (positionOfSpace != - 1) {
                            Mime = aLine.substring (0, positionOfSpace).trim ();
                            value = aLine.substring (positionOfSpace + 1).trim ();
                            String aValue;
                            StringTokenizer valueTokened = new StringTokenizer (value);
                            while (valueTokened.hasMoreTokens () == true) {
                                aValue = valueTokened.nextToken ();
                                mimeTypes.put (aValue, Mime);
                            }
                        }
                    }
                }
            }
        }
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
    } finally {
        try {
            if (mimefile != null) mimefile.close ();
        } catch (IOException e) {
        }
    }
}


Message doAXFR (Name name, Message query, Socket s) {
    Zone zone = (Zone) znames.get (name);
    if (zone == null) {
        return errorMessage (query, Rcode.REFUSED);
    }
    Enumeration e = zone.AXFR ();
    try {
        DataOutputStream dataOut;
        dataOut = new DataOutputStream (s.getOutputStream ());
        while (e.hasMoreElements ()) {
            RRset rrset = (RRset) e.nextElement ();
            Message response = new Message ();
            addRRset (rrset.getName (), response, rrset, false);
            byte [] out = response.toWire ();
            dataOut.writeShort (out.length);
            dataOut.write (out);
        }
    } catch (IOException ex) {
        System.out.println ("AXFR failed");
    }
    try {
        s.close ();
    } catch (IOException ex) {
    }
    return null;
}


-----Function Pair=81=-----==

public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


public void TCPclient (Socket s) {
    try {
        int inLength;
        DataInputStream dataIn;
        DataOutputStream dataOut;
        byte [] in;
        InputStream is = s.getInputStream ();
        dataIn = new DataInputStream (is);
        inLength = dataIn.readUnsignedShort ();
        in = new byte [inLength];
        dataIn.readFully (in);
        Message query;
        byte [] response = null;
        try {
            query = new Message (in);
            response = generateReply (query, in, in.length, s);
            if (response == null) return;
        } catch (IOException e) {
            response = formerrMessage (in);
        }
        dataOut = new DataOutputStream (s.getOutputStream ());
        dataOut.writeShort (response.length);
        dataOut.write (response);
    } catch (IOException e) {
        System.out.println ("TCPclient(" + addrport (s.getLocalAddress (), s.getLocalPort ()) + "): " + e);
    } finally {
        try {
            s.close ();
        } catch (IOException e) {
        }
    }
}


-----Function Pair=82=-----==

private int evalExpr (StreamTokenizer st) throws IOException {
    int val = evalTerm (st);
    int token = st.nextToken ();
    while (token == '+' || token == '-' || token == '|' || token == '^') {
        int t = evalTerm (st);
        switch (token) {
            case '+' :
                val += t;
                break;
            case '-' :
                val -= t;
                break;
            case '|' :
                val |= t;
                break;
            case '^' :
                val ^= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=83=-----==

public static final void unzipFolder (String inFile, String outFolder) throws IOException {
    File zip = new File (inFile);
    File extractTo = new File (outFolder);
    ZipFile archive = new ZipFile (zip);
    Enumeration e = archive.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        File file = new File (extractTo, entry.getName ());
        if (entry.isDirectory () && ! file.exists ()) {
            file.mkdirs ();
        }
        else {
            if (! file.getParentFile ().exists ()) {
                file.getParentFile ().mkdirs ();
            }
            InputStream in = archive.getInputStream (entry);
            BufferedOutputStream out = new BufferedOutputStream (new FileOutputStream (file));
            byte [] buffer = new byte [8192];
            int read;
            while (- 1 != (read = in.read (buffer))) {
                out.write (buffer, 0, read);
            }
            in.close ();
            out.close ();
        }
    }
}


private static void setEnvEntry (File fromEAR, File toEAR, String ejbJarName, String envEntryName, String envEntryValue) throws Exception {
    ZipInputStream earFile = new ZipInputStream (new FileInputStream (fromEAR));
    FileOutputStream fos = new FileOutputStream (toEAR);
    ZipOutputStream tempZip = new ZipOutputStream (fos);
    ZipEntry next = earFile.getNextEntry ();
    while (next != null) {
        ByteArrayOutputStream content = new ByteArrayOutputStream ();
        byte [] data = new byte [30000];
        int numberread;
        while ((numberread = earFile.read (data)) != - 1) {
            content.write (data, 0, numberread);
        }
        if (next.getName ().equals (ejbJarName)) {
            content = editEJBJAR (next, content, envEntryName, envEntryValue);
            next = new ZipEntry (ejbJarName);
        }
        tempZip.putNextEntry (next);
        tempZip.write (content.toByteArray ());
        next = earFile.getNextEntry ();
    }
    earFile.close ();
    tempZip.close ();
    fos.close ();
}


-----Function Pair=84=-----==

static List < File > listAllFilesAndFolders (final File dir, final List < File > list) {
    File [] files = dir.listFiles ();
    if (files != null) {
        for (int i = 0; i < files.length; i ++) {
            File currentFile = files [i];
            boolean currentFileIsDir = currentFile.isDirectory ();
            if (currentFileIsDir) {
                if (currentFile.isHidden ()) {
                    continue;
                }
                if (currentFile.getName ().equalsIgnoreCase ("CVS")) {
                    continue;
                }
                list.add (currentFile);
                listAllFilesAndFolders (currentFile, list);
            }
            else {
                list.add (currentFile);
            }
        }
    }
    return list;
}


private String getCapTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = - 1;
    if (item != null) type = item.getCapType ();
    if (type == - 1) {
        typeList.append ("<label><input name='captype' type='radio' value='-1' checked>AutoSelect</label><br>\n");
    }
    else {
        typeList.append ("<label><input name='captype' type='radio' value='-1'>AutoSelect</label><br>\n");
    }
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int x = 0; x < capabilities.size (); x ++) {
        CaptureCapability capability = capabilities.get (x);
        typeList.append ("<label><input name='captype' type='radio' value='" + capability.getTypeID () + "' ");
        if (type == capability.getTypeID ()) typeList.append ("checked");
        typeList.append (">" + capability.getName () + "</label><br>\n");
    }
    return typeList.toString ();
}


-----Function Pair=85=-----==

public void call (int param) {
    ECBClass tmpECB = ECBList;
    ECBClass tmp2ECB;
    while (tmpECB != null) {
        tmp2ECB = tmpECB.nextECB;
        if (tmpECB.iuflag == USEFLAG_AESCOUNT && param == tmpECB.ECBAddr) {
            tmpECB.setCompletionFlag (COMP_SUCCESS);
            tmpECB.setInUseFlag (USEFLAG_AVAILABLE);
            tmpECB.NotifyESR ();
            return;
        }
        tmpECB = tmp2ECB;
    }
    Log.log_msg ("!!!! Rouge AES !!!!");
}


public void run () {
    String line;
    BufferedReader br = new BufferedReader (new InputStreamReader (_in));
    PrintStream o = new PrintStream (_out);
    while (! stop) {
        try {
            while ((line = br.readLine ()) != null) {
                o.println (_prefix + line);
            }
        } catch (IOException e) {
        }
        try {
            Thread.sleep (200);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=86=-----==

public void initializeMyFrame () throws Exception {
    this.getContentPane ().setLayout (wholeFrameLayout);
    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    this.setSize (new Dimension (screenSize.width * 19 / 20, screenSize.height * 19 / 20));
    this.setTitle ("TASSEL (Trait Analysis by aSSociation, Evolution, and Linkage)");
    this.addWindowListener (new java.awt.event.WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            this_windowClosing (e);
        }
    }
    );
    filerSave.setDialogType (JFileChooser.SAVE_DIALOG);
    mainPanel.setLayout (mainPanelLayout);
    dataTreeReportPanelsSplitPanel.setOrientation (JSplitPane.VERTICAL_SPLIT);
    optionsPanelPanel.setLayout (new BorderLayout ());
    dataTreePanelPanel.setLayout (dataTreePanelPanelLayout);
    dataTreePanelPanel.setToolTipText ("Data Tree Panel");
    reportPanel.setLayout (reportPanelLayout);
    reportPanelTextArea.setEditable (true);
    reportPanelTextArea.setToolTipText ("Report Panel");
    reportPanelTextArea.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseReleased (MouseEvent e) {
            noteTextArea_mouseReleased (e);
        }
    }
    );
    reportPanelTextArea.addKeyListener (new java.awt.event.KeyAdapter () {
        public void keyTyped (KeyEvent e) {
            noteTextArea_keyTyped (e);
        }
    }
    );
    mainPanelTextArea.setDoubleBuffered (true);
    mainPanelTextArea.setEditable (false);
    mainPanelTextArea.setFont (new java.awt.Font ("Monospaced", 0, 12));
    mainPanelTextArea.setToolTipText ("Main Panel");
    mainPanelTextArea.addMouseListener (new java.awt.event.MouseAdapter () {
        public void mouseClicked (MouseEvent e) {
            mainTextArea_mouseClicked (e);
        }
    }
    );
    statusBar.setBackground (Color.lightGray);
    statusBar.setBorder (null);
    statusBar.setText ("Program Status");
    modeSelectorsPanel.setLayout (new GridBagLayout ());
    modeSelectorsPanel.setMinimumSize (new Dimension (380, 32));
    modeSelectorsPanel.setPreferredSize (new Dimension (700, 32));
    URL imageURL = QTPAnalyzerFrame.class.getResource ("images/help1.gif");
    ImageIcon helpIcon = null;
    if (imageURL != null) helpIcon = new ImageIcon (imageURL);
    if (helpIcon != null) helpButton.setIcon (helpIcon);
    helpButton.setMargin (new Insets (0, 0, 0, 0));
    helpButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpButton_actionPerformed (e);
        }
    }
    );
    helpButton.setBackground (Color.white);
    helpButton.setMinimumSize (new Dimension (20, 20));
    helpButton.setToolTipText ("Help me!!");
    resultButton.setText ("Results");
    resultButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            resultButton_actionPerformed (e);
        }
    }
    );
    resultButton.setMargin (new Insets (2, 2, 2, 2));
    imageURL = QTPAnalyzerFrame.class.getResource ("images/Results.gif");
    ImageIcon resultsIcon = null;
    if (imageURL != null) resultsIcon = new ImageIcon (imageURL);
    if (resultsIcon != null) resultButton.setIcon (resultsIcon);
    resultButton.setPreferredSize (new Dimension (90, 25));
    resultButton.setMinimumSize (new Dimension (87, 25));
    resultButton.setMaximumSize (new Dimension (90, 25));
    resultButton.setBackground (Color.white);
    saveButton.setMargin (new Insets (0, 0, 0, 0));
    saveButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveButton_actionPerformed (e);
        }
    }
    );
    saveButton.setBackground (Color.white);
    saveButton.setMinimumSize (new Dimension (20, 20));
    saveButton.setToolTipText ("Save selected data to text file");
    imageURL = QTPAnalyzerFrame.class.getResource ("images/save1.gif");
    ImageIcon saveIcon = null;
    if (imageURL != null) saveIcon = new ImageIcon (imageURL);
    if (saveIcon != null) saveButton.setIcon (saveIcon);
    dataButton.setBackground (Color.white);
    dataButton.setMaximumSize (new Dimension (90, 25));
    dataButton.setMinimumSize (new Dimension (87, 25));
    dataButton.setPreferredSize (new Dimension (90, 25));
    imageURL = QTPAnalyzerFrame.class.getResource ("images/DataSeq.gif");
    ImageIcon dataSeqIcon = null;
    if (imageURL != null) dataSeqIcon = new ImageIcon (imageURL);
    if (dataSeqIcon != null) dataButton.setIcon (dataSeqIcon);
    dataButton.setMargin (new Insets (2, 2, 2, 2));
    dataButton.setText ("Data");
    dataButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            dataButton_actionPerformed (e);
        }
    }
    );
    jProgressBar.setBackground (Color.white);
    jProgressBar.setForeground (Color.red);
    jProgressBar.setPreferredSize (new Dimension (100, 16));
    jProgressBar.setStringPainted (true);
    printButton.setBackground (Color.white);
    printButton.setToolTipText ("Print selected datum");
    imageURL = QTPAnalyzerFrame.class.getResource ("images/print1.gif");
    ImageIcon printIcon = null;
    if (imageURL != null) printIcon = new ImageIcon (imageURL);
    if (printIcon != null) printButton.setIcon (printIcon);
    printButton.setMargin (new Insets (0, 0, 0, 0));
    printButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            printButton_actionPerformed (e);
        }
    }
    );
    analysisButton.setText ("Analysis");
    analysisButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            analysisButton_actionPerformed (e);
        }
    }
    );
    analysisButton.setMargin (new Insets (2, 2, 2, 2));
    imageURL = QTPAnalyzerFrame.class.getResource ("images/Analysis.gif");
    ImageIcon analysisIcon = null;
    if (imageURL != null) analysisIcon = new ImageIcon (imageURL);
    if (analysisIcon != null) analysisButton.setIcon (analysisIcon);
    analysisButton.setPreferredSize (new Dimension (90, 25));
    analysisButton.setMinimumSize (new Dimension (87, 25));
    analysisButton.setMaximumSize (new Dimension (90, 25));
    analysisButton.setBackground (Color.white);
    deleteButton.setOpaque (true);
    deleteButton.setForeground (Color.RED);
    deleteButton.setText ("Delete");
    deleteButton.setFont (new java.awt.Font ("Dialog", 1, 12));
    deleteButton.setToolTipText ("Delete Dataset");
    deleteButton.setMargin (new Insets (2, 2, 2, 2));
    deleteButton.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            theDataTreePanel.deleteSelectedNodes ();
        }
    }
    );
    optionsPanel.setLayout (optionsPanelLayout);
    buttonPanel.setLayout (buttonPanelLayout);
    buttonPanel.setMinimumSize (new Dimension (300, 34));
    buttonPanel.setPreferredSize (new Dimension (300, 34));
    buttonPanelLayout.setHgap (0);
    buttonPanelLayout.setVgap (0);
    optionsPanel.setToolTipText ("Options Panel");
    optionsPanelLayout.setVgap (0);
    mainPopupMenu.setInvoker (this);
    saveMainMenuItem.setText ("Save");
    matchCheckBoxMenuItem.setText ("Match");
    matchCheckBoxMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            matchCheckBoxMenuItem_actionPerformed (e);
        }
    }
    );
    fileMenu.setText ("File");
    toolsMenu.setText ("Tools");
    saveCompleteDataTreeMenuItem.setText ("Save Data Tree");
    saveCompleteDataTreeMenuItem.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveCompleteDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    saveDataTreeAsMenuItem.setText ("Save data tree as ...");
    saveDataTreeAsMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    openCompleteDataTreeMenuItem.setText ("Open Data Tree");
    openCompleteDataTreeMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openCompleteDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    openDataMenuItem.setText ("Open ...");
    openDataMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openDataMenuItem_actionPerformed (e);
        }
    }
    );
    openMultipeAlignmentFileMenuItem.setText ("Open Multiple Alignment File...");
    openMultipeAlignmentFileMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            openMultipleAlignmentFile_actionPerformed (e);
        }
    }
    );
    saveSelectedDataTreeMenuItem.setText ("Save Selected Dataset As...");
    saveSelectedDataTreeMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            saveSelectedDataTreeMenuItem_actionPerformed (e);
        }
    }
    );
    exitMenuItem.setText ("Exit");
    exitMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            exitMenuItem_actionPerformed (e);
        }
    }
    );
    helpMenu.setText ("Help");
    helpMenuItem.setText ("Help Manual");
    helpMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpMenuItem_actionPerformed (e);
        }
    }
    );
    contigencyMenuItem.setText ("Contigency Test");
    contigencyMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            contigencyMenuItem_actionPerformed (e);
        }
    }
    );
    preferencesMenuItem.setText ("Set Preferences");
    preferencesMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            preferencesMenuItem_actionPerformed (e);
        }
    }
    );
    aboutMenuItem.setText ("About");
    aboutMenuItem.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (ActionEvent e) {
            helpAbout_actionPerformed (e);
        }
    }
    );
    this.getContentPane ().add (dataTreeReportMainPanelsSplitPanel, BorderLayout.CENTER);
    dataTreeReportMainPanelsSplitPanel.add (optionsPanelPanel, JSplitPane.TOP);
    optionsPanelPanel.add (dataTreeReportPanelsSplitPanel, BorderLayout.CENTER);
    dataTreeReportPanelsSplitPanel.add (dataTreePanelPanel, JSplitPane.TOP);
    dataTreePanelPanel.add (theDataTreePanel, BorderLayout.CENTER);
    dataTreeReportPanelsSplitPanel.add (reportPanel, JSplitPane.BOTTOM);
    reportPanel.add (reportPanelScrollPane, BorderLayout.CENTER);
    reportPanelScrollPane.getViewport ().add (reportPanelTextArea, null);
    dataTreeReportMainPanelsSplitPanel.add (mainPanel, JSplitPane.BOTTOM);
    mainPanel.add (mainDisplayPanel, BorderLayout.CENTER);
    mainDisplayPanel.setLayout (new BorderLayout ());
    mainPanelScrollPane.getViewport ().add (mainPanelTextArea, null);
    mainDisplayPanel.add (mainPanelScrollPane, BorderLayout.CENTER);
    mainPanelScrollPane.getViewport ().add (mainPanelTextArea, null);
    this.getContentPane ().add (statusBar, BorderLayout.SOUTH);
    this.getContentPane ().add (optionsPanel, BorderLayout.NORTH);
    optionsPanel.add (modeSelectorsPanel, null);
    modeSelectorsPanel.add (resultButton, new GridBagConstraints (2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (dataButton, new GridBagConstraints (0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 4, 1, 0), 0, 0));
    modeSelectorsPanel.add (analysisButton, new GridBagConstraints (1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (helpButton, new GridBagConstraints (8, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 2), 0, 0));
    modeSelectorsPanel.add (printButton, new GridBagConstraints (6, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (saveButton, new GridBagConstraints (7, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 0, 1, 0), 0, 0));
    modeSelectorsPanel.add (deleteButton, new GridBagConstraints (3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets (2, 20, 1, 2), 0, 0));
    modeSelectorsPanel.add (jProgressBar, new GridBagConstraints (5, 0, 1, 1, 0.0, 0.0, GridBagConstraints.SOUTH, GridBagConstraints.VERTICAL, new Insets (6, 252, 6, 8), 57, 0));
    optionsPanel.add (buttonPanel, null);
    mainPopupMenu.add (matchCheckBoxMenuItem);
    mainPopupMenu.add (saveMainMenuItem);
    jMenuBar.add (fileMenu);
    jMenuBar.add (toolsMenu);
    jMenuBar.add (helpMenu);
    fileMenu.add (saveCompleteDataTreeMenuItem);
    fileMenu.add (openCompleteDataTreeMenuItem);
    fileMenu.add (saveDataTreeAsMenuItem);
    fileMenu.add (openDataMenuItem);
    fileMenu.add (openMultipeAlignmentFileMenuItem);
    fileMenu.add (saveSelectedDataTreeMenuItem);
    fileMenu.addSeparator ();
    fileMenu.add (exitMenuItem);
    toolsMenu.add (contigencyMenuItem);
    toolsMenu.add (preferencesMenuItem);
    helpMenu.add (helpMenuItem);
    helpMenu.add (aboutMenuItem);
    this.setJMenuBar (jMenuBar);
    dataTreeReportMainPanelsSplitPanel.setDividerLocation (this.getSize ().width / 4);
    dataTreeReportPanelsSplitPanel.setDividerLocation (this.getSize ().height / 2);
}


public static void extractZipPackage (String fileName, String destinationFolder) throws Exception {
    if (NullStatus.isNull (destinationFolder)) {
        destinationFolder = "";
    }
    new File (destinationFolder).mkdirs ();
    File inputFile = new File (fileName);
    ZipFile zipFile = new ZipFile (inputFile);
    Enumeration < ? extends ZipEntry > oEnum = zipFile.entries ();
    while (oEnum.hasMoreElements ()) {
        ZipEntry zipEntry = oEnum.nextElement ();
        File file = new File (destinationFolder + "/" + zipEntry.getName ());
        if (zipEntry.isDirectory ()) {
            file.mkdirs ();
        }
        else {
            String destinationFolderName = destinationFolder + "/" + zipEntry.getName ();
            destinationFolderName = destinationFolderName.substring (0, destinationFolderName.lastIndexOf ("/"));
            new File (destinationFolderName).mkdirs ();
            FileOutputStream fos = new FileOutputStream (file);
            IOUtils.copy (zipFile.getInputStream (zipEntry), fos);
            fos.close ();
        }
    }
}


-----Function Pair=87=-----==

public void actionPerformed (ActionEvent e) {
    final TimeSlotTracker tst = layoutManager.getTimeSlotTracker ();
    if (chooseFileResult.getFile () == null) {
        String msgTitle = layoutManager.getCoreString ("reports.configuration-window.noResultFile.title");
        String msg = layoutManager.getCoreString ("reports.configuration-window.noResultFile.msg");
        JOptionPane.showMessageDialog (ReportConfiguration.this, msg, msgTitle, JOptionPane.ERROR_MESSAGE);
        return;
    }
    try {
        tst.setCursorWait ();
        Runnable runnable = new Runnable () {
            public void run () {
                Thread.yield ();
                runReport ();
            }
        }
        ;
        Thread runThread = new Thread (runnable);
        runThread.start ();
        runThread.join ();
        if (reportCompleted) {
            ReportConfiguration.this.dispose ();
        }
        else {
            String title = layoutManager.getCoreString ("reprots.configuration-window.run.errorTitle");
            JOptionPane.showMessageDialog (ReportConfiguration.this, reportErrorMessage, title, JOptionPane.ERROR_MESSAGE);
        }
    } catch (InterruptedException ex) {
    } finally {
        tst.setCursorDefault ();
    }
}


public static void INT10_WriteChar (short chr, short attr, short page, int count, boolean showattr) {
    if (Int10_modes.CurMode.type != VGA.M_TEXT) {
        showattr = true;
        switch (Dosbox.machine) {
            case MachineType.MCH_EGA :
            case MachineType.MCH_VGA :
                page %= Int10_modes.CurMode.ptotal;
                break;
            case MachineType.MCH_CGA :
            case MachineType.MCH_PCJR :
                page = 0;
                break;
        }
    }
    short cur_row = Int10.CURSOR_POS_ROW (page);
    short cur_col = Int10.CURSOR_POS_COL (page);
    int ncols = Memory.real_readw (Int10.BIOSMEM_SEG, Int10.BIOSMEM_NB_COLS);
    while (count > 0) {
        WriteChar (cur_col, cur_row, page, chr, attr, showattr);
        count --;
        cur_col ++;
        if (cur_col == ncols) {
            cur_col = 0;
            cur_row ++;
        }
    }
}


-----Function Pair=88=-----==

private static void jbadd (JarOutputStream _jout, File _dir, String _prefix, int packMode) throws IOException {
    File [] content = _dir.listFiles ();
    for (int i = 0, l = content.length; i < l; ++ i) {
        if (content [i].isDirectory ()) {
            jbadd (_jout, content [i], _prefix + (_prefix.equals ("") ? "" : "/") + content [i].getName (), packMode);
        }
        else {
            boolean canPack = false;
            switch (packMode) {
                case PACK_ALL_EXCEPT_JAVA_AND_JAR :
                    if (! (content [i].getName ().endsWith (".java") || content [i].getName ().endsWith (".jar"))) canPack = true;
                    break;
                case PACK_CLASSES_ONLY :
                    if (content [i].getName ().endsWith (".class")) canPack = true;
                    break;
                case PACK_ALL :
                    canPack = true;
                    break;
                default :
                    canPack = true;
            }
            if (canPack == true) {
                _jout.putNextEntry (new ZipEntry (_prefix + "/" + content [i].getName ()));
                FileInputStream in = new FileInputStream (content [i]);
                jbwrite (in, _jout);
                in.close ();
            }
        }
    }
}


public File createArchiveFile (String archiveType, IModule module, List < IModuleResource > resources, IProgressMonitor monitor) throws IOException {
    String suffix = ".zip";
    if (archiveType.equalsIgnoreCase ("zip")) {
        suffix = ".zip";
    }
    else if (archiveType.equalsIgnoreCase ("jar")) {
        suffix = ".jar";
    }
    if (monitor == null) monitor = new NullProgressMonitor ();
    String tempDir = System.getProperty ("java.io.tmpdir");
    File tempFile = new File (tempDir, module.getName () + suffix);
    FileOutputStream fileOutput = new FileOutputStream (tempFile);
    ZipOutputStream zipOutput = new ZipOutputStream (fileOutput);
    try {
        writeResourcesToZipFile (module, resources.toArray (new IModuleResource [0]), zipOutput);
    } finally {
        zipOutput.close ();
    }
    return tempFile;
}


-----Function Pair=89=-----==

private String [] getMachines () {
    String [] linuxAll = this.execSingleLineOutputCmd ("linuxall");
    if (linuxAll == null) {
        System.exit (0);
    }
    StringBuffer goodMachines = new StringBuffer ();
    for (int i = 0; i < linuxAll.length; i ++) {
        try {
            int nodeIndex;
            nodeIndex = Integer.parseInt (linuxAll [i].substring (1));
            if (nodeIndex >= 2 && nodeIndex <= 27) {
                goodMachines.append (linuxAll [i] + " ");
            }
        } catch (Exception ex) {
        }
    }
    System.out.println (" " + goodMachines);
    return goodMachines.toString ().split (" ");
}


public boolean runCommand () {
    String cmd;
    String cmd_args [];
    if (macro.next ()) {
        String cmd_arg_string = " ";
        cmd = macro.cmd ();
        cmd_args = macro.args ();
        for (int i = 0; i < cmd_args.length; i ++) {
            cmd_arg_string += cmd_args [i] + " ";
        }
        jdp_console.writeOutput ("\n");
        jdp_console.writeOutput ("Macro line " + macro.currentLine () + ": " + cmd + cmd_arg_string);
    }
    else {
        jdp_console.readCommand (user);
        cmd = jdp_console.cmd ();
        cmd_args = jdp_console.args ();
    }
    if (! cmd.equals ("")) {
        if (cmd.equals ("quit") || cmd.equals ("q")) {
            return true;
        }
        else {
            try {
                return jdpCommand (cmd, cmd_args);
            } catch (Exception e) {
                jdp_console.writeOutput ("ERROR executing jdp command: " + e.getMessage ());
                jdp_console.writeOutput ("email to jvm-coders or try again . . . ");
            }
        }
    }
    return false;
}


-----Function Pair=90=-----==

void processAudioData (byte [] buffer, int index, int bytes_per_sample) {
    byte [] dummybuffer = new byte [100];
    int samples_at_11 = 0;
    switch (rate) {
        case 44100 :
            samples_at_11 = 4;
            break;
        case 22050 :
            samples_at_11 = 2;
            break;
        case 11025 :
            samples_at_11 = 1;
            break;
        default :
            System.out.println ("Huh? Here is my rate: " + rate);
    }
    int samplestoskip = samples_at_11 - 1;
    if (channels == 2) {
        samplestoskip += samples_at_11;
    }
    int bytestoskip = samplestoskip * (bits_per_sample / 8);
    System.out.println ("Bytes to skip: " + bytestoskip);
    System.out.println ("Samples to skip: " + samplestoskip);
    ByteArrayInputStream in = new ByteArrayInputStream (buffer);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    while (in.available () > 0) {
        baos.write (in.read ());
        if (bits_per_sample == 16) baos.write (in.read ());
        else baos.write (0);
        try {
            if (bytestoskip != 0) {
                int amount = in.read (dummybuffer, 0, bytestoskip);
                if (amount != bytestoskip) System.out.println ("MASSIVE PROBLEM, could not dummy buffer read: " + in.available () + ", " + amount);
            }
        } catch (Exception e) {
            System.out.println ("BAD BAD BAD " + e);
            System.out.println ("Length requested: " + bytes_per_sample);
            throw new RuntimeException (e.toString ());
        }
    }
    audiodata = baos.toByteArray ();
}


public void copyFile (File sourceFile, String toDir, boolean create, boolean overwrite) throws FileNotFoundException, IOException {
    FileInputStream source = null;
    FileOutputStream destination = null;
    byte [] buffer;
    int bytes_read;
    File toFile = new File (toDir);
    if (create && ! toFile.exists ()) toFile.mkdirs ();
    if (toFile.exists ()) {
        File destFile = new File (toDir + "/" + sourceFile.getName ());
        try {
            if (! destFile.exists () || overwrite) {
                source = new FileInputStream (sourceFile);
                destination = new FileOutputStream (destFile);
                buffer = new byte [1024];
                while (true) {
                    bytes_read = source.read (buffer);
                    if (bytes_read == - 1) break;
                    destination.write (buffer, 0, bytes_read);
                }
            }
        } catch (Exception exx) {
            exx.printStackTrace ();
        } finally {
            if (source != null) try {
                source.close ();
            } catch (IOException e) {
            }
            if (destination != null) try {
                destination.close ();
            } catch (IOException e) {
            }
        }
    }
}


-----Function Pair=91=-----==

private void addFileToZip (File file, EntryConfigurationListener callback) throws IOException {
    String abs = file.getAbsolutePath ();
    abs = abs.substring (startFromLen + 1);
    ZipEntry entry = new ZipEntry (abs);
    if (callback != null) callback.configure (entry);
    output.putNextEntry (entry);
    try {
        FileInputStream fis = new FileInputStream (file);
        BufferedInputStream bis = new BufferedInputStream (fis, 2048);
        try {
            int readIn;
            while ((readIn = bis.read (buff)) > 0) output.write (buff, 0, readIn);
        } finally {
            bis.close ();
        }
    } finally {
        output.closeEntry ();
    }
}


private byte [] showAutoDelItems (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "AutoDelItems.html");
    HashMap < String, KeepForDetails > items = store.getAutoDelList ();
    String [] key = (String []) items.keySet ().toArray (new String [0]);
    for (int x = 0; x < key.length; x ++) {
        KeepForDetails item = (KeepForDetails) items.get (key [x]);
        out.append ("<tr>\n");
        out.append ("<td>" + item.getCreated ().toString () + "</td>");
        out.append ("<td>" + item.getFileName () + "</td>");
        out.append ("<td>" + item.getKeepFor () + "</td>");
        out.append ("<td><a href='/servlet/" + urlData.getServletClass () + "?action=07&id=" + key [x] + "'>remove</a></td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$itemList", out.toString ());
    template.replaceAll ("$autoDelLog", store.getAutoDelLog ());
    return template.getPageBytes ();
}


-----Function Pair=92=-----==

public void chooseTheme () {
    String OS = GUImain.OS;
    UIManager.LookAndFeelInfo [] feels = UIManager.getInstalledLookAndFeels ();
    int currentIndex = 0;
    Object [] UINames = new Object [feels.length];
    for (int i = 0; i < feels.length; i ++) {
        UIManager.LookAndFeelInfo feel = feels [i];
        String name = feel.getName ();
        if (OS.contains (name)) {
            name = OS;
        }
        else if (feel.getName ().contains ("Metal")) {
            name = "Java";
        }
        if (laf.getName ().equals (feel.getName ())) {
            currentIndex = i;
        }
        UINames [i] = name;
    }
    Object selectedValue = JOptionPane.showInputDialog (framer, "Pick a Theme", "Theme Chooser", JOptionPane.INFORMATION_MESSAGE, null, UINames, UINames [currentIndex]);
    if (selectedValue == null) return;
    String selStr = ((String) selectedValue);
    UIManager.LookAndFeelInfo ui = null;
    for (int i = 0; i < feels.length; i ++) {
        if (selStr.equals (UINames [i])) ui = feels [i];
    }
    laf = ui;
    try {
        UIManager.setLookAndFeel (ui.getClassName ());
        SwingUtilities.updateComponentTreeUI (this.framer);
    } catch (Exception x) {
    }
}


static void EGA16_CopyRow (short cleft, short cright, short rold, short rnew, int base) {
    int src, dest;
    int copy;
    short cheight = Memory.real_readb (Int10.BIOSMEM_SEG, Int10.BIOSMEM_CHAR_HEIGHT);
    dest = base + (Int10_modes.CurMode.twidth * rnew) * cheight + cleft;
    src = base + (Int10_modes.CurMode.twidth * rold) * cheight + cleft;
    int nextline = Int10_modes.CurMode.twidth;
    IoHandler.IO_Write (0x3ce, 5);
    IoHandler.IO_Write (0x3cf, 1);
    IoHandler.IO_Write (0x3c4, 2);
    IoHandler.IO_Write (0x3c5, 0xf);
    int rowsize = (cright - cleft);
    copy = cheight;
    for (; copy > 0; copy --) {
        for (int x = 0; x < rowsize; x ++) Memory.mem_writeb (dest + x, Memory.mem_readb (src + x));
        dest += nextline;
        src += nextline;
    }
    IoHandler.IO_Write (0x3ce, 5);
    IoHandler.IO_Write (0x3cf, 0);
}


-----Function Pair=93=-----==

private void readDirectories (String userName, UserData userData) {
    File dir = new File (userData.getChrootDir ());
    if (! dir.isDirectory ()) {
        dir.mkdirs ();
    }
    ArrayList < MyFile > leftFiles = new ArrayList < MyFile > ();
    ExtensionFilter filter;
    File [] files;
    String leftPath = userData.getPath ("left");
    dir = new File (userData.getChrootDir () + leftPath + File.separator);
    if (dir.isDirectory () && dir.exists ()) {
        if (! leftPath.equals ("/")) {
            leftFiles.add (new MyFile (".."));
        }
        filter = new ExtensionFilter ("");
        files = dir.listFiles (filter);
        for (int i = 0; i < files.length; i ++) {
            leftFiles.add (new MyFile (files [i]));
        }
        filter = new ExtensionFilter (null, true);
        files = dir.listFiles (filter);
        for (int i = 0; i < files.length; i ++) {
            leftFiles.add (new MyFile (files [i]));
        }
    }
    else {
        leftFiles = null;
    }
    ArrayList < MyFile > rightFiles = new ArrayList < MyFile > ();
    String rightPath = userData.getPath ("right");
    dir = new File (userData.getChrootDir () + rightPath + File.separator);
    if (dir.isDirectory () && dir.exists ()) {
        filter = new ExtensionFilter ("");
        files = dir.listFiles (filter);
        if (! rightPath.equals ("/")) {
            rightFiles.add (new MyFile (".."));
        }
        for (int i = 0; i < files.length; i ++) {
            rightFiles.add (new MyFile (files [i]));
        }
        filter = new ExtensionFilter (null, true);
        files = dir.listFiles (filter);
        for (int i = 0; i < files.length; i ++) {
            rightFiles.add (new MyFile (files [i]));
        }
    }
    else {
        rightFiles = null;
    }
    userData.setLeftFileList (leftFiles);
    userData.setRightFileList (rightFiles);
}


public static void extract (ZipFile zipFile, ZipEntry zipEntry, File toDir) throws IOException {
    File file = new File (toDir, zipEntry.getName ());
    File parentDir = file.getParentFile ();
    if (! parentDir.exists ()) {
        parentDir.mkdirs ();
    }
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try {
        InputStream istr = zipFile.getInputStream (zipEntry);
        bis = new BufferedInputStream (istr);
        FileOutputStream fos = new FileOutputStream (file);
        bos = new BufferedOutputStream (fos);
        StreamUtils.copyStream (bis, bos);
    } finally {
        if (bis != null) {
            bis.close ();
        }
        if (bos != null) {
            bos.close ();
        }
    }
}


-----Function Pair=94=-----==

public void doPost (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    HttpSession ssn = req.getSession (true);
    String send = req.getParameter ("send");
    String host = req.getParameter ("hostname");
    String user = req.getParameter ("username");
    String passwd = req.getParameter ("password");
    URLName url = new URLName (protocol, host, - 1, mbox, user, passwd);
    ServletOutputStream out = res.getOutputStream ();
    res.setContentType ("text/html");
    out.println ("<html><body bgcolor=\"#CCCCFF\">");
    if (send != null) {
        send (req, res, out, ssn);
    }
    else {
        MailUserData mud = new MailUserData (url);
        ssn.putValue ("javamailservlet", mud);
        try {
            Properties props = System.getProperties ();
            props.put ("mail.smtp.host", host);
            Session session = Session.getDefaultInstance (props, null);
            session.setDebug (false);
            Store store = session.getStore (url);
            store.connect ();
            Folder folder = store.getDefaultFolder ();
            if (folder == null) throw new MessagingException ("No default folder");
            folder = folder.getFolder (mbox);
            if (folder == null) throw new MessagingException ("Invalid folder");
            folder.open (Folder.READ_WRITE);
            int totalMessages = folder.getMessageCount ();
            Message [] msgs = folder.getMessages ();
            FetchProfile fp = new FetchProfile ();
            fp.add (FetchProfile.Item.ENVELOPE);
            folder.fetch (msgs, fp);
            System.out.println ("Login from: " + store.getURLName ());
            mud.setSession (session);
            mud.setStore (store);
            mud.setFolder (folder);
            out.print ("<center>");
            out.print ("<font face=\"Arial,Helvetica\" font size=+3>");
            out.println ("<b>Welcome to JavaMail!</b></font></center><p>");
            out.println ("<table width=\"50%\" border=0 align=center>");
            out.print ("<tr><td width=\"75%\" bgcolor=\"#ffffcc\">");
            out.print ("<font face=\"Arial,Helvetica\" font size=-1>");
            out.println ("<b>FolderName</b></font></td><br>");
            out.print ("<td width=\"25%\" bgcolor=\"#ffffcc\">");
            out.print ("<font face=\"Arial,Helvetica\" font size=-1>");
            out.println ("<b>Messages</b></font></td><br>");
            out.println ("</tr>");
            out.print ("<tr><td width=\"75%\" bgcolor=\"#ffffff\">");
            out.print ("<a href=\"" + HttpUtils.getRequestURL (req) + "\">" + "Inbox" + "</a></td><br>");
            out.println ("<td width=\"25%\" bgcolor=\"#ffffff\">" + totalMessages + "</td>");
            out.println ("</tr>");
            out.println ("</table");
        } catch (Exception ex) {
            out.println (ex.toString ());
        } finally {
            out.println ("</body></html>");
            out.close ();
        }
    }
}


private void readStreamedOutcome () throws FileNotFoundException, IOException {
    PacketisedInputStream pis = new PacketisedInputStream (socket.getInputStream ());
    ZipInputStream zis = new ZipInputStream (pis);
    int avail;
    int count = 0;
    logger.fine ("Reading streamed outcome.");
    if ((avail = zis.available ()) != 0) {
        if (directOutput == null) {
            FileOutputStream fos = null;
            File streamedDir = null;
            ZipEntry entry = zis.getNextEntry ();
            byte [] buffer = new byte [4096];
            int read = 0;
            OutcomeManager.clearCache ();
            while (entry != null) {
                String zipName = entry.getName ();
                int lastSep = zipName.lastIndexOf ("/");
                String filename = zipName.substring (lastSep + 1);
                String dir = sessionDir + File.separator + zipName.substring (0, lastSep);
                logger.fine ("Receiving streamed file: " + zipName);
                OutcomeManager.addStreamedFile (zipName);
                streamedDir = new File (dir);
                streamedDir.deleteOnExit ();
                File streamedFile = new File (dir, filename);
                streamedFile.deleteOnExit ();
                streamedDir.mkdirs ();
                fos = new FileOutputStream (streamedFile);
                while ((read = zis.read (buffer)) > 0) {
                    fos.write (buffer, 0, read);
                }
                fos.close ();
                zis.closeEntry ();
                File parent = streamedDir;
                while (parent.getParentFile () != null) {
                    parent.deleteOnExit ();
                    parent = parent.getParentFile ();
                }
                parent = parent.getParentFile ();
                entry = zis.getNextEntry ();
            }
        }
        else {
            logger.fine ("Direct output files into destination directory.");
            copyFile (zis);
        }
        long skipped = pis.skip (Long.MAX_VALUE);
    }
}


-----Function Pair=95=-----==

public static void addJarContentsToZip (String library, ZipOutputStream zos) {
    try {
        FileInputStream fis = new FileInputStream (library);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        ZipEntry entry = null;
        while ((entry = zis.getNextEntry ()) != null) {
            if (! entry.getName ().contains ("META-INF/") || entry.getName ().contains ("services")) {
                try {
                    zos.putNextEntry (entry);
                    byte [] readBuffer = new byte [1024];
                    int bytesIn = 0;
                    while ((bytesIn = zis.read (readBuffer)) != - 1) {
                        zos.write (readBuffer, 0, bytesIn);
                    }
                    zos.closeEntry ();
                } catch (ZipException e) {
                }
            }
        }
        zis.close ();
    } catch (Exception e) {
    }
}


public static void main (String [] args) {
    if (args.length != 3) {
        System.out.println ("Usage: HexStrToBin enc/dec <infileName> <outfilename>");
        System.exit (1);
    }
    try {
        ByteArrayOutputStream os = new ByteArrayOutputStream ();
        InputStream in = new FileInputStream (args [1]);
        int len = 0;
        byte buf [] = new byte [1024];
        while ((len = in.read (buf)) > 0) os.write (buf, 0, len);
        in.close ();
        os.close ();
        byte [] data = null;
        if (args [0].equals ("dec")) data = decode (os.toString ());
        else {
            String strData = encode (os.toByteArray ());
            data = strData.getBytes ();
        }
        FileOutputStream fos = new FileOutputStream (args [2]);
        fos.write (data);
        fos.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=96=-----==

public static void zip (File inFile, File outFile) throws IOException {
    FileInputStream fin = new FileInputStream (inFile);
    FileOutputStream fout = new FileOutputStream (outFile);
    ZipOutputStream zout = new ZipOutputStream (fout);
    try {
        zout.putNextEntry (new ZipEntry (inFile.getName ()));
        byte [] buffer = new byte [1024];
        int len;
        while ((len = fin.read (buffer)) > 0) {
            zout.write (buffer, 0, len);
        }
        zout.closeEntry ();
    } finally {
        zout.close ();
        fin.close ();
    }
}


public static void copyFile (final File source, final File dest) throws IOException {
    dest.createNewFile ();
    final java.io.FileInputStream sourceFile = new java.io.FileInputStream (source);
    try {
        final java.io.FileOutputStream destinationFile = new java.io.FileOutputStream (dest);
        try {
            final byte [] buffer = new byte [NB_BITE];
            int nbLecture = 0;
            while ((nbLecture = sourceFile.read (buffer)) != - 1) {
                destinationFile.write (buffer, 0, nbLecture);
            }
        } finally {
            destinationFile.close ();
        }
    } finally {
        sourceFile.close ();
    }
}


-----Function Pair=97=-----==

public static void setHidden (File file, boolean hidden, boolean synchronously) {
    String osNameStart = System.getProperty ("os.name").substring (0, 3);
    if (osNameStart.equals ("Win")) {
        try {
            Runtime.getRuntime ().exec ("attrib " + (hidden ? "+" : "-") + "H \"" + file.getAbsolutePath () + "\"");
            if (! synchronously) {
                return;
            }
            int timeOut = 10;
            while (file.isHidden () != hidden && timeOut > 0) {
                Thread.sleep (10);
                timeOut --;
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=98=-----==

public static void addFileToZip (ZipOutputStream zos, File file, String leadPath) throws IOException {
    if (leadPath == null) {
        leadPath = new String ("");
    }
    if (file.isDirectory ()) {
        return;
    }
    ZipEntry ze = new ZipEntry (leadPath + file.getName ());
    zos.putNextEntry (ze);
    FileInputStream in = new FileInputStream (file);
    int c;
    byte [] b = new byte [1024];
    while ((c = in.read (b)) != - 1) {
        zos.write (b, 0, c);
    }
    in.close ();
    zos.closeEntry ();
}


public String getMX (String domain) throws Exception {
    Hashtable < String, String > env = new Hashtable < String, String > ();
    env.put ("java.naming.factory.initial", "com.sun.jndi.dns.DnsContextFactory");
    DirContext ictx = new InitialDirContext (env);
    Attributes attrs = ictx.getAttributes (domain, new String [] {"MX"});
    Attribute attr = attrs.get ("MX");
    if ((attr == null) || (attr.size () == 0)) {
        attrs = ictx.getAttributes (domain, new String [] {"A"});
        attr = attrs.get ("A");
        if (attr == null) throw new Exception ("No match for name '" + domain + "'");
    }
    String x = (String) attr.get (0);
    String [] f = x.split (" ");
    if (f [1].endsWith (".")) f [1] = f [1].substring (0, (f [1].length () - 1));
    return f [1];
}


-----Function Pair=99=-----==

public String computeChecksumSHA256 (File file) {
    try {
        FileChannel chan = null;
        try {
            chan = (new FileInputStream (file)).getChannel ();
        } catch (Throwable e) {
            logger.log (Level.SEVERE, "Exception thrown 1", e);
            return null;
        }
        MessageDigest sha256 = MessageDigest.getInstance ("SHA256", "BC");
        byte [] temp = new byte [4 * 1024];
        ByteBuffer _temp = ByteBuffer.wrap (temp);
        try {
            while (true) {
                int pos = _temp.position ();
                int read = chan.read (_temp);
                if (read == - 1) break;
                sha256.update (temp, pos, read);
                if (_temp.remaining () == 0) _temp.position (0);
            }
            chan.close ();
        } catch (Throwable e) {
            logger.log (Level.SEVERE, "Exception thrown 2", e);
        }
        byte [] poop = sha256.digest ();
        StringBuilder sb = new StringBuilder ();
        for (int i = 0; i < poop.length; i ++) {
            sb.append (Integer.toString ((poop [i] & 0xff) + 0x100, 16).substring (1));
        }
        return sb.toString ().toUpperCase ();
    } catch (NoSuchAlgorithmException ex) {
        logger.log (Level.SEVERE, "Algorithm SHA256 not supported.", ex);
    } catch (NoSuchProviderException ex) {
        logger.log (Level.SEVERE, "Provider BC not supported.", ex);
    }
    return null;
}


public static final boolean zipExtract (String zipfile, String name, String dest) {
    boolean f = false;
    try {
        InputStream in = new BufferedInputStream (new FileInputStream (zipfile));
        ZipInputStream zin = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zin.getNextEntry ()) != null) {
            if (e.getName ().equals (name)) {
                FileOutputStream out = new FileOutputStream (dest);
                byte b [] = new byte [TEMP_FILE_BUFFER_SIZE];
                int len = 0;
                while ((len = zin.read (b)) != - 1) out.write (b, 0, len);
                out.close ();
                f = true;
                break;
            }
        }
        zin.close ();
    } catch (FileNotFoundException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "extractZip " + zipfile + " " + name);
    }
    return (f);
}


-----Function Pair=100=-----==

public static String getPoolUsage (String poolName) {
    StringBuilder result = new StringBuilder ();
    if (pools.containsKey (poolName)) {
        SockIOPool sockIOPool = pools.get (poolName);
        int total = 0;
        int busy = 0;
        int dead = 0;
        Iterator < ConcurrentMap < SockIO, Integer > > socketIter = sockIOPool.socketPool.values ().iterator ();
        while (socketIter.hasNext ()) {
            ConcurrentMap < SockIO, Integer > status = socketIter.next ();
            total += status.size ();
            Iterator < Integer > iter = status.values ().iterator ();
            while (iter.hasNext ()) {
                int value = iter.next ();
                if (value == SOCKET_STATUS_BUSY) busy ++;
                if (value == SOCKET_STATUS_DEAD) dead ++;
            }
        }
        result.append ("SockIOPool ").append (poolName).append (" : ").append (" total socket: ").append (total).append (" , busy socket: ").append (busy).append (" , dead socket: ").append (dead);
    }
    return result.toString ();
}


DBFRecords (String filename, DBFHeader header, int [] columnIdx) {
    records = new ArrayList ();
    isvalid = false;
    try {
        FileInputStream fis = new FileInputStream (filename);
        FileChannel fc = fis.getChannel ();
        ByteBuffer buffer = ByteBuffer.allocate ((int) fc.size () - header.getRecordsOffset ());
        fc.read (buffer, header.getRecordsOffset ());
        buffer.flip ();
        int i = 0;
        ArrayList < DBFField > fields = header.getFields ();
        while (i < header.getNumberOfRecords () && buffer.hasRemaining ()) {
            records.add (new DBFRecord (buffer, fields, columnIdx));
            i ++;
        }
        fis.close ();
        isvalid = true;
    } catch (Exception e) {
        System.out.println ("loading records error: " + filename + ": " + e.toString ());
        e.printStackTrace ();
    }
}


-----Function Pair=101=-----==

private void zipDir (File directory, File zipfile) throws IOException {
    URI base = directory.toURI ();
    Queue < File > queue = new LinkedList < File > ();
    queue.add (directory);
    OutputStream out = new FileOutputStream (zipfile);
    Closeable res = out;
    try {
        ZipOutputStream zout = new ZipOutputStream (out);
        res = zout;
        while (! queue.isEmpty ()) {
            directory = queue.poll ();
            for (File kid : directory.listFiles ()) {
                String name = base.relativize (kid.toURI ()).getPath ();
                if (kid.isDirectory ()) {
                    queue.add (kid);
                    name = name.endsWith ("/") ? name : name + "/";
                    zout.putNextEntry (new ZipEntry (name));
                }
                else {
                    zout.putNextEntry (new ZipEntry (name));
                    copy (kid, zout);
                    zout.closeEntry ();
                }
            }
        }
    } finally {
        res.close ();
    }
}


private static void zip (File d) throws FileNotFoundException, IOException {
    String [] entries = d.list ();
    byte [] buffer = new byte [4096];
    int bytesRead;
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (new File (d.getParent () + File.separator + "dist.zip")));
    for (int i = 0; i < entries.length; i ++) {
        File f = new File (d, entries [i]);
        if (f.isDirectory ()) continue;
        FileInputStream in = new FileInputStream (f);
        int skipl = d.getCanonicalPath ().length ();
        ZipEntry entry = new ZipEntry (f.getPath ().substring (skipl));
        out.putNextEntry (entry);
        while ((bytesRead = in.read (buffer)) != - 1) out.write (buffer, 0, bytesRead);
        in.close ();
    }
    out.close ();
    FileUtils.moveFile (new File (d.getParent () + File.separator + "dist.zip"), new File (d + File.separator + "dist.zip"));
}


-----Function Pair=102=-----==

public static void imputeForHapmap (String inputfile, String outputfile) {
    String input;
    String [] info;
    Pattern tab = Pattern.compile ("\t");
    String fill = "\tNA\tNA\tNA\tNA\tNA\tNA\tNA";
    byte A = (byte) 0;
    byte H = (byte) 1;
    byte B = (byte) 2;
    byte N = (byte) 3;
    HashMap < String, Byte > string2byte = new HashMap < String, Byte > ();
    string2byte.put ("A", A);
    string2byte.put ("H", H);
    string2byte.put ("B", B);
    string2byte.put ("N", N);
    String [] b2s = new String [] {"A", "M", "C", "N"};
    try {
        BufferedReader br = new BufferedReader (new FileReader (inputfile));
        BufferedWriter bw = new BufferedWriter (new FileWriter (outputfile));
        int linecount = 0;
        while (br.readLine () != null) linecount ++;
        br.close ();
        int numberOfSnps = linecount - 1;
        br = new BufferedReader (new FileReader (inputfile));
        info = tab.split (br.readLine ());
        int numberOfTaxa = info.length - 4;
        byte [] [] snps = new byte [numberOfTaxa] [numberOfSnps];
        ArrayList < String > snplabel = new ArrayList < String > ();
        bw.write ("rs#\talleles\tchrom\tpos\tstrand\tassembly#\tcentre\tprotLSID\tassayLSID\tpanelLSID\tQCcode");
        for (int i = 4; i < info.length; i ++) bw.write ("\t" + info [i]);
        bw.write ("\n");
        System.out.println ("reading data");
        linecount = 0;
        while ((input = br.readLine ()) != null) {
            info = tab.split (input);
            snplabel.add (info [0] + "\t" + info [1] + "\t" + info [2] + "\t" + info [3]);
            for (int t = 0; t < numberOfTaxa; t ++) {
                snps [t] [linecount] = string2byte.get (info [t + 4]);
            }
            linecount ++;
        }
        System.out.println ("imputing snps");
        for (int t = 0; t < numberOfTaxa; t ++) {
            byte prevsnp = - 1;
            int prevpos = - 1;
            byte [] asnp = snps [t];
            for (int s = 0; s < numberOfSnps; s ++) {
                if (asnp [s] != N) {
                    if (prevsnp == - 1) {
                        for (int i = 0; i < s; i ++) asnp [i] = asnp [s];
                    }
                    else if (asnp [s] == prevsnp) {
                        for (int i = prevpos; i < s; i ++) asnp [i] = prevsnp;
                    }
                    prevsnp = asnp [s];
                    prevpos = s;
                }
            }
            if (prevpos > 0) {
                for (int i = prevpos; i < numberOfSnps; i ++) asnp [i] = prevsnp;
            }
        }
        System.out.println ("writing output");
        for (int s = 0; s < numberOfSnps; s ++) {
            bw.write (snplabel.get (s));
            bw.write (fill);
            for (int t = 0; t < numberOfTaxa; t ++) {
                bw.write ("\t");
                bw.write (b2s [snps [t] [s]]);
            }
            bw.write ("\n");
        }
        br.close ();
        bw.close ();
    } catch (IOException e) {
        e.printStackTrace ();
        System.exit (- 1);
    }
}


public TVRageShowInfo (String xmlShowName) {
    String [] tmp, tmp2;
    String line = "";
    this.usrShowName = xmlShowName;
    try {
        URL url = new URL ("http://www.tvrage.com/quickinfo.php?show=" + xmlShowName.replaceAll (" ", "%20"));
        BufferedReader in = new BufferedReader (new InputStreamReader (url.openStream ()));
        while ((line = in.readLine ()) != null) {
            tmp = line.split ("@");
            if (tmp [0].equals ("Show Name")) showName = tmp [1];
            if (tmp [0].equals ("Show URL")) showURL = tmp [1];
            if (tmp [0].equals ("Latest Episode")) {
                StringTokenizer st = new StringTokenizer (tmp [1], "^");
                for (int i = 0; st.hasMoreTokens (); i ++) {
                    if (i == 0) {
                        tmp2 = st.nextToken ().split ("x");
                        latestSeasonNum = tmp2 [0];
                        latestEpisodeNum = tmp2 [1];
                        if (latestSeasonNum.charAt (0) == '0') latestSeasonNum = latestSeasonNum.substring (1);
                    }
                    else if (i == 1) latestTitle = st.nextToken ().replaceAll ("&", "and");
                    else latestAirDate = st.nextToken ();
                }
            }
            if (tmp [0].equals ("Next Episode")) {
                StringTokenizer st = new StringTokenizer (tmp [1], "^");
                for (int i = 0; st.hasMoreTokens (); i ++) {
                    if (i == 0) {
                        tmp2 = st.nextToken ().split ("x");
                        nextSeasonNum = tmp2 [0];
                        nextEpisodeNum = tmp2 [1];
                        if (nextSeasonNum.charAt (0) == '0') nextSeasonNum = nextSeasonNum.substring (1);
                    }
                    else if (i == 1) nextTitle = st.nextToken ().replaceAll ("&", "and");
                    else nextAirDate = st.nextToken ();
                }
            }
            if (tmp [0].equals ("Status")) status = tmp [1];
            if (tmp [0].equals ("Airtime")) airTime = tmp [1];
        }
        if (airTime.length () != 0) {
            tmp = airTime.split (",");
            airTimeHour = tmp [1];
        }
        in.close ();
        url = new URL (showURL);
        in = new BufferedReader (new InputStreamReader (url.openStream ()));
        while ((line = in.readLine ()) != null) {
            if (line.indexOf ("<b>Latest Episode: </b>") > - 1) {
                tmp = line.split ("'>");
                if (tmp [2].indexOf (':') > - 1) {
                    tmp = tmp [2].split (":");
                    latestSeriesNum = tmp [0];
                }
            }
            else if (line.indexOf ("<b>Next Episode: </b>") > - 1) {
                tmp = line.split ("'>");
                if (tmp [2].indexOf (':') > - 1) {
                    tmp = tmp [2].split (":");
                    nextSeriesNum = tmp [0];
                }
            }
        }
        in.close ();
    } catch (MalformedURLException e) {
    } catch (IOException e) {
    }
}


-----Function Pair=103=-----==

private boolean configureSharedLibraryProject64bit (IProject libProject, String spuProjectName) {
    boolean saveBuildStatus = false;
    try {
        IConfiguration [] configs = ManagedBuildManager.getBuildInfo (libProject).getManagedProject ().getConfigurations ();
        IConfiguration configuration = null;
        for (int i = 0; i < configs.length; i ++) {
            if (configs [i].getId ().startsWith ("celldt.managedbuild.config.cell.ppu.gnu64.so.debug")) {
                configuration = configs [i];
                break;
            }
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_OPEN, true);
        IToolChain toolChain = configuration.getToolChain ();
        ITool embedSpuTool = toolChain.getToolsBySuperClassId ("celldt.managedbuild.tool.cell.ppu.gnu64.embedspu") [0];
        IOption embedSpuInputOption = embedSpuTool.getOptionBySuperClassId ("cell.ppu.gnu.embedspu.option.inputs");
        ManagedBuildManager.setOption (configuration, embedSpuTool, embedSpuInputOption, new String [] {"\"${workspace_loc:/" + spuProjectName + "/spu-gnu-debug/" + spuProjectName + "}\""});
        saveBuildStatus = ManagedBuildManager.saveBuildInfo (libProject, true);
        IManagedBuildInfo bi = ManagedBuildManager.getBuildInfo (libProject);
        if (bi != null & bi instanceof ManagedBuildInfo) ((ManagedBuildInfo) bi).initializePathEntries ();
        if (is64bit) {
            ManagedBuildManager.setDefaultConfiguration (libProject, configuration);
            ManagedBuildManager.setSelectedConfiguration (libProject, configuration);
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_APPLY, true);
        if (! saveBuildStatus) throw new Exception ();
    } catch (Exception e) {
        wizard.openWarningMessage (Messages.ALFWizardCreationAction_queryTitle, Messages.ALFWizardCreationAction_errorConfiguringSharedLibraryProject);
    }
    return saveBuildStatus;
}


boolean copyFileStructure (File oldFile, File newFile) {
    if (oldFile == null || newFile == null) return false;
    File searchFile = newFile;
    do {
        if (oldFile.equals (searchFile)) return false;
        searchFile = searchFile.getParentFile ();
    }
    while (searchFile != null);
    if (oldFile.isDirectory ()) {
        if (progressDialog != null) {
            progressDialog.setDetailFile (oldFile, ProgressDialog.COPY);
        }
        if (simulateOnly) {
        }
        else {
            if (! newFile.mkdirs ()) return false;
        }
        File [] subFiles = oldFile.listFiles ();
        if (subFiles != null) {
            if (progressDialog != null) {
                progressDialog.addWorkUnits (subFiles.length);
            }
            for (int i = 0; i < subFiles.length; i ++) {
                File oldSubFile = subFiles [i];
                File newSubFile = new File (newFile, oldSubFile.getName ());
                if (! copyFileStructure (oldSubFile, newSubFile)) return false;
                if (progressDialog != null) {
                    progressDialog.addProgress (1);
                    if (progressDialog.isCancelled ()) return false;
                }
            }
        }
    }
    else {
        if (simulateOnly) {
        }
        else {
            FileReader in = null;
            FileWriter out = null;
            try {
                in = new FileReader (oldFile);
                out = new FileWriter (newFile);
                int count;
                while ((count = in.read ()) != - 1) out.write (count);
            } catch (FileNotFoundException e) {
                return false;
            } catch (IOException e) {
                return false;
            } finally {
                try {
                    if (in != null) in.close ();
                    if (out != null) out.close ();
                } catch (IOException e) {
                    return false;
                }
            }
        }
    }
    return true;
}


-----Function Pair=104=-----==

private boolean configurePPUProject64bit (IProject ppuProject, String libProjectName, String spuProjectName) {
    boolean saveBuildStatus = false;
    try {
        IConfiguration [] configs = ManagedBuildManager.getBuildInfo (ppuProject).getManagedProject ().getConfigurations ();
        IConfiguration configuration = null;
        for (int i = 0; i < configs.length; i ++) {
            if (configs [i].getId ().startsWith ("celldt.managedbuild.config.cell.ppu.gnu64.exe.debug")) {
                configuration = configs [i];
                break;
            }
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_OPEN, true);
        IToolChain toolChain = configuration.getToolChain ();
        ITool linkerTool = toolChain.getToolsBySuperClassId ("celldt.managedbuild.tool.cell.ppu.gnu64.c.linker") [0];
        IOption libraryOption = linkerTool.getOptionBySuperClassId ("cell.ppu.gnu.c.linker.option.libs");
        IOption librarySearchPathOption = linkerTool.getOptionBySuperClassId ("gnu.c.link.option.paths");
        ManagedBuildManager.setOption (configuration, linkerTool, libraryOption, new String [] {"dl", "pthread", "spe2", "alf"});
        ManagedBuildManager.setOption (configuration, linkerTool, librarySearchPathOption, new String [] {"/opt/cell/sysroot/usr/lib64"});
        ITool compilerTool = toolChain.getToolsBySuperClassId ("celldt.managedbuild.tool.cell.ppu.gnu64.c.compiler.debug") [0];
        IOption includePathOption = compilerTool.getOptionBySuperClassId ("gnu.c.compiler.option.include.paths");
        ManagedBuildManager.setOption (configuration, compilerTool, includePathOption, new String [] {"/opt/cell/sysroot/usr/include", "/opt/cell/sysroot/opt/cell/sdk/usr/include"});
        IOption definedSymbolOption = compilerTool.getOptionBySuperClassId ("gnu.c.compiler.option.preprocessor.def.symbols");
        ManagedBuildManager.setOption (configuration, compilerTool, definedSymbolOption, new String [] {"__64BIT__"});
        saveBuildStatus = ManagedBuildManager.saveBuildInfo (ppuProject, true);
        IManagedBuildInfo bi = ManagedBuildManager.getBuildInfo (ppuProject);
        if (bi != null & bi instanceof ManagedBuildInfo) ((ManagedBuildInfo) bi).initializePathEntries ();
        if (is64bit) {
            ManagedBuildManager.setDefaultConfiguration (ppuProject, configuration);
            ManagedBuildManager.setSelectedConfiguration (ppuProject, configuration);
        }
        ManagedBuildManager.performValueHandlerEvent (configuration, IManagedOptionValueHandler.EVENT_APPLY, true);
        if (! saveBuildStatus) throw new Exception ();
    } catch (Exception e) {
        wizard.openWarningMessage (Messages.ALFWizardCreationAction_queryTitle, Messages.ALFWizardCreationAction_errorConfiguringPpuProject);
    }
    return saveBuildStatus;
}


public void addAttributes (IMemento parent, List < RepositoryTaskAttribute > attributes) {
    for (RepositoryTaskAttribute attribute : attributes) {
        IMemento attribMemento = parent.createChild (ELEMENT_ATTRIBUTE);
        attribMemento.putString (ATTRIBUTE_ID, getCleanText (attribute.getId ()));
        attribMemento.putString (ATTRIBUTE_NAME, getCleanText (attribute.getName ()));
        attribMemento.putString (ATTRIBUTE_HIDDEN, String.valueOf (attribute.isHidden ()));
        attribMemento.putString (ATTRIBUTE_READONLY, String.valueOf (attribute.isReadOnly ()));
        IMemento values = attribMemento.createChild (ELEMENT_VALUES);
        for (String value : attribute.getValues ()) {
            values.createChild (ELEMENT_VALUE).putTextData (getCleanText (value));
        }
        IMemento options = attribMemento.createChild (ELEMENT_OPTIONS);
        for (String optionValue : attribute.getOptions ()) {
            IMemento option = options.createChild (ELEMENT_OPTION);
            option.putTextData (getCleanText (optionValue));
            String parameter = attribute.getOptionParameter (optionValue);
            if (parameter != null) {
                option.putString (ATTRIBUTE_PARAMETER, getCleanText (parameter));
            }
        }
        IMemento metaData = attribMemento.createChild (ELEMENT_META_DATA);
        Map < String, String > metadata = attribute.getMetaData ();
        if (metadata != null && metadata.size () > 0) {
            for (String key : metadata.keySet ()) {
                IMemento meta = metaData.createChild (ELEMENT_META);
                meta.putString (ATTRIBUTE_KEY, getCleanText (key));
                meta.putTextData (getCleanText (metadata.get (key)));
            }
        }
    }
}


-----Function Pair=105=-----==

public boolean creaRegistrosFichero (String rutaFichero, String registrosInicio) {
    System.out.println ("");
    System.out.println ("*********** DENTRO DE 'creaRegistrosFichero' ***********");
    boolean estado = false;
    try {
        FileWriter escritor = new FileWriter (rutaFichero);
        BufferedWriter salida = new BufferedWriter (escritor);
        PrintWriter imprime = new PrintWriter (salida);
        imprime.println (registrosInicio);
        imprime.close ();
        estado = true;
    } catch (FileNotFoundException e) {
        System.out.println ("No se encontro el Archivo: " + registrosInicio);
        e.printStackTrace ();
        estado = false;
    } catch (IOException e) {
        System.out.println ("Error de I/O");
        e.printStackTrace ();
        estado = false;
    }
    return estado;
}


private String getCapTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = - 1;
    if (item != null) type = item.getCapType ();
    if (type == - 1) {
        typeList.append ("<label><input name='captype' type='radio' value='-1' checked>AutoSelect</label><br>\n");
    }
    else {
        typeList.append ("<label><input name='captype' type='radio' value='-1'>AutoSelect</label><br>\n");
    }
    Vector < CaptureCapability > capabilities = CaptureCapabilities.getInstance ().getCapabilities ();
    for (int x = 0; x < capabilities.size (); x ++) {
        CaptureCapability capability = capabilities.get (x);
        typeList.append ("<label><input name='captype' type='radio' value='" + capability.getTypeID () + "' ");
        if (type == capability.getTypeID ()) typeList.append ("checked");
        typeList.append (">" + capability.getName () + "</label><br>\n");
    }
    return typeList.toString ();
}


-----Function Pair=106=-----==

public void doPrintCommand (String command, String [] args) {
    int addr, frame;
    String varname;
    if (args.length == 0) {
        jdp_console.writeOutput (user.bmap.localVariableToString (0, null));
        return;
    }
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            addr = parseHex32 (args [1]);
            String classname = args [0].substring (1, rparen);
            try {
                jdp_console.writeOutput (classname + " = " + user.bmap.classToString (classname, addr, false));
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
        return;
    }
    frame = CommandLine.localParseFrame (args [0]);
    varname = CommandLine.localParseName (args [0]);
    if (frame != - 1) {
        if (varname == null) {
            jdp_console.writeOutput (user.bmap.localVariableToString (frame, null));
        }
        else {
            if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (frame, varname));
            else jdp_console.writeOutput (user.bmap.localVariableToString (frame, varname));
        }
        return;
    }
    if (varname.equals ("this") || varname.startsWith ("this.")) jdp_console.writeOutput (args [0] + " = " + user.bmap.currentClassToString (0, varname));
    else jdp_console.writeOutput (user.bmap.localVariableToString (0, varname));
    return;
}


public static void zipFilesToZipFile (String dirPath, File file, ZipOutputStream zouts) {
    FileInputStream fin = null;
    ZipEntry entry = null;
    byte [] buf = new byte [4096];
    int readByte = 0;
    if (file.isFile ()) {
        try {
            fin = new FileInputStream (file);
            entry = new ZipEntry (getEntryName (dirPath, file));
            zouts.putNextEntry (entry);
            while ((readByte = fin.read (buf)) != - 1) {
                zouts.write (buf, 0, readByte);
            }
            zouts.closeEntry ();
            fin.close ();
            System.out.println ("����ļ�" + file.getAbsolutePath () + "��zip�ļ���!");
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=107=-----==

public void doGetInstanceCommand (String command, String [] args) {
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            JDP_Class jdpClass = new JDP_Class ();
            jdpClass.address = parseHex32 (args [1]);
            jdpClass.name = args [0].substring (1, rparen);
            jdpClass.instance = true;
            try {
                user.bmap.classToJDPClass (jdpClass.name, jdpClass.address, false, jdpClass);
                jdpClass.fields.trimToSize ();
                jdp_console.writeOutput (jdpClass);
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            } catch (NoSuchClassException e2) {
                jdp_console.writeOutput (jdpClass.name + " is an invalid class name");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
    }
    else {
        jdp_console.writeOutput ("invalid args for getinstance");
    }
    return;
}


public static void appendFile (String namePrefix, File baseDir, File file, ZipOutputStream zipOut) throws IOException {
    Assert.Arg.notNull (baseDir, "baseDir");
    Assert.Arg.notNull (file, "file");
    Assert.Arg.notNull (zipOut, "zipOut");
    if (namePrefix == null) namePrefix = "";
    String path = FileSystemUtils.getRelativePath (baseDir, file);
    ZipEntry zipEntry = new ZipEntry (namePrefix + path);
    zipOut.putNextEntry (zipEntry);
    InputStream fileInput = FileUtils.openInputStream (file);
    try {
        org.apache.commons.io.IOUtils.copyLarge (fileInput, zipOut);
    } finally {
        fileInput.close ();
    }
}


-----Function Pair=108=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=109=-----==

public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
        Platform.printbp ();
    }
}


void showWindow () {
    ImageJ ij = IJ.getInstance ();
    addKeyListener (ij);
    addMouseListener (this);
    addMouseWheelListener (this);
    WindowManager.addWindow (this);
    setLayout (new BorderLayout ());
    list.add ("012345678901234");
    list.addItemListener (this);
    list.addKeyListener (ij);
    list.addMouseListener (this);
    list.addMouseWheelListener (this);
    if (IJ.isLinux ()) list.setBackground (Color.white);
    add ("Center", list);
    panel = new Panel ();
    int nButtons = BUTTONS;
    panel.setLayout (new GridLayout (nButtons, 1, 5, 0));
    addButton ("Add [t]");
    addButton ("Update");
    addButton ("Delete");
    addButton ("Rename...");
    addButton ("Measure");
    addButton ("Deselect");
    addButton ("Properties...");
    addButton ("Flatten [F]");
    addButton (moreButtonLabel);
    showAllCheckbox.addItemListener (this);
    panel.add (showAllCheckbox);
    labelsCheckbox.addItemListener (this);
    panel.add (labelsCheckbox);
    add ("East", panel);
    addPopupMenu ();
    pack ();
    Dimension size = getSize ();
    if (size.width > 270) setSize (size.width - 40, size.height);
    list.remove (0);
    Point loc = Prefs.getLocation (LOC_KEY);
    if (loc != null) setLocation (loc);
    else GUI.center (this);
    show ();
    if (IJ.isMacOSX () && IJ.isJava16 ()) {
        list.setMultipleMode (false);
        list.setMultipleMode (true);
    }
}


-----Function Pair=110=-----==

public static void createBackup () {
    String workspacePath = Workspace.INSTANCE.getWorkspace ();
    if (workspacePath.length () == 0) return;
    workspacePath += "/";
    String backupPath = workspacePath + "Backup";
    File directory = new File (backupPath);
    if (! directory.exists ()) directory.mkdirs ();
    String dateString = DataUtils.DateAndTimeOfNowAsLocalString ();
    dateString = dateString.replace (" ", "_");
    dateString = dateString.replace (":", "");
    backupPath += "/Backup_" + dateString + ".zip";
    ArrayList < String > backupedFiles = new ArrayList < String > ();
    backupedFiles.add ("Database/Database.properties");
    backupedFiles.add ("Database/Database.script");
    FileInputStream in;
    byte [] data = new byte [1024];
    int read = 0;
    try {
        ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (backupPath));
        zip.setMethod (ZipOutputStream.DEFLATED);
        for (int i = 0; i < backupedFiles.size (); i ++) {
            String backupedFile = backupedFiles.get (i);
            try {
                File inFile = new File (workspacePath + backupedFile);
                if (inFile.exists ()) {
                    in = new FileInputStream (workspacePath + backupedFile);
                    if (in != null) {
                        ZipEntry entry = new ZipEntry (backupedFile);
                        zip.putNextEntry (entry);
                        while ((read = in.read (data, 0, 1024)) != - 1) zip.write (data, 0, read);
                        zip.closeEntry ();
                        in.close ();
                    }
                }
            } catch (Exception e) {
                Logger.logError (e, "Error during file backup:" + backupedFile);
            }
        }
        zip.close ();
    } catch (IOException ex) {
        Logger.logError (ex, "Error during backup");
    }
}


public static void unjar (File jarFile, String resource, File targetDir) throws FileNotFoundException, IOException {
    if (targetDir.exists ()) {
        targetDir.delete ();
    }
    targetDir.mkdirs ();
    String targetPath = targetDir.getAbsolutePath () + File.separatorChar;
    byte [] buffer = new byte [1024 * 1024];
    JarFile input = new JarFile (jarFile, false, ZipFile.OPEN_READ);
    Enumeration < JarEntry > enumeration = input.entries ();
    for (; enumeration.hasMoreElements ();) {
        JarEntry entry = enumeration.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().equals (resource)) {
                String path = targetPath + entry.getName ();
                File file = new File (path);
                if (! file.getParentFile ().exists ()) {
                    file.getParentFile ().mkdirs ();
                }
                FileOutputStream out = new FileOutputStream (file);
                InputStream in = input.getInputStream (entry);
                int read;
                while ((read = in.read (buffer)) != - 1) {
                    out.write (buffer, 0, read);
                }
                in.close ();
                out.close ();
            }
        }
    }
}


-----Function Pair=111=-----=1=

private void compressAuxFiles (String path, ZipOutputStream zip) throws IOException {
    String [] dirList = AgentFilesystem.listDir (path);
    byte [] readBuffer = new byte [2156];
    int bytesIn = 0;
    for (String filename : dirList) {
        File file = new File (path, filename);
        if (file.isDirectory ()) {
            if (file.getPath ().contains ("_images") || file.getPath ().contains ("_styles")) compressAuxFiles (file.getPath (), zip);
            continue;
        }
        FileInputStream input = new FileInputStream (file);
        String entryPath = file.getCanonicalPath ().substring (themePath.length () + 1, file.getCanonicalPath ().length ());
        ZipEntry entry = new ZipEntry (entryPath);
        zip.putNextEntry (entry);
        while ((bytesIn = input.read (readBuffer)) != - 1) {
            zip.write (readBuffer, 0, bytesIn);
        }
        input.close ();
    }
}


public void compress (String dir2zip, ZipOutputStream zip) throws IOException {
    String [] dirList = AgentFilesystem.listDir (dir2zip);
    byte [] readBuffer = new byte [2156];
    int bytesIn = 0;
    for (String filename : dirList) {
        File file = new File (dir2zip, filename);
        if (file.isDirectory ()) {
            String filepath = file.getPath ();
            compress (filepath, zip);
            continue;
        }
        if (LibraryFile.getExtension (file.getName ()).equals ("zip")) continue;
        FileInputStream input = new FileInputStream (file);
        String entryPath = file.getCanonicalPath ().substring (outputPath.length () + 1, file.getCanonicalPath ().length ());
        ZipEntry entry = new ZipEntry (entryPath);
        zip.putNextEntry (entry);
        while ((bytesIn = input.read (readBuffer)) != - 1) {
            zip.write (readBuffer, 0, bytesIn);
        }
        input.close ();
    }
}


-----Function Pair=112=-----==

public void run () {
    System.out.println ("Test STARTED..");
    System.out.println ("Used machines: ");
    String [] machines = this.getMachines ();
    if (machines.length == 0) {
        System.out.println ("\nNo machine is available between nodes: n2-n27! ( Based upon 'linuxall')\n");
        return;
    }
    for (int i = 0; i < this.jobNumber; i ++) {
        String hostname = machines [i % machines.length];
        String rInt = "" + Math.round (Math.random () * 100000);
        StringBuffer rIndex = new StringBuffer ();
        for (int j = 0; j < rInt.length () - 5; j ++) {
            rIndex.append ("0");
        }
        rIndex.append (rInt);
        String jobID = "testJob-" + hostname + "-" + i + "_" + rIndex;
        int msgNumb = this.maxMessageForAJob;
        this.mappings.put (jobID, new Integer (msgNumb));
        this.startAppWithMonitoring (hostname, jobID, msgNumb);
    }
}


public static void appendStream (BufferedWriter out, BufferedReader in, Map < String, String > replaceMap) throws IOException {
    int n;
    int bufferSize = 4096;
    char cbuf [] = new char [bufferSize];
    n = in.read (cbuf);
    String toWrite = "";
    while (n > 0) {
        StringBuilder sb = new StringBuilder (4096);
        sb.append (cbuf, 0, n);
        toWrite += sb.toString ();
        n = in.read (cbuf);
    }
    toWrite = AStringUtilities.replace (toWrite, replaceMap);
    out.write (toWrite);
}


-----Function Pair=113=-----==

public void editButtonActionPerformed (long id) {
    try {
        KMetaUtilsClass.cursorWait (parentWindow);
        JDialog Dialog = getPDCEditorWidow ();
        ((KDialogInterface) Dialog).initializeDialog (KDialogInterface.EDIT_MODE, id, null);
        KMetaUtilsClass.cursorNormal (parentWindow);
        Dialog.setVisible (true);
    } catch (KExceptionClass error) {
        log.log (this, error.longMessage);
        KMetaUtilsClass.showErrorMessageFromException (parentWindow, error);
    } catch (Exception error) {
        log.log (this, KMetaUtilsClass.getStackTrace (error));
        KMetaUtilsClass.showErrorMessageFromException (parentWindow, error);
    } finally {
        KMetaUtilsClass.cursorNormal (parentWindow);
    }
}


public void run () {
    Enumeration keys;
    while (! this.main.finishedAll) {
        keys = this.main.mappings.keys ();
        while (keys.hasMoreElements ()) {
            String jobId = "" + keys.nextElement ();
            TraceFile tf = this.main.tfm.getTraceFile (jobId, this.main.mainMonitorURL);
            if (tf != null) {
                if (tf.getLinesNumber () == (this.main.maxMessageForAJob + 2)) this.main.finished (jobId);
            }
        }
        try {
            Thread.sleep (1000);
        } catch (InterruptedException ex) {
        }
    }
}


-----Function Pair=114=-----==

public List < TaskComment > readComments (IMemento parent) {
    List < TaskComment > comments = new ArrayList < TaskComment > ();
    for (IMemento commentMemento : parent.getChildren (ELEMENT_COMMENT)) {
        Integer commentNumber = commentMemento.getInteger (ATTRIBUTE_NUMBER);
        String hasAttachment = commentMemento.getString (ATTRIBUTE_HAS_ATTACHMENT);
        String attachmentId = commentMemento.getString (ATTRIBUTE_ATTACHMENT_ID);
        if (commentNumber != null) {
            TaskComment comment = new TaskComment (temporaryFactory, commentNumber);
            if (hasAttachment != null) {
                comment.setHasAttachment (Boolean.parseBoolean (hasAttachment));
            }
            if (attachmentId != null) {
                comment.setAttachmentId (attachmentId);
            }
            IMemento attributesMemento = commentMemento.getChild (ELEMENT_ATTRIBUTES);
            if (attributesMemento != null) {
                List < RepositoryTaskAttribute > attributes = readAttributes (attributesMemento);
                for (RepositoryTaskAttribute repositoryTaskAttribute : attributes) {
                    comment.addAttribute (repositoryTaskAttribute.getId (), repositoryTaskAttribute);
                }
            }
            comments.add (comment);
        }
    }
    return comments;
}


public String gzipDecompress (String compressedFileName, String FileName) {
    String ret = null;
    final int BUFFER = 2048;
    try {
        FileInputStream fis = new FileInputStream (compressedFileName);
        java.util.zip.GZIPInputStream zis = new java.util.zip.GZIPInputStream (new BufferedInputStream (fis));
        FileOutputStream fos = new FileOutputStream (FileName);
        int count;
        byte data [] = new byte [BUFFER];
        while ((count = zis.read (data, 0, BUFFER)) != - 1) {
            fos.write (data, 0, count);
        }
        fos.flush ();
        fos.close ();
        zis.close ();
    } catch (Exception e) {
        ret = e.getMessage ();
    }
    return ret;
}


-----Function Pair=115=-----==

public void importDeck () {
    fc = new JFileChooser ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setFileFilter (new FileNameExtensionFilter (null, Filer.FILE_EXT));
    fc.setMultiSelectionEnabled (true);
    int returnVal = fc.showOpenDialog (framer);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File [] files = fc.getSelectedFiles ();
        if (files.length < 1) return;
        String [] paths = new String [files.length];
        for (int i = 0; i < files.length; i ++) {
            paths [i] = files [i].getAbsolutePath ();
        }
        importDecks (paths);
    }
    fc.setMultiSelectionEnabled (false);
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=116=-----=1=

void testCommand (String [] args, int expect_rc) throws Exception {
    System.err.println ("Test command: " + Arrays.asList (args));
    File javaHome = new File (System.getProperty ("java.home"));
    if (javaHome.getName ().equals ("jre")) javaHome = javaHome.getParentFile ();
    List < String > command = new ArrayList < String > ();
    command.add (new File (new File (javaHome, "bin"), "javah").getPath ());
    command.add ("-J-Xbootclasspath:" + System.getProperty ("sun.boot.class.path"));
    command.addAll (Arrays.asList (args));
    ProcessBuilder pb = new ProcessBuilder (command);
    pb.redirectErrorStream (true);
    Process p = pb.start ();
    p.getOutputStream ().close ();
    StringWriter sw = new StringWriter ();
    String line;
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    while ((line = in.readLine ()) != null) sw.write (line + NEWLINE);
    int rc = p.waitFor ();
    expect ("testCommand", sw.toString (), rc, expect_rc);
}


void testCommand (String [] args, int expect_rc) throws Exception {
    System.err.println ("Test command: " + Arrays.asList (args));
    File javaHome = new File (System.getProperty ("java.home"));
    if (javaHome.getName ().equals ("jre")) javaHome = javaHome.getParentFile ();
    List < String > command = new ArrayList < String > ();
    command.add (new File (new File (javaHome, "bin"), "javah").getPath ());
    command.add ("-J-Xbootclasspath:" + System.getProperty ("sun.boot.class.path"));
    command.addAll (Arrays.asList (args));
    ProcessBuilder pb = new ProcessBuilder (command);
    pb.redirectErrorStream (true);
    Process p = pb.start ();
    p.getOutputStream ().close ();
    StringWriter sw = new StringWriter ();
    String line;
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    while ((line = in.readLine ()) != null) sw.write (line + NEWLINE);
    int rc = p.waitFor ();
    expect ("testCommand", sw.toString (), rc, expect_rc);
}


-----Function Pair=117=-----==

private void readConfig (String xmlFile) {
    try {
        File file = new File (xmlFile);
        if (file.exists ()) {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
            DocumentBuilder builder = factory.newDocumentBuilder ();
            Document doc = builder.parse (xmlFile);
            NodeList nodes;
            if (doc.getElementsByTagName ("buttons").item (0) != null) {
                nodes = doc.getElementsByTagName ("buttons").item (0).getChildNodes ();
                for (int i = 0; i < nodes.getLength (); i ++) {
                    Node node = nodes.item (i);
                    if (node instanceof Element) {
                        Element child = (Element) node;
                        JButton btn = new AntRunnerButton (child.getAttribute ("name"), child.getAttribute ("file"), child.getAttribute ("execute"), child.getAttribute ("description"));
                        btn.addActionListener (buttonHandler);
                        panelCmdButtons.add (btn);
                    }
                }
            }
            else {
                panelCmdButtons.setVisible (false);
            }
            nodes = doc.getElementsByTagName ("options");
            if (nodes.getLength () > 0) {
                Node node = nodes.item (0);
                if (node instanceof Element) {
                    Element child = (Element) node;
                    loggerClass = child.getAttribute ("logger");
                }
            }
            nodes = doc.getElementsByTagName ("tabs").item (0).getChildNodes ();
            for (int i = 0; i < nodes.getLength (); i ++) {
                Node node = nodes.item (i);
                if (node instanceof Element) {
                    Element child = (Element) node;
                    new AntRunnerTab (this, tabbedPane, child.getAttribute ("name"), child.getAttribute ("type"), child.getAttribute ("file"), child.getAttribute ("source"));
                }
            }
            nodes = doc.getElementsByTagName ("timer");
            if (nodes.getLength () > 0) {
                for (int i = 0; i < nodes.getLength (); i ++) {
                    Node node = nodes.item (i);
                    if (node instanceof Element) {
                        Element child = (Element) node;
                        setUpdateTimer (child.getAttribute ("file"), child.getAttribute ("execute"), Long.parseLong (child.getAttribute ("interval")));
                    }
                }
            }
            else {
                chkPoll.setSelected (false);
                chkPoll.setEnabled (false);
            }
        }
        else {
            System.err.print ("File " + xmlFile + " not found!");
        }
    } catch (Exception e) {
        System.err.print (e.toString ());
        System.exit (1);
    }
    try {
        if (loggerClass == null) loggerClass = "org.apache.tools.ant.DefaultLogger";
        Class c = Class.forName (loggerClass);
        logger = (BuildLogger) c.newInstance ();
        loggerTextField.setText (logger.getClass ().getCanonicalName ());
    } catch (Exception e) {
        System.err.print (e.toString ());
        System.exit (1);
    }
}


public static Any getReportAttrs (Connection con, Any values, Any retValue) throws SQLException, IOException, ParserConfigurationException, SAXException {
    OracleCallableStatement ps = null;
    try {
        HashMap map = (HashMap) values.extract_Value ();
        String sID = (String) map.get ("ID");
        String sSql = ResourceBundle.getBundle (ExcelReports.class.getName ()).getString ("getReportAttrs");
        ps = (OracleCallableStatement) con.prepareCall (sSql);
        ps.setString (1, sID);
        OracleResultSet rSet = (OracleResultSet) ps.executeQuery ();
        if (rSet.next ()) {
            ObjAttrs arAttrs = (ObjAttrs) rSet.getORAData ("ATTRS", new ObjAttrs ());
            ObjAttr attrs [] = arAttrs.getArray ();
            ArrayList < HashMap > arHash = new ArrayList < HashMap > ();
            for (ObjAttr atr : attrs) {
                HashMap val = new HashMap ();
                val.put ("NAME", atr.getCname ());
                val.put ("DESC", atr.getCdesc ());
                val.put ("MASK", atr.getCtype ());
                arHash.add (val);
            }
            retValue.insert_Value (arHash.toArray (new HashMap [arHash.size ()]));
        }
    } finally {
        if (ps != null) ps.close ();
    }
    return retValue;
}


-----Function Pair=118=-----==

String [] getFirstLetters () {
    Vector < String > firsts = new Vector < String > ();
    for (int x = 0; x < channelMap.size (); x ++) {
        String [] map = (String []) channelMap.get (x);
        HashMap < String, GuideItem > progs = (HashMap < String, GuideItem >) progList.get (map [1]);
        if (progs != null) {
            GuideItem [] items = (GuideItem []) progs.values ().toArray (new GuideItem [0]);
            for (int y = 0; y < items.length; y ++) {
                if (items [y].getName () != null && items [y].getName ().length () > 1) {
                    String firstLetter = items [y].getName ().substring (0, 1).toUpperCase ();
                    if (! firsts.contains (firstLetter)) firsts.add (firstLetter);
                }
            }
        }
    }
    String [] result = (String []) firsts.toArray (new String [0]);
    Arrays.sort (result);
    return result;
}


public static void extract (File zipfile, File destDir, FilenameFilter filter) throws IOException {
    FileInputStream fis = new FileInputStream (zipfile);
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
    ZipEntry zipentry;
    while ((zipentry = zis.getNextEntry ()) != null) {
        log.debug ("Unzipping: " + zipentry.getName ());
        File f = new File (destDir, zipentry.getName ());
        if (! f.isDirectory ()) {
            if (filter.accept (f.getParentFile (), f.getName ())) {
                f.getParentFile ().mkdirs ();
                FileOutputStream fos = new FileOutputStream (f);
                log.debug ("outputting: " + f.getName ());
                copyInputStream (zis, fos);
            }
        }
    }
}


-----Function Pair=119=-----==

private String getTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = 0;
    if (item != null) type = item.getType ();
    typeList.append ("<label><input name='type' type='radio' value='0' ");
    if (type == ScheduleItem.ONCE) typeList.append ("checked");
    typeList.append (">Once</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='1' ");
    if (type == ScheduleItem.DAILY) typeList.append ("checked");
    typeList.append (">Daily</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='2' ");
    if (type == ScheduleItem.WEEKLY) typeList.append ("checked");
    typeList.append (">Weekly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='3' ");
    if (type == ScheduleItem.MONTHLY) typeList.append ("checked");
    typeList.append (">Monthly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='4' ");
    if (type == ScheduleItem.WEEKDAY) typeList.append ("checked");
    typeList.append (">Week Day</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='5' ");
    if (type == ScheduleItem.EPG) typeList.append ("checked");
    typeList.append (">EPG</label><br>\n");
    return typeList.toString ();
}


private String getTypeList (ScheduleItem item) {
    StringBuffer typeList = new StringBuffer (1024);
    int type = 0;
    if (item != null) type = item.getType ();
    typeList.append ("<label><input name='type' type='radio' value='0' ");
    if (type == ScheduleItem.ONCE) typeList.append ("checked");
    typeList.append (">Once</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='1' ");
    if (type == ScheduleItem.DAILY) typeList.append ("checked");
    typeList.append (">Daily</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='2' ");
    if (type == ScheduleItem.WEEKLY) typeList.append ("checked");
    typeList.append (">Weekly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='3' ");
    if (type == ScheduleItem.MONTHLY) typeList.append ("checked");
    typeList.append (">Monthly</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='4' ");
    if (type == ScheduleItem.WEEKDAY) typeList.append ("checked");
    typeList.append (">Week Day</label><br>\n");
    typeList.append ("<label><input name='type' type='radio' value='5' ");
    if (type == ScheduleItem.EPG) typeList.append ("checked");
    typeList.append (">EPG</label><br>\n");
    return typeList.toString ();
}


-----Function Pair=120=-----==

public long copyDirAllFilesToDirectory (String baseDirStr, String destDirStr) throws Exception {
    long plussQuotaSize = 0;
    if (baseDirStr.endsWith (sep)) {
        baseDirStr = baseDirStr.substring (0, baseDirStr.length () - 1);
    }
    if (destDirStr.endsWith (sep)) {
        destDirStr = destDirStr.substring (0, destDirStr.length () - 1);
    }
    FileUtils.getInstance ().createDirectory (destDirStr);
    BufferedInputStream in = null;
    BufferedOutputStream out = null;
    byte dataBuff [] = new byte [bufferSize];
    File baseDir = new File (baseDirStr);
    baseDir.mkdirs ();
    if (! baseDir.exists ()) {
        createDirectory (baseDirStr);
    }
    if ((baseDir.exists ()) && (baseDir.isDirectory ())) {
        String [] entryList = baseDir.list ();
        if (entryList.length > 0) {
            for (int pos = 0; pos < entryList.length; pos ++) {
                String entryName = entryList [pos];
                String oldPathFileName = baseDirStr + sep + entryName;
                File entryFile = new File (oldPathFileName);
                if (entryFile.isFile ()) {
                    String newPathFileName = destDirStr + sep + entryName;
                    File newFile = new File (newPathFileName);
                    if (newFile.exists ()) {
                        plussQuotaSize -= newFile.length ();
                        newFile.delete ();
                    }
                    in = new BufferedInputStream (new FileInputStream (oldPathFileName), bufferSize);
                    out = new BufferedOutputStream (new FileOutputStream (newPathFileName), bufferSize);
                    int readLen;
                    while ((readLen = in.read (dataBuff)) > 0) {
                        out.write (dataBuff, 0, readLen);
                        plussQuotaSize += readLen;
                    }
                    out.flush ();
                    in.close ();
                    out.close ();
                }
            }
        }
    }
    else {
        throw new Exception ("Base dir not exist ! baseDirStr = (" + baseDirStr + ")");
    }
    return plussQuotaSize;
}


public void run (ServletConfig servcon) throws Exception {
    this.setResult (Daemon.RESULT_PROCESSING);
    Log.info ("running robot stuff");
    DBConnection dbconn = null;
    String query = "select distinct SAMPLE.SAMPLE_ID, USERS_ID from SAMPLE left join RAW_FILE using (SAMPLE_ID) where URL is null and FINISHED=\"false\" and (PROCESS=\"" + OrderAction.ROBOT + "\" or PROCESS=\"" + OrderAction.SELF + "\")";
    try {
        dbconn = TurbineDB.getConnection ();
        Statement stmt = dbconn.createStatement ();
        ResultSet rs = stmt.executeQuery (query);
        while (rs.next ()) {
            String sampleid = rs.getString (1);
            String usersid = rs.getString (2);
            File zipfile = new File (GeneralUtils.getNmrshiftdbProperty ("compressedfiledirectory", servcon) + "/" + usersid + ".zip");
            FileOutputStream baos = new FileOutputStream (zipfile);
            ZipOutputStream zipout = new ZipOutputStream (baos);
            File rawfiledir = new File (GeneralUtils.getNmrshiftdbProperty ("rawfiledirectoryrobot", servcon));
            StringBuffer attachedfiles = new StringBuffer ();
            searchfiles (rawfiledir, usersid, zipout, attachedfiles, new File (GeneralUtils.getNmrshiftdbProperty ("compressedfiledirectory", servcon)));
            if (! attachedfiles.toString ().equals ("")) {
                zipout.close ();
                DBRawFile rawfile = new DBRawFile ();
                rawfile.setSampleId (sampleid);
                rawfile.setUrl (GeneralUtils.getNmrshiftdbProperty ("urlcompressedfiles", servcon) + "/" + usersid + ".zip");
                rawfile.setContainedFiles (attachedfiles.toString ());
                rawfile.setAssigned ("false");
                rawfile.save ();
                DBSample sample = DBSamplePeer.retrieveByPK (new NumberKey (sampleid));
                sample.setFinished ("true");
                sample.save ();
            }
        }
        dbconn.close ();
        this.setResult (Daemon.RESULT_SUCCESS);
    } catch (Exception ex) {
        dbconn.close ();
        GeneralUtils.logError (ex, "robot daemon", null, true);
    }
}


-----Function Pair=121=-----==

public void importDeck () {
    fc = new JFileChooser ();
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (true);
    int returnVal = fc.showOpenDialog (framer);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File [] files = fc.getSelectedFiles ();
        if (files.length < 1) return;
        String [] paths = new String [files.length];
        for (int i = 0; i < files.length; i ++) {
            paths [i] = files [i].getAbsolutePath ();
        }
        importDecks (paths);
    }
    fc.setMultiSelectionEnabled (false);
}


public void generateExe () throws IOException {
    new File (System.getProperty ("java.io.tmpdir") + "/config.txt").delete ();
    new File (System.getProperty ("java.io.tmpdir") + "/installer.7z").delete ();
    if (System.getProperty ("os.name").startsWith ("Windows")) p = Runtime.getRuntime ().exec (new String [] {RunnerClass.homedir + "utils/wrappers/izpack2exe/7za.exe", "a", "-t7z", "-mx=9", "-ms=off", System.getProperty ("java.io.tmpdir") + "/installer.7z", jarF.getAbsolutePath ()}, null, new File (RunnerClass.homedir + "utils/wrappers/izpack2exe"));
    else p = Runtime.getRuntime ().exec (new String [] {"7za", "a", "-t7z", "-mx=9", "-ms=off", System.getProperty ("java.io.tmpdir") + "/installer.7z", jarF.getAbsolutePath ()}, null, new File (RunnerClass.homedir + "utils/wrappers/izpack2exe"));
    final BufferedReader inps = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    final BufferedReader errs = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
    new Thread (new Runnable () {
        @Override
        public void run () {
            try {
                fr.taskMsg.setText ("Compressing");
                fr.taskPB.setIndeterminate (true);
                String c;
                long l = System.currentTimeMillis ();
                while ((c = inps.readLine ()) != null) {
                    RunnerClass.logger.info ((System.currentTimeMillis () - l) + " Input: " + c);
                    l = System.currentTimeMillis ();
                }
                if (crashed) fr.crash ();
                jarF.delete ();
            } catch (IOException ex) {
                RunnerClass.logger.log (Level.SEVERE, null, ex);
            }
        }
    }
    ).start ();
    new Thread (new Runnable () {
        @Override
        public void run () {
            try {
                String c;
                while ((c = errs.readLine ()) != null) {
                    crashed = true;
                    RunnerClass.logger.severe ("Error: " + c);
                }
            } catch (IOException ex) {
                RunnerClass.logger.log (Level.SEVERE, null, ex);
            }
        }
    }
    ).start ();
    try {
        p.waitFor ();
    } catch (InterruptedException ex) {
    }
    if (stopped) return;
    PrintWriter out = new PrintWriter (new FileWriter (System.getProperty ("java.io.tmpdir") + "/config.txt"));
    out.println (";!@Install@!UTF-8!");
    out.println ("Title=\"Installer\"");
    out.println ("InstallPath=\"%temp%\\\\packjacket-installer\"");
    out.println ("ExtractDialogText=\"Extracting installer\"");
    out.println ("Progress=\"yes\"");
    out.println ("GUIFlags=\"4+32\"");
    out.println ("GUIMode=\"1\"");
    out.println ("ExecuteFile=\"" + jarF.getName () + "\"");
    out.println (";!@InstallEnd@!");
    out.close ();
    exeF.delete ();
    FileOutputStream outFile = new FileOutputStream (new File (exeF.getAbsolutePath ()), true);
    writeFile (new FileInputStream (new File (RunnerClass.homedir + "utils/wrappers/izpack2exe/7zS.sfx")), outFile);
    writeFile (new FileInputStream (new File (System.getProperty ("java.io.tmpdir") + "/config.txt")), outFile);
    writeFile (new FileInputStream (new File (System.getProperty ("java.io.tmpdir") + "/installer.7z")), outFile);
    outFile.close ();
    fr.setPB (100);
    fr.taskPB.setIndeterminate (false);
    fr.taskMsg.setText ("Completed");
    new File (System.getProperty ("java.io.tmpdir") + "/config.txt").delete ();
    new File (System.getProperty ("java.io.tmpdir") + "/installer.7z").delete ();
}


-----Function Pair=122=-----==

public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


public SubscribeTest (String testAppAbsPath, int jobNumber, int maxMessageForAJob, String mainMonitorURL, int delay, boolean portalEmul) {
    System.out.println ("SubscribeTest(" + testAppAbsPath + ", " + jobNumber + ", " + maxMessageForAJob + ", " + mainMonitorURL + ", " + delay + ", " + portalEmul + ") called");
    String path = "" + this.getClass ().getClassLoader ().getResource (".");
    this.traceFilesDir = path.substring (path.indexOf (":") + 1, path.length ()) + "testTraces/";
    File tracesDir = new File (this.traceFilesDir);
    if (! tracesDir.exists ()) {
        try {
            tracesDir.mkdirs ();
        } catch (Exception ex) {
            System.out.println ("Failed to create dir: " + tracesDir.getAbsolutePath ());
            ex.printStackTrace ();
        }
    }
    this.testAppAbsPath = testAppAbsPath;
    this.jobNumber = jobNumber;
    this.finishedJobs = 0;
    this.maxMessageForAJob = maxMessageForAJob;
    this.mainMonitorURL = mainMonitorURL;
    this.mappings = new Hashtable ();
    this.delay = delay;
    this.portalEmul = portalEmul;
    if (portalEmul) {
        try {
            this.tfm = TraceFileMonitor.getInstance (this.traceFilesDir);
        } catch (Exception ex) {
            ex.printStackTrace ();
            System.exit (0);
        }
    }
    this.run ();
}


-----Function Pair=123=-----==

private void displayDiffResults () throws IOException {
    File outFile = File.createTempFile ("diff", ".htm");
    outFile.deleteOnExit ();
    FileOutputStream outStream = new FileOutputStream (outFile);
    BufferedWriter out = new BufferedWriter (new OutputStreamWriter (outStream));
    out.write ("<html><head><title>LOC Differences</title>\n" + SCRIPT + "</head>\n" + "<body bgcolor='#ffffff'>\n" + "<div onMouseOver=\"window.defaultStatus='Metrics'\">\n");
    if (addedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Added:</th>" + "<th>Add</th><th>Type</th></tr>");
        out.write (addedTable.toString ());
        out.write ("</table><br><br>");
    }
    if (modifiedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Modified:</th>" + "<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>" + "<th>Total</th><th>Type</th></tr>");
        out.write (modifiedTable.toString ());
        out.write ("</table><br><br>");
    }
    if (deletedTable.length () > 0) {
        out.write ("<table border><tr><th>Files Deleted:</th>" + "<th>Del</th><th>Type</th></tr>");
        out.write (deletedTable.toString ());
        out.write ("</table><br><br>");
    }
    out.write ("<table name=METRICS BORDER>\n");
    if (modifiedTable.length () > 0 || deletedTable.length () > 0) {
        out.write ("<tr><td>Base:&nbsp;</td><td>");
        out.write (Long.toString (base));
        out.write ("</td></tr>\n<tr><td>Deleted:&nbsp;</td><td>");
        out.write (Long.toString (deleted));
        out.write ("</td></tr>\n<tr><td>Modified:&nbsp;</td><td>");
        out.write (Long.toString (modified));
        out.write ("</td></tr>\n<tr><td>Added:&nbsp;</td><td>");
        out.write (Long.toString (added));
        out.write ("</td></tr>\n<tr><td>New & Changed:&nbsp;</td><td>");
        out.write (Long.toString (added + modified));
        out.write ("</td></tr>\n");
    }
    out.write ("<tr><td>Total:&nbsp;</td><td>");
    out.write (Long.toString (total));
    out.write ("</td></tr>\n</table></div>");
    redlinesOut.close ();
    out.flush ();
    InputStream redlines = new FileInputStream (redlinesTempFile);
    byte [] buffer = new byte [4096];
    int bytesRead;
    while ((bytesRead = redlines.read (buffer)) != - 1) outStream.write (buffer, 0, bytesRead);
    outStream.write ("</BODY></HTML>".getBytes ());
    outStream.close ();
    Browser.launch (outFile.toURL ().toString ());
}


public int getChannelMaxLevel (String path) throws Exception {
    DBOperation dbo = null;
    ResultSet resultSet = null;
    int maxLevel = - 1;
    try {
        dbo = createDBOperation ();
        String sql = "select max(channel_path) from t_ip_channel where channel_path like '" + path + "%'";
        resultSet = dbo.select (sql);
        if (resultSet.next ()) {
            String mPath = resultSet.getString (1);
            maxLevel = mPath.length () / 5 - 1;
        }
    } catch (Exception e) {
        log.error ("�õ�ĳƵ��Path�¿�������ʱ����", e);
        throw e;
    } finally {
        close (resultSet, null, null, null, dbo);
    }
    return maxLevel;
}


-----Function Pair=124=-----==

public static void saveDialog (Component parent, String content, String lastUsedDirectory, String title) {
    final JFileChooser fc = new JFileChooser (lastUsedDirectory);
    fc.setDialogTitle (title);
    fc.setFileHidingEnabled (true);
    fc.setFileSelectionMode (JFileChooser.FILES_AND_DIRECTORIES);
    fc.setMultiSelectionEnabled (false);
    int returnVal = fc.showSaveDialog (parent);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile ();
        if (file != null) {
            Core.frostSettings.setValue (SettingsClass.DIR_LAST_USED, file.getParent ());
            if (! file.isDirectory ()) {
                writeFile (content, file, "UTF-8");
            }
        }
    }
}


protected static synchronized File getLatestIndexDirectory (final File file, final File latestSoFar) {
    if (file == null) {
        return latestSoFar;
    }
    File latest = latestSoFar;
    if (file.isDirectory ()) {
        File [] children = file.listFiles ();
        for (File child : children) {
            if (FileUtilities.isDigits (child.getName ())) {
                if (latest == null) {
                    latest = child;
                }
                long oneTime = Long.parseLong (child.getName ());
                long twoTime = Long.parseLong (latest.getName ());
                latest = oneTime > twoTime ? child : latest;
            }
            else {
                latest = getLatestIndexDirectory (child, latest);
            }
        }
    }
    return latest;
}


-----Function Pair=125=-----==

public static String readFile (File file, String encoding) {
    String line;
    StringBuilder sb = new StringBuilder ();
    try {
        InputStreamReader iSReader = new InputStreamReader (new FileInputStream (file), encoding);
        BufferedReader reader = new BufferedReader (iSReader);
        while ((line = reader.readLine ()) != null) {
            sb.append (line).append ("\n");
        }
        reader.close ();
    } catch (IOException e) {
        logger.log (Level.SEVERE, "Exception thrown in readFile(String path, String encoding)", e);
    }
    return sb.toString ();
}


public static void cleanUnzippedFiles (String zipFileName, String outputDirectory) throws IOException {
    FileInputStream inStream;
    ZipInputStream zipFile = new ZipInputStream (inStream = new FileInputStream (zipFileName));
    ZipEntry entry;
    File f;
    while ((entry = zipFile.getNextEntry ()) != null) {
        f = new File (outputDirectory + File.separator + entry.getName ());
        if (f.exists ()) {
            Utils.delete (f);
        }
        zipFile.closeEntry ();
    }
    zipFile.close ();
    inStream.close ();
}


-----Function Pair=126=-----==

private void createProject () {
    JFileChooser chooser = getFileChooser ();
    chooser.setDialogTitle ("Choose export directory");
    chooser.setApproveButtonText ("Open");
    chooser.setApproveButtonToolTipText ("Open the selected directory.");
    chooser.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
    chooser.setFileFilter (null);
    if (chooser.showOpenDialog (getProjectFrame ()) == JFileChooser.APPROVE_OPTION) {
        String file = getExportTextField ().getText ();
        project = new Project (file, srcFolder);
        if (project == null) {
            JOptionPane.showMessageDialog (getProjectFrame (), "Error creating project");
            hideTree ();
        }
        else {
            String path = chooser.getSelectedFile ().getPath ();
            boolean jar = getCreateJar ().isSelected ();
            if (! jar) {
                File f = new File (path + File.separator + "config.prj");
                if (f.exists ()) {
                    int result = JOptionPane.showConfirmDialog (projectFrame, "A project already exists in this directory, overwrite?");
                    if (result == JOptionPane.NO_OPTION) {
                        createProject ();
                        return;
                    }
                    else if (result == JOptionPane.CANCEL_OPTION) return;
                }
            }
            project.exportFiles (path, jar);
            JOptionPane.showMessageDialog (getProjectFrame (), "Project successfully created:\n" + project.getLastSavedLocation ());
            showTree (getProjectName (file));
        }
    }
}


public static boolean bzip2 (File toZip, File zipped) {
    try {
        BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (zipped));
        bos.write ('B');
        bos.write ('Z');
        CBZip2OutputStream zOut = new CBZip2OutputStream (bos);
        FileInputStream in = new FileInputStream (toZip);
        byte [] buffer = new byte [8 * 1024];
        int count = 0;
        do {
            zOut.write (buffer, 0, count);
            count = in.read (buffer, 0, buffer.length);
        }
        while (count != - 1);
        zOut.close ();
        in.close ();
        return true;
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        return false;
    }
}


-----Function Pair=127=-----==

public String [] groupCreated (String id, int x, int y, ArrayList < String > subShapeIds, String attributeNameValues [], String logRecipients, String contextKey, String userName, String projectName, String previousTimeStamp, int undoCount) {
    DAO dao = ServerUtils.getDao ();
    String result [] = new String [2];
    String projectKey = createProjectKey (contextKey, projectName);
    ServerGroupShape groupShape = new ServerGroupShape (x, y, id, subShapeIds, projectKey);
    dao.persistObject (groupShape);
    result [0] = groupShape.getTimeStampString ();
    if (logRecipients != null) {
        HashMap < String, TiedNumberExpression < IntegerValue > > idToTiedNumberMap = new HashMap < String, TiedNumberExpression < IntegerValue > > ();
        logShapeCreationOrUpdate (CommonFormatEventType.CREATION, groupShape.getPatternShape (null, idToTiedNumberMap), userName, projectName, attributeNameValues, logRecipients);
    }
    linkTimeStamps (previousTimeStamp, undoCount, result [0], projectKey);
    return result;
}


public void writeTrailer () throws IOException {
    if (! isMultiPage ()) closePage ();
    PDFPageTree pages = os.openPageTree ("RootPage", null);
    for (int i = 1; i <= currentPage; i ++) {
        pages.addPage ("Page" + i);
    }
    Dimension pageSize = PageConstants.getSize (getProperty (PAGE_SIZE), getProperty (ORIENTATION));
    pages.setMediaBox (0, 0, pageSize.getWidth (), pageSize.getHeight ());
    pages.setResources ("Resources");
    os.close (pages);
    os.object ("PageProcSet", new Object [] {os.name ("PDF"), os.name ("Text"), os.name ("ImageC")});
    int nFonts = fontTable.addFontDictionary ();
    int nXObjects = delayImageQueue.addXObjects ();
    int nPatterns = delayPaintQueue.addPatterns ();
    if (extGStates.size () > 0) {
        PDFDictionary extGState = os.openDictionary ("ExtGState");
        for (Iterator i = extGStates.keySet ().iterator (); i.hasNext ();) {
            Float alpha = (Float) i.next ();
            String alphaName = (String) extGStates.get (alpha);
            PDFDictionary alphaDictionary = extGState.openDictionary (alphaName);
            alphaDictionary.entry ("ca", alpha.floatValue ());
            alphaDictionary.entry ("CA", alpha.floatValue ());
            alphaDictionary.entry ("BM", os.name ("Normal"));
            alphaDictionary.entry ("AIS", false);
            extGState.close (alphaDictionary);
        }
        os.close (extGState);
    }
    PDFDictionary resources = os.openDictionary ("Resources");
    resources.entry ("ProcSet", os.ref ("PageProcSet"));
    if (nFonts > 0) resources.entry ("Font", os.ref ("FontList"));
    if (nXObjects > 0) resources.entry ("XObject", os.ref ("XObjects"));
    if (nPatterns > 0) resources.entry ("Pattern", os.ref ("Pattern"));
    if (extGStates.size () > 0) resources.entry ("ExtGState", os.ref ("ExtGState"));
    os.close (resources);
    PDFOutlineList outlines = os.openOutlineList ("Outlines", "Outline1", "Outline" + currentPage);
    os.close (outlines);
    for (int i = 1; i <= currentPage; i ++) {
        String prev = i > 1 ? "Outline" + (i - 1) : null;
        String next = i < currentPage ? "Outline" + (i + 1) : null;
        PDFOutline outline = os.openOutline ("Outline" + i, (String) titles.get (i - 1), "Outlines", prev, next);
        outline.setDest (new Object [] {os.ref ("Page" + i), os.name ("Fit")});
        os.close (outline);
    }
    processDelayed ();
}


-----Function Pair=128=-----==

public static void appendStream (BufferedWriter out, BufferedReader in, Map < String, String > replaceMap) throws IOException {
    int n;
    int bufferSize = 4096;
    char cbuf [] = new char [bufferSize];
    n = in.read (cbuf);
    String toWrite = "";
    while (n > 0) {
        StringBuilder sb = new StringBuilder (4096);
        sb.append (cbuf, 0, n);
        toWrite += sb.toString ();
        n = in.read (cbuf);
    }
    toWrite = AStringUtilities.replace (toWrite, replaceMap);
    out.write (toWrite);
}


public static void pipe (InputStream in, OutputStream out, boolean isBlocking, ByteFilter filter) throws IOException {
    byte [] buf = new byte [MAX_BUFFER_SIZE];
    int nread;
    int navailable;
    int total = 0;
    synchronized (in) {
        while ((navailable = isBlocking ? buf.length : in.available ()) > 0 && (nread = in.read (buf, 0, Math.min (buf.length, navailable))) >= 0) {
            if (filter == null) {
                out.write (buf, 0, nread);
            }
            else {
                byte [] filtered = filter.filter (buf, nread);
                out.write (filtered);
            }
            total += nread;
        }
    }
    out.flush ();
    buf = null;
}


-----Function Pair=129=-----==

public static Object getClientProxy (Webservice.Description webserviceDescription) throws AxisException, ClassNotFoundException, IllegalArgumentException {
    log_.entering (new Object [] {webserviceDescription});
    Class < ? > [] ifclasses;
    Class < ? > clazz;
    String [] ifnames;
    Object client;
    Object stub;
    String msg;
    int i;
    WebservicePermission.checkPermission (null, "createClient");
    if (webserviceDescription == null) {
        log_.error (msg = "The Webservice description is null");
        throw new IllegalArgumentException (msg);
    }
    ifnames = webserviceDescription.getInterfaces ();
    if (ifnames != null) {
        ifclasses = new Class [ifnames.length];
        for (i = 0; i < ifnames.length; i ++) {
            ifclasses [i] = Class.forName (ifnames [i]);
        }
    }
    else {
        ifclasses = null;
    }
    stub = StubGenerator.createStub (webserviceDescription.getWsdlURL ());
    clazz = stub.getClass ();
    client = Proxy.newProxyInstance (clazz.getClassLoader (), ifclasses != null ? ifclasses : clazz.getInterfaces (), new StubInvocationHandler (stub));
    log_.info ("Successfully created webservice client for " + webserviceDescription);
    log_.exiting (client);
    return client;
}


public void run () {
    String command;
    while (true) {
        synchronized (cmd) {
            if (cmd.isEmpty ()) {
                try {
                    cmd.wait ();
                } catch (InterruptedException e) {
                }
            }
            command = (String) cmd.firstElement ();
            cmd.removeElementAt (0);
        }
        if (command.equals ("cftd")) {
            wlPanel panel = (wlPanel) cmd.firstElement ();
            cmd.removeElementAt (0);
            try {
                Transfer transfer = (Transfer) cmd.firstElement ();
                cmd.removeElementAt (0);
                MyFile file = transfer.getSource ();
                MyFile to = transfer.getDest ();
                if (file.isDirectory ()) {
                    new File (to.getAbsolutePath ()).mkdir ();
                    frame.getQueueList ().removeFirst ();
                    frame.getQueueList ().updateView ();
                    MyFile [] files = file.list ();
                    for (int i = files.length - 1; i >= 0; i --) {
                        MyFile tmp = new MyFile (files [i].getName ());
                        tmp.setFtpMode (false);
                        tmp.setAbsolutePath (to.getAbsolutePath () + File.separator + files [i].getName ());
                        frame.getQueueList ().addAtBegin (new Transfer (files [i], tmp, transfer.modeFrom, transfer.modeTo, transfer.from_to, null, null));
                    }
                }
                else {
                    copyFileToDir (file, to, panel);
                    frame.getQueueList ().removeFirst ();
                    frame.getQueueList ().updateView ();
                }
            } catch (IOException e) {
                System.out.println (e.toString ());
            }
            while (! wlFxp.getTm ().waiting) {
                try {
                    Thread.sleep (20);
                } catch (InterruptedException e) {
                }
            }
            synchronized (wlFxp.getTm ().done) {
                wlFxp.getTm ().done.notify ();
            }
        }
        try {
            sleep (50);
        } catch (InterruptedException e) {
        }
    }
}


-----Function Pair=130=-----==

public void doPost (HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
    HttpSession ssn = req.getSession (true);
    String send = req.getParameter ("send");
    String host = req.getParameter ("hostname");
    String user = req.getParameter ("username");
    String passwd = req.getParameter ("password");
    URLName url = new URLName (protocol, host, - 1, mbox, user, passwd);
    ServletOutputStream out = res.getOutputStream ();
    res.setContentType ("text/html");
    out.println ("<html><body bgcolor=\"#CCCCFF\">");
    if (send != null) {
        send (req, res, out, ssn);
    }
    else {
        MailUserData mud = new MailUserData (url);
        ssn.putValue ("javamailservlet", mud);
        try {
            Properties props = System.getProperties ();
            props.put ("mail.smtp.host", host);
            Session session = Session.getDefaultInstance (props, null);
            session.setDebug (false);
            Store store = session.getStore (url);
            store.connect ();
            Folder folder = store.getDefaultFolder ();
            if (folder == null) throw new MessagingException ("No default folder");
            folder = folder.getFolder (mbox);
            if (folder == null) throw new MessagingException ("Invalid folder");
            folder.open (Folder.READ_WRITE);
            int totalMessages = folder.getMessageCount ();
            Message [] msgs = folder.getMessages ();
            FetchProfile fp = new FetchProfile ();
            fp.add (FetchProfile.Item.ENVELOPE);
            folder.fetch (msgs, fp);
            System.out.println ("Login from: " + store.getURLName ());
            mud.setSession (session);
            mud.setStore (store);
            mud.setFolder (folder);
            out.print ("<center>");
            out.print ("<font face=\"Arial,Helvetica\" font size=+3>");
            out.println ("<b>Welcome to JavaMail!</b></font></center><p>");
            out.println ("<table width=\"50%\" border=0 align=center>");
            out.print ("<tr><td width=\"75%\" bgcolor=\"#ffffcc\">");
            out.print ("<font face=\"Arial,Helvetica\" font size=-1>");
            out.println ("<b>FolderName</b></font></td><br>");
            out.print ("<td width=\"25%\" bgcolor=\"#ffffcc\">");
            out.print ("<font face=\"Arial,Helvetica\" font size=-1>");
            out.println ("<b>Messages</b></font></td><br>");
            out.println ("</tr>");
            out.print ("<tr><td width=\"75%\" bgcolor=\"#ffffff\">");
            out.print ("<a href=\"" + HttpUtils.getRequestURL (req) + "\">" + "Inbox" + "</a></td><br>");
            out.println ("<td width=\"25%\" bgcolor=\"#ffffff\">" + totalMessages + "</td>");
            out.println ("</tr>");
            out.println ("</table");
        } catch (Exception ex) {
            out.println (ex.toString ());
        } finally {
            out.println ("</body></html>");
            out.close ();
        }
    }
}


public static byte [] zipUpdate (byte [] zip, String name, String oldname, byte [] contents, boolean delete) {
    try {
        File temp = File.createTempFile ("atf", ".zip");
        InputStream in = new BufferedInputStream (new ByteArrayInputStream (zip));
        OutputStream os = new BufferedOutputStream (new FileOutputStream (temp));
        ZipInputStream zin = new ZipInputStream (in);
        ZipOutputStream zout = new ZipOutputStream (os);
        ZipEntry e;
        ZipEntry e2;
        byte buffer [] = new byte [TEMP_FILE_BUFFER_SIZE];
        int bytesRead;
        boolean found = false;
        boolean rename = false;
        String oname = name;
        if (oldname != null) {
            name = oldname;
            rename = true;
        }
        while ((e = zin.getNextEntry ()) != null) {
            if (! e.isDirectory ()) {
                String ename = e.getName ();
                if (delete && ename.equals (name)) continue;
                e2 = new ZipEntry (rename ? oname : ename);
                zout.putNextEntry (e2);
                if (ename.equals (name)) {
                    found = true;
                    zout.write (contents);
                }
                else {
                    while ((bytesRead = zin.read (buffer)) != - 1) zout.write (buffer, 0, bytesRead);
                }
                zout.closeEntry ();
            }
        }
        if (! found && ! delete) {
            e = new ZipEntry (name);
            zout.putNextEntry (e);
            zout.write (contents);
            zout.closeEntry ();
        }
        zin.close ();
        zout.close ();
        byte [] res = MLUtil.loadFileToBuffer (temp.getPath ());
        temp.delete ();
        return (res);
    } catch (FileNotFoundException e) {
        MLUtil.runtimeError (e, name);
    } catch (IOException e) {
        MLUtil.runtimeError (e, name);
    }
    return (null);
}


-----Function Pair=131=-----==

public String createFolders (String folderPath, String paths) {
    String txts = folderPath;
    try {
        String txt;
        txts = folderPath;
        StringTokenizer st = new StringTokenizer (paths, "|");
        for (int i = 0; st.hasMoreTokens (); i ++) {
            txt = st.nextToken ().trim ();
            if (txts.lastIndexOf ("/") != - 1) {
                txts = createFolder (txts + txt);
            }
            else {
                txts = createFolder (txts + txt + "/");
            }
        }
    } catch (Exception e) {
        message = "����Ŀ¼�������?";
    }
    return txts;
}


public PersistentQueue (String name, File dir, int capacity) throws IOException {
    this.name = name;
    this.capacity = capacity;
    if (! dir.isDirectory () && ! dir.canWrite ()) throw new IllegalArgumentException ("Invalid directory " + dir.getAbsolutePath ());
    this.dir = new File (dir, name);
    this.dir.mkdirs ();
    File indexFile = new File (this.dir, INDEX_FILE);
    if (indexFile.exists ()) {
        byte [] idx = new byte [14];
        FileInputStream fis = new FileInputStream (indexFile);
        fis.read (idx);
        fis.close ();
        size = Utils.decodeInt (idx, 0);
        decodePointer (head, idx, 4);
        decodePointer (tail, idx, 9);
    }
    EMPTY_SEMAPHORE.release (size);
    FULL_SEMAPHORE.release (capacity - size);
}


-----Function Pair=132=-----==

protected void writeEntry () throws IOException {
    ListIterator it;
    FormatData fd = null;
    LBuffer buf = null;
    compressOutputData ();
    if ((m_fdList.size () == 0) && (m_outFile == null)) {
        if (m_outFile == null) {
            m_preNT.clear ();
            m_postNT.clear ();
        }
        else {
            it = m_postNT.listIterator (m_postNT.size ());
            while (it.hasPrevious ()) {
                fd = (FormatData) it.previous ();
                m_preNT.add (fd);
            }
        }
        m_postNT.clear ();
        m_fdList.clear ();
        m_tagList.clear ();
        m_ws = false;
        m_hasText = false;
        return;
    }
    if (m_outFile != null) {
        it = m_preNT.listIterator ();
        while (it.hasNext ()) {
            fd = (FormatData) it.next ();
            buf = fd.getOrig ();
            m_outFile.write (buf.getBuf (), 0, buf.size ());
        }
    }
    if (m_fdList.size () > 0) {
        it = m_fdList.listIterator ();
        LBuffer out = new LBuffer (256);
        while (it.hasNext ()) {
            fd = (FormatData) it.next ();
            out.append (fd.getDisplay ());
        }
        processEntry (out, m_file);
    }
    if (m_outFile != null) {
        it = m_postNT.listIterator (m_postNT.size ());
        while (it.hasPrevious ()) {
            fd = (FormatData) it.previous ();
            buf = fd.getOrig ();
            m_outFile.write (buf.getBuf (), 0, buf.size ());
        }
    }
    m_preNT.clear ();
    m_postNT.clear ();
    m_fdList.clear ();
    m_tagList.clear ();
    m_ws = false;
    m_hasText = false;
}


public static void writeEntry (File file, File input) throws PersistenceException {
    try {
        File temporaryFile = File.createTempFile ("pmMDA_zargo", ARGOUML_EXT);
        temporaryFile.deleteOnExit ();
        ZipOutputStream output = new ZipOutputStream (new FileOutputStream (temporaryFile));
        FileInputStream inputStream = new FileInputStream (input);
        ZipEntry entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT);
        output.putNextEntry (new ZipEntry (entry));
        IOUtils.copy (inputStream, output);
        output.closeEntry ();
        inputStream.close ();
        entry = new ZipEntry (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + ".argo");
        output.putNextEntry (new ZipEntry (entry));
        output.write (ArgoWriter.getArgoContent (file.getName ().substring (0, file.getName ().indexOf (ARGOUML_EXT)) + XMI_EXT).getBytes ());
        output.closeEntry ();
        output.close ();
        temporaryFile.renameTo (file);
    } catch (IOException ioe) {
        throw new PersistenceException (ioe);
    }
}


-----Function Pair=133=-----==

public Map getSecurityDefinitionSelectionMap () {
    Map securityMap = new LinkedHashMap ();
    List availableRoles = Application.getInstance ().getAllRoles ();
    for (Iterator iter = getSecurityDefinitionList ().iterator (); iter.hasNext ();) {
        SecurityDefinition def = (SecurityDefinition) iter.next ();
        String allowedRoles = def.getAllowedRoles ();
        if (allowedRoles == null) allowedRoles = "";
        Map roleMap = new LinkedHashMap ();
        for (Iterator roleiter = availableRoles.iterator (); roleiter.hasNext ();) {
            String role = (String) roleiter.next ();
            if (allowedRoles.indexOf (role) != - 1 || "APP_ADMINISTRATOR".equals (role)) {
                roleMap.put (role, Boolean.TRUE);
            }
            else {
                roleMap.put (role, Boolean.FALSE);
            }
        }
        securityMap.put (def, roleMap);
    }
    return securityMap;
}


public static void gzCompress (File sourceFile) throws Exception {
    final int BUFFER_SIZE = 100000;
    if (sourceFile.getName ().endsWith (".gz")) {
    }
    else {
        File targetFile = new File (sourceFile.getAbsolutePath () + ".gz");
        FileInputStream fis = new FileInputStream (sourceFile);
        FileOutputStream fos = new FileOutputStream (targetFile);
        GZIPOutputStream gos = new GZIPOutputStream (new BufferedOutputStream (fos));
        BufferedInputStream bis = new BufferedInputStream (fis, BUFFER_SIZE);
        int count;
        byte data [] = new byte [BUFFER_SIZE];
        while ((count = bis.read (data, 0, BUFFER_SIZE)) != - 1) {
            gos.write (data, 0, count);
        }
        bis.close ();
        gos.close ();
    }
}


-----Function Pair=134=-----==

public void menuAction (String name) {
    if (name.equals ("Open")) {
        JFileChooser jfc = new JFileChooser ("c:\\");
        jfc.showOpenDialog (null);
        File file = jfc.getSelectedFile ();
        Scanner sc = null;
        try {
            sc = new Scanner (file);
        } catch (FileNotFoundException ex) {
        }
        clear ();
        while (sc.hasNextLine ()) {
            println (sc.nextLine ());
        }
    }
    else if (name.equals ("Save")) {
        JFileChooser jfc = new JFileChooser ("c:\\");
        jfc.showSaveDialog (null);
        File file = jfc.getSelectedFile ();
        PrintStream ps = null;
        try {
            ps = new PrintStream (file);
        } catch (FileNotFoundException ex1) {
        }
        String s = console.getText ();
        ps.print (s);
        ps.close ();
        JOptionPane.showMessageDialog (null, "Output has been saved as\n" + file.getPath (), "File Saved", JOptionPane.DEFAULT_OPTION);
    }
    else if (name.equals ("Close")) {
        System.exit (0);
    }
    else if (name.equals ("Copy Selection")) {
        setClipboard (console.getSelectedText ());
    }
    else if (name.equals ("Copy Input")) {
        setClipboard (sysIn.getText ());
    }
    else if (name.equals ("Paste to Input")) {
        sysIn.setText (getClipboard ());
    }
    else if (name.equals ("Paste to Console")) {
        println (getClipboard ());
    }
    else if (name.equals ("Select All")) {
        console.setSelectionStart (0);
        console.setSelectionEnd (console.getText ().length ());
    }
    else if (name.equals ("Toggle Edit Lock")) {
        editLock = ! editLock;
        setEditLock (editLock);
    }
    else if (name.equals ("Help Me!")) {
        JOptionPane.showMessageDialog (null, "Coming Soon!", "Help", JOptionPane.DEFAULT_OPTION);
    }
    else if (name.equals ("About SC++")) {
        JOptionPane.showMessageDialog (null, "SenezConsole++\nVersion 1.0\n\nby Chris Senez", "SC++", JOptionPane.DEFAULT_OPTION);
    }
    else if (name.equals ("Contact Senez")) {
        JOptionPane.showMessageDialog (null, "email: csenez64@yahoo.com", "Contact", JOptionPane.DEFAULT_OPTION);
    }
    else if (name.equals ("Submit a Bug")) {
        JOptionPane.showMessageDialog (null, "email: csenez64@yahoo.com\nsubject: sc++ bug report\nmessage: details", "Bugfix", JOptionPane.DEFAULT_OPTION);
    }
}


public synchronized String find (String file, String regExpression, long maximumWaitTime) throws Exception {
    long startTime = System.currentTimeMillis ();
    String foundString = null;
    while (foundString == null) {
        try {
            foundString = this.find (file, regExpression);
        } catch (IOException e) {
            this.logger.fine ("Ignoring the exception '" + e.getMessage () + "' - while finding the regular expression '" + regExpression + "' in file '" + file + "'.");
        }
        if (foundString != null) {
            break;
        }
        long currentTime = System.currentTimeMillis ();
        long lapTime = currentTime - startTime;
        if (lapTime > maximumWaitTime) {
            break;
        }
        try {
            this.wait (500);
        } catch (InterruptedException ie) {
            this.logger.log (Level.WARNING, ie.getMessage (), ie);
        }
    }
    return foundString;
}


-----Function Pair=135=-----==

protected void init () {
    page = new PagePanel ();
    page.setBackground (Color.DARK_GRAY);
    page.addKeyListener (this);
    if (doThumb) {
        split = new JSplitPane (JSplitPane.HORIZONTAL_SPLIT);
        split.addPropertyChangeListener (JSplitPane.DIVIDER_LOCATION_PROPERTY, thumbAction);
        split.setOneTouchExpandable (true);
        thumbs = new ThumbPanel (null);
        thumbscroll = new JScrollPane (thumbs, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
        split.setLeftComponent (thumbscroll);
        split.setRightComponent (page);
        getContentPane ().add (split, BorderLayout.CENTER);
    }
    else {
        getContentPane ().add (page, BorderLayout.CENTER);
    }
    JToolBar toolbar = new JToolBar ();
    toolbar.setFloatable (false);
    JButton jb;
    jb = new JButton (firstAction);
    jb.setText ("");
    toolbar.add (jb);
    jb = new JButton (prevAction);
    jb.setText ("");
    toolbar.add (jb);
    pageField = new JTextField ("-", 3);
    pageField.setMaximumSize (new Dimension (45, 32));
    pageField.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent evt) {
            doPageTyped ();
        }
    }
    );
    toolbar.add (pageField);
    jb = new JButton (nextAction);
    jb.setText ("");
    toolbar.add (jb);
    jb = new JButton (lastAction);
    jb.setText ("");
    toolbar.add (jb);
    toolbar.add (Box.createHorizontalGlue ());
    toolbar.add (Box.createHorizontalGlue ());
    jb = new JButton (printAction);
    jb.setText ("");
    toolbar.add (jb);
    getContentPane ().add (toolbar, BorderLayout.NORTH);
    JMenuBar mb = new JMenuBar ();
    JMenu file = new JMenu ("File");
    file.add (openAction);
    file.addSeparator ();
    file.add (pageSetupAction);
    file.add (printAction);
    file.addSeparator ();
    file.add (quitAction);
    mb.add (file);
    JMenu view = new JMenu ("View");
    JMenu zoom = new JMenu ("Zoom");
    zoom.add (zoomInAction);
    zoom.add (zoomOutAction);
    zoom.add (fitInWindowAction);
    zoom.setEnabled (false);
    view.add (zoom);
    if (doThumb) {
        view.addSeparator ();
        view.add (thumbAction);
    }
    mb.add (view);
    setJMenuBar (mb);
    setEnabling ();
    pack ();
    Dimension screen = Toolkit.getDefaultToolkit ().getScreenSize ();
    int x = (screen.width - getWidth ()) / 2;
    int y = (screen.height - getHeight ()) / 2;
    setLocation (x, y);
    if (SwingUtilities.isEventDispatchThread ()) {
        show ();
    }
    else {
        try {
            SwingUtilities.invokeAndWait (new Runnable () {
                public void run () {
                    show ();
                }
            }
            );
        } catch (InvocationTargetException ie) {
        } catch (InterruptedException ie) {
        }
    }
}


private int getOverlapCount (ScheduleItem item, Vector < ScheduleItem > overlapping) {
    Date start = item.getStart ();
    Date end = item.getStop ();
    DataStore store = DataStore.getInstance ();
    HashMap < String, Channel > channels = store.getChannels ();
    Channel schChannel = channels.get (item.getChannel ());
    String muxString = schChannel.getFrequency () + "-" + schChannel.getBandWidth ();
    Calendar startCal = Calendar.getInstance ();
    startCal.setTime (start);
    Calendar endCal = Calendar.getInstance ();
    endCal.setTime (end);
    int maxOverlap = 0;
    while (startCal.before (endCal)) {
        Calendar span = Calendar.getInstance ();
        span.setTime (startCal.getTime ());
        span.add (Calendar.MINUTE, 1);
        HashMap < String, Integer > muxOverlapCount = new HashMap < String, Integer > ();
        muxOverlapCount.put (muxString, new Integer (1));
        getOverlapsForMin (startCal.getTime (), span.getTime (), muxOverlapCount, overlapping, channels);
        Integer [] count = (Integer []) muxOverlapCount.values ().toArray (new Integer [0]);
        if (maxOverlap < count.length) maxOverlap = count.length;
        startCal.add (Calendar.MINUTE, 1);
    }
    return maxOverlap;
}


-----Function Pair=136=-----==

private void displayPart (MailUserData mud, int msgNum, Part part, int partNum, HttpServletRequest req, ServletOutputStream out) throws IOException {
    if (partNum != 0) out.println ("<p><hr>");
    try {
        String sct = part.getContentType ();
        if (sct == null) {
            out.println ("invalid part");
            return;
        }
        ContentType ct = new ContentType (sct);
        if (partNum != 0) out.println ("<b>Attachment Type:</b> " + ct.getBaseType () + "<br>");
        if (ct.match ("text/plain")) {
            out.println ("<pre>");
            out.println ((String) part.getContent ());
            out.println ("</pre>");
        }
        else {
            String s;
            if ((s = part.getFileName ()) != null) out.println ("<b>Filename:</b> " + s + "<br>");
            s = null;
            if ((s = part.getDescription ()) != null) out.println ("<b>Description:</b> " + s + "<br>");
            out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + msgNum + "&part=" + partNum + "\">Display Attachment</a>");
        }
    } catch (MessagingException mex) {
        out.println (mex.toString ());
    }
}


boolean measure (int mode) {
    ImagePlus imp = getImage ();
    if (imp == null) return false;
    int [] indexes = list.getSelectedIndexes ();
    if (indexes.length == 0) indexes = getAllIndexes ();
    if (indexes.length == 0) return false;
    boolean allSliceOne = true;
    for (int i = 0; i < indexes.length; i ++) {
        String label = list.getItem (indexes [i]);
        Roi roi = (Roi) rois.get (label);
        if (getSliceNumber (roi, label) > 1) allSliceOne = false;
    }
    int measurements = Analyzer.getMeasurements ();
    if (imp.getStackSize () > 1) Analyzer.setMeasurements (measurements | Measurements.SLICE);
    int currentSlice = imp.getCurrentSlice ();
    for (int i = 0; i < indexes.length; i ++) {
        if (restore (getImage (), indexes [i], ! allSliceOne)) IJ.run ("Measure");
        else break;
    }
    imp.setSlice (currentSlice);
    Analyzer.setMeasurements (measurements);
    if (indexes.length > 1) IJ.run ("Select None");
    if (record ()) Recorder.record ("roiManager", "Measure");
    return true;
}


-----Function Pair=137=-----==

public void doListInstruction (String command, String [] args) {
    int count;
    int addr = - 1;
    try {
        switch (args.length) {
            case 0 :
                addr = user.reg.currentIP ();
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            case 1 :
                addr = parseHex32 (args [0]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, 10));
                break;
            default :
                addr = parseHex32 (args [0]);
                count = Integer.parseInt (args [1]);
                jdp_console.writeOutput (user.mem.listInstruction (addr, count));
                break;
        }
    } catch (NumberFormatException e) {
        jdp_console.writeOutput ("bad address: " + args [0]);
    }
}


public static void execute1 () throws IOException, InterruptedException {
    ProcessBuilder pb = new ProcessBuilder ("myCommand", "myArg1", "myArg2");
    Map < String, String > env = pb.environment ();
    env.put ("VAR1", "myValue");
    env.remove ("OTHERVAR");
    env.put ("VAR2", env.get ("VAR1") + "suffix");
    pb.directory (new File ("myDir"));
    File log = new File ("log");
    pb.redirectErrorStream (true);
    pb.redirectOutput (Redirect.appendTo (log));
    Process p = pb.start ();
    p.waitFor ();
    p.destroy ();
}


-----Function Pair=138=-----==

public void init (ServletConfig config) throws ServletException {
    super.init (config);
    try {
        String keyStorePath = getInitParameter (config, INIT_PARAM_JARSIGNERPATH);
        char [] keyStorePasswd = config.getInitParameter (INIT_PARAM_JARSIGNERPASSWD).toCharArray ();
        String alias = config.getInitParameter (INIT_PARAM_JARSIGNERALIAS);
        application = getInitParameter (INIT_PARAM_APPLICATION);
        uRLPrefix = ("/htmf/" + application + "/").length ();
        KeyStore ks = KeyStore.getInstance ("JKS");
        ks.load (new FileInputStream (keyStorePath), keyStorePasswd);
        if (! ks.containsAlias (alias)) {
            log.error ("Error alias '" + alias + "' doesn't exist in jar signer keystore: " + keyStorePath);
        }
        jarSigner = new JarSigner (ks, alias, keyStorePasswd);
    } catch (Exception e) {
        log.error ("Error configuring GenHTMFPackageServlet, message: " + e.getMessage (), e);
    }
}


public boolean loadRegion (String filename) {
    if (new File (filename).exists ()) {
        try {
            FileInputStream fis = new FileInputStream (filename);
            BufferedInputStream bis = new BufferedInputStream (fis);
            ObjectInputStream ois = new ObjectInputStream (bis);
            shapesreference = (ShapesReference) ois.readObject ();
            singleLookup = (String []) ois.readObject ();
            singleColumn = (short []) ois.readObject ();
            ois.close ();
            return true;
        } catch (Exception e) {
        }
    }
    return false;
}


-----Function Pair=139=-----==

public static final ArrayList < String > zipFind (String zipfile, String name, boolean endTest) {
    ArrayList < String > result = new ArrayList < String > ();
    String filter = (name != null ? name.toUpperCase () : null);
    try {
        InputStream in = new BufferedInputStream (new FileInputStream (zipfile));
        ZipInputStream zin = new ZipInputStream (in);
        ZipEntry e;
        while ((e = zin.getNextEntry ()) != null) {
            if (filter == null) {
                result.add (e.getName ());
            }
            else {
                if (endTest) {
                    if (e.getName ().toUpperCase ().endsWith (filter)) result.add (e.getName ());
                }
                else {
                    if (e.getName ().toUpperCase ().indexOf (filter) >= 0) result.add (e.getName ());
                }
            }
        }
        zin.close ();
    } catch (FileNotFoundException e) {
        MLUtil.runtimeError (e, "findZip " + zipfile + " " + name);
    } catch (IOException e) {
        MLUtil.runtimeError (e, "findZip " + zipfile + " " + name);
    }
    return (result);
}


public void run () {
    byte [] data = soundMap.get (effect);
    AudioFormat af = soundFormat.get (effect);
    final CyclicBarrier barrier = new CyclicBarrier (2);
    try {
        Clip c = AudioSystem.getClip ();
        c.open (af, data, 0, data.length);
        FloatControl fc = (FloatControl) c.getControl (FloatControl.Type.MASTER_GAIN);
        if (fc != null) {
            fc.setValue (AudioThread.computeGain (fc, vol));
        }
        LineListener ll = new LineListener () {
            @Override
            public void update (LineEvent event) {
                if (event.getType () == Type.STOP || event.getType () == Type.CLOSE) {
                    try {
                        barrier.await ();
                    } catch (InterruptedException ex) {
                    } catch (BrokenBarrierException ex) {
                    }
                }
            }
        }
        ;
        c.addLineListener (ll);
        c.start ();
        barrier.await ();
        c.removeLineListener (ll);
        c.close ();
    } catch (LineUnavailableException ex) {
        ex.printStackTrace ();
    } catch (InterruptedException ex) {
    } catch (BrokenBarrierException ex) {
    }
}


-----Function Pair=140=-----==

public synchronized boolean exists (String dir, String fileNameAsRegularExpression, long maximumWaitTime) {
    if (dir == null) {
        return false;
    }
    if (fileNameAsRegularExpression == null) {
        return false;
    }
    long startTime = System.currentTimeMillis ();
    boolean hasAppeard = false;
    java.util.regex.Pattern pattern = java.util.regex.Pattern.compile (fileNameAsRegularExpression);
    while (true) {
        File directory = new File (dir);
        File [] files = directory.listFiles ();
        int length = files.length;
        for (int i = 0; i < length; i ++) {
            File file = files [i];
            if (file.isDirectory ()) {
                continue;
            }
            String fileName = file.getName ();
            java.util.regex.Matcher matcher = pattern.matcher (fileName);
            if (matcher.find ()) {
                return true;
            }
            else {
            }
        }
        if (maximumWaitTime <= 0) {
            break;
        }
        long currentTime = System.currentTimeMillis ();
        long lapTime = currentTime - startTime;
        if (lapTime > maximumWaitTime) {
            break;
        }
        try {
            this.wait (500);
        } catch (InterruptedException ie) {
            this.logger.log (Level.WARNING, ie.getMessage (), ie);
        }
    }
    return hasAppeard;
}


public static void init () {
    settings = SettingsManager.settingsManager;
    Thread.currentThread ().setPriority (Thread.MAX_PRIORITY);
    SettingHookGenerator.generateHooks (Misc.class);
    final Thread RSA = new Thread ("RSALoad") {
        public void run () {
            this.setPriority (Thread.MIN_PRIORITY);
            if (! RSAFILE.exists ()) {
                log.info ("No Authentication Key found, generating one");
                RSA key = new RSA (3000);
                if (authKey == null) authKey = key;
                if (! RSAFILE.exists ()) {
                    saveObject (RSAFILE.getAbsolutePath (), authKey);
                    log.info ("New Authentication Key generated and saved");
                }
                else log.info ("Authentication Key not saved because already one here!");
            }
            else authKey = (RSA) Misc.loadObject (RSAFILE.getAbsolutePath ());
        }
    }
    ;
    RSA.start ();
    Setting namesetting = SettingsManager.settingsManager.findSetting ("Name");
    String n = namesetting.getValue ().toString ();
    final AtomicBoolean wizarddone = new AtomicBoolean (false);
    final PropertyChangeListener pcl = new PropertyChangeListener () {
        @Override
        public void propertyChange (PropertyChangeEvent evt) {
            wizarddone.set (true);
        }
    }
    ;
    if (! checkName (n)) {
        if (n.equals ("Unknown")) {
            SwingUtilities.invokeLater (new Runnable () {
                public void run () {
                    FirstTimeWizard ftw = new FirstTimeWizard ();
                    ftw.addPropertyChangeListener (pcl);
                    ftw.startWizard ();
                }
            }
            );
        }
        else {
            BuddyList.askForNewName ("Your name is invalid");
            wizarddone.set (true);
        }
    }
    else wizarddone.set (true);
    if (SettingsManager.settingsManager.findSetting ("defaultSaveFolder").getValue ().toString ().equals ("")) Misc.askForDirectory ();
    try {
        RSA.join ();
        while (! wizarddone.get ()) sleeps (100);
    } catch (InterruptedException e) {
        log.warn ("", e);
    }
    awayManager = new AwayManager ();
    myself = new Contact ("127.0.0.1", namesetting.getValue ().toString (), "9999", authKey.getPublic ());
    Setting s = settings.findSetting ("SettingsXMLVersion");
    if (! s.getValue ().equals (Misc.VERSIONNUMBER)) {
        log.info ("First start on new version {}", Misc.VERSIONNUMBER);
        VersionJump.jumpFrom (s.getValue ().toString (), new SQLConnection ());
        s.setValue (Misc.VERSIONNUMBER);
        SettingsManager.settingsManager.saveToXML (null);
    }
    BuddyList.loadFromXML ();
    settings = SettingsManager.settingsManager;
    if (settings.findSetting ("useDatabaseDebugMode").getOriginalBoolean ()) {
        try {
            Server.createTcpServer (new String [] {"-baseDir", new CFile ("db").getAbsolutePath ()}).start ();
            Server ws = Server.createWebServer (null);
            ws.start ();
            BrowserControl.displayURL (ws.getURL ());
        } catch (SQLException e1) {
            log.warn ("", e1);
        }
    }
    sql = new SQLConnection ();
    othersql = new SQLConnection ("shares");
    loadShares ();
    Thread.currentThread ().setPriority (Thread.NORM_PRIORITY);
}


-----Function Pair=141=-----==

public void insertStringInFile (String file, String textToInsert, long fromByte, long toByte) throws Exception {
    String tmpFile = file + ".tmp";
    BufferedInputStream in = null;
    BufferedOutputStream out = null;
    long byteCount = 0;
    try {
        in = new BufferedInputStream (new FileInputStream (new File (file)));
        out = new BufferedOutputStream (new FileOutputStream (tmpFile));
        long size = fromByte;
        byte [] buf = null;
        if (size == 0) {
        }
        else {
            buf = new byte [(int) size];
            int length = - 1;
            if ((length = in.read (buf)) != - 1) {
                out.write (buf, 0, length);
                byteCount = byteCount + length;
            }
            else {
                String msg = "Failed to read the first '" + size + "' bytes of file '" + file + "'. This might be a programming error.";
                this.logger.warning (msg);
                throw new Exception (msg);
            }
        }
        buf = textToInsert.getBytes ();
        int length = buf.length;
        out.write (buf, 0, length);
        byteCount = byteCount + length;
        long skipLength = toByte - fromByte;
        long skippedBytes = in.skip (skipLength);
        if (skippedBytes == - 1) {
        }
        else {
            buf = new byte [4096];
            length = - 1;
            while ((length = in.read (buf)) != - 1) {
                out.write (buf, 0, length);
                byteCount = byteCount + length;
            }
        }
        in.close ();
        in = null;
        out.close ();
        out = null;
        File fileToDelete = new File (file);
        boolean wasDeleted = fileToDelete.delete ();
        if (! wasDeleted) {
            String msg = "Failed to delete the original file '" + file + "' to replace it with the modified file after text insertion.";
            this.logger.warning (msg);
            throw new Exception (msg);
        }
        File fileToRename = new File (tmpFile);
        boolean wasRenamed = fileToRename.renameTo (fileToDelete);
        if (! wasRenamed) {
            String msg = "Failed to rename tmp file '" + tmpFile + "' to the name of the original file '" + file + "'";
            this.logger.warning (msg);
            throw new Exception (msg);
        }
    } catch (Exception e) {
        this.logger.log (Level.WARNING, "Failed to read/write file '" + file + "'.", e);
        throw e;
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (IOException e) {
                this.logger.log (Level.FINEST, "Ignoring error closing input file '" + file + "'.", e);
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
                this.logger.log (Level.FINEST, "Ignoring error closing output file '" + tmpFile + "'.", e);
            }
        }
    }
}


private static void initSevenZipFromPlatformJARIntern (String platform, File tmpDirectory) throws SevenZipNativeInitializationException {
    try {
        autoInitializationWillOccur = false;
        if (initializationSuccessful) {
            return;
        }
        String pathInJAR = platform;
        if (pathInJAR == null) {
            pathInJAR = getPlatformBestMatch ();
        }
        usedPlatform = pathInJAR;
        pathInJAR = "/" + pathInJAR + "/";
        InputStream sevenZipJBindingLibProperties = SevenZip.class.getResourceAsStream (pathInJAR + SEVENZIPJBINDING_LIB_PROPERTIES_FILENAME);
        if (sevenZipJBindingLibProperties == null) {
            throwInitException ("error loading property file '" + pathInJAR + SEVENZIPJBINDING_LIB_PROPERTIES_FILENAME + "' from a jar-file 'sevenzipjbinding-<Platform>.jar'. Is the platform jar-file not in the class path?");
        }
        Properties properties = new Properties ();
        try {
            properties.load (sevenZipJBindingLibProperties);
        } catch (IOException e) {
            throwInitException ("error loading property file '" + SEVENZIPJBINDING_LIB_PROPERTIES_FILENAME + "' from a jar-file 'sevenzipjbinding-<Platform>.jar'");
        }
        File tmpDirFile;
        if (tmpDirectory != null) {
            tmpDirFile = tmpDirectory;
        }
        else {
            String systemPropertyTmp = System.getProperty (SYSTEM_PROPERTY_TMP);
            if (systemPropertyTmp == null) {
                throwInitException ("can't determinte tmp directory. Use may use -D" + SYSTEM_PROPERTY_TMP + "=<path to tmp dir> parameter for jvm to fix this.");
            }
            tmpDirFile = new File (systemPropertyTmp);
        }
        if (! tmpDirFile.exists () || ! tmpDirFile.isDirectory ()) {
            throwInitException ("invalid tmp directory '" + tmpDirectory + "'");
        }
        if (! tmpDirFile.canWrite ()) {
            throwInitException ("can't create files in '" + tmpDirFile.getAbsolutePath () + "'");
        }
        File tmpSubdirFile = new File (tmpDirFile.getAbsolutePath () + File.separator + "SevenZipJBinding-" + new Random ().nextInt (10000000));
        if (! tmpSubdirFile.mkdir ()) {
            throwInitException ("Directory '" + tmpDirFile.getAbsolutePath () + "' couldn't be created");
        }
        tmpSubdirFile.deleteOnExit ();
        List < File > librariesToInit = new ArrayList < File > (2);
        for (int i = 1;; i ++) {
            String propertyName = String.format (PROPERTY_SEVENZIPJBINDING_LIBNAME, Integer.valueOf (i));
            String libname = properties.getProperty (propertyName);
            if (libname == null) {
                if (librariesToInit.size () == 0) {
                    throwInitException ("property file '" + SEVENZIPJBINDING_LIB_PROPERTIES_FILENAME + "' from a jar-file 'sevenzipjbinding-<Platform>.jar' don't contain the property named '" + propertyName + "'");
                }
                else {
                    break;
                }
            }
            File libTmpFile = new File (tmpSubdirFile.getAbsolutePath () + File.separatorChar + libname);
            libTmpFile.deleteOnExit ();
            InputStream libInputStream = SevenZip.class.getResourceAsStream (pathInJAR + libname);
            if (libInputStream == null) {
                throwInitException ("error loading native library '" + libname + "' from a jar-file 'sevenzipjbinding-<Platform>.jar'.");
            }
            copyLibraryToFS (libTmpFile, libInputStream);
            librariesToInit.add (libTmpFile);
        }
        for (int i = librariesToInit.size () - 1; i != - 1; i --) {
            System.load (librariesToInit.get (i).getAbsolutePath ());
        }
        nativeInitialization ();
    } catch (SevenZipNativeInitializationException sevenZipNativeInitializationException) {
        lastInitializationException = sevenZipNativeInitializationException;
        throw sevenZipNativeInitializationException;
    }
}


-----Function Pair=142=-----==

private void update () {
    if (VERSION.contains ("dev")) return;
    System.out.println (updateURL_s);
    try {
        URL updateURL = new URL (updateURL_s);
        InputStream uis = updateURL.openStream ();
        InputStreamReader uisr = new InputStreamReader (uis);
        BufferedReader ubr = new BufferedReader (uisr);
        String header = ubr.readLine ();
        if (header.equals ("GENREMANUPDATEPAGE")) {
            String cver = ubr.readLine ();
            String cdl = ubr.readLine ();
            if (! cver.equals (VERSION)) {
                System.out.println ("Update available!");
                int i = JOptionPane.showConfirmDialog (this, Language.get ("UPDATE_AVAILABLE_MSG").replaceAll ("%o", VERSION).replaceAll ("%c", cver), Language.get ("UPDATE_AVAILABLE_TITLE"), JOptionPane.YES_NO_OPTION);
                if (i == 0) {
                    URL url = new URL (cdl);
                    HttpURLConnection connection = (HttpURLConnection) url.openConnection ();
                    connection.connect ();
                    if (connection.getResponseCode () / 100 != 2) {
                        throw new Exception ("Server error! Response code: " + connection.getResponseCode ());
                    }
                    int contentLength = connection.getContentLength ();
                    if (contentLength < 1) {
                        throw new Exception ("Invalid content length!");
                    }
                    int size = contentLength;
                    File tempfile = File.createTempFile ("genreman_update", ".zip");
                    tempfile.deleteOnExit ();
                    RandomAccessFile file = new RandomAccessFile (tempfile, "rw");
                    InputStream stream = connection.getInputStream ();
                    int downloaded = 0;
                    ProgressWindow pwin = new ProgressWindow (this, "Downloading");
                    pwin.setVisible (true);
                    pwin.setProgress (0);
                    pwin.setText ("Connecting...");
                    while (downloaded < size) {
                        byte buffer [];
                        if (size - downloaded > 1024) {
                            buffer = new byte [1024];
                        }
                        else {
                            buffer = new byte [size - downloaded];
                        }
                        int read = stream.read (buffer);
                        if (read == - 1) break;
                        file.write (buffer, 0, read);
                        downloaded += read;
                        pwin.setProgress (downloaded / size);
                    }
                    file.close ();
                    System.out.println ("Downloaded file to " + tempfile.getAbsolutePath ());
                    pwin.setVisible (false);
                    pwin.dispose ();
                    pwin = null;
                    ZipInputStream zin = new ZipInputStream (new FileInputStream (tempfile));
                    ZipEntry entry;
                    while ((entry = zin.getNextEntry ()) != null) {
                        File outf = new File (entry.getName ());
                        System.out.println (outf.getAbsoluteFile ());
                        if (outf.exists ()) outf.delete ();
                        OutputStream out = new FileOutputStream (outf);
                        byte [] buf = new byte [1024];
                        int len;
                        while ((len = zin.read (buf)) > 0) {
                            out.write (buf, 0, len);
                        }
                        out.close ();
                    }
                    JOptionPane.showMessageDialog (this, Language.get ("UPDATE_SUCCESS_MSG"), Language.get ("UPDATE_SUCCESS_TITLE"), JOptionPane.INFORMATION_MESSAGE);
                    setVisible (false);
                    if (System.getProperty ("os.name").indexOf ("Windows") != - 1) {
                        Runtime.getRuntime ().exec ("iTunesGenreArtManager.exe");
                    }
                    else {
                        Runtime.getRuntime ().exec ("java -jar \"iTunes Genre Art Manager.app/Contents/Resources/Java/iTunes_Genre_Art_Manager.jar\"");
                    }
                    System.exit (0);
                }
                else {
                }
            }
            ubr.close ();
            uisr.close ();
            uis.close ();
        }
        else {
            while (ubr.ready ()) {
                System.out.println (ubr.readLine ());
            }
            ubr.close ();
            uisr.close ();
            uis.close ();
            throw new Exception ("Update page had invalid header: " + header);
        }
    } catch (Exception ex) {
        JOptionPane.showMessageDialog (this, Language.get ("UPDATE_ERROR_MSG"), Language.get ("UPDATE_ERROR_TITLE"), JOptionPane.ERROR_MESSAGE);
        ex.printStackTrace ();
    }
}


public UpdateReturn updateMod (ArrayList < Mod > mods) {
    ExecutorService pool = Executors.newCachedThreadPool ();
    Iterator < Mod > it = mods.iterator ();
    HashSet < Future < UpdateThread > > temp = new HashSet < Future < UpdateThread > > ();
    while (it.hasNext ()) {
        Mod tempMod = it.next ();
        temp.add (pool.submit (new UpdateThread (tempMod)));
        logger.info ("Started update on: " + tempMod.getName () + " - " + tempMod.getVersion ());
    }
    HashSet < Future < UpdateThread > > result = new HashSet < Future < UpdateThread > > ();
    while (temp.size () != result.size ()) {
        Iterator < Future < UpdateThread > > ite = temp.iterator ();
        while (ite.hasNext ()) {
            Future < UpdateThread > ff = ite.next ();
            if (! result.contains (ff) && ff.isDone ()) {
                result.add (ff);
                int [] ints = new int [2];
                ints [0] = result.size ();
                ints [1] = temp.size ();
                setChanged ();
                notifyObservers (ints);
            }
        }
    }
    Iterator < Future < UpdateThread > > ite = result.iterator ();
    UpdateReturn returnValue = new UpdateReturn ();
    while (ite.hasNext ()) {
        Future < UpdateThread > ff = ite.next ();
        try {
            UpdateThread mod = (UpdateThread) ff.get ();
            File file = mod.getFile ();
            if (file != null) {
                new File (mod.getMod ().getPath ()).setWritable (true);
                FileUtils.copyFile (file, mod.getMod ().getPath ());
                Mod newMod = null;
                String olderVersion = mod.getMod ().getVersion ();
                try {
                    newMod = XML.xmlToMod (new String (ZIP.getFile (file, Mod.MOD_FILENAME)));
                } catch (StreamException ex) {
                    logger.info ("StreamException: Failed to update: " + mod.getMod ().getName (), ex);
                    returnValue.addModFailed (mod.getMod (), ex);
                } catch (ZipException ex) {
                    logger.info ("ZipException: Failed to update: " + mod.getMod ().getName (), ex);
                    returnValue.addModFailed (mod.getMod (), ex);
                }
                if (newMod != null) {
                    newMod.setPath (mod.getMod ().getPath ());
                    Mod oldMod = getMod (mod.getMod ().getName (), olderVersion);
                    boolean wasEnabled = oldMod.isEnabled ();
                    HashSet < Mod > gotDisable = new HashSet < Mod > ();
                    gotDisable.add (oldMod);
                    while (! gotDisable.isEmpty ()) {
                        Iterator < Mod > iter = gotDisable.iterator ();
                        while (iter.hasNext ()) {
                            try {
                                Mod next = iter.next ();
                                disableMod (next);
                                gotDisable.remove (next);
                            } catch (ModEnabledException ex) {
                                Iterator < Pair < String, String > > itera = ex.getDeps ().iterator ();
                                while (itera.hasNext ()) {
                                    Pair < String, String > pair = itera.next ();
                                    if (! gotDisable.contains (getMod (Tuple.get1 (pair), Tuple.get2 (pair)))) {
                                        gotDisable.add (getMod (Tuple.get1 (pair), Tuple.get2 (pair)));
                                    }
                                }
                            }
                        }
                    }
                    oldMod.copy (newMod);
                    if (wasEnabled) {
                        try {
                            enableMod (newMod, false);
                        } catch (Exception ex) {
                            logger.error ("Could not enable mod " + newMod.getName ());
                        }
                    }
                    returnValue.addUpdated (mod.getMod (), olderVersion);
                    logger.info (mod.getMod ().getName () + " was updated to " + newMod.getVersion () + " from " + olderVersion);
                }
            }
            else {
                logger.info (mod.getMod ().getName () + " is up-to-date");
                returnValue.addUpToDate (mod.getMod ());
            }
        } catch (SecurityException ex) {
            logger.info ("Couldn't write on the file.");
        } catch (InterruptedException ex) {
        } catch (ExecutionException ex) {
            try {
                UpdateModException ex2 = (UpdateModException) ex.getCause ();
                logger.info ("Failed to update: " + ex2.getMod ().getName () + " - " + ex2.getCause ().getClass () + " - " + ex2.getCause ().getMessage ());
                returnValue.addModFailed (ex2.getMod (), (Exception) ex2.getCause ());
            } catch (ClassCastException ex3) {
                logger.info (ex.getCause ());
            }
        } catch (FileNotFoundException ex) {
        } catch (IOException ex) {
            logger.error ("Random I/O Exception happened", ex);
        }
    }
    pool.shutdown ();
    return returnValue;
}


-----Function Pair=143=-----==

public void copyDocsApps () {
    System.out.println ("Attempting to pull files using copyDocsApps()");
    try {
        CodeSource src = GWrap_GUI_ClickMe.class.getProtectionDomain ().getCodeSource ();
        if (src != null) {
            docsDirectory = new File (saveDirectory, "Documentation");
            docsDirectory.mkdir ();
            appsDirectory = new File (saveDirectory, "Apps");
            appsDirectory.mkdir ();
            URL jar = src.getLocation ();
            System.out.println ("src jar " + jar.getFile ());
            ZipInputStream zip = new ZipInputStream (jar.openStream ());
            BufferedInputStream bis = new BufferedInputStream (zip);
            ZipEntry ze = null;
            FileOutputStream fos = null;
            DataOutputStream dos = null;
            int count;
            byte data [] = new byte [2048];
            while ((ze = zip.getNextEntry ()) != null) {
                String entryName = ze.getName ();
                if (entryName.startsWith ("Documentation/")) {
                    String trimmedName = entryName.replace ("Documentation/", "");
                    if (trimmedName.length () == 0) continue;
                    fos = new FileOutputStream (new File (docsDirectory, trimmedName));
                }
                else if (entryName.startsWith ("Apps/")) {
                    String trimmedName = entryName.replace ("Apps/", "");
                    if (trimmedName.length () == 0) continue;
                    fos = new FileOutputStream (new File (appsDirectory, trimmedName));
                }
                else fos = null;
                if (fos != null) {
                    dos = new DataOutputStream (new BufferedOutputStream (fos));
                    while ((count = bis.read (data, 0, 2048)) != - 1) dos.write (data, 0, count);
                    dos.close ();
                    fos.close ();
                }
            }
            bis.close ();
            zip.close ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public static void addValidationMessagesToDocxFile (File docxFile, File newDocxFile, Document logDoc) throws ZipException, IOException, BosMemberValidationException, DomException, Exception, XPathExpressionException, FileNotFoundException {
    String [] catalogs = new String [0];
    Document documentDom = null;
    Document commentsDom = null;
    Map < URI, Document > domCache = new HashMap < URI, Document > ();
    BosConstructionOptions bosOptions = new BosConstructionOptions (log, domCache);
    bosOptions.setCatalogs (catalogs);
    ZipFile docxZip = new ZipFile (docxFile);
    ZipComponents zipComponents = new ZipComponents (docxZip);
    ZipComponent documentXml = zipComponents.getEntry (DocxConstants.DOCUMENT_XML_PATH);
    URL commentsTemplateUrl = DocxConstants.class.getResource ("resources/comments.xml");
    Element commentTemplate = Word2DitaValidationHelper.getCommentTemplate (commentsTemplateUrl, bosOptions);
    commentsDom = Word2DitaValidationHelper.getCommentsDom (bosOptions, zipComponents, commentsTemplateUrl);
    documentDom = zipComponents.getDomForZipComponent (bosOptions, DocxConstants.DOCUMENT_XML_PATH);
    addMessagesToDocxXml (logDoc, documentDom, commentsDom, commentTemplate);
    Word2DitaValidationHelper.saveDomToZipComponent (documentDom, documentXml);
    ZipComponent comments = zipComponents.getEntry (DocxConstants.COMMENTS_XML_PATH);
    if (comments == null) {
        comments = zipComponents.createZipComponent (DocxConstants.COMMENTS_XML_PATH);
    }
    Word2DitaValidationHelper.saveDomToZipComponent (commentsDom, zipComponents.getEntry (DocxConstants.COMMENTS_XML_PATH));
    Word2DitaValidationHelper.addCommentFileRelationship (zipComponents, bosOptions);
    Word2DitaValidationHelper.addCommentFileContentType (zipComponents, bosOptions);
    Word2DitaValidationHelper.saveZipComponents (zipComponents, newDocxFile);
}


-----Function Pair=144=-----==

public static void copyJar (JarFile src, JarOutputStream dest) throws IOException {
    Enumeration entries = src.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry zse = (ZipEntry) entries.nextElement ();
        if (zse.getName ().equals ("META-INF/MODULEINFO")) continue;
        if (zse.getName ().equals ("META-INF/")) continue;
        dest.putNextEntry (zse);
        InputStream fis = src.getInputStream (zse);
        byte [] b = new byte [2048];
        int n;
        while ((n = fis.read (b)) != - 1) {
            dest.write (b, 0, n);
        }
    }
}


private void refreshFiles () {
    if (allTemplates != null) {
        IOFileFilter sheetFilter = FileFilterUtils.asFileFilter ((FilenameFilter) exportBox.getSelectedItem ());
        IOFileFilter prefixFilter;
        if (partyBox.isSelected ()) {
            prefixFilter = FileFilterUtils.prefixFileFilter (Constants.PARTY_TEMPLATE_PREFIX);
        }
        else {
            prefixFilter = FileFilterUtils.prefixFileFilter (Constants.CHARACTER_TEMPLATE_PREFIX);
        }
        IOFileFilter filter = FileFilterUtils.and (prefixFilter, sheetFilter);
        List < File > files = FileFilterUtils.filterList (filter, allTemplates);
        URI osPath = new File (ConfigurationSettings.getOutputSheetsDir ()).toURI ();
        Object [] uriList = new Object [files.size ()];
        for (int i = 0; i < uriList.length; i ++) {
            uriList [i] = osPath.relativize (files.get (i).toURI ());
        }
        fileList.setListData (uriList);
    }
}


-----Function Pair=145=-----==

private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Run\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=44&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/RunTaskSmall.png' border='0' alt='Delete' title='Run' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("tasks.deftask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("tasks.pretask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("tasks.starterrortask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("tasks.nodataerrortask"));
    return template.getPageBytes ();
}


private byte [] editTaskPage (HTTPurl urlData) throws Exception {
    PageTemplate template = new PageTemplate (store.getProperty ("path.template").replace ('\\', File.separatorChar) + File.separator + "TaskEdit.html");
    String taskName = urlData.getParameter ("name");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    TaskCommand task = (TaskCommand) tasks.get (taskName);
    if (task != null) {
        template.replaceAll ("$taskName", taskName);
        String command = task.getCommand ();
        command = command.replaceAll ("\"", "&#34;");
        command = command.replaceAll ("<", "&lt;");
        command = command.replaceAll (">", "&gt;");
        template.replaceAll ("$taskCommand", command);
        template.replaceAll ("$taskDelayFor", new Integer (task.getDelay ()).toString ());
        if (task.getAutoRemove ()) template.replaceAll ("$autoRemove", "checked");
        else template.replaceAll ("$autoRemove", "");
        template.replaceAll ("$concurrentTasks", new Integer (task.getConcurrent ()).toString ());
        template.replaceAll ("$timeToNextSchedule", new Integer (task.getTimeToNextSchedule ()).toString ());
        if (task.getWhenNotCapturing ()) template.replaceAll ("$whenNotCapturing", "checked");
        else template.replaceAll ("$whenNotCapturing", "");
    }
    else {
        String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
        return out.getBytes ();
    }
    return template.getPageBytes ();
}


-----Function Pair=146=-----==

public Set < String > getNamesOfSerializedFiles (String documentID) throws IndexException {
    String location = null;
    try {
        location = new File (((URL) parameters.get (Constants.INDEX_LOCATION_URL)).toURI ()).getAbsolutePath ();
    } catch (URISyntaxException use) {
        location = new File (((URL) parameters.get (Constants.INDEX_LOCATION_URL)).getFile ()).getAbsolutePath ();
    }
    Set < String > toReturn = new HashSet < String > ();
    try {
        Term term = new Term (Constants.DOCUMENT_ID, documentID);
        TermQuery tq = new TermQuery (term);
        gate.creole.annic.apache.lucene.search.Searcher searcher = new IndexSearcher (location);
        try {
            Hits luceneHits = searcher.search (tq);
            for (int i = 0; i < luceneHits.length (); i ++) {
                Document luceneDoc = luceneHits.doc (i);
                String documentIdOfSerializedFile = luceneDoc.get (Constants.DOCUMENT_ID_FOR_SERIALIZED_FILE);
                toReturn.add (documentIdOfSerializedFile);
            }
            return toReturn;
        } finally {
            searcher.close ();
        }
    } catch (IOException ioe) {
        throw new IndexException (ioe);
    }
}


private int modifiedFiles (int executionCount) {
    System.out.println (" ");
    if (executionCount == 1) {
        rootFolder1.mkdir ();
        System.out.println ("TestThread: " + executionCount + " -> created folder: " + rootFolder1.getAbsolutePath () + " Expecting to find him as NEW");
    }
    if (executionCount == 2) {
        subFolder1 = new File (rootFolder1, subFolder1Name);
        subFolder1.mkdir ();
        file1 = new File (rootFolder1, file1Name);
        writeTextFile (file1, "contend1");
        System.out.println ("TestThread: " + executionCount + " -> created folder: " + subFolder1.getAbsolutePath () + " and file: " + file1.getAbsolutePath () + " Expecting to find them as NEW");
    }
    if (executionCount == 3) {
        subFolder1.delete ();
        writeTextFile (file1, "other contend");
        file2 = new File (rootFolder1, file2Name);
        writeTextFile (file2, "contend2");
        System.out.println ("TestThread: " + executionCount + " -> folder: " + subFolder1.getAbsolutePath () + " deleted," + " file: " + file1.getAbsolutePath () + " modified," + " file: " + file2.getAbsolutePath () + " created." + " Expecting to find them as such");
    }
    if (executionCount == 4) {
        rootFolder2.mkdir ();
        file5 = new File (rootFolder2, file5Name);
        writeTextFile (file5, "contend5");
        System.out.println ("TestThread: " + executionCount + " -> created folder: " + rootFolder2.getAbsolutePath () + " and file:" + file5.getAbsolutePath () + " Expecting to find them as NEW");
    }
    if (executionCount == 5) {
        subFolder1 = new File (rootFolder1, subFolder1Name);
        subFolder1.mkdir ();
        subFolder2 = new File (subFolder1, subFolder2Name);
        subFolder2.mkdir ();
        subFolder3 = new File (subFolder2, subFolder3Name);
        subFolder3.mkdir ();
        file3 = new File (subFolder3, file3Name);
        writeTextFile (file3, "contend3");
        System.out.println ("TestThread: " + executionCount + " -> created folders: " + subFolder3.getAbsolutePath () + " and file:" + file3.getAbsolutePath () + " Expecting to find them as NEW");
    }
    if (executionCount == 6) {
        writeTextFile (file3, "other contend");
        file4 = new File (subFolder3, file4Name);
        writeTextFile (file4, "contend4");
        System.out.println ("TestThread: " + executionCount + " ->" + " file: " + file3.getAbsolutePath () + " modified" + " file: " + file4.getAbsolutePath () + " created" + " Expecting to find them as such");
    }
    if (executionCount == 7) {
        file6 = new File (subFolder2, file6Name);
        writeTextFile (file6, "contend6");
        System.out.println ("TestThread: " + executionCount + " ->" + " file: " + file6.getAbsolutePath () + " created" + " Expecting to find it as such");
    }
    if (executionCount == 8) {
        writeTextFile (file6, "other contend6");
        System.out.println ("TestThread: " + executionCount + " ->" + " file: " + file6.getAbsolutePath () + " modified" + " Expecting to find it as such");
    }
    if (executionCount == 9) {
        file6.delete ();
        System.out.println ("TestThread: " + executionCount + " ->" + " file: " + file6.getAbsolutePath () + " deleted" + " Expecting to find it as such");
    }
    if (executionCount == 10) {
        deletFileRecursive (rootFolder1);
        deletFileRecursive (rootFolder2);
        System.out.println ("TestThread: " + executionCount + " -> deleted all root folders " + " Expecting to find them as DELETED");
    }
    stopCount = 11;
    if (executionCount == stopCount) {
        System.out.println ("TestThread: " + executionCount + " -> stopping FileMonitor");
        fileMonitor.stop ();
    }
    System.out.println (" ");
    executionCount ++;
    return executionCount;
}


-----Function Pair=147=-----==

public static Bitmap returnBitMap (File cache, Context context) {
    final int imageWidth = context.getResources ().getDisplayMetrics ().widthPixels - 20;
    if (! cache.exists ()) return null;
    BitmapFactory.Options o = new BitmapFactory.Options ();
    o.inJustDecodeBounds = true;
    BitmapFactory.decodeFile (cache.getAbsolutePath (), o);
    if (o.outWidth == - 1) return null;
    int scale = 1;
    if (o.outWidth > imageWidth) {
        scale = o.outWidth / imageWidth;
    }
    BitmapFactory.Options o1 = new BitmapFactory.Options ();
    o1.inSampleSize = scale;
    Bitmap bitmap = BitmapFactory.decodeFile (cache.getAbsolutePath (), o1);
    if (bitmap == null) {
        return null;
    }
    if (bitmap.getWidth () > imageWidth) try {
        return Bitmap.createScaledBitmap (bitmap, imageWidth, imageWidth * bitmap.getHeight () / bitmap.getWidth (), true);
    } finally {
        if (! bitmap.isRecycled ()) bitmap.recycle ();
    }
    else return bitmap;
}


private static void checkArgs (String [] args) {
    Options options = createCommandlineOptions ();
    try {
        CommandLineParser parser = new GnuParser ();
        CommandLine cmd = parser.parse (options, args);
        if (cmd.hasOption (SAFEMODE)) {
            safemode = true;
        }
        if (cmd.hasOption (HELP)) {
            printHelp (options);
            System.exit (0);
        }
        if (cmd.hasOption (SERVER)) {
            String value = cmd.getOptionValue (SERVER);
            String ip = value.substring (0, value.indexOf (OnlineClientData.IP_PORT_SEPARATOR));
            Globals.setServerIP (ip);
            int port = Integer.parseInt (value.substring (value.indexOf (OnlineClientData.IP_PORT_SEPARATOR) + 1));
            Globals.setServerPort (port);
        }
        if (cmd.hasOption (DEBUG)) {
            Globals.enableDebug ();
        }
        if (cmd.hasOption (MULTIPLE_INSTANCES)) {
            multipleInstances = true;
        }
    } catch (ParseException ex) {
        System.out.println (ex.getMessage ());
        System.out.println ();
        printHelp (options);
        System.exit (1);
    }
}


-----Function Pair=148=-----==

public static void main (String...args) throws Exception {
    jtreg = (System.getProperty ("test.src") != null);
    File tmpDir;
    if (jtreg) {
        tmpDir = new File (System.getProperty ("user.dir"));
    }
    else {
        tmpDir = new File (System.getProperty ("java.io.tmpdir"), MessageInfo.class.getName () + (new SimpleDateFormat ("yyMMddHHmmss")).format (new Date ()));
    }
    Example.setTempDir (tmpDir);
    Example.Compiler.factory = new ArgTypeCompilerFactory ();
    MessageInfo mi = new MessageInfo ();
    try {
        if (mi.run (args)) return;
    } finally {
        if (tmpDir.isDirectory () && tmpDir.getName ().startsWith (MessageInfo.class.getName ())) {
            if (clean (tmpDir)) tmpDir.delete ();
        }
    }
    if (jtreg) throw new Exception (mi.errors + " errors occurred");
    else System.exit (1);
}


public static void main (String...args) throws Exception {
    jtreg = (System.getProperty ("test.src") != null);
    File tmpDir;
    if (jtreg) {
        tmpDir = new File (System.getProperty ("user.dir"));
    }
    else {
        tmpDir = new File (System.getProperty ("java.io.tmpdir"), MessageInfo.class.getName () + (new SimpleDateFormat ("yyMMddHHmmss")).format (new Date ()));
    }
    Example.setTempDir (tmpDir);
    Example.Compiler.factory = new ArgTypeCompilerFactory ();
    MessageInfo mi = new MessageInfo ();
    try {
        if (mi.run (args)) return;
    } finally {
        if (tmpDir.isDirectory () && tmpDir.getName ().startsWith (MessageInfo.class.getName ())) {
            if (clean (tmpDir)) tmpDir.delete ();
        }
    }
    if (jtreg) throw new Exception (mi.errors + " errors occurred");
    else System.exit (1);
}


-----Function Pair=149=-----==

public void execute () throws BuildException {
    boolean selfCreatedLock = false;
    validate ();
    try {
        log ("Uploading to: " + getUrl (), ifVerbose ());
        if (this.file == null) {
            Utils.assureExistingCollection (getHttpClient (), getUrl (), this.locktoken);
        }
        if (this.lock && this.locktoken == null) {
            log ("Locking " + getUrl (), ifVerbose ());
            this.locktoken = Utils.lockResource (getHttpClient (), getUrl (), this.lockOwnerInfo, DepthSupport.DEPTH_INFINITY, this.lockTimeout);
            log ("locktoken: " + this.locktoken, Project.MSG_DEBUG);
            selfCreatedLock = true;
        }
        if (this.file != null) {
            if (Utils.collectionExists (getHttpClient (), getUrl ())) {
                setUrl (assureCollectionUrl (getUrl ()));
                uploadFile (this.file.getName (), this.file);
            }
            else {
                if (getUrl ().getURI ().endsWith ("/")) {
                    Utils.assureExistingCollection (getHttpClient (), getUrl (), this.locktoken);
                    uploadFile (this.file.getName (), this.file);
                }
                else {
                    HttpURL targetColl = Utils.createHttpURL (getUrl (), ".");
                    Utils.assureExistingCollection (getHttpClient (), targetColl, this.locktoken);
                    uploadFile (getUrl (), this.file, this.file.getName ());
                }
            }
        }
        else {
            for (int i = 0; i < filesets.size (); i ++) {
                FileSet fileset = (FileSet) filesets.get (i);
                uploadFileSet (fileset);
            }
            for (int i = 0; i < zipfilesets.size (); i ++) {
                ZipFileSet fileset = (ZipFileSet) zipfilesets.get (i);
                uploadZipFileSet (fileset);
            }
        }
        log ("Puted " + this.countWrittenFiles + (this.countWrittenFiles == 1 ? " file" : " files") + " to " + getUrl (), this.countWrittenFiles > 0 ? Project.MSG_INFO : ifVerbose ());
    } catch (IOException e) {
        throw Utils.makeBuildException ("Put error!", e);
    } finally {
        try {
            if (this.locktoken != null && selfCreatedLock) {
                log ("Unlocking " + getUrl (), ifVerbose ());
                Utils.unlockResource (getHttpClient (), getUrl (), this.locktoken);
            }
        } catch (IOException e) {
            throw Utils.makeBuildException ("Can't unlock!", e);
        }
    }
}


private void pickColor (final JTextComponent colorText) {
    int color = Integer.decode ("0x" + colorText.getText ());
    if (colorChooser == null) {
        colorChooser = new JColorChooser ();
    }
    colorChooser.setColor (color);
    JDialog dlg = JColorChooser.createDialog (this, "Pick color", true, colorChooser, new ActionListener () {
        public void actionPerformed (ActionEvent e) {
            int i = colorChooser.getColor ().getRGB () & 0xffffff;
            colorText.setText (Integer.toHexString (i));
        }
    }
    , null);
    dlg.setLocationByPlatform (true);
    dlg.pack ();
    dlg.setVisible (true);
}


-----Function Pair=150=-----==

public void compareTopicXmlContent (FileWriter fw) throws IOException {
    Iterator iter = this.resultPair.entrySet ().iterator ();
    while (iter.hasNext ()) {
        int count = 0;
        Map.Entry entry = (Map.Entry) iter.next ();
        String topicId = (String) entry.getKey ();
        String shot_id = (String) entry.getValue ();
        fw.append (topicId + ' ');
        HashSet < String > words = this.queryWords.get (topicId);
        String xmlcontent = this.xmlContent.get (shot_id);
        if (xmlcontent == null) {
            fw.append ("null file" + '\n');
            continue;
        }
        xmlcontent = xmlcontent.toLowerCase ();
        Iterator it = words.iterator ();
        int termcount = 0;
        while (it.hasNext ()) {
            String queryTerm = (String) it.next ();
            queryTerm = queryTerm.toLowerCase ();
            Pattern pattern = Pattern.compile (' ' + queryTerm + ' ');
            if (queryTerm.length () == 0) {
                System.out.println ("query term is null" + queryTerm);
                continue;
            }
            System.out.println (xmlcontent);
            Matcher matcher = pattern.matcher (xmlcontent);
            while (matcher.find ()) termcount ++;
            fw.append (queryTerm + " ");
            fw.append (termcount + " ");
            count += termcount;
            termcount = 0;
        }
        fw.append (count + " ");
        fw.append ('\n');
        fw.flush ();
    }
}


private static int bruteforceKzip (String caption, File packFile, File packGzFile, int splitOffset, int splitStep, int steps, int reruns) throws IOException {
    File min = packGzFile;
    File [] dst = new File [steps];
    int minSplit = - 1;
    for (int i = 0; i < dst.length; i ++) {
        dst [i] = new File (packGzFile.getParentFile (), i + "_" + packGzFile.getName ());
        int split = splitOffset + i * splitStep;
        for (int k = 0; k < reruns; k ++) {
            if (kzip_deflopt_gz (caption, packFile, dst [i], split, k != 0)) {
                if (dst [i].length () != 0 && ((min == null || min.length () == 0) || dst [i].length () < min.length ())) {
                    min = dst [i];
                    minSplit = split;
                }
            }
        }
    }
    if (minSplit != - 1) {
        FileUtil.copyFile (min, packGzFile);
    }
    for (int i = 0; i < dst.length; i ++) {
        dst [i].delete ();
    }
    return minSplit;
}


-----Function Pair=151=-----==

static SubtitleDataBase.CreateAccountResponse osdbUserAdd (String user, String pass, String email) throws IOException, TimeoutException, InterruptedException {
    if (user.matches ("^[a-zA-Z0-9_-]{3,20}$") == false) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_BAD_LOGIN;
    }
    if (pass.equals ("")) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_BAD_PASS;
    }
    if (email.matches ("^[a-zA-Z0-9\\-\\_]{1,30}@[a-zA-Z0-9]+(\\.[a-zA-Z0-9]+)+$") == false) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_BAD_EMAIL;
    }
    URLConnection conn = null;
    ClientHttpRequest httpPost = null;
    InputStreamReader responseStream = null;
    URL url = new URL ("http://www.opensubtitles.org/en/newuser");
    String response = "";
    String line;
    conn = url.openConnection (Global.getProxy ());
    httpPost = new ClientHttpRequest (conn);
    httpPost.setParameter ("email", "");
    httpPost.setParameter ("password", "");
    httpPost.setParameter ("UserNickname", user);
    httpPost.setParameter ("UserMail", email);
    httpPost.setParameter ("UserPassword", pass);
    httpPost.setParameter ("UserPassword2", pass);
    httpPost.setParameter ("Terms", "on");
    httpPost.setParameter ("action", "newuser");
    responseStream = new InputStreamReader (httpPost.post (), "UTF-8");
    BufferedReader responseReader = new BufferedReader (responseStream);
    while ((line = responseReader.readLine ()) != null) {
        response += line;
    }
    int index = response.indexOf ("<div class=\"msg error\">");
    if (index == - 1) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_OK;
    }
    int index2 = response.indexOf ("</div>", index);
    if (index2 == - 1) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_BAD_UNKNOWN;
    }
    response = response.substring (index + 23, index2);
    response = response.replace ("<br />", "\n");
    response = response.replaceAll ("<.{1,4}>", "");
    if (response.indexOf ("is already taken") != - 1) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_LOGIN_EXISTS;
    }
    if (response.indexOf ("is already being used") != - 1) {
        return SubtitleDataBase.CreateAccountResponse.ADD_USER_EMAIL_EXISTS;
    }
    return SubtitleDataBase.CreateAccountResponse.ADD_USER_BAD_UNKNOWN;
}


public void testMarshall () throws JiBXException, SAXException, IOException {
    Permission o = OperationFactory.createPermission ();
    IBindingFactory bfact = BindingDirectory.getFactory (Permission.class);
    IMarshallingContext marshallingContext = bfact.createMarshallingContext ();
    Writer outConsole = new BufferedWriter (new OutputStreamWriter (System.out));
    marshallingContext.setOutput (outConsole);
    marshallingContext.setIndent (3);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
    Writer out = new BufferedWriter (new OutputStreamWriter (outputStream));
    marshallingContext.setIndent (3);
    marshallingContext.setOutput (out);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    InputSource marshallingResult = new InputSource (new ByteArrayInputStream (outputStream.toByteArray ()));
    FileInputStream fis = new FileInputStream (new File ("src/test/resources/PermissionTestData.xml"));
    InputSource expectedResult = new InputSource (fis);
    DifferenceListener differenceListener = new IgnoreTextAndAttributeValuesDifferenceListener ();
    Diff diff = new Diff (expectedResult, marshallingResult);
    diff.overrideDifferenceListener (differenceListener);
    assertTrue ("Marshalled OperationAllowed matches expected XML " + diff, diff.similar ());
}


-----Function Pair=152=-----==

private OpenRolapResultSet getResultSetSingle () {
    String sql = new String ();
    if (detail_direct) {
        System.out.println ("test10.java, 280: " + "detail_direct set true, going to detail table.");
        sql = new String (getDetailQuery ());
        orrs.detail_query = new Boolean (true);
        selected_table_name = getDetailTableName ();
        orrs.sql_statements.add (sql);
    }
    else if (fpm.getFilterPathSize () == 0) {
        sql = "select * from ora_cardinalities";
        selected_table_name = "ora_cardinalities";
        orrs.sql_statements.add (sql);
    }
    else if (fpm.getFilterPathSize () == 1) {
        FilterPathLevel fpl = fpm.getFilterPathLevel (0);
        if (fpl.getCurrentDimValue () == null) {
            sql = "select * from L1_" + fpl.dim_name + " order by " + fpl.dim_name;
        }
        else {
            sql = "select * from L1_" + fpl.dim_name + " where " + fpl.dim_name + " = '" + fpl.getCurrentDimValue () + "'";
        }
        selected_table_name = "L1_" + fpl.dim_name;
        orrs.sql_statements.add (sql);
    }
    else if (fpm.getFilterPathSize () == 2) {
        FilterPathLevel fpl1 = fpm.getFilterPathLevel (0);
        FilterPathLevel fpl2 = fpm.getFilterPathLevel (1);
        int row_count = getRowCount ("select * from L1_" + fpl1.dim_name + " where " + fpl1.dim_name + "='" + fpl1.getCurrentDimValue () + "'");
        if (row_count > getGlobalRowLimit ()) {
            System.out.println ("test10.java, 328: " + "row_count above row limit, going to L2 table.");
            if (fpl2.getCurrentDimValue () == null) {
                sql = "select * from L2_" + fpl1.dim_name + "_" + fpl2.dim_name + " " + "where " + fpl1.dim_name + "='" + fpl1.getCurrentDimValue () + "' " + "order by " + fpl2.dim_name;
            }
            else {
                sql = "select * from L2_" + fpl1.dim_name + "_" + fpl2.dim_name + " " + "where " + fpl1.dim_name + "='" + fpl1.getCurrentDimValue () + "' " + "and " + fpl2.dim_name + "='" + fpl2.getCurrentDimValue () + "'";
            }
            selected_table_name = "L2_" + fpl1.dim_name + "_" + fpl2.dim_name;
        }
        else {
            System.out.println ("test10.java, 345: " + "row_count less than row limit, going to detail table.");
            sql = new String (getDetailQuery ());
            orrs.detail_query = new Boolean (true);
            selected_table_name = getDetailTableName ();
        }
        orrs.sql_statements.add (sql);
    }
    else if (fpm.getFilterPathSize () >= 3) {
        orrs = deepQuery (orrs, 1);
    }
    else {
        System.out.println ("test10.java, 359: " + "empty else");
    }
    return orrs;
}


static void createStatements (Map map, String basename) throws Exception {
    FileOutputStream sqlFile;
    String [] createStrings;
    String url = "jdbc:postgresql:sports?user=nobody&password=PASSWORD", driver = "org.postgresql.Driver";
    Connection conn;
    Class.forName (driver);
    conn = DriverManager.getConnection (url);
    map.setConnection (conn);
    sqlFile = new FileOutputStream (basename + ".sql");
    createStrings = map.getCreateTableStrings ();
    for (int i = 0; i < createStrings.length; i ++) {
        sqlFile.write (createStrings [i].getBytes ());
        sqlFile.write (RETURN);
    }
    sqlFile.close ();
}


-----Function Pair=153=-----==

public Player reorderPlayersByCash (boolean ascending) {
    final boolean _ascending = ascending;
    List < Player > reorderedPlayers = new ArrayList < Player > (players.viewList ());
    Collections.sort (reorderedPlayers, new Comparator < Player > () {
        public int compare (Player p1, Player p2) {
            return _ascending ? p1.getCash () - p2.getCash () : p2.getCash () - p1.getCash ();
        }
    }
    );
    players.clear ();
    Player player;
    for (int i = 0; i < reorderedPlayers.size (); i ++) {
        player = reorderedPlayers.get (i);
        players.add (player);
        player.setIndex (i);
        playerNameModels [i].set (player.getName ());
        log.debug ("New player " + i + " is " + player.getName () + " (cash=" + Bank.format (player.getCash ()) + ")");
    }
    return this.players.get (0);
}


private final String postLogic (int index) {
    log.info ("(" + index + ") " + p_po);
    if (! m_ass [index].isSuspenseBalancing () && ! isBalanced ()) return STATUS_NotBalanced;
    if (! isConvertible (m_ass [index])) return STATUS_NotConvertible;
    if (! isPeriodOpen ()) return STATUS_PeriodClosed;
    ArrayList < Fact > facts = createFacts (m_ass [index]);
    if (facts == null) return STATUS_Error;
    String validatorMsg = ModelValidationEngine.get ().fireFactsValidate (m_ass [index], facts, getPO ());
    if (validatorMsg != null) {
        p_Error = validatorMsg;
        return STATUS_Error;
    }
    for (int f = 0; f < facts.size (); f ++) {
        Fact fact = facts.get (f);
        if (fact == null) return STATUS_Error;
        m_fact.add (fact);
        p_Status = STATUS_PostPrepared;
        if (! fact.checkAccounts ()) return STATUS_InvalidAccount;
        if (! fact.distribute ()) return STATUS_Error;
        if (! fact.isSourceBalanced ()) {
            fact.balanceSource ();
            if (! fact.isSourceBalanced ()) return STATUS_NotBalanced;
        }
        if (! fact.isSegmentBalanced ()) {
            fact.balanceSegments ();
            if (! fact.isSegmentBalanced ()) return STATUS_NotBalanced;
        }
        if (! fact.isAcctBalanced ()) {
            fact.balanceAccounting ();
            if (! fact.isAcctBalanced ()) return STATUS_NotBalanced;
        }
    }
    return STATUS_Posted;
}


-----Function Pair=154=-----==

public void resynchro (int [] result) {
    int source1 = result [0];
    int dest1 = result [1];
    int source2 = result [2];
    int dest2 = result [3];
    int delay1 = dest1 - source1;
    int delay2 = dest2 - source2;
    float scale = (float) (delay2 - delay1) / ((float) source2 - (float) source1);
    Trace.trace ("Computed scale : " + scale, Trace.ALGO_PRIORITY);
    Iterator < Subtitle > subtitles = subtitleList.iterator ();
    while (subtitles.hasNext ()) {
        Subtitle subtitle = subtitles.next ();
        int localDelay = Math.round (((float) (subtitle.getStartDate () - source1) * scale) + (float) delay1);
        subtitle.delay (localDelay);
    }
    fileChanged = true;
}


public static < T > T createGetSetBean (final Object o, Class < T > iType) {
    InvocationHandler handler = new InvocationHandler () {
        @Override
        public Object invoke (Object proxy, Method method, Object [] args) throws Throwable {
            String methodName = method.getName ();
            if (methodName.startsWith ("get") || methodName.startsWith ("is")) {
                String pName = methodName.substring (3);
                if (pName.length () >= 1) {
                    Object pValue = o.getClass ().getField (pName).get (o);
                    if (pValue instanceof IReadProperty < ? >) {
                        return ((IReadProperty < ? >) pValue).get ();
                    }
                    return pValue;
                }
            }
            else if (methodName.startsWith ("set")) {
                String pName = methodName.substring (3);
                if (pName.length () >= 1) {
                    Field pField = o.getClass ().getField (pName);
                    if (IWriteProperty.class.isAssignableFrom (pField.getType ())) {
                        ((IWriteProperty < Object >) pField.get (o)).set (args [0]);
                    }
                    else {
                        pField.set (o, args [0]);
                    }
                    return null;
                }
            }
            return o.getClass ().getMethod (method.getName (), method.getParameterTypes ()).invoke (o, args);
        }
    }
    ;
    Class < ? > proxyClass = Proxy.getProxyClass (o.getClass ().getClassLoader (), iType);
    try {
        final T instance = (T) proxyClass.getConstructor (new Class [] {InvocationHandler.class}).newInstance (new Object [] {handler});
        return instance;
    } catch (Throwable e) {
        throw new IllegalArgumentException (e);
    }
}


-----Function Pair=155=-----==

public String getToken () {
    String token;
    int wsIdx;
    int delimIdx;
    int index;
    int length;
    if (input == null) {
        return "";
    }
    length = input.length ();
    for (wsIdx = 0; (wsIdx < length) && (input.charAt (wsIdx) == ' '); wsIdx ++);
    length -= wsIdx;
    input = input.substring (wsIdx);
    wsIdx = input.indexOf (' ');
    delimIdx = input.indexOf (DELIMITER);
    if (delimIdx == 0) {
        input = input.substring (DELIMITER_STR.length ());
        return DELIMITER_STR;
    }
    length = input.length ();
    if (delimIdx == - 1) delimIdx = length;
    if (wsIdx == - 1) wsIdx = length;
    index = Math.min (delimIdx, wsIdx);
    token = input.substring (0, index);
    input = input.substring (index);
    return token;
}


private void buildSheetGrid (EuclideSheet sheet, String sheetToken, Hashtable < String, String > tokens) {
    String gridType = tokens.get (sheetToken.concat ("GridType"));
    if (gridType != null) {
        gridType = gridType.trim ().toLowerCase ();
        Grid2D grid = null;
        if (gridType.equals ("square")) {
            grid = new SquareGridBuilder ().buildGrid (sheetToken, tokens);
        }
        else if (gridType.equals ("triangle")) {
            grid = new TriangleGridBuilder (0).buildGrid (sheetToken, tokens);
        }
        else if (gridType.equals ("triangleupdown")) {
            grid = new TriangleGridBuilder (0).buildGrid (sheetToken, tokens);
        }
        else if (gridType.equals ("triangleleftright")) {
            grid = new TriangleGridBuilder (1).buildGrid (sheetToken, tokens);
        }
        else {
            throw (new RuntimeException (String.format ("Unable to parse grid type: %s", gridType)));
        }
        if (grid != null) sheet.setGrid (grid);
        String line = tokens.get (sheetToken.concat ("GridVisible"));
        if (line != null) {
            line = line.trim ().toLowerCase ();
            sheet.setGridVisible (Boolean.parseBoolean (line));
        }
    }
}


-----Function Pair=156=-----=1=

public void configClassifier (XMLConfiguration config, String section) {
    super.configClassifier (config, section);
    Configuration methodConf = config.configurationAt (section);
    try {
        knnName = CommonUtils.getFromConfIfNotNull (methodConf, "knn", knnName);
        Class c = Class.forName (knnName);
        Constructor [] a = c.getConstructors ();
        for (Constructor con : a) {
            if (con.getParameterTypes ().length == 0) {
                knnModel = (NearestNeighbourSearch) con.newInstance ();
            }
        }
    } catch (Exception e) {
    }
    N = CommonUtils.getIntFromConfIfNotNull (methodConf, "N", N);
}


private SceneGraphObject createNodeFromSuper (String className, Class [] parameterTypes, Object [] parameters) {
    SceneGraphObject ret;
    String tmp = this.getClass ().getName ();
    String superClass = tmp.substring (tmp.indexOf ("state") + 6, tmp.length () - 5);
    Constructor constructor;
    try {
        Class state = Class.forName (superClass);
        constructor = state.getConstructor (parameterTypes);
        ret = (SceneGraphObject) constructor.newInstance (parameters);
    } catch (ClassNotFoundException e1) {
        throw new SGIORuntimeException ("No State class for " + superClass);
    } catch (IllegalAccessException e2) {
        throw new SGIORuntimeException ("Broken State class for " + className + " - IllegalAccess");
    } catch (InstantiationException e3) {
        throw new SGIORuntimeException ("Broken State class for " + className);
    } catch (java.lang.reflect.InvocationTargetException e4) {
        throw new SGIORuntimeException ("InvocationTargetException for " + className);
    } catch (NoSuchMethodException e5) {
        for (int i = 0; i < parameterTypes.length; i ++) System.err.println (parameterTypes [i].getName ());
        System.err.println ("------");
        throw new SGIORuntimeException ("Invalid constructor for " + className);
    }
    return ret;
}


-----Function Pair=157=-----==

public static void openURL (String url) throws IOException {
    System.out.println ("BbrowserLauncher: opening " + url);
    if (! loadedWithoutErrors) {
        throw new IOException ("Exception in finding browser: " + errorMessage);
    }
    Object browser = locateBbrowser ();
    if (browser == null) {
        throw new IOException ("Unable to locate browser: " + errorMessage);
    }
    switch (jvm) {
        case MRJ_2_0 :
            Object aeDesc = null;
            try {
                aeDesc = aeDescConstructor.newInstance (new Object [] {url});
                putParameter.invoke (browser, new Object [] {keyDirectObject, aeDesc});
                sendNoReply.invoke (browser, new Object [] {});
            } catch (InvocationTargetException ite) {
                throw new IOException ("InvocationTargetException while creating AEDesc: " + ite.getMessage ());
            } catch (IllegalAccessException iae) {
                throw new IOException ("IllegalAccessException while building AppleEvent: " + iae.getMessage ());
            } catch (InstantiationException ie) {
                throw new IOException ("InstantiationException while creating AEDesc: " + ie.getMessage ());
            } finally {
                aeDesc = null;
                browser = null;
            }
            break;
        case MRJ_2_1 :
            Runtime.getRuntime ().exec (new String [] {(String) browser, url});
            break;
        case MRJ_3_0 :
            int [] instance = new int [1];
            int result = ICStart (instance, 0);
            if (result == 0) {
                int [] selectionStart = new int [] {0};
                byte [] urlBytes = url.getBytes ();
                int [] selectionEnd = new int [] {urlBytes.length};
                result = ICLaunchURL (instance [0], new byte [] {0}, urlBytes, urlBytes.length, selectionStart, selectionEnd);
                if (result == 0) {
                    ICStop (instance);
                }
                else {
                    throw new IOException ("Unable to launch URL: " + result);
                }
            }
            else {
                throw new IOException ("Unable to create an Internet Config instance: " + result);
            }
            break;
        case MRJ_3_1 :
            try {
                openURL.invoke (null, new Object [] {url});
            } catch (InvocationTargetException ite) {
                throw new IOException ("InvocationTargetException while calling openURL: " + ite.getMessage ());
            } catch (IllegalAccessException iae) {
                throw new IOException ("IllegalAccessException while calling openURL: " + iae.getMessage ());
            }
            break;
        case WINDOWS_NT :
        case WINDOWS_9x :
            Process process = Runtime.getRuntime ().exec (new String [] {(String) browser, FIRST_WINDOWS_PARAMETER, SECOND_WINDOWS_PARAMETER, THIRD_WINDOWS_PARAMETER, '"' + url + '"'});
            try {
                process.waitFor ();
                process.exitValue ();
            } catch (InterruptedException ie) {
                throw new IOException ("InterruptedException while launching browser: " + ie.getMessage ());
            }
            break;
        case OTHER :
            process = Runtime.getRuntime ().exec (new String [] {(String) browser, NETSCAPE_REMOTE_PARAMETER, NETSCAPE_OPEN_PARAMETER_START + url + NETSCAPE_OPEN_PARAMETER_END});
            try {
                int exitCode = process.waitFor ();
                if (exitCode != 0) {
                    Runtime.getRuntime ().exec (new String [] {(String) browser, url});
                }
            } catch (InterruptedException ie) {
                throw new IOException ("InterruptedException while launching browser: " + ie.getMessage ());
            }
            break;
        default :
            Runtime.getRuntime ().exec (new String [] {(String) browser, url});
            break;
    }
}


public Object [] [] getParameterOptions (NakedReference target) {
    Object [] options = (Object []) parameterOptions.execute (domainObject (target));
    if (options == null) {
        return new Object [getParameterCount ()] [];
    }
    Object [] [] array = new Object [options.length] [];
    for (int i = 0; i < options.length; i ++) {
        Object option = options [i];
        if (option == null) {
            continue;
        }
        else if (option.getClass ().isArray ()) {
            Class arrayType = option.getClass ().getComponentType ();
            if (arrayType.isPrimitive ()) {
                if (arrayType == char.class) {
                    array [i] = convertCharToCharaterArray (options [i]);
                }
                else {
                    array [i] = convertPrimitiveToObjectArray (arrayType, options [i]);
                }
            }
            else {
                array [i] = (Object []) option;
            }
        }
        else {
            NakedCollection adapter = NakedObjectsContext.getObjectLoader ().createAdapterForCollection (option, getParameterTypes () [i]);
            Enumeration e = adapter.elements ();
            Object [] optionArray = new Object [adapter.size ()];
            int j = 0;
            while (e.hasMoreElements ()) {
                optionArray [j ++] = ((Naked) e.nextElement ()).getObject ();
            }
            array [i] = optionArray;
        }
    }
    return array;
}


-----Function Pair=158=-----==

private Object createAdaptedEnumerationLiteral (IModelInstanceEnumerationLiteral modelInstanceEnumerationLiteral, Class < ? > typeClass) {
    Object result;
    if (typeClass.isEnum ()) {
        result = null;
        for (Object anEnumConstant : typeClass.getEnumConstants ()) {
            if (anEnumConstant.toString ().equals (modelInstanceEnumerationLiteral.getLiteral ().getName ())) {
                result = anEnumConstant;
                break;
            }
        }
        if (result == null) {
            String msg;
            msg = EcoreModelInstanceTypeMessages.EcoreModelInstance_EnumerationLiteralNotFound;
            msg = NLS.bind (modelInstanceEnumerationLiteral.getLiteral ().getQualifiedName (), "The enumeration literal could not be adapted to any constant of the given Enum class.");
            throw new IllegalArgumentException (msg);
        }
    }
    else {
        List < String > enumerationQualifiedName;
        String enumClassName;
        enumerationQualifiedName = modelInstanceEnumerationLiteral.getLiteral ().getQualifiedNameList ();
        enumerationQualifiedName.remove (enumerationQualifiedName.size () - 1);
        enumClassName = EcoreModelInstanceTypeUtility.toCanonicalName (enumerationQualifiedName);
        try {
            Class < ? > enumClass;
            enumClass = this.loadJavaClass (enumClassName);
            if (enumClass.isEnum ()) {
                result = null;
                for (Object anEnumConstant : enumClass.getEnumConstants ()) {
                    if (anEnumConstant.toString ().equals (modelInstanceEnumerationLiteral.getLiteral ().getName ())) {
                        result = anEnumConstant;
                        break;
                    }
                }
                if (result == null) {
                    String msg;
                    msg = EcoreModelInstanceTypeMessages.EcoreModelInstance_EnumerationLiteralNotFound;
                    msg = NLS.bind (modelInstanceEnumerationLiteral.getLiteral ().getQualifiedName (), "The enumeration literal could not be adapted to any constant of the given Enum class.");
                    throw new IllegalArgumentException (msg);
                }
            }
            else {
                String msg;
                msg = EcoreModelInstanceTypeMessages.EcoreModelInstance_EnumerationLiteralNotFound;
                msg = NLS.bind (modelInstanceEnumerationLiteral.getLiteral ().getQualifiedName (), "The found class " + enumClass + " is not an Enum.");
                throw new IllegalArgumentException (msg);
            }
        } catch (ClassNotFoundException e) {
            String msg;
            msg = EcoreModelInstanceTypeMessages.EcoreModelInstance_EnumerationLiteralNotFound;
            msg = NLS.bind (modelInstanceEnumerationLiteral.getLiteral ().getQualifiedName (), e.getMessage ());
            throw new IllegalArgumentException (msg, e);
        }
    }
    return result;
}


public static int execR (String cmd) {
    try {
        String binR = u2w (rs_home + "/bin/R");
        if (isWin32) {
            binR += ".exe";
            File fin = File.createTempFile ("rboot", ".R");
            File fout = File.createTempFile ("rboot", ".tmp");
            PrintStream p = new PrintStream (new FileOutputStream (fin));
            p.println (cmd);
            p.close ();
            Process rp = Runtime.getRuntime ().exec (new String [] {binR, "CMD", "BATCH", "--no-restore", "--no-save", "--slave", fin.getAbsolutePath (), fout.getAbsolutePath ()});
            int i = rp.waitFor ();
            if (! fin.delete ()) fin.deleteOnExit ();
            if (! fout.delete ()) fout.deleteOnExit ();
            return i;
        }
        else {
            Process rp = Runtime.getRuntime ().exec (new String [] {"/bin/sh", "-c", "echo \"" + cmd + "\" |" + binR + " --no-restore --no-save --slave >/dev/null 2>&1"});
            return rp.waitFor ();
        }
    } catch (Exception e) {
        lastError = e.toString ();
        return - 1;
    }
}


-----Function Pair=159=-----=1=

protected void launchMediaApplication () {
    if (audio_app != null || video_app != null) {
        printLog ("DEBUG: media application is already running", LogLevel.HIGH);
        return;
    }
    SessionDescriptor local_sdp = new SessionDescriptor (call.getLocalSessionDescriptor ());
    String local_media_address = (new Parser (local_sdp.getConnection ().toString ())).skipString ().skipString ().getString ();
    int local_audio_port = 0;
    int local_video_port = 0;
    for (Enumeration < MediaDescriptor > e = local_sdp.getMediaDescriptors ().elements (); e.hasMoreElements ();) {
        MediaField media = ((MediaDescriptor) e.nextElement ()).getMedia ();
        if (media.getMedia ().equals ("audio")) local_audio_port = media.getPort ();
        if (media.getMedia ().equals ("video")) local_video_port = media.getPort ();
    }
    SessionDescriptor remote_sdp = new SessionDescriptor (call.getRemoteSessionDescriptor ());
    String remote_media_address = (new Parser (remote_sdp.getConnection ().toString ())).skipString ().skipString ().getString ();
    int remote_audio_port = 0;
    int remote_video_port = 0;
    for (Enumeration < MediaDescriptor > e = remote_sdp.getMediaDescriptors ().elements (); e.hasMoreElements ();) {
        MediaField media = ((MediaDescriptor) e.nextElement ()).getMedia ();
        if (media.getMedia ().equals ("audio")) remote_audio_port = media.getPort ();
        if (media.getMedia ().equals ("video")) remote_video_port = media.getPort ();
    }
    int dir = 0;
    if (userProfile.recv_only) dir = - 1;
    else if (userProfile.send_only) dir = 1;
    if (((MediaUserAgentProfile) userProfile).audio && local_audio_port != 0 && remote_audio_port != 0) {
        if (((MediaUserAgentProfile) userProfile).use_rat) {
            audio_app = new RATLauncher (((MediaUserAgentProfile) userProfile).bin_rat, local_audio_port, remote_media_address, remote_audio_port, log);
        }
        else if (((MediaUserAgentProfile) userProfile).use_jmf) {
            try {
                Class myclass = Class.forName ("local.ua.JMFAudioLauncher");
                Class [] parameter_types = {java.lang.Integer.TYPE, Class.forName ("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Class.forName ("org.jjsip.tools.Log")};
                Object [] parameters = {new Integer (local_audio_port), remote_media_address, new Integer (remote_audio_port), new Integer (dir), log};
                java.lang.reflect.Constructor constructor = myclass.getConstructor (parameter_types);
                audio_app = (MediaLauncher) constructor.newInstance (parameters);
            } catch (Exception e) {
                printException (e, LogLevel.HIGH);
                printLog ("Error trying to create the JMFAudioLauncher", LogLevel.HIGH);
            }
        }
        if (audio_app == null) {
            String audio_in = null;
            if (userProfile.send_tone) audio_in = JAudioLauncher.TONE;
            else if (userProfile.send_file != null) audio_in = userProfile.send_file;
            String audio_out = null;
            if (userProfile.recv_file != null) audio_out = userProfile.recv_file;
            audio_app = new JAudioLauncher (local_audio_port, remote_media_address, remote_audio_port, dir, audio_in, audio_out, ((MediaUserAgentProfile) userProfile).audio_sample_rate, ((MediaUserAgentProfile) userProfile).audio_sample_size, ((MediaUserAgentProfile) userProfile).audio_frame_size, log);
        }
        audio_app.startMedia ();
    }
    if (((MediaUserAgentProfile) userProfile).video && local_video_port != 0 && remote_video_port != 0) {
        if (((MediaUserAgentProfile) userProfile).use_vic) {
            video_app = new VICLauncher (((MediaUserAgentProfile) userProfile).bin_vic, local_video_port, remote_media_address, remote_video_port, log);
        }
        else if (((MediaUserAgentProfile) userProfile).use_jmf) {
            try {
                Class myclass = Class.forName ("local.ua.JMFVideoLauncher");
                Class [] parameter_types = {java.lang.Integer.TYPE, Class.forName ("java.lang.String"), java.lang.Integer.TYPE, java.lang.Integer.TYPE, Class.forName ("org.jjsip.tools.Log")};
                Object [] parameters = {new Integer (local_video_port), remote_media_address, new Integer (remote_video_port), new Integer (dir), log};
                java.lang.reflect.Constructor constructor = myclass.getConstructor (parameter_types);
                video_app = (MediaLauncher) constructor.newInstance (parameters);
            } catch (Exception e) {
                printException (e, LogLevel.HIGH);
                printLog ("Error trying to create the JMFVideoLauncher", LogLevel.HIGH);
            }
        }
        if (video_app == null) {
            printLog ("No external video application nor JMF has been provided: Video not started", LogLevel.HIGH);
            return;
        }
        video_app.startMedia ();
    }
}


private IGpxCreatable instantiateCreatable (String parms) throws ClassNotFoundException, InstantiationException, IllegalAccessException, SecurityException, NoSuchMethodException, IllegalArgumentException, InvocationTargetException {
    IGpxCreatable object = null;
    String [] parmsArray = parms.split (",");
    String className = parmsArray [0];
    Class objclass = Class.forName (className);
    if (parmsArray.length > 1) {
        Class [] constructTypes = new Class [parmsArray.length - 1];
        Object [] constructVals = new Object [parmsArray.length - 1];
        for (int ii = 1; ii < parmsArray.length; ++ ii) {
            String [] parm = parmsArray [ii].split ("=");
            String constructType = parm [0];
            String constructVal = parm [1];
            constructTypes [ii - 1] = Class.forName (constructType);
            Class [] valConstructorArgs = new Class [1];
            valConstructorArgs [0] = Class.forName ("java.lang.String");
            Constructor objConstructor = constructTypes [ii - 1].getConstructor (valConstructorArgs);
            String [] valStringArr = new String [1];
            valStringArr [0] = constructVal;
            Object obj = objConstructor.newInstance (valStringArr);
            constructVals [ii - 1] = obj;
        }
        Constructor constructor = objclass.getConstructor (constructTypes);
        object = (IGpxCreatable) constructor.newInstance (constructVals);
    }
    else {
        object = (IGpxCreatable) objclass.newInstance ();
        ArgsRequestor argsReq = new ArgsRequestor (mainFrame, className, object);
        object = argsReq.getObject ();
    }
    return object;
}


-----Function Pair=160=-----==

void doSend () {
    String topic = (String) topicC.getSelectedItem ();
    Hashtable props = new Hashtable ();
    for (int i = 0; i < propTable.getRowCount (); i ++) {
        Object key = propTable.getValueAt (i, 0);
        Object val = propTable.getValueAt (i, 1);
        if (key != null && ! "".equals (key)) {
            String name = key.toString ();
            if (val != null) {
                props.put (name, val);
            }
        }
    }
    props.put ("timestamp.generated", new Long (System.currentTimeMillis ()));
    org.osgi.service.event.Event ev = new org.osgi.service.event.Event (topic, props);
    ServiceReference sr = Activator.getBC ().getServiceReference (EventAdmin.class.getName ());
    if (sr != null) {
        try {
            EventAdmin ea = (EventAdmin) Activator.getBC ().getService (sr);
            ea.postEvent (ev);
        } finally {
            Activator.getBC ().ungetService (sr);
        }
    }
}


public Object find (Class type, String fieldName, String fieldValue) {
    Class fieldType = null;
    Object fieldObj = null;
    String methodName = null;
    methodName = "get" + fieldName.substring (0, 1).toUpperCase () + fieldName.substring (1, fieldName.length ());
    System.out.println ("methodName = " + methodName);
    Method m0 = null;
    try {
        m0 = type.getMethod (methodName);
        System.out.println ("methodName from type  = " + m0.getReturnType ());
        fieldType = m0.getReturnType ();
    } catch (Exception e1) {
        e1.printStackTrace ();
    }
    try {
        fieldObj = fieldType.getConstructor (String.class).newInstance (fieldValue);
    } catch (IllegalArgumentException e) {
        e.printStackTrace ();
    } catch (SecurityException e) {
        e.printStackTrace ();
    } catch (InstantiationException e) {
        e.printStackTrace ();
    } catch (IllegalAccessException e) {
        e.printStackTrace ();
    } catch (InvocationTargetException e) {
        e.printStackTrace ();
    } catch (NoSuchMethodException e) {
        e.printStackTrace ();
    }
    Query query = db.query ();
    query.constrain (type);
    query.descend (fieldName).constrain (fieldObj);
    ObjectSet set = query.execute ();
    if (set.size () > 0) return set.get (0);
    else return null;
}


-----Function Pair=161=-----==

private void handlePop (Request request, Response response) throws MessagingException, IOException {
    final String popHost = request.getResourceRef ().getHostDomain ();
    int popPort = request.getResourceRef ().getHostPort ();
    final String path = request.getResourceRef ().getPath ();
    if (popPort == - 1) {
        popPort = request.getProtocol ().getDefaultPort ();
    }
    if ((popHost == null) || (popHost.equals (""))) {
        throw new IllegalArgumentException ("Invalid POP host specified");
    }
    final boolean authenticate = ((getLogin (request) != null) && (getPassword (request) != null));
    final boolean apop = authenticate && (POP_DIGEST.equals (request.getChallengeResponse ().getScheme ()));
    String transport = null;
    if (POP.equals (request.getProtocol ())) {
        transport = "pop3";
    }
    else if (POPS.equals (request.getProtocol ())) {
        transport = "pop3s";
    }
    final Properties props = System.getProperties ();
    props.put ("mail." + transport + ".host", popHost);
    props.put ("mail." + transport + ".port", Integer.toString (popPort));
    props.put ("mail." + transport + ".apop.enable", Boolean.toString (apop));
    boolean updateFolder = false;
    final Session session = Session.getDefaultInstance (props);
    session.setDebug (isDebug ());
    final Store store = session.getStore (transport);
    store.connect (getLogin (request), getPassword (request));
    final POP3Folder inbox = (POP3Folder) store.getFolder ("INBOX");
    inbox.open (Folder.READ_WRITE);
    final FetchProfile profile = new FetchProfile ();
    profile.add (UIDFolder.FetchProfileItem.UID);
    final Message [] messages = inbox.getMessages ();
    inbox.fetch (messages, profile);
    if ((path == null) || path.equals ("") || path.equals ("/")) {
        if (Method.GET.equals (request.getMethod ()) || Method.HEAD.equals (request.getMethod ())) {
            response.setEntity (createRepresentation (messages, inbox));
        }
        else {
            response.setStatus (Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
            response.getAllowedMethods ().add (Method.GET);
            response.getAllowedMethods ().add (Method.HEAD);
        }
    }
    else if (path.startsWith ("/")) {
        final String mailUid = path.substring (1);
        Message message = null;
        for (int i = 0; (message == null) && (i < messages.length); i ++) {
            final String uid = inbox.getUID (messages [i]);
            if (mailUid.equals (uid)) {
                message = messages [i];
            }
        }
        if (message == null) {
            response.setStatus (Status.CLIENT_ERROR_NOT_FOUND, "No message matches the given UID: " + mailUid);
        }
        else {
            if (Method.GET.equals (request.getMethod ()) || Method.HEAD.equals (request.getMethod ())) {
                response.setEntity (createRepresentation (message));
            }
            else if (Method.DELETE.equals (request.getMethod ())) {
                message.setFlag (Flags.Flag.DELETED, true);
                updateFolder = true;
            }
            else {
                response.setStatus (Status.CLIENT_ERROR_METHOD_NOT_ALLOWED);
                response.getAllowedMethods ().add (Method.GET);
                response.getAllowedMethods ().add (Method.HEAD);
                response.getAllowedMethods ().add (Method.DELETE);
            }
        }
    }
    inbox.close (updateFolder);
    store.close ();
}


public JMenuBar createMenus () {
    JMenuItem mi;
    JMenuBar menuBar = new JMenuBar ();
    menuBar.getAccessibleContext ().setAccessibleName (getString ("MenuBar.accessible_description"));
    JMenu fileMenu = (JMenu) menuBar.add (new JMenu (getString ("FileMenu.file_label")));
    fileMenu.setMnemonic (getMnemonic ("FileMenu.file_mnemonic"));
    fileMenu.getAccessibleContext ().setAccessibleDescription (getString ("FileMenu.accessible_description"));
    createMenuItem (fileMenu, "FileMenu.about_label", "FileMenu.about_mnemonic", "FileMenu.about_accessible_description", new AboutAction (this));
    fileMenu.addSeparator ();
    createMenuItem (fileMenu, "FileMenu.open_label", "FileMenu.open_mnemonic", "FileMenu.open_accessible_description", null);
    createMenuItem (fileMenu, "FileMenu.save_label", "FileMenu.save_mnemonic", "FileMenu.save_accessible_description", null);
    createMenuItem (fileMenu, "FileMenu.save_as_label", "FileMenu.save_as_mnemonic", "FileMenu.save_as_accessible_description", null);
    createMenuItem (fileMenu, "FileMenu.save_as_label", "FileMenu.save_as_mnemonic", "FileMenu.save_as_accessible_description", null);
    if (! isApplet ()) {
        fileMenu.addSeparator ();
        createMenuItem (fileMenu, "FileMenu.exit_label", "FileMenu.exit_mnemonic", "FileMenu.exit_accessible_description", new ExitAction (this));
    }
    if (numSSs == 0) {
        lafMenu = (JMenu) menuBar.add (new JMenu (getString ("LafMenu.laf_label")));
        lafMenu.setMnemonic (getMnemonic ("LafMenu.laf_mnemonic"));
        lafMenu.getAccessibleContext ().setAccessibleDescription (getString ("LafMenu.laf_accessible_description"));
        mi = createLafMenuItem (lafMenu, "LafMenu.java_label", "LafMenu.java_mnemonic", "LafMenu.java_accessible_description", metal);
        mi.setSelected (true);
        UIManager.LookAndFeelInfo [] lafInfo = UIManager.getInstalledLookAndFeels ();
        for (int counter = 0; counter < lafInfo.length; counter ++) {
            String className = lafInfo [counter].getClassName ();
            if (className == motif) {
                createLafMenuItem (lafMenu, "LafMenu.motif_label", "LafMenu.motif_mnemonic", "LafMenu.motif_accessible_description", motif);
            }
            else if (className == windows) {
                createLafMenuItem (lafMenu, "LafMenu.windows_label", "LafMenu.windows_mnemonic", "LafMenu.windows_accessible_description", windows);
            }
            else if (className == gtk) {
                createLafMenuItem (lafMenu, "LafMenu.gtk_label", "LafMenu.gtk_mnemonic", "LafMenu.gtk_accessible_description", gtk);
            }
        }
        EasyAccessibilityLookAndFeel.initialize ("EALFConfig.xml");
        JMenuItem mi3 = lafMenu.add (new JMenuItem ("Easy Accessibility Configuration"));
        lafMenuGroup.add (mi3);
        mi3.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                JPanel configPanel = EasyAccessibilityLookAndFeel.getConfigurationPanel ();
                JFrame frame = new JFrame ("Easy Accessibility Configuration");
                frame.add (configPanel);
                frame.pack ();
                frame.setVisible (true);
            }
        }
        );
        themesMenu = (JMenu) menuBar.add (new JMenu (getString ("ThemesMenu.themes_label")));
        themesMenu.setMnemonic (getMnemonic ("ThemesMenu.themes_mnemonic"));
        themesMenu.getAccessibleContext ().setAccessibleDescription (getString ("ThemesMenu.themes_accessible_description"));
        audioMenu = (JMenu) themesMenu.add (new JMenu (getString ("AudioMenu.audio_label")));
        audioMenu.setMnemonic (getMnemonic ("AudioMenu.audio_mnemonic"));
        audioMenu.getAccessibleContext ().setAccessibleDescription (getString ("AudioMenu.audio_accessible_description"));
        createAudioMenuItem (audioMenu, "AudioMenu.on_label", "AudioMenu.on_mnemonic", "AudioMenu.on_accessible_description", new OnAudioAction (this));
        mi = createAudioMenuItem (audioMenu, "AudioMenu.default_label", "AudioMenu.default_mnemonic", "AudioMenu.default_accessible_description", new DefaultAudioAction (this));
        mi.setSelected (true);
        createAudioMenuItem (audioMenu, "AudioMenu.off_label", "AudioMenu.off_mnemonic", "AudioMenu.off_accessible_description", new OffAudioAction (this));
        JMenu fontMenu = (JMenu) themesMenu.add (new JMenu (getString ("FontMenu.fonts_label")));
        fontMenu.setMnemonic (getMnemonic ("FontMenu.fonts_mnemonic"));
        fontMenu.getAccessibleContext ().setAccessibleDescription (getString ("FontMenu.fonts_accessible_description"));
        ButtonGroup fontButtonGroup = new ButtonGroup ();
        mi = createButtonGroupMenuItem (fontMenu, "FontMenu.plain_label", "FontMenu.plain_mnemonic", "FontMenu.plain_accessible_description", new ChangeFontAction (this, true), fontButtonGroup);
        mi.setSelected (true);
        mi = createButtonGroupMenuItem (fontMenu, "FontMenu.bold_label", "FontMenu.bold_mnemonic", "FontMenu.bold_accessible_description", new ChangeFontAction (this, false), fontButtonGroup);
        mi = createThemesMenuItem (themesMenu, "ThemesMenu.ocean_label", "ThemesMenu.ocean_mnemonic", "ThemesMenu.ocean_accessible_description", new OceanTheme ());
        mi.setSelected (true);
        createThemesMenuItem (themesMenu, "ThemesMenu.steel_label", "ThemesMenu.steel_mnemonic", "ThemesMenu.steel_accessible_description", new DefaultMetalTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.aqua_label", "ThemesMenu.aqua_mnemonic", "ThemesMenu.aqua_accessible_description", new AquaTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.charcoal_label", "ThemesMenu.charcoal_mnemonic", "ThemesMenu.charcoal_accessible_description", new CharcoalTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.contrast_label", "ThemesMenu.contrast_mnemonic", "ThemesMenu.contrast_accessible_description", new ContrastTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.emerald_label", "ThemesMenu.emerald_mnemonic", "ThemesMenu.emerald_accessible_description", new EmeraldTheme ());
        createThemesMenuItem (themesMenu, "ThemesMenu.ruby_label", "ThemesMenu.ruby_mnemonic", "ThemesMenu.ruby_accessible_description", new RubyTheme ());
        optionsMenu = (JMenu) menuBar.add (new JMenu (getString ("OptionsMenu.options_label")));
        optionsMenu.setMnemonic (getMnemonic ("OptionsMenu.options_mnemonic"));
        optionsMenu.getAccessibleContext ().setAccessibleDescription (getString ("OptionsMenu.options_accessible_description"));
        mi = createCheckBoxMenuItem (optionsMenu, "OptionsMenu.tooltip_label", "OptionsMenu.tooltip_mnemonic", "OptionsMenu.tooltip_accessible_description", new ToolTipAction ());
        mi.setSelected (true);
        createCheckBoxMenuItem (optionsMenu, "OptionsMenu.dragEnabled_label", "OptionsMenu.dragEnabled_mnemonic", "OptionsMenu.dragEnabled_accessible_description", new DragSupportAction ());
    }
    if (! isApplet ()) {
        GraphicsDevice [] screens = GraphicsEnvironment.getLocalGraphicsEnvironment ().getScreenDevices ();
        if (screens.length > 1) {
            JMenu multiScreenMenu = (JMenu) menuBar.add (new JMenu (getString ("MultiMenu.multi_label")));
            multiScreenMenu.setMnemonic (getMnemonic ("MultiMenu.multi_mnemonic"));
            multiScreenMenu.getAccessibleContext ().setAccessibleDescription (getString ("MultiMenu.multi_accessible_description"));
            createMultiscreenMenuItem (multiScreenMenu, MultiScreenAction.ALL_SCREENS);
            for (int i = 0; i < screens.length; i ++) {
                createMultiscreenMenuItem (multiScreenMenu, i);
            }
        }
    }
    return menuBar;
}


-----Function Pair=162=-----=1=

public static void main (String [] args) throws Exception {
    if (args.length == 0) {
        junit.textui.TestRunner.run (new AllTests ());
    }
    else {
        String s = args [0];
        s = s.replace ('/', '.');
        Class _suiteClass = null;
        try {
            _suiteClass = Class.forName (s);
        } catch (ClassNotFoundException ex) {
        }
        Test t;
        if (_suiteClass != null) {
            if (TestSuite.class.isAssignableFrom (_suiteClass)) {
                t = (TestSuite) _suiteClass.newInstance ();
            }
            else {
                t = new TestSuite (_suiteClass);
            }
        }
        else {
            int i = s.lastIndexOf ('.');
            String _className = s.substring (0, i);
            String _methodName = s.substring (i + 1);
            Class c = Class.forName (_className);
            Class [] ca = {String.class};
            Constructor con = c.getConstructor (ca);
            Object [] oa = {_methodName};
            t = (Test) con.newInstance (oa);
        }
        junit.textui.TestRunner.run (t);
    }
}


private < T > T getApplicationObject (Class < T > interfaceClass, Class < ? extends T > extendedInterfaceClass, Class < ? extends T > extendedInterfaceWrapperClass, Collection < String > classNamesIterator, T defaultObject) {
    T current = defaultObject;
    for (String implClassName : classNamesIterator) {
        Class < ? extends T > implClass = ClassUtils.simpleClassForName (implClassName);
        if (! interfaceClass.isAssignableFrom (implClass)) {
            throw new IllegalArgumentException ("Class " + implClassName + " is no " + interfaceClass.getName ());
        }
        if (current == null) {
            current = (T) ClassUtils.newInstance (implClass);
        }
        else {
            T newCurrent = null;
            try {
                Constructor < ? extends T > delegationConstructor = null;
                if (extendedInterfaceClass != null && extendedInterfaceClass.isAssignableFrom (current.getClass ())) {
                    try {
                        delegationConstructor = implClass.getConstructor (new Class [] {extendedInterfaceClass});
                    } catch (NoSuchMethodException mnfe) {
                    }
                }
                if (delegationConstructor == null) {
                    delegationConstructor = implClass.getConstructor (new Class [] {interfaceClass});
                }
                try {
                    newCurrent = delegationConstructor.newInstance (new Object [] {current});
                } catch (InstantiationException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                } catch (IllegalAccessException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                } catch (InvocationTargetException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                }
            } catch (NoSuchMethodException e) {
                newCurrent = (T) ClassUtils.newInstance (implClass);
            }
            if (extendedInterfaceWrapperClass != null && ! extendedInterfaceClass.isAssignableFrom (newCurrent.getClass ())) {
                try {
                    Constructor < ? extends T > wrapperConstructor = extendedInterfaceWrapperClass.getConstructor (new Class [] {interfaceClass, extendedInterfaceClass});
                    newCurrent = wrapperConstructor.newInstance (new Object [] {newCurrent, current});
                } catch (NoSuchMethodException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                } catch (InstantiationException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                } catch (IllegalAccessException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                } catch (InvocationTargetException e) {
                    log.log (Level.SEVERE, e.getMessage (), e);
                    throw new FacesException (e);
                }
            }
            current = newCurrent;
        }
    }
    return current;
}


-----Function Pair=163=-----==

private static boolean writeResourceByPathAndStream (ServletResponse response, String path, InputStream inputStream) throws IOException {
    if (inputStream != null) {
        OutputStream outputStream = response.getOutputStream ();
        try {
            setupContentType (path, response);
            int size = 0;
            byte buffer [] = new byte [65536];
            while (true) {
                int readCount = inputStream.read (buffer);
                if (readCount >= 0) {
                    outputStream.write (buffer, 0, readCount);
                    size += readCount;
                }
                else {
                    break;
                }
            }
            response.setContentLength (size);
        } finally {
            outputStream.close ();
            inputStream.close ();
        }
        return true;
    }
    else {
        return false;
    }
}


private String getSequenceMemberInfos (Element sequence) throws Wsdl2JsException {
    if (! (sequence.getNamespaceURI ().equals (XMLNS_SCHEMA) && sequence.getLocalName ().equals ("sequence"))) throw new IllegalArgumentException ("Expected sequence declaration element as argument");
    String memberList = "";
    Element [] elems = getSchemaChildren (sequence);
    for (int i = 0; i < elems.length; i ++) {
        Element elem = elems [i];
        if (elem.getLocalName ().equals ("element")) {
            String name = elem.getAttribute ("name");
            String typeInfo = createTypeInfo (elem);
            memberList += "\"" + name + "\"," + typeInfo;
            if (i < elems.length - 1) memberList += ",";
        }
    }
    return memberList;
}


-----Function Pair=164=-----==

private static String execCmd (String cmd) {
    String msg = new String ("");
    boolean cmdOK = true;
    Process proc = null;
    Runtime runtime = Runtime.getRuntime ();
    try {
        proc = runtime.exec (cmd);
        InputStreamReader isrError = new InputStreamReader (proc.getErrorStream ());
        BufferedReader brError = new BufferedReader (isrError);
        String line = null;
        while ((line = brError.readLine ()) != null) {
            System.out.println ("ERROR MSG>" + line);
        }
        InputStreamReader isrOutput = new InputStreamReader (proc.getInputStream ());
        BufferedReader brOutput = new BufferedReader (isrOutput);
        line = null;
        while ((line = brOutput.readLine ()) != null) {
            System.out.println ("OUTPUT>" + line);
        }
        int exitVal = proc.waitFor ();
        System.out.println ("ExitValue: " + exitVal);
    } catch (Exception e) {
        cmdOK = false;
        msg += "Problem executing command: " + cmd + "  DAMN. Exception " + e.toString ();
        System.err.println (msg);
    }
    if (cmdOK) {
        msg += "Command: " + cmd + " OK.";
    }
    return msg;
}


public void run () {
    String command = "featurama -m " + workingDir + "/featurama.params";
    System.out.println (execCmd (command));
    Runtime blastingMachine = Runtime.getRuntime ();
    int availableProcessors = blastingMachine.availableProcessors ();
    String blastParams = "-I -p blastn -a " + availableProcessors + " -i " + workingDir + "/results.fasta";
    String blastParamLine;
    String blastLib;
    try {
        BufferedReader brBlastParams = new BufferedReader (new FileReader (workingDir + "/blast.params"));
        blastParamLine = brBlastParams.readLine ();
        while (blastParamLine != null) {
            if ("blast_library=".equals (blastParamLine.substring (0, 14))) {
                blastLib = blastParamLine.substring (14);
                blastParams += " -d " + blastLib;
            }
            blastParamLine = brBlastParams.readLine ();
        }
        blastParams += " -e " + "1e-4";
    } catch (Exception e) {
        System.err.println ("Problem Reading BLAST params. Exception: " + e.toString ());
    }
    try {
        FileWriter fwOutput = new FileWriter (workingDir + "/blastResults.ml");
        System.out.println (runBlast (blastCmd + " " + blastParams, new BufferedWriter (fwOutput)));
        fwOutput.close ();
    } catch (java.io.IOException e) {
        System.err.println ("Problem running/filtering BLAST: " + e.toString ());
    }
    FileWriter fwOutput = null;
    try {
        fwOutput = new FileWriter (workingDir + "/BioSapOut.xml");
        fwOutput.write ("<?xml version=\"1.0\"?>\n");
        fwOutput.write ("<BioSapRun comments=\"");
    } catch (Exception e) {
        System.err.println ("Problem writing BioSap xml output: " + e.toString ());
    }
    BufferedReader inFile = null;
    String line = null;
    try {
        inFile = new BufferedReader (new FileReader (workingDir + "/comments"));
        line = null;
        line = inFile.readLine ();
        while (line != null) {
            fwOutput.write (line.replace ('"', '\''));
            line = inFile.readLine ();
            if (line != null) {
                fwOutput.write ("\n");
            }
        }
        inFile.close ();
    } catch (Exception e) {
        System.err.println ("WARNING: comments file not found.");
    } finally {
        try {
            fwOutput.write ("\">\n");
            inFile = new BufferedReader (new FileReader (workingDir + "/featurama.ml"));
            while ((line = inFile.readLine ()) != null) {
                fwOutput.write (line + "\n");
            }
            inFile = new BufferedReader (new FileReader (workingDir + "/blastResults.ml"));
            while ((line = inFile.readLine ()) != null) {
                fwOutput.write (line + "\n");
            }
            fwOutput.write ("</BioSapRun>\n");
            fwOutput.flush ();
            fwOutput.close ();
        } catch (Exception ioe) {
            System.err.println ("Problem writing BioSap xml output:" + ioe.toString ());
        }
    }
    command = "load_BioSapOut.pl --quiet " + workingDir + "/BioSapOut.xml ";
    System.out.println (execCmd (command));
    return;
}


-----Function Pair=165=-----=1=

public int runLoad (int requestId, int loadId, int server) throws RemoteException {
    int ret = 0;
    try {
        Process P;
        System.out.println ("LINUX: " + linuxPath + "/Load1 " + requestId);
        System.out.println ("java " + linuxPath + "/LoadId " + requestId);
        if (loadId == 1) P = Runtime.getRuntime ().exec ("cr_run java LoadId " + requestId);
        else P = Runtime.getRuntime ().exec ("cr_run java LoadId " + requestId);
        StringBuffer strBuf = new StringBuffer ();
        String strLine = "";
        String strLine1 = "";
        BufferedReader outCommand = new BufferedReader (new InputStreamReader (P.getInputStream ()));
        while ((strLine = outCommand.readLine ()) != null) {
            strLine1 = strLine;
        }
        P.waitFor ();
        return ret;
    } catch (Exception e) {
        e.printStackTrace ();
        return - 1;
    }
}


public void solve2 (IoSession s, String puzzle) throws Exception {
    long startTime = System.currentTimeMillis ();
    reflash ();
    session = s;
    parsePuzzleInfo (puzzle);
    int offset = startPos;
    searchProc = Runtime.getRuntime ().exec ("cmd /c E:\\workspace\\pushboy\\src\\pusherboy_v1_1.exe " + offset + " -1 " + boardX + " " + blocksNum + " " + boardString);
    isSearchProcRun = true;
    if (stopTag) return;
    BufferedReader ir = new BufferedReader (new InputStreamReader (searchProc.getInputStream ()));
    String rs = ir.readLine ();
    if (rs.compareTo ("") > 0) {
        session.write ("solution:" + rs);
        System.out.println ("collaborator solved,solution:" + rs);
        session.write ("stoped");
    }
    ir.close ();
    long endTime = System.currentTimeMillis ();
    System.out.println ("slove2 timeused: " + (endTime - startTime));
}


-----Function Pair=166=-----=1=

public ArrayList createClassList (String rootClass, ArrayList currentClassList) {
    if (exclude (rootClass)) return currentClassList;
    excludedClasses.add (rootClass);
    int index;
    Element thisElement = null;
    if (useDependenceFile) thisElement = getElementForClass (rootClass);
    if ((thisElement == null) && (useDependenceFile)) {
        thisElement = xmlDepDoc.createElement ("class");
        thisElement.setAttribute ("name", rootClass);
        rootElement.appendChild (thisElement);
        dependencyChanged = true;
    }
    else {
        if (useDependenceFile) {
            NodeList nList = thisElement.getElementsByTagName ("depClass");
            int tmpLen = nList.getLength ();
            for (int i = 0; i < tmpLen; i ++) {
                Element tmpElement = (Element) nList.item (i);
                String depClass = tmpElement.getAttribute ("name");
                index = currentClassList.indexOf (depClass);
                if (index == - 1) {
                    currentClassList = createClassList (depClass, currentClassList);
                }
            }
        }
    }
    if (useReflection) {
        Class thisClass = null;
        try {
            thisClass = Class.forName (rootClass);
        } catch (ClassNotFoundException cnfe) {
        } catch (NoClassDefFoundError ncdfe) {
        }
        if (thisClass != null) {
            Constructor [] cons;
            try {
                cons = thisClass.getDeclaredConstructors ();
                for (int i = 0; i < cons.length; i ++) {
                    Class [] constructorParams = cons [i].getParameterTypes ();
                    for (int j = 0; j < constructorParams.length; j ++) {
                        instNode (thisElement, constructorParams [j].getName ());
                        index = currentClassList.indexOf (constructorParams [j].getName ());
                        if (index == - 1) {
                            currentClassList = createClassList (constructorParams [j].getName (), currentClassList);
                        }
                    }
                }
            } catch (NoClassDefFoundError nce) {
                String message = nce.getMessage ();
                int pos1 = message.lastIndexOf (" ");
                String problemClassName = message.substring (pos1 + 1).replace ('/', '.');
                index = currentClassList.indexOf (problemClassName);
                if (index == - 1) {
                    currentClassList = createClassList (problemClassName, currentClassList);
                }
                instNode (thisElement, problemClassName);
            }
            Method [] methods;
            try {
                methods = thisClass.getDeclaredMethods ();
                for (int i = 0; i < methods.length; i ++) {
                    Class [] params = methods [i].getParameterTypes ();
                    for (int j = 0; j < params.length; j ++) {
                        instNode (thisElement, params [j].getName ());
                        index = currentClassList.indexOf (params [j].getName ());
                        if (index == - 1) {
                            currentClassList = createClassList (params [j].getName (), currentClassList);
                        }
                    }
                    params = methods [i].getExceptionTypes ();
                    for (int j = 0; j < params.length; j ++) {
                        instNode (thisElement, params [j].getName ());
                        index = currentClassList.indexOf (params [j].getName ());
                        if (index == - 1) {
                            currentClassList = createClassList (params [j].getName (), currentClassList);
                        }
                    }
                    Class fieldType = methods [i].getReturnType ();
                    instNode (thisElement, fieldType.getName ());
                    index = currentClassList.indexOf (fieldType.getName ());
                    if (index == - 1) {
                        currentClassList = createClassList (fieldType.getName (), currentClassList);
                    }
                }
            } catch (NoClassDefFoundError nce) {
                String message = nce.getMessage ();
                int pos1 = message.lastIndexOf (" ");
                String problemClassName = message.substring (pos1 + 1).replace ('/', '.');
                index = currentClassList.indexOf (problemClassName);
                if (index == - 1) {
                    currentClassList = createClassList (problemClassName, currentClassList);
                }
                instNode (thisElement, problemClassName);
            }
            Field [] fields;
            try {
                fields = thisClass.getFields ();
                for (int i = 0; i < fields.length; i ++) {
                    Class fieldType = fields [i].getType ();
                    instNode (thisElement, fieldType.getName ());
                    index = currentClassList.indexOf (fieldType.getName ());
                    if (index == - 1) {
                        currentClassList = createClassList (fieldType.getName (), currentClassList);
                    }
                }
            } catch (NoClassDefFoundError nce) {
                String message = nce.getMessage ();
                int pos1 = message.lastIndexOf (" ");
                String problemClassName = message.substring (pos1 + 1).replace ('/', '.');
                index = currentClassList.indexOf (problemClassName);
                if (index == - 1) {
                    currentClassList = createClassList (problemClassName, currentClassList);
                }
                instNode (thisElement, problemClassName);
            }
            Class [] interfaces;
            try {
                interfaces = thisClass.getInterfaces ();
                for (int i = 0; i < interfaces.length; i ++) {
                    instNode (thisElement, interfaces [i].getName ());
                    index = currentClassList.indexOf (interfaces [i].getName ());
                    if (index == - 1) {
                        currentClassList = createClassList (interfaces [i].getName (), currentClassList);
                    }
                }
            } catch (NoClassDefFoundError nce) {
                String message = nce.getMessage ();
                int pos1 = message.lastIndexOf (" ");
                String problemClassName = message.substring (pos1 + 1).replace ('/', '.');
                index = currentClassList.indexOf (problemClassName);
                if (index == - 1) {
                    currentClassList = createClassList (problemClassName, currentClassList);
                }
                instNode (thisElement, problemClassName);
            }
            Class superClass;
            try {
                superClass = thisClass.getSuperclass ();
                if (superClass != null) {
                    instNode (thisElement, superClass.getName ());
                    index = currentClassList.indexOf (superClass.getName ());
                    if (index == - 1) {
                        currentClassList = createClassList (superClass.getName (), currentClassList);
                    }
                }
            } catch (NoClassDefFoundError nce) {
                String message = nce.getMessage ();
                int pos1 = message.lastIndexOf (" ");
                String problemClassName = message.substring (pos1 + 1).replace ('/', '.');
                index = currentClassList.indexOf (problemClassName);
                if (index == - 1) {
                    currentClassList = createClassList (problemClassName, currentClassList);
                }
                instNode (thisElement, problemClassName);
            }
            try {
                Runtime rt = Runtime.getRuntime ();
                String classPath = System.getProperty ("java.class.path");
                String command = "javap -c -b -classpath " + classPath + " " + rootClass;
                Process p = rt.exec (command);
                BufferedReader out = new BufferedReader (new InputStreamReader (p.getInputStream ()));
                String outLine;
                String codeString = new String ();
                while ((outLine = out.readLine ()) != null) {
                    Matcher m = fieldPattern.matcher (outLine);
                    while (m.find ()) {
                        String fieldClassName = (m.group (1)).replace ('/', '.');
                        instNode (thisElement, fieldClassName);
                        index = currentClassList.indexOf (fieldClassName);
                        if (index == - 1) {
                            currentClassList = createClassList (fieldClassName, currentClassList);
                        }
                    }
                    m = methodPattern.matcher (outLine);
                    while (m.find ()) {
                        String fieldClassName = m.group (1);
                        instNode (thisElement, fieldClassName);
                        index = currentClassList.indexOf (fieldClassName);
                        if (index == - 1) {
                            currentClassList = createClassList (fieldClassName, currentClassList);
                        }
                    }
                    m = methodPattern2.matcher (outLine);
                    while (m.find ()) {
                        String methodParameters = m.group (1);
                        Matcher m2 = internalMethodPattern.matcher (methodParameters);
                        while (m2.find ()) {
                            String fieldClassName = (m2.group (1)).replace ('/', '.');
                            instNode (thisElement, fieldClassName);
                            index = currentClassList.indexOf (fieldClassName);
                            if (index == - 1) {
                                currentClassList = createClassList (fieldClassName, currentClassList);
                            }
                        }
                    }
                    m = classPattern.matcher (outLine);
                    while (m.find ()) {
                        String fieldClassName = m.group (1);
                        instNode (thisElement, fieldClassName);
                        index = currentClassList.indexOf (fieldClassName);
                        if (index == - 1) {
                            currentClassList = createClassList (fieldClassName, currentClassList);
                        }
                    }
                }
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
    index = currentClassList.indexOf (rootClass);
    if (index == - 1) {
        currentClassList.add (rootClass);
    }
    excludedClasses.remove (rootClass);
    return currentClassList;
}


protected void doGet (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    response.setContentType ("text/html");
    PrintWriter outPage = response.getWriter ();
    outPage.println ("<html>");
    outPage.println ("<head><title>User Registration</title></head>");
    FileItemFactory factory = new DiskFileItemFactory ();
    ServletFileUpload upload = new ServletFileUpload (factory);
    List items;
    Properties propTransporter = new Properties ();
    Properties propVBE = new Properties ();
    propTransporter.load (this.getClass ().getClassLoader ().getResourceAsStream ("transporter.properties"));
    propVBE.load (new FileInputStream (propTransporter.getProperty ("path") + "vbe.properties"));
    String gramFolder = propTransporter.getProperty ("path") + propTransporter.getProperty ("gramfolder");
    try {
        items = upload.parseRequest ((HttpServletRequest) request);
    } catch (FileUploadException e) {
        outPage.println ("<h2>Error parsing the uploaded file: " + e.getMessage () + "</h2>");
        outPage.println ("</body></html>");
        return;
    }
    String classFileName = null;
    String inFileName = null;
    String propFileName = null;
    String outFileName = null;
    String arguments = null;
    String classpath = null;
    String maxCpuTime = null;
    String maxMem = null;
    boolean stdout = false;
    boolean stderr = false;
    boolean scwLog = false;
    String nombre = null;
    FileItem item = null;
    if (items.size () > 0) {
        for (int x = 0; x < items.size (); x ++) {
            item = (FileItem) items.get (x);
            nombre = item.getFieldName ();
            try {
                if (item.isFormField ()) {
                    String valor = item.getString ("UTF-8");
                    if (valor != null && ! valor.equals ("")) {
                        if (nombre.equals ("arguments")) arguments = new String (valor);
                        else if (nombre.equals ("classpath")) classpath = new String (valor);
                        else if (nombre.equals ("outFile")) outFileName = new String (valor);
                        else if (nombre.equals ("maxCpuTime")) maxCpuTime = new String (valor);
                        else if (nombre.equals ("maxMem")) maxMem = new String (valor);
                        else if (nombre.equals ("stdout")) stdout = true;
                        else if (nombre.equals ("stderr")) stderr = true;
                        else if (nombre.equals ("scwLog")) scwLog = true;
                    }
                }
                else {
                    if (nombre.equals ("classFile")) {
                        classFileName = item.getName ();
                        FileOutputStream out = new FileOutputStream (gramFolder + classFileName);
                        out.write (item.get ());
                        out.close ();
                    }
                    else if (nombre.equals ("inFile")) {
                        inFileName = item.getName ();
                        FileOutputStream out = new FileOutputStream (gramFolder + inFileName);
                        out.write (item.get ());
                        out.close ();
                    }
                    else if (nombre.equals ("PropFile")) {
                        propFileName = item.getName ();
                        FileOutputStream out = new FileOutputStream (gramFolder + propFileName);
                        out.write (item.get ());
                        out.close ();
                    }
                }
            } catch (Exception e) {
                outPage.println ("<h2>Error getting the parameters or the file: " + e.getMessage () + "</h2>");
                outPage.println ("</body></html>");
                return;
            }
        }
        GridTrustJobDescriptor descriptor = new GridTrustJobDescriptor ("mng2.moviquity.com:2811", gramFolder, classFileName, arguments.split (","), classpath, inFileName, propFileName, outFileName, maxCpuTime, maxMem, stdout, stderr, scwLog);
        descriptor.writeToFile (gramFolder + "job.xml");
        String jobDescriptorPath = gramFolder + "job.xml";
        String voCertificatePath = "/var/tmp/pruebasgridtrust/asm35@moviquity.com_MovVO34.pem";
        String proxyCertificatePath = "/var/tmp/pruebasgridtrust/asm35@moviquity.com.pem";
        String command = "/usr/local/gridtrust/globus/bin/globusrun-ws -F http://146.48.96.75:4444/wsrf/services/ManagedJobFactoryService -submit -S -f " + jobDescriptorPath;
        String classPath = new BufferedReader (new FileReader ("/tmp/classpath.txt")).readLine ();
        String [] env = new String [2];
        env [0] = "GLOBUS_LOCATION=/usr/local/gridtrust/globus";
        env [1] = "LD_LIBRARY_PATH=/usr/local/gridtrust/globus/lib/";
        Runtime runtime = Runtime.getRuntime ();
        Process job = runtime.exec (command, env);
        StreamReaderThread errorThread = new StreamReaderThread (job.getErrorStream ());
        errorThread.start ();
        StreamReaderThread outputThread = new StreamReaderThread (job.getInputStream ());
        outputThread.start ();
        try {
            job.waitFor ();
        } catch (Exception e) {
            outPage.println ("Error: " + e.getMessage ());
        }
        try {
            errorThread.join ();
            outputThread.join ();
        } catch (Exception e) {
            outPage.println ("Error: " + e.getMessage ());
        }
        outPage.println (errorThread.getText ());
        outPage.println (outputThread.getText ());
        outPage.println ("</body></html>");
    }
}


-----Function Pair=167=-----==

void calculateDiscoveryRates (int nBioReps, CombinationPair nullhyp) {
    if (proteinList == null) return;
    this.overallFilterPassCount = new double [this.GStatisticCutoffs.size ()] [this.PValueCutoffs.size ()];
    this.nullhypothesisFilterPassCount = new double [this.GStatisticCutoffs.size ()] [this.PValueCutoffs.size ()];
    this.nullhypothesisFilterPassProteins = new Vector < Vector < Vector < Protein > > > ();
    for (int gi = 0; gi < this.GStatisticCutoffs.size (); gi ++) {
        this.nullhypothesisFilterPassProteins.add (new Vector < Vector < Protein > > ());
        for (int pi = 0; pi < this.PValueCutoffs.size (); pi ++) {
            this.nullhypothesisFilterPassProteins.elementAt (gi).add (new Vector < Protein > ());
            this.overallFilterPassCount [gi] [pi] = 0;
            this.nullhypothesisFilterPassCount [gi] [pi] = 0;
        }
    }
    CombinationGenerator combos = new CombinationGenerator (nBioReps);
    int [] groupsCount = new int [nBioReps];
    BitSet [] selections = new BitSet [nBioReps];
    double selectionRate = (double) this.nMaxPermutations / combos.getTotal ().doubleValue ();
    if (selectionRate < 1.0) {
        System.out.println ("Randomly sampling " + Math.round (combos.getTotal ().doubleValue () * selectionRate) + " (" + (int) Math.ceil (selectionRate * 100.0) + "%) of " + combos.getTotal ().intValue () + " data permutations...");
    }
    else {
        System.out.println ("Processing " + combos.getTotal ().intValue () + " data permutations...");
    }
    for (int order = 0; order < nBioReps; order ++) {
        int orderSize = combos.getOrderSize (order);
        selections [order] = new BitSet (orderSize);
        if (selectionRate < 1.0) {
            Random r = new Random (orderSize);
            int nSelect = 1 + (int) ((double) orderSize * selectionRate);
            nSelect = Math.min (nSelect, orderSize);
            for (int i = nSelect; i > 0;) {
                int slot = r.nextInt (orderSize);
                if (! selections [order].get (slot)) {
                    selections [order].set (slot);
                    i --;
                }
            }
        }
        else {
            selections [order].set (0, orderSize);
        }
    }
    double progress = 0;
    int last_pct = 0;
    while (combos.hasMore ()) {
        CombinationPair pair = combos.getNext ();
        int order = pair.getOrder ();
        int pctdone = (int) (100.0 * ++ progress / combos.getTotal ().doubleValue ());
        if (pctdone != last_pct) {
            last_pct = pctdone;
            System.out.print (((last_pct % 5) == 0) ? (last_pct + "%") : ".");
        }
        if (selections [order].get (groupsCount [order] ++)) {
            this.nPermutationsTried ++;
            boolean bNullHyp = pair.equals (nullhyp);
            for (Protein prot : this.proteinList) {
                ProteinPermutation perm = prot.doPermutation (pair);
                if (bNullHyp) {
                    prot.nullHypothesis = perm;
                }
                for (int gi = 0; gi < GStatisticCutoffs.size (); gi ++) {
                    if (perm.getGStatistic () >= GStatisticCutoffs.get (gi)) {
                        for (int pi = PValueCutoffs.size (); pi -- > 0;) {
                            if (perm.getPValue () <= PValueCutoffs.get (pi)) {
                                this.overallFilterPassCount [gi] [pi] ++;
                                if (bNullHyp) {
                                    this.nullhypothesisFilterPassCount [gi] [pi] ++;
                                    this.nullhypothesisFilterPassProteins.elementAt (gi).elementAt (pi).add (prot);
                                }
                            }
                            else {
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
        }
    }
}


void calculateDiscoveryRates (int nBioReps, CombinationPair nullhyp) {
    if (proteinList == null) return;
    this.overallFilterPassCount = new double [this.GStatisticCutoffs.size ()] [this.PValueCutoffs.size ()];
    this.nullhypothesisFilterPassCount = new double [this.GStatisticCutoffs.size ()] [this.PValueCutoffs.size ()];
    this.nullhypothesisFilterPassProteins = new Vector < Vector < Vector < Protein > > > ();
    for (int gi = 0; gi < this.GStatisticCutoffs.size (); gi ++) {
        this.nullhypothesisFilterPassProteins.add (new Vector < Vector < Protein > > ());
        for (int pi = 0; pi < this.PValueCutoffs.size (); pi ++) {
            this.nullhypothesisFilterPassProteins.elementAt (gi).add (new Vector < Protein > ());
            this.overallFilterPassCount [gi] [pi] = 0;
            this.nullhypothesisFilterPassCount [gi] [pi] = 0;
        }
    }
    CombinationGenerator combos = new CombinationGenerator (nBioReps);
    int [] groupsCount = new int [nBioReps];
    BitSet [] selections = new BitSet [nBioReps];
    double selectionRate = (double) this.nMaxPermutations / combos.getTotal ().doubleValue ();
    if (selectionRate < 1.0) {
        System.out.println ("Randomly sampling " + Math.round (combos.getTotal ().doubleValue () * selectionRate) + " (" + (int) Math.ceil (selectionRate * 100.0) + "%) of " + combos.getTotal ().intValue () + " data permutations...");
    }
    else {
        System.out.println ("Processing " + combos.getTotal ().intValue () + " data permutations...");
    }
    for (int order = 0; order < nBioReps; order ++) {
        int orderSize = combos.getOrderSize (order);
        selections [order] = new BitSet (orderSize);
        if (selectionRate < 1.0) {
            Random r = new Random (orderSize);
            int nSelect = 1 + (int) ((double) orderSize * selectionRate);
            nSelect = Math.min (nSelect, orderSize);
            for (int i = nSelect; i > 0;) {
                int slot = r.nextInt (orderSize);
                if (! selections [order].get (slot)) {
                    selections [order].set (slot);
                    i --;
                }
            }
        }
        else {
            selections [order].set (0, orderSize);
        }
    }
    double progress = 0;
    int last_pct = 0;
    while (combos.hasMore ()) {
        CombinationPair pair = combos.getNext ();
        int order = pair.getOrder ();
        int pctdone = (int) (100.0 * ++ progress / combos.getTotal ().doubleValue ());
        if (pctdone != last_pct) {
            last_pct = pctdone;
            System.out.print (((last_pct % 5) == 0) ? (last_pct + "%") : ".");
        }
        if (selections [order].get (groupsCount [order] ++)) {
            this.nPermutationsTried ++;
            boolean bNullHyp = pair.equals (nullhyp);
            for (Protein prot : this.proteinList) {
                ProteinPermutation perm = prot.doPermutation (pair);
                if (bNullHyp) {
                    prot.nullHypothesis = perm;
                }
                for (int gi = 0; gi < GStatisticCutoffs.size (); gi ++) {
                    if (perm.getGStatistic () >= GStatisticCutoffs.get (gi)) {
                        for (int pi = PValueCutoffs.size (); pi -- > 0;) {
                            if (perm.getPValue () <= PValueCutoffs.get (pi)) {
                                this.overallFilterPassCount [gi] [pi] ++;
                                if (bNullHyp) {
                                    this.nullhypothesisFilterPassCount [gi] [pi] ++;
                                    this.nullhypothesisFilterPassProteins.elementAt (gi).elementAt (pi).add (prot);
                                }
                            }
                            else {
                                break;
                            }
                        }
                    }
                    else {
                        break;
                    }
                }
            }
        }
    }
}


-----Function Pair=168=-----==

public static File chooseFileOpen (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showOpenDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


private byte [] remTunerFromList (HTTPurl urlData) throws Exception {
    int tunerIndex = - 1;
    try {
        CaptureDeviceList devList = CaptureDeviceList.getInstance ();
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount ()) {
                devList.remDevice (tunerIndex);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=169=-----==

public boolean delete (URI uri) throws BackupException {
    logger.info ("Deleting backup from storage: uri=" + uri);
    validateUri (uri);
    String fileName = uri.getPath ();
    File specFile = new File (directory, fileName);
    if (logger.isDebugEnabled ()) {
        logger.debug ("Loading storage specification: file=" + specFile.getAbsolutePath ());
    }
    if (! specFile.canRead ()) {
        logger.info ("Backup not found for deletion: uri=" + uri);
        return false;
    }
    TungstenProperties storageProps = this.loadProperties (specFile, "Unable to load storage specification");
    StorageSpecification storageSpec = new StorageSpecification (storageProps);
    File backupFile;
    boolean deletedFile = true;
    for (int i = 0; i < storageSpec.getFilesCount (); i ++) {
        boolean backupFileDeleted;
        backupFile = new File (directory, storageSpec.getFileName (i));
        backupFileDeleted = backupFile.delete ();
        if (! backupFileDeleted) {
            logger.warn ("Unable to delete backup: file=" + backupFile.getAbsolutePath ());
            deletedFile = false;
        }
    }
    boolean deletedSpec = specFile.delete ();
    if (deletedSpec && deletedFile) {
        logger.info ("Deleted backup files successfully: " + uri);
        return true;
    }
    else {
        if (! deletedSpec) logger.warn ("Unable to delete storage specification: file=" + specFile.getAbsolutePath ());
        if (! deletedFile) logger.warn ("Failed to delete some backup files");
        return false;
    }
}


public String zipForDir (File jarnameDir, File zipFile, boolean printProgress, String extension) throws IOException {
    alltargetdirs.clear ();
    getAllTargetFile (jarnameDir);
    String zipnonamaehakorenisubeshi = jarnameDir.getName () + extension;
    ZipOutputStream output = new ZipOutputStream (new FileOutputStream (zipFile));
    int allsize = alltargetdirs.size ();
    for (int i = 0; i < allsize; i ++) {
        File tfile = (File) alltargetdirs.get (i);
        String directparent = tfile.getParentFile ().getName ();
        if (tfile.isDirectory ()) {
        }
        else {
            writeEntry (tfile, output, jarnameDir);
        }
        if (printProgress) {
            System.out.println ("Zip中・・・(" + i + "/" + allsize + ")");
        }
    }
    output.finish ();
    output.close ();
    alltargetdirs.clear ();
    return zipnonamaehakorenisubeshi;
}


-----Function Pair=170=-----==

public void addFile (File file, ZipOutputStream zos) throws IOException {
    if (Thread.currentThread ().isInterrupted ()) return;
    compressStarted (file);
    String enname = file.getAbsolutePath ().substring (archiveRoot.length () + 1);
    ZipEntry en = new ZipEntry (enname);
    CRC32 crc32 = new CRC32 ();
    byte [] chs = new byte [1024];
    FileInputStream fis = new FileInputStream (file);
    int len = 0;
    while ((len = fis.read (chs)) > - 1) crc32.update (chs, 0, len);
    fis.close ();
    en.setSize (file.length ());
    en.setTime (file.lastModified ());
    en.setCrc (crc32.getValue ());
    zos.putNextEntry (en);
    fis = new FileInputStream (file);
    while ((len = fis.read (chs)) > - 1) zos.write (chs, 0, len);
    fis.close ();
    zos.closeEntry ();
    compressComplete (file);
}


public File copyFile (String src) throws IOException {
    doSetup ();
    File srcFile = new File (src);
    File file = new File (dir, srcFile.getName ());
    OutputStream fout = new FileOutputStream (file);
    InputStream in = new FileInputStream (srcFile);
    byte [] buffer = new byte [4000];
    while (true) {
        int n = in.read (buffer);
        if (n < 0) break;
        fout.write (buffer, 0, n);
    }
    fout.close ();
    return file;
}


-----Function Pair=171=-----==

public boolean isAdmin () {
    try {
        Connection conn = getDBConnection ();
        Statement stmt = conn.createStatement ();
        String dbQuery = "SELECT COUNT(A_ID) FROM Admins WHERE U_ID='" + getUID () + "'";
        ResultSet results = stmt.executeQuery (dbQuery);
        if (results.getInt ("COUNT(A_ID)") == 1) return true;
        else return false;
    } catch (SQLException e) {
        System.out.println (e);
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    } catch (InstantiationException e) {
        System.out.println (e);
    } catch (IllegalAccessException e) {
        System.out.println (e);
    }
    return false;
}


public String modifyPassword (User user, String username, String newPass) {
    if (user.getEmail ().equals (GAEConstants.ANONYMOUSE_NAME)) {
        return "Can't modify anonymous user's password!";
    }
    if (user.getEmail ().equals (GAEConstants.ROOT_NAME) || user.getEmail ().equals (username)) {
        User modifyuser = UserManagementService.getUserWithName (username);
        if (null == modifyuser) {
            return GAEConstants.USER_NOTFOUND;
        }
        if (null == newPass) {
            return "New password can't be empty!";
        }
        modifyuser.setPasswd (newPass);
        UserManagementService.saveUser (modifyuser);
        return null;
    }
    return GAEConstants.AUTH_FAILED;
}


-----Function Pair=172=-----==

public pspdiffDialog (TinyWebServer webServer) {
    this.webServer = webServer;
    frame = new JFrame ("Compare Files/Directories");
    frame.setIconImage (java.awt.Toolkit.getDefaultToolkit ().createImage (PSPDiff.class.getResource ("icon32.gif")));
    Box vBox = Box.createVerticalBox ();
    Box hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Original file/directory (optional):"));
    hBox.add (hBox.createHorizontalStrut (150));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileA = new JTextField ());
    dontStretchVertically (fileA);
    hBox.add (browseA = new JButton ("Browse..."));
    browseA.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (new JLabel ("Modified/new file/directory:"));
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    hBox = Box.createHorizontalBox ();
    hBox.add (fileB = new JTextField ());
    dontStretchVertically (fileB);
    hBox.add (browseB = new JButton ("Browse..."));
    browseB.addActionListener (this);
    vBox.add (hBox);
    vBox.add (vBox.createVerticalStrut (5));
    vBox.add (vBox.createVerticalGlue ());
    hBox = Box.createHorizontalBox ();
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (compareButton = new JButton ("Compare"));
    compareButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    hBox.add (closeButton = new JButton ("Close"));
    closeButton.addActionListener (this);
    hBox.add (hBox.createHorizontalGlue ());
    vBox.add (hBox);
    frame.getContentPane ().add (vBox);
    frame.pack ();
    frame.show ();
}


protected void DoAction (String actionString, int tabIndex) {
    if (actionString.equals ("Add Tab")) {
        OptionUI oui = new OptionUI ();
        String result = oui.promptString (_myTabs.getComponentAt (tabIndex >= 0 ? tabIndex : 0), "Enter the name of the tab to add.  Prefer brevity.", "Add New Tab", "");
        if (result == null) return;
        result = result.trim ();
        if (result.length () == 0) return;
        FilterManager.getInstance ().addTab (result);
        return;
    }
    String tabName = _myTabs.getTitleAt (tabIndex);
    if (actionString.charAt (0) == '~') {
        boolean result = FilterManager.getInstance ().toggleField (tabName, actionString.substring (1));
        if (tabToProperties != null) {
            JTabProperties properties = (JTabProperties) tabToProperties.get (tabName);
            if (properties != null) {
                properties.setColumnStatus (actionString.substring (1), result);
            }
        }
    }
    if (actionString.equals ("Properties")) {
        JFrame jf = getFrame (tabName);
        jf.setState (Frame.NORMAL);
        jf.setVisible (true);
    }
    if (actionString.equals ("Export")) {
        JFileChooser jfc = new JFileChooser ();
        jfc.setApproveButtonText ("Export");
        int result = jfc.showSaveDialog (null);
        switch (result) {
            case JFileChooser.APPROVE_OPTION :
                String fname = jfc.getSelectedFile ().getAbsolutePath ();
                if (! FilterManager.getInstance ().exportTab (tabName, fname)) {
                    JOptionPane.showMessageDialog (null, "Could not export tab [" + tabName + "].", "Export error", JOptionPane.PLAIN_MESSAGE);
                }
                return;
            case JFileChooser.ERROR_OPTION :
            case JFileChooser.CANCEL_OPTION :
            default :
                return;
        }
    }
    if (actionString.equals ("Print")) {
        if (tabIndex == - 1) {
            ErrorManagement.logDebug ("Can't print unknown tab, must prompt...");
        }
        else {
            if (! FilterManager.getInstance ().printTab (tabName)) {
                JOptionPane.showMessageDialog (null, "Could not print tab [" + tabName + "].", "Print error", JOptionPane.PLAIN_MESSAGE);
            }
        }
    }
    boolean eraseEntries = false;
    if (actionString.equals ("Tab & All Entries")) {
        eraseEntries = true;
        actionString = "Just Tab";
    }
    if (actionString.equals ("Just Tab")) {
        if (tabIndex == - 1) {
            ErrorManagement.logDebug ("Prompting for Delete...\n");
        }
        else {
            ErrorManagement.logDebug ("Deleting tab [" + tabName + "]...\n");
            if (! FilterManager.getInstance ().deleteTab (tabName, eraseEntries)) {
                JOptionPane.showMessageDialog (null, "Could not delete tab [" + tabName + "].", "Tab deletion error", JOptionPane.PLAIN_MESSAGE);
            }
        }
    }
}


-----Function Pair=173=-----==

public void stateChanged (ChangeEvent e) {
    JSlider slider = (JSlider) e.getSource ();
    int value = slider.getValue ();
    TitledBorder tb = (TitledBorder) slider.getBorder ();
    String s = tb.getTitle ();
    tb.setTitle (s.substring (0, s.indexOf ('=') + 1) + s.valueOf (value));
    if (s.startsWith ("Velocity")) {
        cc.velocity = value;
    }
    else if (s.startsWith ("Pressure")) {
        cc.channel.setChannelPressure (cc.pressure = value);
    }
    else if (s.startsWith ("Bend")) {
        cc.channel.setPitchBend (cc.bend = value);
    }
    else if (s.startsWith ("Reverb")) {
        cc.channel.controlChange (REVERB, cc.reverb = value);
    }
    slider.repaint ();
}


private void originalLabelMouseReleased (java.awt.event.MouseEvent evt) {
    if (treeBtn.isSelected () && ! pickMode) {
        ImageIcon originalimage = (ImageIcon) originalLabel.getIcon ();
        int position = 0;
        BufferedImage oi = (BufferedImage) originalimage.getImage ();
        if (originalLabel.getHeight () - oi.getHeight () > 0) position = (originalLabel.getHeight () - oi.getHeight ()) / 2;
        else position = 0;
        treeSelectionAreaEndX = evt.getX ();
        treeSelectionAreaEndY = evt.getY ();
        pickMode = true;
        trees.add (new TreeNode (treeSelectionAreaStartX, treeSelectionAreaStartY - position, treeSelectionAreaEndX, treeSelectionAreaEndY - position));
        Graphics g = oi.getGraphics ();
        g.setColor (Color.RED);
        drawRectangle (g, treeSelectionAreaStartX, treeSelectionAreaStartY - position, treeSelectionAreaEndX, treeSelectionAreaEndY - position);
        originalLabel.repaint ();
    }
    if (evt.getButton () == evt.BUTTON1) isDrawing = false;
}


-----Function Pair=174=-----==

private void obtenerCarpetasConjuntosSeleccionadas (HashMap < Long, Long > hsmCarpetas, HashMap < Long, Long > hsmConjuntos, Treeitem item) {
    String tipo = (String) item.getAttribute ("tipo");
    if ("CONJUNTO".equals (tipo)) {
        if (! item.isSelected ()) hsmConjuntos.remove ((Long) item.getAttribute ("id"));
        else hsmConjuntos.put ((Long) item.getAttribute ("id"), (Long) item.getAttribute ("id"));
    }
    else {
        if (! item.isSelected ()) hsmCarpetas.remove ((Long) item.getAttribute ("id"));
        else hsmCarpetas.put ((Long) item.getAttribute ("id"), (Long) item.getAttribute ("id"));
    }
    if (item.getChildren () != null) {
        List items = item.getChildren ();
        for (Object objItem : items) {
            if (objItem instanceof Treeitem) {
                obtenerCarpetasConjuntosSeleccionadas (hsmCarpetas, hsmConjuntos, (Treeitem) objItem);
            }
        }
    }
}


public static boolean fileExists (File zip, String fileName) throws ZipException, IOException {
    String filename = fileName;
    if (! zip.exists ()) {
        return false;
    }
    while (filename.charAt (0) == '/') {
        filename = filename.substring (1);
    }
    if (filename.contains ("\\")) {
        filename = filename.replace ("\\", "/");
    }
    ZipFile zipFile = new ZipFile (zip);
    Enumeration entries = zipFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.getName ().equalsIgnoreCase (filename)) {
            return true;
        }
    }
    return false;
}


-----Function Pair=175=-----==

public static InputStream getZipEntry (String zipFile, String zipEntry) {
    try {
        ZipInputStream zis = new ZipInputStream (new FileInputStream (zipFile));
        ZipEntry entry;
        while ((entry = zis.getNextEntry ()) != null) {
            if (entry.getName ().equals (zipEntry)) {
                InputStream instream = deflate (zis, entry);
                zis.close ();
                return instream;
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return null;
}


public void addToODF (ZipOutputStream zo) throws IOException, ZipException, BarcodeException {
    ZipEntry ze = new ZipEntry ("Pictures/" + getImageName ());
    zo.putNextEntry (ze);
    if (isBarcode ()) {
        Barcoder barcode = Barcoder.buildBarcoder (barcodeType);
        barcode.setValue (barcodeValue);
        barcode.setImageWidth (width);
        barcode.setImageHeight (height);
        barcode.setIncludeCaption (includeCaption);
        barcode.setCheckDigit (checkDigit);
        BarcoderImage bcimage = new BarcoderImage (barcode);
        bcimage.sendGifTo (zo);
    }
    else {
        FileInputStream fis = new FileInputStream (file);
        addFile (fis, zo);
    }
}


-----Function Pair=176=-----==

public List < RepositoryOperation > readOperations (IMemento parent) {
    List < RepositoryOperation > operations = new ArrayList < RepositoryOperation > ();
    for (IMemento operationMemento : parent.getChildren (ELEMENT_OPERATION)) {
        String knobName = operationMemento.getString (ATTRIBUTE_KNOB_NAME);
        String operationName = operationMemento.getString (ATTRIBUTE_OPERATION_NAME);
        String optionName = operationMemento.getString (ATTRIBUTE_OPTION_NAME);
        String selection = operationMemento.getString (ATTRIBUTE_OPTION_SELECTION);
        String isChecked = operationMemento.getString (ATTRIBUTE_IS_CHECKED);
        String inputName = operationMemento.getString (ATTRIBUTE_INPUT_NAME);
        String inputValue = operationMemento.getString (ATTRIBUTE_INPUT_VALUE);
        if (knobName == null || operationName == null) continue;
        RepositoryOperation op = new RepositoryOperation (knobName, operationName);
        if (optionName != null) {
            op.setUpOptions (optionName);
        }
        if (isChecked != null) {
            op.setChecked (Boolean.parseBoolean (isChecked));
        }
        if (inputName != null) {
            op.setInputName (inputName);
        }
        if (inputValue != null) {
            op.setInputValue (inputValue);
        }
        IMemento optionNames = operationMemento.getChild (ELEMENT_OPTION_NAMES);
        if (optionNames != null) {
            for (IMemento nameMemento : optionNames.getChildren (ELEMENT_NAME)) {
                if (nameMemento.getTextData () != null && nameMemento.getTextData ().length () > 0) {
                    op.addOption (nameMemento.getTextData (), nameMemento.getString (ATTRIBUTE_VALUE));
                }
            }
        }
        if (selection != null) {
            op.setOptionSelection (selection);
        }
        operations.add (op);
    }
    return operations;
}


private byte [] addTestSchedules (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (4096);
    int type = 1;
    int number = 1;
    int duration = 1;
    int gap = 1;
    try {
        type = Integer.parseInt (urlData.getParameter ("type"));
    } catch (Exception e) {
    }
    try {
        number = Integer.parseInt (urlData.getParameter ("number"));
    } catch (Exception e) {
    }
    try {
        duration = Integer.parseInt (urlData.getParameter ("duration"));
    } catch (Exception e) {
    }
    try {
        gap = Integer.parseInt (urlData.getParameter ("gap"));
    } catch (Exception e) {
    }
    Calendar start = Calendar.getInstance ();
    start.set (Calendar.SECOND, 0);
    start.set (Calendar.MILLISECOND, 0);
    start.add (Calendar.MINUTE, 1);
    HashMap < String, Channel > channels = store.getChannels ();
    String [] keys = (String []) channels.keySet ().toArray (new String [0]);
    for (int y = 0; y < number; y ++) {
        for (int x = 0; x < keys.length; x ++) {
            start.add (Calendar.MINUTE, duration + gap);
            ScheduleItem item = new ScheduleItem (store.rand.nextLong ());
            item.setCapType (type);
            item.setType (ScheduleItem.ONCE);
            item.setState (ScheduleItem.WAITING);
            item.setStatus ("Waiting");
            item.setStart (start);
            item.setDuration (duration);
            item.setChannel (keys [x]);
            item.setAutoDeletable (false);
            item.setPostTask ("");
            String [] namePatterns = store.getNamePatterns ();
            item.setFilePattern (namePatterns [0]);
            item.log ("New TEST Schedule added/edited");
            store.addScheduleItem (item);
        }
    }
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + "/servlet/" + urlData.getServletClass () + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=177=-----==

public static void geraPacotes () throws IOException, InterruptedException {
    Properties packs = new Properties ();
    packs.load (new FileInputStream ("releasePacks"));
    for (Object packName : packs.keySet ()) {
        System.out.println ("Packing " + packName + "...");
        File zipFile = new File (destDir, packName.toString ());
        zipFile.getParentFile ().mkdirs ();
        ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (zipFile));
        String regex = makeRegex (packs.getProperty (packName.toString ()));
        for (File f : FileDestDir.listFiles ()) {
            String filename = f.getName ();
            if (filename.matches (regex)) addToZip (f, zip);
        }
        zip.close ();
        String [] commandLine = {"C:/Arquivos de programas/Java/jdk1.6.0_03/bin/jarsigner", "-storepass", keyPassword, "-keystore", keyStore.getCanonicalPath (), zipFile.getCanonicalPath (), keyAlias};
        System.out.println ("Assinando Arquivo " + zipFile);
        Process signProcess = Runtime.getRuntime ().exec (commandLine);
        signProcess.waitFor ();
        BufferedReader pIn = new BufferedReader (new InputStreamReader (signProcess.getInputStream ()));
        BufferedReader pErr = new BufferedReader (new InputStreamReader (signProcess.getErrorStream ()));
        while (pIn.ready ()) {
            System.out.println (pIn.readLine ());
        }
        while (pErr.ready ()) {
            System.out.println (pErr.readLine ());
        }
    }
}


public static void writeReportsToOutputStream (OutputStream pOut, ReportGenerator pReportFactory, ReportFactoryParameters pReportParams, DataContainer pDataContainer) throws ReportFactoryException {
    try {
        OutputStream vOut = new BufferedOutputStream (pOut);
        if (pReportParams.isZip ()) {
            vOut = new ZipOutputStream (pOut);
        }
        for (int vIndex = 0; vIndex < pReportParams.getReportIDs ().length; vIndex ++) {
            String vIdReport = pReportParams.getReportIDs () [vIndex];
            IReportConfig vReportConfig = pReportFactory.getConfiguration ().getReport (vIdReport);
            if (vReportConfig == null) {
                String vConfigurationName = pReportParams.getConfigurationName ();
                throw new ReportFactoryException ("Unable to find configuration for report [" + vIdReport + "] in configuration [" + vConfigurationName + "]");
            }
            String vFilename = pReportParams.getFilenames () [vIndex];
            if (vFilename == null || vFilename.equals ("report-" + vIdReport)) {
                vFilename = StringUtils.defaultString (vReportConfig.getDefaultFileName (), vIdReport);
                if (pReportParams.isDateSuffixe ()) {
                    StringBuffer vNewFilename = new StringBuffer ();
                    vNewFilename.append (vFilename.substring (0, vFilename.lastIndexOf (".")));
                    vNewFilename.append ("_").append ((new Date ()).getTime ());
                    vNewFilename.append (vFilename.lastIndexOf ("."));
                    vFilename = vNewFilename.toString ();
                }
            }
            if (pReportParams.isZip ()) {
                ZipEntry vZipEntry = new ZipEntry (vFilename);
                ((ZipOutputStream) vOut).putNextEntry (vZipEntry);
            }
            if (pDataContainer != null) {
                pReportFactory.process (vIdReport, pDataContainer, pReportParams.getParameterValues (), vOut);
            }
            else {
                pReportFactory.process (vIdReport, pReportParams.getParameterValues (), vOut);
            }
            if (pReportParams.isZip ()) {
                ((ZipOutputStream) vOut).closeEntry ();
                if (logger.isDebugEnabled ()) {
                    logger.debug ("closing zip entry [" + vFilename + "]...");
                }
            }
        }
        if (pReportParams.isZip ()) {
            ((ZipOutputStream) vOut).finish ();
        }
    } catch (Exception e) {
        logger.error (e.getMessage (), e);
        throw new ReportFactoryException (e.getMessage (), e);
    }
}


-----Function Pair=178=-----==

public void save () throws IOException {
    CodeTimer saveTimer;
    if (! dirty) {
        return;
    }
    saveTimer = new CodeTimer ("PackedFile.save");
    saveTimer.setEnabled (log.isDebugEnabled ());
    File newFile = new File (tmpDir.getAbsolutePath () + "/" + new GUID () + ".pak");
    ZipOutputStream zout = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (newFile)));
    zout.setLevel (1);
    try {
        saveTimer.start ("contentFile");
        if (hasFile (CONTENT_FILE)) {
            zout.putNextEntry (new ZipEntry (CONTENT_FILE));
            InputStream is = getFileAsInputStream (CONTENT_FILE);
            IOUtils.copy (is, zout);
            zout.closeEntry ();
        }
        saveTimer.stop ("contentFile");
        saveTimer.start ("propertyFile");
        if (getPropertyMap ().isEmpty ()) {
            removeFile (PROPERTY_FILE);
        }
        else {
            zout.putNextEntry (new ZipEntry (PROPERTY_FILE));
            xstream.toXML (getPropertyMap (), zout);
            zout.closeEntry ();
        }
        saveTimer.stop ("propertyFile");
        saveTimer.start ("addFiles");
        addedFileSet.remove (CONTENT_FILE);
        for (String path : addedFileSet) {
            zout.putNextEntry (new ZipEntry (path));
            InputStream is = getFileAsInputStream (path);
            IOUtils.copy (is, zout);
            zout.closeEntry ();
        }
        saveTimer.stop ("addFiles");
        saveTimer.start ("copyFiles");
        if (file.exists ()) {
            Enumeration < ? extends ZipEntry > entries = zFile.entries ();
            while (entries.hasMoreElements ()) {
                ZipEntry entry = entries.nextElement ();
                if (! entry.isDirectory () && ! addedFileSet.contains (entry.getName ()) && ! removedFileSet.contains (entry.getName ()) && ! CONTENT_FILE.equals (entry.getName ()) && ! PROPERTY_FILE.equals (entry.getName ())) {
                    zout.putNextEntry (entry);
                    InputStream is = getFileAsInputStream (entry.getName ());
                    IOUtils.copy (is, zout);
                    zout.closeEntry ();
                }
                else if (entry.isDirectory ()) {
                    zout.putNextEntry (entry);
                    zout.closeEntry ();
                }
            }
        }
        try {
            if (zFile != null) zFile.close ();
        } catch (IOException e) {
        }
        zFile = null;
        saveTimer.stop ("copyFiles");
        saveTimer.start ("close");
        zout.close ();
        zout = null;
        saveTimer.stop ("close");
        saveTimer.start ("backup");
        File backupFile = new File (tmpDir.getAbsolutePath () + "/" + new GUID () + ".mv");
        if (file.exists ()) {
            backupFile.delete ();
            if (! file.renameTo (backupFile)) {
                FileUtil.copyFile (file, backupFile);
                file.delete ();
            }
        }
        saveTimer.stop ("backup");
        saveTimer.start ("finalize");
        if (! newFile.renameTo (file)) FileUtil.copyFile (newFile, file);
        if (backupFile.exists ()) backupFile.delete ();
        saveTimer.stop ("finalize");
        dirty = false;
    } finally {
        saveTimer.start ("cleanup");
        try {
            if (zFile != null) zFile.close ();
        } catch (IOException e) {
        }
        if (newFile.exists ()) newFile.delete ();
        try {
            if (zout != null) zout.close ();
        } catch (IOException e) {
        }
        saveTimer.stop ("cleanup");
        if (log.isDebugEnabled ()) log.debug (saveTimer);
        saveTimer = null;
    }
}


public void generateKMZ (File kmzFile, Route r) {
    byte [] buf = new byte [2048];
    try {
        kmzFile.createNewFile ();
        ZipOutputStream zipFile = new ZipOutputStream (new FileOutputStream (kmzFile));
        zipFile.putNextEntry (new ZipEntry ("doc.kml"));
        writeKml (zipFile, r);
        zipFile.closeEntry ();
        ListIterator < Photo > iter = r.getPhotos ().listIterator ();
        while (iter.hasNext ()) {
            String p = iter.next ().getPath ();
            if (p != null) {
                File f = new File (p);
                String name = "files/" + f.getName ();
                zipFile.putNextEntry (new ZipEntry (name));
                FileInputStream in = new FileInputStream (f);
                int len;
                while ((len = in.read (buf)) > 0) {
                    zipFile.write (buf, 0, len);
                }
                zipFile.closeEntry ();
            }
        }
        zipFile.flush ();
        zipFile.close ();
    } catch (Exception e) {
        Log.e (TAG, e.getMessage ());
    }
}


-----Function Pair=179=-----==

public static String download (final String sURL, final String sFilename) throws IOException {
    final URL u = new URL (sURL);
    final URLConnection conn = u.openConnection ();
    final InputStream is = conn.getInputStream ();
    final byte [] buff = new byte [10240];
    int read;
    final OutputStream os;
    String actualFileName = sFilename;
    if (sFilename != null) {
        File f = new File (sFilename);
        if (f.exists () && f.isDirectory ()) {
            String sLastPart = sURL;
            int idx = sLastPart.indexOf ('?');
            if (idx >= 0) sLastPart = sLastPart.substring (0, idx);
            idx = sLastPart.lastIndexOf ('/');
            if (idx >= 0) sLastPart = sLastPart.substring (idx + 1);
            f = new File (f, sLastPart);
            actualFileName = f.getCanonicalPath ();
        }
        os = new FileOutputStream (f);
    }
    else {
        os = new ByteArrayOutputStream ();
    }
    try {
        while ((read = is.read (buff)) > 0) {
            os.write (buff, 0, read);
        }
    } finally {
        os.close ();
    }
    is.close ();
    if (os instanceof ByteArrayOutputStream) {
        String encoding = conn.getContentEncoding ();
        if (encoding == null) encoding = "UTF-8";
        final byte [] content = ((ByteArrayOutputStream) os).toByteArray ();
        try {
            return new String (content, encoding);
        } catch (final UnsupportedEncodingException uee) {
            return new String (content);
        }
    }
    return actualFileName;
}


private void storeProcessList (Date date, List < ProcessList > processListes, boolean doNotOverrideFile) {
    final int BUFFER = 2048;
    String filename = BASE_FILES_PATH + serverGroup + "/processlist/" + sdf.format (date) + ".zip";
    if (doNotOverrideFile && new File (filename).exists ()) return;
    try {
        FileOutputStream dest = new FileOutputStream (filename);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        for (ProcessList processList : processListes) {
            ByteArrayInputStream fi = new ByteArrayInputStream (buildProcessListText (processList).getBytes ());
            BufferedInputStream origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (processList.getMysqlServer ().getName () + ".txt");
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=180=-----==

private void addHeirarchy (File directory, ZipOutputStream out, String repoPath, HierarchyFilter filter, ProgressMeter progressMeter) throws IOException {
    File [] files = directory.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        File file = files [i];
        if (file.isDirectory () && filter.includeDirectory (file)) {
            progressMeter.scanning (file);
            addHeirarchy (file, out, repoPath + "/" + file.getName (), filter, progressMeter);
        }
        else {
            if (filter.includeFile (file)) {
                progressMeter.adding (file);
                addEntry (file, repoPath + "/" + file.getName (), out);
            }
        }
    }
}


public static void unZip (InputStream inputStream, java.io.File dstFilePath, boolean overWrite) throws IOException {
    BufferedInputStream bis = new BufferedInputStream (inputStream);
    ZipInputStream zis = new ZipInputStream (bis);
    byte [] buff = new byte [2048];
    ZipEntry zip = zis.getNextEntry ();
    while (zip != null) {
        java.io.File file = new java.io.File (dstFilePath, zip.getName ());
        if (zip.isDirectory ()) {
            if (! file.exists ()) {
                file.mkdirs ();
            }
        }
        else {
            if (! file.exists ()) {
                file.createNewFile ();
                readEntry (zis, file, buff);
            }
            else if (overWrite) {
                readEntry (zis, file, buff);
            }
        }
        zip = zis.getNextEntry ();
    }
    zis.close ();
    bis.close ();
}


-----Function Pair=181=-----==

public void run () {
    if (! sourceFile.exists ()) {
        System.out.println ("Error, file not found: '" + sourceFile.getPath () + "'");
        return;
    }
    try {
        fireStarted ();
        System.out.println ("Starting file reading...");
        long startTime = System.currentTimeMillis ();
        BufferedReader in = new BufferedReader (new FileReader (sourceFile));
        String ligne = in.readLine ();
        iterationNum = 0;
        long totalByteRead = ligne.length ();
        long sourceFileSize = sourceFile.length ();
        long percentageMaxChunkSize = sourceFileSize * maxChunkSize / 100;
        boolean startNextChunk = false;
        fireChunkStarted ("Chunk file #" + iterationNum);
        while (ligne != null) {
            switch (maxChunkSizeUnit) {
                case PERCENTAGE_OF_ORIGINAL :
                    startNextChunk = totalByteRead >= percentageMaxChunkSize;
                    break;
                case NUMBER_OF_LINES :
                    startNextChunk = sortedMap.size () > maxChunkSize;
                    break;
            }
            if (startNextChunk) {
                flushSortedMap ();
                fireChunkStopped ("Chunk file #" + iterationNum);
                sortedMap.clear ();
                totalByteRead = 0;
                iterationNum ++;
                fireChunkStarted ("Chunk file #" + iterationNum);
            }
            String key = generateKeyFromLine (ligne);
            sortedMap.put (key, ligne);
            ligne = in.readLine ();
            if (ligne != null) totalByteRead += ligne.length ();
        }
        flushSortedMap ();
        fireChunkStopped ("Chunk file #" + iterationNum);
        in.close ();
        long endTime = System.currentTimeMillis ();
        System.out.println ("Finished reading file.");
        long duration = endTime - startTime;
        long throughput = duration / sortedMap.size ();
        System.out.println ("Read file in: " + duration + " ms.");
        System.out.println ("Read rate: " + throughput + " ms per line.");
        if (destinationFile.exists ()) {
            System.out.println ("WARNING: Destination file will be overwritten: '" + destinationFile.getPath () + "'");
        }
        System.out.println ("Starting writing final file to '" + destinationFile + ".");
        startTime = System.currentTimeMillis ();
        mergeSortedFiles (destinationFile);
        endTime = System.currentTimeMillis ();
        duration = endTime - startTime;
        System.out.println ("Finished writing final file in " + duration + " ms.");
        fireStopped ();
        System.out.println ("End of Scrat Big File Sorter.");
    } catch (IOException ioe) {
        ioe.printStackTrace ();
        System.exit (- 1);
    }
}


protected void writePackageInfo (Resource resource, OutputStream out) throws IOException, TransformerException, FormatException {
    Document doc = documentBuilder.newDocument ();
    Element documentElement = doc.createElement ("package");
    documentElement.setAttribute ("version", "2.0");
    documentElement.setAttribute ("xmlns", "http://www.idpf.org/2007/opf");
    documentElement.setAttribute ("unique-identifier", getValue (resource, DublinCore.IDENTIFIER, "UNKNOWN"));
    doc.appendChild (documentElement);
    Element metadata = doc.createElement ("metadata");
    documentElement.appendChild (metadata);
    Element manifest = doc.createElement ("manifest");
    Queue < Resource > queue = new LinkedList < Resource > (resource.getEmbeddedResources ());
    while (! queue.isEmpty ()) {
        Resource embedded = queue.poll ();
        Element item = doc.createElement ("item");
        String mediaType = embedded.getMediaType ();
        String mediaSubtype = getExporter (mediaType).getFormat ();
        item.setAttribute ("media-type", mediaType + "/" + mediaSubtype);
    }
    documentElement.appendChild (manifest);
    Element spine = doc.createElement ("spine");
    documentElement.appendChild (spine);
    Element guide = doc.createElement ("guide");
    documentElement.appendChild (guide);
    transformer.transform (new DOMSource (doc), new StreamResult (out));
    out.flush ();
}


-----Function Pair=182=-----==

private static void generate (Writer out, Map < String, XSSFCellStyle > styles) throws Exception {
    Random rnd = new Random ();
    Calendar calendar = Calendar.getInstance ();
    SpreadsheetWriter sw = new SpreadsheetWriter (out);
    sw.beginSheet ();
    sw.insertRow (0);
    int styleIndex = styles.get ("header").getIndex ();
    sw.createCell (0, "Title", styleIndex);
    sw.createCell (1, "% Change", styleIndex);
    sw.createCell (2, "Ratio", styleIndex);
    sw.createCell (3, "Expenses", styleIndex);
    sw.createCell (4, "Date", styleIndex);
    sw.endRow ();
    for (int rownum = 1; rownum < 100000; rownum ++) {
        sw.insertRow (rownum);
        sw.createCell (0, "Hello, " + rownum + "!");
        sw.createCell (1, (double) rnd.nextInt (100) / 100, styles.get ("percent").getIndex ());
        sw.createCell (2, (double) rnd.nextInt (10) / 10, styles.get ("coeff").getIndex ());
        sw.createCell (3, rnd.nextInt (10000), styles.get ("currency").getIndex ());
        sw.createCell (4, calendar, styles.get ("date").getIndex ());
        sw.endRow ();
        calendar.roll (Calendar.DAY_OF_YEAR, 1);
    }
    sw.endSheet ();
}


public void remove (String fs, FilenameFilter ff, boolean tf) throws Exception {
    File f = new File (fs);
    if (f.getName ().length () < 1) return;
    String [] flist = f.list (ff);
    if (flist == null || flist.length < 1) {
        if (! (f.isDirectory () && ! tf)) f.delete ();
        return;
    }
    for (int i = 0; i < flist.length; i ++) {
        String p = f.getAbsolutePath ();
        if (! p.endsWith ("" + File.separatorChar)) p = p + File.separatorChar;
        FileUtil.deleteAll (p + flist [i], ff, tf);
    }
    if (f != null) if (! (f.isDirectory () && ! tf)) f.delete ();
}


-----Function Pair=183=-----==

private static void addFromResource (String resource, OutputStream out) {
    URL url = OpenOfficeDocumentCreator.class.getResource (resource);
    try {
        InputStream in = url.openStream ();
        byte [] buffer = new byte [256];
        synchronized (in) {
            synchronized (out) {
                while (true) {
                    int bytesRead = in.read (buffer);
                    if (bytesRead == - 1) break;
                    out.write (buffer, 0, bytesRead);
                }
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public static void main (String [] args) {
    System.out.println (MimeType.getMimeType ("data.xls"));
    System.out.println (MimeType.getMimeType ("data.cvs"));
    System.out.println (MimeType.getMimeType ("data.txt"));
    System.out.println (MimeType.getMimeType ("data.log"));
    System.out.println (MimeType.getMimeType ("data.html"));
    System.out.println (MimeType.getMimeType ("data.htm"));
    System.out.println (MimeType.getMimeType ("data.png"));
    System.out.println (MimeType.getMimeType ("data.gif"));
    System.out.println (MimeType.getMimeType ("data.jpg"));
    System.out.println (MimeType.getMimeType ("data.xml"));
    System.out.println (MimeType.getMimeType ("data.rtf"));
    System.exit (0);
    org.openXpertya.OpenXpertya.startupEnvironment (true);
    MAttachment att = new MAttachment (Env.getCtx (), 100, 0, null);
    att.addEntry (new File ("C:\\OpenXpertya\\Dev.properties"));
    att.addEntry (new File ("C:\\ServidorOXP\\index.html"));
    att.save ();
    System.out.println (att);
    att.dumpEntryNames ();
    int AD_Attachment_ID = att.getAD_Attachment_ID ();
    System.out.println ("===========================================");
    att = new MAttachment (Env.getCtx (), AD_Attachment_ID, null);
    System.out.println (att);
    att.dumpEntryNames ();
    System.out.println ("===========================================");
    MAttachmentEntry [] entries = att.getEntries ();
    for (int i = 0; i < entries.length; i ++) {
        MAttachmentEntry entry = entries [i];
        entry.dump ();
    }
    System.out.println ("===========================================");
    att.delete (true);
}


-----Function Pair=184=-----==

private static void substitute (File zipfile, File tmpfile, String entry, OutputStream out) throws IOException {
    ZipFile zip = new ZipFile (zipfile);
    ZipOutputStream zos = new ZipOutputStream (out);
    @SuppressWarnings ("unchecked")
    Enumeration < ZipEntry > en = (Enumeration < ZipEntry >) zip.entries ();
    while (en.hasMoreElements ()) {
        ZipEntry ze = en.nextElement ();
        if (! ze.getName ().equals (entry)) {
            zos.putNextEntry (new ZipEntry (ze.getName ()));
            InputStream is = zip.getInputStream (ze);
            copyStream (is, zos);
            is.close ();
        }
    }
    zos.putNextEntry (new ZipEntry (entry));
    InputStream is = new FileInputStream (tmpfile);
    copyStream (is, zos);
    is.close ();
    zos.close ();
}


private static void addDir (File rootDir, File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (rootDir, files [i], out);
            continue;
        }
        FileInputStream in = new FileInputStream (files [i].getAbsolutePath ());
        System.out.println (" Adding: " + files [i].getAbsolutePath ());
        out.putNextEntry (new ZipEntry (files [i].getAbsolutePath ().substring (rootDir.getAbsolutePath ().length () + 1)));
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


-----Function Pair=185=-----==

public boolean removeBaseForWord (String word, String remove) {
    boolean got_it = false;
    String upperWord = word.toUpperCase ();
    remove = remove.toUpperCase ();
    List l = (List) apelonAdditions.get (upperWord);
    if (l == null || l.size () == 0) return got_it;
    Iterator iter = l.iterator ();
    while (iter.hasNext ()) {
        WordEntry we = (WordEntry) iter.next ();
        if (we.getBase ().equals (remove)) {
            iter.remove ();
            got_it = true;
            break;
        }
    }
    apelonAdditions.put (upperWord, l);
    return got_it;
}


static boolean exec (String [] args) throws IOException {
    if (args.length < 2) {
        System.err.println ("java -cp requestfactory-client.jar:your_server-code.jar " + ValidationTool.class.getCanonicalName () + " (/some/directory | output.jar) com.example.shared.MyRequestFactory");
        System.err.println ("See " + "http://code.google.com/p/google-web-toolkit/wiki/RequestFactoryInterfaceValidation " + "for more information.");
        return false;
    }
    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler ();
    if (compiler == null) {
        System.err.println ("This tool must be run with a JDK, not a JRE");
        return false;
    }
    if (! compiler.getSourceVersions ().contains (SourceVersion.RELEASE_6)) {
        System.err.println ("This tool must be run with a Java 1.6 compiler");
        return false;
    }
    boolean clientOnly = false;
    List < String > argList = new ArrayList < String > (Arrays.asList (args));
    if (argList.get (0).equals ("-client")) {
        clientOnly = true;
        argList.remove (0);
    }
    JavaFileManager fileManager = new JarOrDirectoryOutputFileManager (new File (argList.remove (0)), compiler.getStandardFileManager (null, null, null));
    RfValidator processor = new RfValidator ();
    if (clientOnly) {
        processor.setClientOnly (true);
    }
    else {
        processor.setMustResolveAllMappings (true);
    }
    processor.setRootOverride (argList);
    CompilationTask task = compiler.getTask (null, fileManager, null, null, null, Arrays.asList (new FakeJavaFileObject ()));
    task.setProcessors (Arrays.asList (processor));
    if (! task.call ()) {
        return false;
    }
    fileManager.close ();
    return true;
}


-----Function Pair=186=-----==

private List parseDuplicateFiles (String responseBodyAsString) {
    List result = new ArrayList ();
    LineNumberReader reader = new LineNumberReader (new InputStreamReader (new ByteArrayInputStream (responseBodyAsString.getBytes ())));
    try {
        String trim;
        for (String read = reader.readLine (); read != null; read = reader.readLine ()) {
            trim = read.trim ();
            if (! (trim.equals ("") || trim.equals ("\n"))) {
                result.add (read);
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return result;
}


public boolean compressIt () {
    try {
        File f = new File (this.outFileName);
        f.createNewFile ();
        f.deleteOnExit ();
        ZipOutputStream outStream = new ZipOutputStream (new FileOutputStream (this.outFileName));
        System.out.println ("Creating compressed file " + this.outFileName + "...");
        for (int i = 0; i < this.fileNamesToCompress.length; i ++) {
            System.out.print ("\tAdding " + this.fileNamesToCompress [i] + "... ");
            FileInputStream inStream = new FileInputStream (this.directory + File.separator + this.fileNamesToCompress [i]);
            outStream.putNextEntry (new ZipEntry (this.fileNamesToCompress [i]));
            Integer auxLength;
            while ((auxLength = inStream.read (this.buffer)) > 0) {
                outStream.write (this.buffer, 0, auxLength);
            }
            inStream.close ();
            System.out.println ("DONE.");
        }
        outStream.close ();
    } catch (java.io.FileNotFoundException ex) {
        System.out.println ("ERROR :: File NOT found!!! " + ex.getMessage ());
        return false;
    } catch (IOException ex) {
        System.out.println ("ERRROR :: Input/Ouput error!!! " + ex.getMessage ());
        return false;
    }
    return true;
}


-----Function Pair=187=-----==

public void compress (String packageName) {
    FileOutputStream oDestination;
    ZipOutputStream oOutput;
    try {
        File oDestFile = new File (String.format (this.globalData.getData (IGlobalData.PROJECT_OUTPUT_PATH) + "/%s.zip", packageName));
        if (! oDestFile.exists ()) oDestFile.createNewFile ();
        oDestination = new FileOutputStream (oDestFile);
        oOutput = new ZipOutputStream (new BufferedOutputStream (oDestination));
        oOutput.setLevel (9);
        for (Module module : modules) {
            String sRelativePath = module.getResource ().getProjectRelativePath ().toString ();
            ZipEntry oEntry = new ZipEntry (sRelativePath);
            oOutput.putNextEntry (oEntry);
            if (module.getDocument () == null) {
                writeBinary (module.getResource ().getLocation ().toString (), oOutput);
            }
            else {
                writeXml (module.getDocument (), oOutput);
            }
        }
        oOutput.close ();
    } catch (Exception e) {
        this.problems.add (new InternalError (null, e.getMessage ()));
    }
}


public void load (InputStream in) throws ZipException, IOException {
    ZipInputStream zip;
    ZipEntry ze;
    byte [] buffer;
    byte [] tmp;
    Outlet out;
    int l;
    if (in instanceof ZipInputStream) {
        zip = (ZipInputStream) in;
    }
    else {
        zip = new ZipInputStream (in);
    }
    map_.clear ();
    buffer = new byte [BUFFER_SIZE];
    while ((ze = zip.getNextEntry ()) != null) {
        if (ze.isDirectory ()) {
            continue;
        }
        out = (Outlet) getOutputStream (ze.getName ());
        if (out == null) {
            throw new IllegalStateException ("Can't write to memory!");
        }
        while ((l = zip.read (buffer)) > 0) {
            out.write (buffer, 0, l);
        }
        tmp = out.toByteArray ();
        out.close ();
        zip.closeEntry ();
        map_.put (ze.getName (), tmp);
    }
}


-----Function Pair=188=-----==

void addFile (ZipOutputStream zos, File file) throws IOException {
    String name = file.getPath ();
    boolean isDir = file.isDirectory ();
    if (isDir) {
        name = name.endsWith (File.separator) ? name : (name + File.separator);
    }
    name = entryName (name);
    if (name.equals ("") || name.equals (".") || name.equals (zname)) {
        return;
    }
    else if ((name.equals (MANIFEST_DIR) || name.equals (MANIFEST_NAME)) && ! Mflag) {
        if (vflag) {
            output (formatMsg ("out.ignore.entry", name));
        }
        return;
    }
    long size = isDir ? 0 : file.length ();
    if (vflag) {
        out.print (formatMsg ("out.adding", name));
    }
    ZipEntry e = new ZipEntry (name);
    e.setTime (file.lastModified ());
    if (size == 0) {
        e.setMethod (ZipEntry.STORED);
        e.setSize (0);
        e.setCrc (0);
    }
    else if (flag0) {
        crc32File (e, file);
    }
    zos.putNextEntry (e);
    if (! isDir) {
        copy (file, zos);
    }
    zos.closeEntry ();
    if (vflag) {
        size = e.getSize ();
        long csize = e.getCompressedSize ();
        out.print (formatMsg2 ("out.size", String.valueOf (size), String.valueOf (csize)));
        if (e.getMethod () == ZipEntry.DEFLATED) {
            long ratio = 0;
            if (size != 0) {
                ratio = ((size - csize) * 100) / size;
            }
            output (formatMsg ("out.deflated", String.valueOf (ratio)));
        }
        else {
            output (getMsg ("out.stored"));
        }
    }
}


public static void unzipFileToLocation (final String zipFilePath, final String toDirName) throws IOException {
    final ZipFile zipFile;
    final Enumeration enumr;
    boolean isEmptyFile = false;
    try {
        zipFile = new ZipFile (zipFilePath);
        if (zipFile.size () == 0) {
            isEmptyFile = true;
        }
        else {
            final String infoMessage = "Unzipping file: " + zipFilePath;
            LOG.info (infoMessage);
            enumr = zipFile.entries ();
            while (enumr.hasMoreElements ()) {
                final ZipEntry target = (ZipEntry) enumr.nextElement ();
                final String message = "Exploding: " + target.getName ();
                LOG.debug (message);
                saveItem (zipFile, toDirName, target);
            }
            zipFile.close ();
        }
    } catch (FileNotFoundException fnfe) {
        final String message = "Could not find zip file" + zipFilePath;
        LOG.error (message, fnfe);
        throw new RuntimeException (message, fnfe);
    } catch (ZipException ze) {
        final String message = "Zip error occured while unzipping file " + zipFilePath;
        LOG.error (message, ze);
        throw new RuntimeException (message, ze);
    } catch (IOException ioe) {
        final String message = "Error occured while unzipping file " + zipFilePath;
        LOG.error (message, ioe);
        throw new RuntimeException (message, ioe);
    }
    if (isEmptyFile) {
        final String message = "Zip file has no entries: " + zipFilePath;
        LOG.warn (message);
        throw new IOException (message);
    }
    final String infoMessage = "Unzip complete";
    LOG.info (infoMessage);
}


-----Function Pair=189=-----==

private static Element getElement (Document document, String elementName) {
    NodeList resourcesDomNodes = document.getElementsByTagName (elementName);
    Element resourcesElement = null;
    for (int i = 0; i < resourcesDomNodes.getLength (); i ++) {
        org.w3c.dom.Node resourcesNode = resourcesDomNodes.item (i);
        if (resourcesNode instanceof Element) {
            resourcesElement = (Element) resourcesNode;
            break;
        }
    }
    if (resourcesElement == null) {
        resourcesElement = document.createElement (elementName);
        org.w3c.dom.Node manifestNode = document.getFirstChild ();
        manifestNode.appendChild (resourcesElement);
    }
    return resourcesElement;
}


public static File openZIP (File zip, String folder) throws FileNotFoundException, IOException, ZipException {
    if (! zip.exists ()) {
        throw new FileNotFoundException (zip.getAbsolutePath ());
    }
    ZipFile zipFile = new ZipFile (zip.getAbsolutePath ());
    Enumeration entries = zipFile.entries ();
    File file = new File (folder);
    if (! file.exists ()) {
        file.mkdirs ();
    }
    FileOutputStream output;
    while (entries.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) entries.nextElement ();
        if (entry.isDirectory ()) {
            new File (folder + File.separator + entry.getName ().substring (0, entry.getName ().lastIndexOf ("/"))).mkdirs ();
        }
        else if (entry.getName ().contains ("/")) {
            new File (folder + File.separator + entry.getName ().substring (0, entry.getName ().lastIndexOf ("/"))).mkdirs ();
        }
        else {
            FileUtils.copyInputStream (zipFile.getInputStream (entry), output = new FileOutputStream (file.getAbsolutePath () + File.separator + entry.getName ()));
            output.close ();
        }
    }
    zipFile.close ();
    return file;
}


-----Function Pair=190=-----==

private void LoadTemplateFromDatabase (NpsContext ctxt) throws NpsException {
    String sql = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Reader is = null;
    try {
        sql = "select template from template where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        rs = pstmt.executeQuery ();
        if (rs.next ()) {
            CLOB clob = ((OracleResultSet) rs).getCLOB ("template");
            if (clob != null) {
                FileOutputStream fo = null;
                OutputStreamWriter so = null;
                try {
                    is = clob.getCharacterStream ();
                    template = new File (Config.OUTPATH_TEMPLATE + File.separator + id + ".template");
                    if (template.exists ()) try {
                        template.delete ();
                    } catch (Exception e1) {
                    }
                    template.createNewFile ();
                    template.deleteOnExit ();
                    fo = new FileOutputStream (template);
                    so = new OutputStreamWriter (fo, "UTF-8");
                    int b;
                    while ((b = is.read ()) != - 1) {
                        so.write (b);
                    }
                } catch (Exception e) {
                    throw e;
                } finally {
                    try {
                        so.close ();
                    } catch (Exception e) {
                    }
                    try {
                        fo.close ();
                    } catch (Exception e) {
                    }
                }
            }
        }
    } catch (Exception e) {
        DefaultLog.error (e);
    } finally {
        if (is != null) try {
            is.close ();
        } catch (Exception e1) {
        }
        if (rs != null) try {
            rs.close ();
        } catch (Exception e1) {
        }
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        is = null;
        rs = null;
        pstmt = null;
    }
}


public static String [] getCookieStringsTest (String urlString, String postString) {
    String [] tempCookieStrings = null;
    try {
        URL url = new URL (urlString);
        HttpURLConnection connection = (HttpURLConnection) url.openConnection ();
        connection.setRequestProperty ("User-Agent", "User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-TW; rv:1.9.2.8) Gecko/20100722 Firefox/3.6.8");
        connection.setDoInput (true);
        connection.setDoOutput (true);
        connection.setRequestMethod ("POST");
        connection.getOutputStream ().write (postString.getBytes ());
        connection.getOutputStream ().flush ();
        connection.getOutputStream ().close ();
        int code = connection.getResponseCode ();
        System.out.println ("code   " + code);
        tempCookieStrings = tryConnect (connection);
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
    String [] cookieStrings = tempCookieStrings;
    int cookieCount = 0;
    if (tempCookieStrings != null) {
        for (int i = 0; i < tempCookieStrings.length; i ++) {
            if (tempCookieStrings [i] != null) {
                cookieStrings [cookieCount ++] = tempCookieStrings [i];
                System.out.println (cookieCount + " " + tempCookieStrings [i]);
            }
        }
    }
    return cookieStrings;
}


-----Function Pair=191=-----==

public void Delete (NpsContext ctxt) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        List topics = null;
        if (Config.CACHE) {
            topics = GetTopics (ctxt);
        }
        String sql = "delete from topic_pts where templateid=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "update topic set art_template=null where art_template=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        sql = "delete from template where id=?";
        pstmt = ctxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        for (int i = 0; topics != null && i < topics.size (); i ++) {
            TopicProfile profile = (TopicProfile) topics.get (i);
            Site site = ctxt.GetSite (profile.GetSiteId ());
            if (site == null) continue;
            TopicTree topic_tree = site.GetTopicTree ();
            if (topic_tree == null) continue;
            Topic topic = topic_tree.GetTopic (profile.GetId ());
            if (topic == null) continue;
            if (this instanceof ArticleTemplate) topic.SetArticleTemplate (null);
            else topic.RemovePageTemplate (id);
        }
        DeleteJavaFiles ();
        TemplatePool.GetPool ().remove (this);
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


public static ByteBuffer readFromZipFile (File f) {
    try {
        FileInputStream in = new FileInputStream (f);
        ZipInputStream zipIn = new ZipInputStream (in);
        int len, curlen, read;
        ZipFile zip = new ZipFile (f);
        ZipEntry entry = zip.getEntry ("contents");
        len = (int) entry.getSize ();
        curlen = 0;
        byte [] buf = new byte [len];
        zipIn.getNextEntry ();
        while (curlen < len) {
            read = zipIn.read (buf, curlen, len - curlen);
            if (read >= 0) {
                curlen += read;
            }
            else {
                break;
            }
        }
        zipIn.closeEntry ();
        zipIn.close ();
        in.close ();
        zip.close ();
        return new ByteBuffer (buf, ByteBuffer.BO_BIG_ENDIAN);
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=192=-----==

protected void saveAttributesBinary (DataOutputStream out, Attributes a) throws IOException {
    out.writeUTF (a.getClass ().getName ());
    out.writeInt (version);
    out.writeInt (a.getTimeKeyIndex ());
    out.writeUTF (a.getName ());
    if (this.version >= 11) {
        String temp_id = a.getID ();
        if (temp_id == null) temp_id = "";
        out.writeUTF (temp_id);
        temp_id = a.getThemeID ();
        if (temp_id == null) temp_id = "";
        out.writeUTF (temp_id);
    }
    a.getExtents ().save (out);
    a.getMatrix ().save (out);
    a.getPrecisionExtent ().save (out);
    a.getUnitExtent ().save (out);
    a.getDataLegendExtent ().save (out);
    a.getGraphExtent ().save (out);
    a.getSourceExtent ().save (out);
    a.getNoteExtent ().save (out);
    a.getLinkExtent ().save (out);
    a.getReferenceExtent ().save (out);
    try {
        out.writeUTF (a.getHeader ());
    } catch (Exception ex) {
    }
    if (this.version >= 10) {
        a.getSampleExtent ().save (out);
    }
    if (this.version >= 12) {
        a.getPublishExtent ().save (out);
    }
}


public void testJarVerificationModifiedEntry () throws IOException {
    Support_Resources.copyFile (resources, null, JAR5);
    File f = new File (resources, JAR5);
    JarFile jarFile = new JarFile (f);
    ZipEntry zipEntry = jarFile.getJarEntry (JAR5_SIGNED_ENTRY);
    zipEntry.setSize (zipEntry.getSize () + 1);
    jarFile.getInputStream (zipEntry).skip (Long.MAX_VALUE);
    jarFile = new JarFile (f);
    zipEntry = jarFile.getJarEntry (JAR5_SIGNED_ENTRY);
    zipEntry.setSize (zipEntry.getSize () - 1);
    try {
        jarFile.getInputStream (zipEntry).read (new byte [5000], 0, 5000);
        fail ("SecurityException expected");
    } catch (SecurityException e) {
    }
}


-----Function Pair=193=-----==

public static File readFileFromZipFile (ZipEntry entry, ZipFile zipFile) throws IOException {
    long size = entry.getSize ();
    if (size > 0) {
        BufferedInputStream reader = new BufferedInputStream (zipFile.getInputStream (entry));
        String fileName = new File (entry.getName ()).getName ();
        File outputFile = FileUtilities.createTemporaryFileInDefaultTemporaryDirectory (fileName, "tmp");
        BufferedOutputStream output = new BufferedOutputStream (new FileOutputStream (outputFile), BUFFER_SIZE);
        byte readBytes [] = new byte [BUFFER_SIZE];
        int readByteCount;
        while ((readByteCount = reader.read (readBytes, 0, BUFFER_SIZE)) != - 1) {
            output.write (readBytes, 0, readByteCount);
        }
        output.close ();
        return outputFile;
    }
    else {
        return null;
    }
}


private static final void compressFile (final ZipOutputStream out, final String parentFolder, final File file) throws IOException {
    final String zipName = new StringBuilder (parentFolder).append (file.getName ()).append (file.isDirectory () ? '/' : "").toString ();
    final ZipEntry entry = new ZipEntry (zipName);
    entry.setSize (file.length ());
    entry.setTime (file.lastModified ());
    out.putNextEntry (entry);
    if (file.isDirectory ()) {
        for (final File f : file.listFiles ()) compressFile (out, zipName.toString (), f);
        return;
    }
    final InputStream in = new BufferedInputStream (new FileInputStream (file));
    try {
        final byte [] buf = new byte [8192];
        int bytesRead;
        while (- 1 != (bytesRead = in.read (buf))) out.write (buf, 0, bytesRead);
    } finally {
        in.close ();
    }
}


-----Function Pair=194=-----==

private final int copyFiles (ZipEntry [] list, String path) {
    int counter = 0;
    try {
        long dir_size = 0, byte_count = 0;
        for (int i = 0; i < list.length; i ++) {
            ZipEntry f = list [i];
            if (! f.isDirectory ()) dir_size += f.getSize ();
        }
        double conv = 100./ (double) dir_size;
        for (int i = 0; i < list.length; i ++) {
            ZipEntry entry = list [i];
            if (entry == null) continue;
            String entry_name_fixed = fixName (entry);
            if (entry_name_fixed == null) continue;
            String file_name = new File (entry_name_fixed).getName ();
            File dest_file = new File (dest_folder, path + file_name);
            String rel_name = entry_name_fixed.substring (base_len);
            if (entry.isDirectory ()) {
                if (! dest_file.mkdir ()) {
                    if (! dest_file.exists () || ! dest_file.isDirectory ()) {
                        errMsg = "Can't create folder \"" + dest_file.getAbsolutePath () + "\"";
                        break;
                    }
                }
                ZipEntry [] subItems = GetFolderList (entry_name_fixed);
                if (subItems == null) {
                    errMsg = "Failed to get the file list of the subfolder '" + rel_name + "'.\n";
                    break;
                }
                counter += copyFiles (subItems, rel_name);
                if (errMsg != null) break;
            }
            else {
                if (dest_file.exists ()) {
                    int res = askOnFileExist (ctx.getString (R.string.file_exist, dest_file.getAbsolutePath ()), commander);
                    if (res == Commander.ABORT) break;
                    if (res == Commander.SKIP) continue;
                    if (res == Commander.REPLACE) {
                        if (! dest_file.delete ()) {
                            error (ctx.getString (R.string.cant_del, dest_file.getAbsoluteFile ()));
                            break;
                        }
                    }
                }
                InputStream in = zip.getInputStream (entry);
                FileOutputStream out = new FileOutputStream (dest_file);
                byte buf [] = new byte [BLOCK_SIZE];
                int n = 0;
                int so_far = (int) (byte_count * conv);
                String unp_msg = ctx.getString (R.string.unpacking, rel_name);
                while (true) {
                    n = in.read (buf);
                    if (n < 0) break;
                    out.write (buf, 0, n);
                    byte_count += n;
                    sendProgress (unp_msg, so_far, (int) (byte_count * conv));
                    if (stop || isInterrupted ()) {
                        in.close ();
                        out.close ();
                        dest_file.delete ();
                        errMsg = "File '" + dest_file.getName () + "' was not completed, delete.";
                        break;
                    }
                }
            }
            final int GINGERBREAD = 9;
            if (android.os.Build.VERSION.SDK_INT >= GINGERBREAD) ForwardCompat.setFullPermissions (dest_file);
            if (stop || isInterrupted ()) {
                error (ctx.getString (R.string.canceled));
                break;
            }
            if (i >= list.length - 1) sendProgress (ctx.getString (R.string.unpacked_p, rel_name), (int) (byte_count * conv));
            counter ++;
        }
    } catch (Exception e) {
        Log.e (TAG, "copyFiles()", e);
        error ("Exception: " + e.getMessage ());
    }
    return counter;
}


protected void doGet (HttpServletRequest req, HttpServletResponse response) throws ServletException, IOException {
    if (Constants.REQUIRE_SECURE_REMOTE && ! req.isSecure ()) {
        if (req.getRemoteAddr ().equals (InetAddress.getLocalHost ().getHostAddress ()) || req.getRemoteAddr ().equals ("127.0.0.1") || InetAddress.getByName (req.getRemoteAddr ()).isLoopbackAddress ()) {
            log.debug ("Requested from local host");
        }
        else {
            log.error ("Accessing secure command over non-secure line from remote host is not allowed");
            response.setContentType ("text/html");
            response.getOutputStream ().println ("<html><head><title>Error</title></head>");
            response.getOutputStream ().println ("<body><b>");
            response.getOutputStream ().println ("Secure connection is required. Prefix your request with 'https: " + "<br>");
            response.getOutputStream ().println ("</body>");
            response.getOutputStream ().println ("</html>");
            return;
        }
    }
    keysString = req.getParameter ("resultKeys");
    if (req.getParameter ("includeTIF") != null && ! req.getParameter ("includeTIF").equals ("")) {
        includeTIF = req.getParameter ("includeTIF");
    }
    if (req.getParameter ("includeJPG") != null && ! req.getParameter ("includeJPG").equals ("")) {
        includeJPG = req.getParameter ("includeJPG");
    }
    if (req.getParameter ("mode") != null && ! req.getParameter ("mode").equals ("")) {
        archiveHelper.setMode (req.getParameter ("mode"));
    }
    SecurityAdvisor secAdvisor = null;
    try {
        secAdvisor = (SecurityAdvisor) req.getSession ().getAttribute (SecurityAdvisor.SECURITY_ADVISOR_SESSION_KEY);
        if (secAdvisor != null) {
            response.setContentType ("application/x-download");
            response.setHeader ("Content-Disposition", "attachment;filename=gnomexExperimentData.zip");
            response.setHeader ("Cache-Control", "max-age=0, must-revalidate");
            Session sess = secAdvisor.getHibernateSession (req.getUserPrincipal () != null ? req.getUserPrincipal ().getName () : "guest");
            DictionaryHelper dh = DictionaryHelper.getInstance (sess);
            baseDirFlowCell = dh.getFlowCellDirectory (req.getServerName ());
            baseDir = dh.getMicroarrayDirectoryForReading (req.getServerName ());
            archiveHelper.setTempDir (dh.getPropertyDictionary (PropertyDictionary.TEMP_DIRECTORY));
            Map fileDescriptorMap = new HashMap ();
            long compressedFileSizeTotal = getFileNamesToDownload (baseDir, baseDirFlowCell, keysString, fileDescriptorMap, includeTIF.equals ("Y"), includeJPG.equals ("Y"), dh.getPropertyDictionary (PropertyDictionary.FLOWCELL_DIRECTORY_FLAG));
            ZipOutputStream zipOut = null;
            TarArchiveOutputStream tarOut = null;
            if (archiveHelper.isZipMode ()) {
                zipOut = new ZipOutputStream (response.getOutputStream ());
            }
            else {
                tarOut = new TarArchiveOutputStream (response.getOutputStream ());
            }
            int totalArchiveSize = 0;
            for (Iterator i = fileDescriptorMap.keySet ().iterator (); i.hasNext ();) {
                String requestNumber = (String) i.next ();
                Request request = findRequest (sess, requestNumber);
                if (request == null) {
                    log.error ("Unable to find request " + requestNumber + ".  Bypassing download for user " + req.getUserPrincipal ().getName () + ".");
                    continue;
                }
                if (! secAdvisor.canRead (request)) {
                    log.error ("Insufficient permissions to read request " + requestNumber + ".  Bypassing download for user " + req.getUserPrincipal ().getName () + ".");
                    continue;
                }
                List fileDescriptors = (List) fileDescriptorMap.get (requestNumber);
                for (Iterator i1 = fileDescriptors.iterator (); i1.hasNext ();) {
                    FileDescriptor fd = (FileDescriptor) i1.next ();
                    TransferLog xferLog = new TransferLog ();
                    xferLog.setFileName (fd.getZipEntryName ());
                    xferLog.setStartDateTime (new java.util.Date (System.currentTimeMillis ()));
                    xferLog.setTransferType (TransferLog.TYPE_DOWNLOAD);
                    xferLog.setTransferMethod (TransferLog.METHOD_HTTP);
                    xferLog.setPerformCompression ("Y");
                    xferLog.setIdRequest (request.getIdRequest ());
                    xferLog.setIdLab (request.getIdLab ());
                    InputStream in = archiveHelper.getInputStreamToArchive (fd.getFileName (), fd.getZipEntryName ());
                    if (archiveHelper.isZipMode ()) {
                        zipOut.putNextEntry (new ZipEntry (archiveHelper.getArchiveEntryName ()));
                    }
                    else {
                        TarArchiveEntry entry = new TarArchiveEntry (archiveHelper.getArchiveEntryName ());
                        entry.setSize (archiveHelper.getArchiveFileSize ());
                        tarOut.putArchiveEntry (entry);
                    }
                    OutputStream out = null;
                    if (archiveHelper.isZipMode ()) {
                        out = zipOut;
                    }
                    else {
                        out = tarOut;
                    }
                    int size = archiveHelper.transferBytes (in, out);
                    totalArchiveSize += size;
                    xferLog.setFileSize (new BigDecimal (size));
                    xferLog.setEndDateTime (new java.util.Date (System.currentTimeMillis ()));
                    sess.save (xferLog);
                    if (archiveHelper.isZipMode ()) {
                        zipOut.closeEntry ();
                    }
                    else {
                        tarOut.closeArchiveEntry ();
                    }
                    archiveHelper.removeTemporaryFile ();
                }
            }
            response.setContentLength (totalArchiveSize);
            if (archiveHelper.isZipMode ()) {
                zipOut.finish ();
                zipOut.flush ();
            }
            else {
                tarOut.finish ();
            }
            sess.flush ();
        }
        else {
            response.setStatus (999);
            System.out.println ("DownloadResultsServlet: You must have a SecurityAdvisor in order to run this command.");
        }
    } catch (Exception e) {
        response.setStatus (999);
        System.out.println ("DownloadResultsServlet: An exception occurred " + e.toString ());
        e.printStackTrace ();
    } finally {
        if (secAdvisor != null) {
            try {
                secAdvisor.closeHibernateSession ();
            } catch (Exception e) {
            }
        }
        archiveHelper.removeTemporaryFile ();
    }
}


-----Function Pair=195=-----==

private void zip (File root, File folder, ZipOutputStream zip) throws IOException {
    String path = root.getParentFile ().getAbsolutePath ();
    File [] files = folder.listFiles ();
    if (files != null) {
        for (File file : files) {
            String entryName = path.endsWith (File.separator) ? file.getAbsolutePath ().substring (path.length ()) : file.getAbsolutePath ().substring (path.length () + 1);
            if (file.isFile ()) {
                ZipEntry entry = new ZipEntry (entryName);
                zip.putNextEntry (entry);
                InputStream in = new FileInputStream (file);
                write (in, zip);
                in.close ();
                zip.closeEntry ();
            }
            else if (file.isDirectory ()) {
                ZipEntry entry = new ZipEntry (entryName + "/");
                zip.putNextEntry (entry);
                zip.closeEntry ();
                zip (root, file, zip);
            }
        }
    }
}


private Reply doSend (ConsignJob request, PortfolioTh [] portfolios) throws Connection.Exception {
    if (portfolios == null) return doSend (request);
    try {
        if (output == null) {
            output = new ObjectOutputStream (socket.getOutputStream ());
        }
        output.reset ();
        output.writeObject (request);
        output.flush ();
        ZipOutputStream zos = getDataOutputStream ();
        for (int i = 0; i < portfolios.length; i ++) {
            String dir_name = portfolios [i].getPortfolio ().getUPLDirectoryName () + "/";
            for (int j = 0; j < portfolios [i].getFiles ().length; j ++) {
                if (portfolios [i].getFiles () [j].exists ()) {
                    String name;
                    if (portfolios [i].getDestinationNames () == null) {
                        name = portfolios [i].getFiles () [j].getName ();
                    }
                    else {
                        name = portfolios [i].getDestinationNames () [j];
                    }
                    transferFiles (dir_name, portfolios [i].getFiles () [j], name, zos);
                }
                else {
                    CLogger.status ("Adding no overwrite marker to stream <" + dir_name + "> " + portfolios [i].getFiles () [j].getName ());
                    ZipEntry marker = new ZipEntry (dir_name);
                    marker.setExtra (new byte [1]);
                    zos.putNextEntry (marker);
                    zos.closeEntry ();
                }
            }
        }
        CLogger.status ("Done sending streamed");
        doneWithDataOutputStream ();
        return (Reply) getObjectInputStream ().readObject ();
    } catch (java.lang.Exception ex) {
        _close ();
        throw new Connection.Exception ("Error sending Request with streamed: " + ex.getMessage ());
    }
}


-----Function Pair=196=-----==

public void buildCSS (String epubUrl, Hashtable < String, String > estilos, boolean putLineHeight) throws FileNotFoundException, IOException, Exception {
    ByteArrayOutputStream bos = new ByteArrayOutputStream ();
    PrintWriter pw = new PrintWriter (bos);
    int i;
    if (! doNotEmbedOTFFonts) {
        for (i = 0; i < otfDefs.length; i ++) {
            pw.println ("@font-face { font-family: \"" + otfDefs [i] [1] + "\"; " + otfDefs [i] [2] + " src: url(" + otfDefs [i] [0] + "); }");
        }
        for (i = 0; i < otfDefs.length; i ++) {
            processFile (getClass ().getResourceAsStream ("/" + otfDefs [i] [0]), otfDefs [i] [0]);
        }
    }
    String tosort [] = new String [estilos.size ()];
    i = 0;
    Hashtable < String, String > reverse = new Hashtable < String, String > ();
    for (Enumeration < String > keys = estilos.keys (); keys.hasMoreElements ();) {
        String k = keys.nextElement ();
        String v = estilos.get (k);
        if (putLineHeight && k.contains ("text-indent") && ! k.contains ("line-height")) {
            k += ";line-height:0.9em";
        }
        reverse.put (v, k);
        tosort [i ++] = v;
    }
    Arrays.sort (tosort);
    for (i = 0; i < tosort.length; i ++) {
        String na = tosort [i];
        String st = reverse.get (na);
        pw.println ("." + na + " { " + st.replace ('\'', '\"') + " } ");
    }
    pw.flush ();
    processFile (bos, epubUrl);
}


private static void compress (File root, File in, ZipOutputStream out, MessageDigest md, Set < String > fileNamesToSkipInCheckSumCalculation) throws IOException {
    if (in.isDirectory ()) {
        List < File > files = Arrays.asList (in.listFiles ());
        if (md != null) {
            Collections.sort (files, new Comparator < File > () {
                public int compare (File o1, File o2) {
                    return o1.getName ().compareTo (o2.getName ());
                }
            }
            );
        }
        for (File f : files) {
            compress (root, f, out, md, fileNamesToSkipInCheckSumCalculation);
        }
    }
    else {
        String path = root.toURI ().relativize (in.toURI ()).toString ();
        out.putNextEntry (new ZipEntry (path));
        FileInputStream fin = new FileInputStream (in);
        byte [] buffer = new byte [1024];
        int br;
        if (md == null || (fileNamesToSkipInCheckSumCalculation != null && fileNamesToSkipInCheckSumCalculation.contains (in.getName ()))) {
            while ((br = fin.read (buffer)) > 0) {
                out.write (buffer, 0, br);
            }
        }
        else {
            while ((br = fin.read (buffer)) > 0) {
                out.write (buffer, 0, br);
                md.update (buffer, 0, br);
            }
        }
        fin.close ();
        out.closeEntry ();
    }
}


-----Function Pair=197=-----==

protected void createArchive (File dir2Archive) {
    if (dir2Archive.getParentFile ().canWrite ()) {
        ZipOutputStream out = null;
        String prefix = dir2Archive.getName () + "/";
        ZipEntry entry;
        int cRead;
        try {
            FileOutputStream stream = new FileOutputStream (new File (dir2Archive.getParentFile (), dir2Archive.getName () + ".zip"));
            out = new ZipOutputStream (stream);
            entry = new ZipEntry (prefix);
            entry.setTime (dir2Archive.lastModified ());
            out.putNextEntry (entry);
            for (File cur : dir2Archive.listFiles ()) {
                if (cur.isFile () && cur.canRead ()) {
                    entry = new ZipEntry (prefix + cur.getName ());
                    entry.setTime (cur.lastModified ());
                    entry.setSize (cur.length ());
                    out.putNextEntry (entry);
                    FileInputStream in = new FileInputStream (cur);
                    while ((cRead = in.read (buf, 0, buf.length)) > 0) {
                        out.write (buf, 0, cRead);
                    }
                    in.close ();
                }
            }
        } catch (Throwable t) {
            t.printStackTrace ();
        } finally {
            try {
                if (out != null) out.close ();
            } catch (Throwable t) {
            }
        }
    }
}


public static void extractZip (File jarFile, File destDir) throws IOException {
    java.util.zip.ZipFile jar = new java.util.zip.ZipFile (jarFile);
    java.util.Enumeration en = jar.entries ();
    while (en.hasMoreElements ()) {
        java.util.zip.ZipEntry file = (java.util.zip.ZipEntry) en.nextElement ();
        java.io.File f = new java.io.File (destDir + java.io.File.separator + file.getName ());
        if (file.isDirectory ()) {
            f.mkdir ();
            continue;
        }
        f.getParentFile ().mkdirs ();
        java.io.InputStream is = jar.getInputStream (file);
        java.io.FileOutputStream fos = new java.io.FileOutputStream (f);
        while (is.available () > 0) {
            fos.write (is.read ());
        }
        fos.close ();
        is.close ();
    }
}


-----Function Pair=198=-----==

private void copyFiles (ZipOutputStream out, Pattern includes, Pattern excludes) throws IOException {
    Set possibleDuplicateFiles = new HashSet ();
    for (Iterator i = openedJarFiles.iterator (); i.hasNext ();) {
        JarFile jf = (JarFile) i.next ();
        for (Enumeration e = jf.entries (); e.hasMoreElements ();) {
            ZipEntry entry = (ZipEntry) e.nextElement ();
            String filename = entry.getName ();
            if (excludes != null && excludes.matcher (filename).matches ()) continue;
            if (includes != null && ! includes.matcher (filename).matches ()) continue;
            if (entry.isDirectory () || MANIFEST_FILE_PATTERN.matcher (filename).matches ()) {
                if (possibleDuplicateFiles.contains (entry.getName ())) continue;
                possibleDuplicateFiles.add (entry.getName ());
            }
            copyFile (entry, out, jf.getInputStream (entry));
        }
    }
}


private final void toTar (TarOutputStream out, File file, String path) throws IOException {
    if (file.isFile ()) {
        TarEntry entry = new TarEntry (path + file.getName ());
        if (file.length () > 0) {
            entry.setSize (file.length ());
        }
        out.putNextEntry (entry);
        BufferedInputStream origin = null;
        byte data [] = new byte [BUFFER];
        FileInputStream fi = new FileInputStream (file);
        origin = new BufferedInputStream (fi, BUFFER);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    else {
        File [] files = file.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            toTar (out, files [i], path + file.getName () + "/");
        }
    }
}


-----Function Pair=199=-----==

public static List < File > unzipFiles (File zippedfile, String destPath) throws FileNotFoundException, IOException {
    ZipFile zipFile = new ZipFile (zippedfile);
    Enumeration < ? extends ZipEntry > entries = zipFile.entries ();
    List < File > outputFiles = new ArrayList < File > ();
    while (entries.hasMoreElements ()) {
        ZipEntry entry = entries.nextElement ();
        if (entry.isDirectory ()) {
            (new File (entry.getName ())).mkdir ();
            continue;
        }
        InputStream inputStream = zipFile.getInputStream (entry);
        File outputFile = new File (destPath + File.separator + entry.getName ());
        FileOutputStream outStream = new FileOutputStream (outputFile);
        copyByteStream (inputStream, outStream);
        outputFiles.add (outputFile);
    }
    return outputFiles;
}


public void load (InputStream inStream) throws IOException {
    DateFormat dateFormat = DateFormat.getDateTimeInstance ();
    ZipInputStream zipIn = new ZipInputStream (inStream);
    synchronized (this.trustedListValues) {
        reset ();
        Properties loadHelperVals = new Properties ();
        Properties loadHelperTimestmps = new Properties ();
        ZipEntry zipEntry;
        while ((zipEntry = zipIn.getNextEntry ()) != null) {
            if (zipEntry.getName ().equals (TRUSTED_TIMES_NAME)) {
                loadHelperTimestmps.load (zipIn);
            }
            else if (zipEntry.getName ().equals (TRUSTED_VALUES_NAME)) {
                loadHelperVals.load (zipIn);
            }
        }
        for (Object oIdentifier : loadHelperVals.keySet ()) {
            String curIdentifier = (String) oIdentifier;
            Integer curTrustValue = new Integer (loadHelperVals.getProperty (curIdentifier));
            Long timestmp;
            try {
                timestmp = new Long (dateFormat.parse (loadHelperTimestmps.getProperty (curIdentifier)).getTime ());
            } catch (Exception e) {
                timestmp = new Long (System.currentTimeMillis ());
            }
            this.trustedListValues.put (curIdentifier, curTrustValue);
            if (timestmp != null) this.trustedListTimestamps.put (curIdentifier, timestmp);
        }
    }
}


-----Function Pair=200=-----==

private static List < String > getFilesToZip (String dir2zip) {
    List < String > fileList = new ArrayList < String > ();
    File zipDir = new File (dir2zip);
    String [] dirList = zipDir.list ();
    for (int i = 0; i < dirList.length; i ++) {
        File f = new File (zipDir, dirList [i]);
        if (f.isDirectory ()) {
            String filePath = f.getPath ();
            List < String > subDirFileList = getFilesToZip (filePath);
            fileList.addAll (subDirFileList);
            continue;
        }
        fileList.add (f.getPath ());
    }
    return fileList;
}


public static int selectSaleNumber (String message, Thing seller, Thing buyer, int max) {
    Thing [] things = seller.getItems ();
    Item.tryIdentify (seller, things);
    InventoryScreen is = Game.getQuestapp ().getScreen ().getInventoryScreen ();
    is.setUp (message, buyer, things);
    Game.getQuestapp ().switchScreen (is);
    String line = is.getLine ();
    try {
        if (line.equals ("ESC")) {
            return 0;
        }
        if (line.equals ("") || line.equals ("all")) {
            return max;
        }
        int r = Integer.parseInt (line);
        r = Maths.middle (0, r, max);
        return r;
    } catch (Exception e) {
        Game.warn ("Invalid number in Game.getNumber(...)");
    }
    return 0;
}


-----Function Pair=201=-----==

public static boolean restaurarCopiaSeguridad (File copia) {
    boolean retorno = true;
    try {
        BufferedOutputStream dest = null;
        FileInputStream fis = new FileInputStream (copia);
        ZipInputStream zis = new ZipInputStream (new BufferedInputStream (fis));
        int count;
        byte data [] = new byte [BUFFER];
        ZipEntry entry;
        String destino = DATOS;
        Conexion.apargarBD ();
        while ((entry = zis.getNextEntry ()) != null) {
            if (! entry.isDirectory ()) {
                String entryName = entry.getName ();
                String destFN = destino + entry.getName ();
                FileOutputStream fos = new FileOutputStream (destFN);
                dest = new BufferedOutputStream (fos, BUFFER);
                while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                    dest.write (data, 0, count);
                }
                dest.flush ();
                dest.close ();
            }
        }
        zis.close ();
        Conexion.getConexion ();
        retorno = Conexion.isConectado ();
    } catch (Exception ex) {
        Logger.getLogger (Conexion.class.getName ()).log (Level.SEVERE, null, ex);
        retorno = false;
    }
    return retorno;
}


private Vector < String > getFiles (String dir, AbsTime start, AbsTime end) {
    Vector < String > res = new Vector < String > ();
    TreeMap < Long, String > map = new TreeMap < Long, String > ();
    String [] files = (new File (dir)).list ();
    if (files == null || files.length == 0) {
        return res;
    }
    for (int i = 0; i < files.length; i ++) {
        Date date = null;
        if (isCompressed (files [i])) {
            date = getDateTime (files [i].substring (0, files [i].length () - 4));
        }
        else {
            date = getDateTime (files [i]);
        }
        if (date == null) {
            System.err.println ("PointArchiverASCII:getFiles: Bad File Name " + files [i] + " in directory " + dir);
            continue;
        }
        AbsTime atime = AbsTime.factory (date);
        map.put (new Long (atime.getValue ()), files [i]);
    }
    Iterator it = map.keySet ().iterator ();
    boolean hit = false;
    Object prevkey = null;
    while (it.hasNext ()) {
        Object key = it.next ();
        AbsTime ftime = AbsTime.factory (((Long) key).longValue ());
        if (ftime.isBefore (start)) {
            prevkey = key;
        }
        else if (ftime.isAfter (end)) {
            if (! hit) {
                if (prevkey != null) {
                    hit = true;
                    res.add (map.get (prevkey));
                }
            }
            break;
        }
        else {
            if (! hit) {
                hit = true;
                if (prevkey != null) {
                    res.add (map.get (prevkey));
                }
            }
            res.add (map.get (key));
        }
    }
    if (! hit) {
        if (prevkey != null) {
            res.add (map.get (prevkey));
        }
    }
    return res;
}


-----Function Pair=202=-----=1=

private boolean writeEntry (File f, JarOutputStream out, int depth) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            i = f.getPath ().length ();
            fPath = f.getPath ();
            for (int a = 0; a <= depth; a ++) {
                i = fPath.lastIndexOf (FILESEPARATOR, i) - 1;
            }
            en = fPath.substring (i + 2, fPath.length ());
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, depth + 1);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


public void doZip () {
    String filename = "";
    try {
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream (outputfilename);
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
        byte data [] = new byte [BUFFER];
        Set < String > keys = files.keySet ();
        for (String key : keys) {
            filename = key;
            String fpath = files.get (key);
            FileInputStream fi = new FileInputStream (fpath);
            origin = new BufferedInputStream (fi, BUFFER);
            ZipEntry entry = new ZipEntry (key);
            out.putNextEntry (entry);
            int count;
            while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                out.write (data, 0, count);
            }
            origin.close ();
        }
        out.close ();
        zipComplete = true;
    } catch (FileNotFoundException e) {
        Activator.getDefault ().showMessage (bundle.getString ("Missing_File") + ": " + filename);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


-----Function Pair=203=-----=1=

private boolean writeEntry (File f, JarOutputStream out, int depth) {
    String en = "";
    File [] dContent;
    int i;
    String fPath;
    byte [] buffer = new byte [BUFFERSIZE];
    int bytes_read;
    try {
        if (f.isDirectory () == false) {
            BufferedInputStream in = new BufferedInputStream (new FileInputStream (f), BUFFERSIZE);
            i = f.getPath ().length ();
            fPath = f.getPath ();
            for (int a = 0; a <= depth; a ++) {
                i = fPath.lastIndexOf (FILESEPARATOR, i) - 1;
            }
            en = fPath.substring (i + 2, fPath.length ());
            out.putNextEntry (new ZipEntry (en));
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
                if (aborted) {
                    in.close ();
                    out.closeEntry ();
                    return false;
                }
                writtenBytes += bytes_read;
            }
            in.close ();
            out.closeEntry ();
            return true;
        }
        else {
            dContent = f.listFiles ();
            for (int a = 0; a < dContent.length; a ++) {
                writeEntry (dContent [a], out, depth + 1);
                if (aborted) {
                    return false;
                }
            }
        }
    } catch (Exception e) {
        System.out.println ("[writeEntry(), JarWriter] ERROR\n" + e);
        return false;
    }
    return true;
}


public void deleteEntries (String [] entries) {
    ZipOutputStream zout = null;
    ZipInputStream zin = null;
    File tmpzip = null;
    try {
        tmpzip = File.createTempFile ("zip", ".tmp", new File ("."));
        zin = new ZipInputStream (new FileInputStream (selfFile));
        zout = new ZipOutputStream (new FileOutputStream (tmpzip));
        ZipEntry ze;
        int len = 0;
        byte [] b = new byte [4096];
        while ((ze = zin.getNextEntry ()) != null) {
            if (getContainEntry (ze.getName (), entries) != - 1) {
                zin.closeEntry ();
                count --;
                continue;
            }
            zout.putNextEntry (new ZipEntry (ze.getName ()));
            while ((len = zin.read (b)) != - 1) {
                zout.write (b, 0, len);
            }
            zout.closeEntry ();
            zin.closeEntry ();
        }
        zout.close ();
        zin.close ();
        String slefFileName = selfFile.getPath ();
        selfFile.delete ();
        tmpzip.renameTo (new File (slefFileName));
        selfFile = new File (slefFileName);
        isChanged = true;
    } catch (IOException e) {
        logger.error (e.getLocalizedMessage ());
    }
}


-----Function Pair=204=-----==

public void start () {
    if (! processProperties ()) return;
    try {
        log (VAGlobals.i18n ("VAArchiver_CompressingFiles"));
        archiveInfos_ = new ByteArrayOutputStream ();
        File zip = makeArchive ("archive.zip");
        zip.deleteOnExit ();
        System.out.println (VAGlobals.i18n ("VAArchiver_CreatingJarFiles"));
        archiveInfos_.flush ();
        byte [] infosbytes = archiveInfos_.toByteArray ();
        File jar = makeJar ("install.jar", zip, license_, readme_, infosbytes);
        jarSize_ = jar.length ();
        archiveInfos_.close ();
        jar.deleteOnExit ();
        File installJavaFile = new File (instClassName_ + ".java");
        installJavaFile.deleteOnExit ();
        File instClass = null;
        boolean deleteInstallClass = true;
        for (int i = 0; i < targets_.length; i ++) {
            System.out.println ();
            System.out.println (targets_ [i] + VAGlobals.i18n ("VAArchiver_Target"));
            currentTarget_ = targets_ [i];
            System.out.println (VAGlobals.i18n ("VAArchiver_GeneratingInstallClass"));
            generateInstallCode (installJavaFile, "com/memoire/vainstall/resources/Install.vaitpl", "com/memoire/vainstall/VAClassLoader.class");
            System.out.println (VAGlobals.i18n ("VAArchiver_CompilingInstallClass"));
            instClass = compile (installJavaFile.getName ());
            installClassSize_ = instClass.length ();
            VAGlobals.printDebug ("  InstallClass size=" + installClassSize_);
            if ("jar".equals (targets_ [i])) {
                File jarTarget = new File (instClassName_ + ".jar");
                File mfFile = new File (instClassName_ + ".mf");
                mfFile.deleteOnExit ();
                System.out.println (VAGlobals.i18n ("VAArchiver_CreatingManifestFile"));
                generateManifestFile (mfFile);
                System.out.println (VAGlobals.i18n ("VAArchiver_UpdatingJarFile"));
                copy (jar, jarTarget);
                jar ("uvfm", jarTarget, new File [] {mfFile, instClass});
                if (jarAlias_ != null && ! "".equals (jarAlias_.trim ()) && jarPassphrase_ != null && ! "".equals (jarPassphrase_.trim ())) {
                    System.out.println (VAGlobals.i18n ("VAArchiver_SigningJarFile"));
                    jarsign (jarPassphrase_, jarTarget, jarAlias_);
                }
            }
            else if ("jnlp".equals (targets_ [i])) {
                File jnlpFile = new File (instClassName_ + ".jnlp");
                System.out.println (VAGlobals.i18n ("VAArchiver_CreatingJnlpFile"));
                generateJnlpFile (jnlpFile);
            }
            else if ("java".equals (targets_ [i])) {
                installClassOffset_ = - 10987654321L;
                deleteInstallClass = false;
                if (archMethod_.equals ("append")) {
                    archOffset_ = instClass.length ();
                    VAGlobals.printDebug (VAGlobals.i18n ("VAArchiver_ArchiveOffset") + archOffset_);
                    generateInstallCode (installJavaFile, "com/memoire/vainstall/resources/Install.vaitpl", "com/memoire/vainstall/VAClassLoader.class");
                    System.out.println (VAGlobals.i18n ("VAArchiver_CompilingInstallClass"));
                    compile (installJavaFile.getName ());
                    System.out.println (VAGlobals.i18n ("VAArchiver_AppendingArchive"));
                    appendArchive (instClass);
                }
            }
            else if ("unix".equals (targets_ [i])) {
                File unixShellFile = new File (instClassName_ + ".sh");
                installClassOffset_ = generateUnixInstallShell (unixShellFile, "com/memoire/vainstall/resources/Install-sh.vaitpl", instClass);
                VAGlobals.printDebug (VAGlobals.i18n ("VAArchiver_InstallClassOffset") + installClassOffset_);
                if (archMethod_.equals ("append")) {
                    archOffset_ = unixShellFile.length ();
                    VAGlobals.printDebug (VAGlobals.i18n ("VAArchiver_ArchiveOffset") + archOffset_);
                    generateInstallCode (installJavaFile, "com/memoire/vainstall/resources/Install.vaitpl", "com/memoire/vainstall/VAClassLoader.class");
                    System.out.println (VAGlobals.i18n ("VAArchiver_CompilingInstallClass"));
                    compile (installJavaFile.getName ());
                    generateUnixInstallShell (unixShellFile, "com/memoire/vainstall/resources/Install-sh.vaitpl", instClass);
                    System.out.println (VAGlobals.i18n ("VAArchiver_AppendingArchive"));
                    appendArchive (unixShellFile);
                }
            }
            else if (("win95".equals (targets_ [i])) || ("linux-i386".equals (targets_ [i]))) {
                File nativeExeFile = null;
                if ("win95".equals (targets_ [i])) nativeExeFile = new File (instClassName_ + ".exe");
                else if ("linux-i386".equals (targets_ [i])) nativeExeFile = new File (instClassName_ + ".lin");
                installClassOffset_ = generateNativeInstallExe (nativeExeFile, "com/memoire/vainstall/resources/Install-" + targets_ [i] + "-exe.vaitpl", instClass);
                VAGlobals.printDebug (VAGlobals.i18n ("VAArchiver_InstallClassOffset") + installClassOffset_);
                if (archMethod_.equals ("append")) {
                    archOffset_ = nativeExeFile.length ();
                    VAGlobals.printDebug (VAGlobals.i18n ("VAArchiver_ArchiveOffset") + archOffset_);
                    generateInstallCode (installJavaFile, "com/memoire/vainstall/resources/Install.vaitpl", "com/memoire/vainstall/VAClassLoader.class");
                    System.out.println (VAGlobals.i18n ("VAArchiver_CompilingInstallClass"));
                    compile (installJavaFile.getName ());
                    generateNativeInstallExe (nativeExeFile, "com/memoire/vainstall/resources/Install-" + targets_ [i] + "-exe.vaitpl", instClass);
                    System.out.println (VAGlobals.i18n ("VAArchiver_AppendingArchive"));
                    appendArchive (nativeExeFile);
                }
            }
        }
        if (instClass != null && deleteInstallClass) instClass.delete ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


public static void main (String [] args) throws ZipException, IOException, JSchException {
    String targetVersion = ManagerOptions.getInstance ().getVersion ();
    File oldJarVersion = new File ("C:\\Users\\Shirkit\\Dropbox\\HonModManager\\Dropbox\\Public\\versions\\Manager.jar");
    File newJarVersion = new File ("store\\Manager.jar");
    String verionsFile = "C:\\Users\\Shirkit\\Dropbox\\HonModManager\\Dropbox\\Public\\versions.txt";
    File rootVersionsFolder = new File ("C:\\Users\\Shirkit\\Dropbox\\HonModManager\\Dropbox\\Public\\versions\\");
    File output = new File (rootVersionsFolder, targetVersion + ".jar");
    System.out.println ("Version to be released=" + targetVersion);
    System.out.println ("Old version file=" + oldJarVersion.getAbsolutePath ());
    System.out.println ("New version file=" + newJarVersion.getAbsolutePath ());
    System.out.println ();
    if (calculate (oldJarVersion, newJarVersion, output.getAbsolutePath ())) {
        System.out.println ("Output file generated.\nPath=" + output.getAbsolutePath () + "\nSize=" + output.length () / 1024 + "KB");
        FileInputStream fis = new FileInputStream (verionsFile);
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        copyInputStream (fis, baos);
        String s = baos.toString ();
        fis.close ();
        baos.close ();
        System.out.println (s);
        if (! s.trim ().isEmpty ()) {
            if (s.contains ("\n")) {
                System.out.println ("Older version=" + s.substring (0, s.indexOf ("\n")));
            }
            else {
                System.out.println ("Older version=" + s);
            }
            s = targetVersion + "\n" + s;
        }
        else {
            System.out.println ("First version!");
            s = targetVersion;
        }
        if (JOptionPane.showConfirmDialog (null, "Confirm upload?", "Confirmation", JOptionPane.YES_NO_OPTION) != 0) {
            System.exit (0);
        }
        FileWriter fw = new FileWriter (verionsFile);
        fw.write (s);
        fw.flush ();
        fw.close ();
        System.out.println ("Versions file written with sucess!");
        fis = new FileInputStream (newJarVersion);
        FileOutputStream fos = new FileOutputStream (rootVersionsFolder + File.separator + "Manager.jar");
        copyInputStream (fis, fos);
        fis.close ();
        fos.close ();
        System.out.println ("Manager.jar file written!");
        System.out.println ();
    }
    else {
        System.err.println ("No differences file. Output file not generated.");
        System.exit (0);
    }
    JSch jsch = new JSch ();
    Session session = null;
    try {
        System.out.println ("Connecting to SF");
        session = jsch.getSession (JOptionPane.showInputDialog ("SourceForge Username") + ",all-inhonmodman", "frs.sourceforge.net", 22);
        session.setConfig ("StrictHostKeyChecking", "no");
        session.setPassword (JOptionPane.showInputDialog ("SourceForge Password"));
        session.connect ();
        Channel channel = session.openChannel ("sftp");
        channel.connect ();
        ChannelSftp sftpChannel = (ChannelSftp) channel;
        System.out.println ("Connected!");
        String root = "/home/frs/project/a/al/all-inhonmodman";
        sftpChannel.cd (root);
        StringTokenizer versionTokens = new StringTokenizer (targetVersion, " ");
        boolean flag = true;
        while (versionTokens.hasMoreTokens ()) {
            String s = versionTokens.nextToken ();
            if (! cdExists (sftpChannel, s)) {
                sftpChannel.mkdir (s);
                flag = false;
            }
            sftpChannel.cd (s);
        }
        if (flag) {
            System.err.println ("Version already exists!");
            sftpChannel.exit ();
            session.disconnect ();
            System.exit (0);
        }
        System.out.println ("Uploading file");
        OutputStream out = sftpChannel.put ("Manager.jar");
        FileInputStream fis = new FileInputStream (newJarVersion);
        copyInputStream (fis, out);
        out.close ();
        fis.close ();
        System.out.println ("Upload complete");
        sftpChannel.exit ();
        session.disconnect ();
        System.out.println ("SUCESS!");
    } catch (JSchException e) {
        e.printStackTrace ();
    } catch (SftpException e) {
        e.printStackTrace ();
    }
    System.exit (0);
}


-----Function Pair=205=-----==

private File makeJar (String filename, File archive, File license, File readme, byte [] archiveInfos) throws IOException {
    File jar = new File (filename);
    JarOutputStream out = new JarOutputStream (new FileOutputStream (jar));
    copyInternalToJar (out, JAR_FILES_COMMON);
    copyInternalToJar (out, JAR_FILES_JNIREGISTRY);
    copyInternalToJar (out, JAR_FILES_JNISHORTCUT);
    copyInternalToJar (out, JAR_FILES_TEXT_UI);
    copyInternalToJar (out, JAR_FILES_ANSI_UI);
    if (uiMode_.equals ("graphic") == true) {
        copyInternalToJar (out, JAR_FILES_GRAPHIC_UI);
    }
    if (uiMode_.equals ("xtra") == true) {
        copyInternalToJar (out, JAR_FILES_XTRA_UI);
    }
    addToJar (out, new ByteArrayInputStream (archiveInfos), "com/memoire/vainstall/archive_infos", archiveInfos.length);
    addToJar (out, new FileInputStream (archive), "com/memoire/vainstall/archive.zip", archive.length ());
    InputStream licenseStream = new FileInputStream (license);
    String licenseEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.license.encoding");
    if (licenseEncoding == null || licenseEncoding.equals ("") == true) {
        licenseEncoding = new InputStreamReader (licenseStream).getEncoding ();
    }
    InputStreamReader isrLicense = new InputStreamReader (licenseStream, licenseEncoding);
    addToJarEncoded (out, isrLicense, "com/memoire/vainstall/license.txt", license.length ());
    InputStream readmeStream = new FileInputStream (readme);
    String readmeEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.readme.encoding");
    if (readmeEncoding == null || readmeEncoding.equals ("") == true) {
        readmeEncoding = new InputStreamReader (readmeStream).getEncoding ();
    }
    InputStreamReader isrReadme = new InputStreamReader (readmeStream, readmeEncoding);
    addToJarEncoded (out, isrReadme, "com/memoire/vainstall/readme.txt", readme.length ());
    InputStream invaiimage = null;
    try {
        invaiimage = new FileInputStream (new File (image_));
    } catch (Exception exc) {
        image_ = "/" + image_;
        invaiimage = getClass ().getResourceAsStream (image_);
    }
    if (invaiimage == null) {
        invaiimage = getClass ().getResourceAsStream (IMAGE_KEY);
        image_ = "com/memoire/vainstall/resources/banner.gif";
    }
    if (invaiimage != null) {
        addToJar (out, invaiimage, IMAGE_KEY, invaiimage.available ());
    }
    InputStream invailogo = getClass ().getResourceAsStream ("/" + VAILOGO);
    addToJar (out, invailogo, VAILOGO, invailogo.available ());
    invailogo.close ();
    ByteArrayOutputStream poutstream = new ByteArrayOutputStream ();
    installProperties.store (poutstream, VAGlobals.NAME + " " + VAGlobals.VERSION);
    ByteArrayInputStream pinstream = new ByteArrayInputStream (poutstream.toByteArray ());
    addToJar (out, pinstream, "com/memoire/vainstall/resources/vainstall.properties", poutstream.toByteArray ().length);
    out.close ();
    return jar;
}


public ActionForward massiveMoveToTrash (ActionMapping mapping, ActionForm form, PortletConfig portletConfig, PortletRequest request, PortletResponse response) throws CMSRuntimeException {
    ContentManager contentManager = ManagerRegistry.getContentManager ();
    DirectoryPersister directoryPersister = ManagerRegistry.getDirectoryPersister ();
    String worldId = LiferayHelperFactory.getLiferayHelper ().getWorldId (form, ListContentsAction.CURRENT_WORLD_ID_PARAM, request);
    ActionMessages msgs = new ActionMessages ();
    ActionMessages errors = new ActionMessages ();
    try {
        DirectoryFolder currentFolder = currentFolder (request);
        if (isMainFolder (currentFolder)) {
            errors.add (ActionMessages.GLOBAL_MESSAGE, new ActionMessage ("content_admin.massiveMoveToTrash.error.root.can.not.be.removed"));
            saveErrors (request, errors);
            ActionForward forward = new ActionForward ("moveToTrash?worldId=" + worldId, null, true);
            return forward;
        }
        String workspace = currentWorkspace (request);
        Node currentFolderNode = JCRUtil.getNodeById (currentFolder.getId (), workspace);
        Node parentNode = currentFolderNode.getParent ();
        String parentFolderId = parentNode.getIdentifier ();
        recursiveMoveToTrash (contentManager, directoryPersister, msgs, currentFolder);
        request.getPortletSession ().setAttribute (CMSPortletAction.CURRENT_FOLDER_ID, parentFolderId);
        request.getPortletSession ().setAttribute (CMSPortletAction.CURRENT_WORKSPACE, workspace);
    } catch (MalformedDirectoryItemException e) {
        String msg = "MalformedDirectoryItemException at massiveMoveToTrash";
        log.error (msg);
        throw new CMSRuntimeException (msg, e);
    } catch (DirectoryItemNotFoundException e) {
        String msg = "DirectoryItemNotFoundException at massiveMoveToTrash";
        log.error (msg);
        throw new CMSRuntimeException (msg, e);
    } catch (RepositoryException e) {
        String msg = "RepositoryException at massiveMoveToTrash";
        log.error (msg);
        throw new CMSRuntimeException (msg, e);
    } catch (ContentNotFoundException e) {
        String msg = "ContentNotFoundException at massiveMoveToTrash";
        log.error (msg);
        throw new CMSRuntimeException (msg, e);
    }
    saveMessages (request, msgs);
    saveErrors (request, errors);
    ActionForward forward = new ActionForward ("moveToTrash?worldId=" + worldId, null, true);
    return forward;
}


-----Function Pair=206=-----==

public static void packeAlleDrinkObjekte (String zipfile) {
    File f = new File (".");
    try {
        String entries [] = f.list (new DrnFilenameFilter ());
        byte [] buf = new byte [BLOCKSIZE];
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipfile));
        for (int i = 0; i < entries.length; ++ i) {
            File ff = new File (entries [i]);
            System.out.println ("adding " + ff);
            FileReader in = new FileReader (ff);
            out.putNextEntry (new ZipEntry (entries [i]));
            int len;
            while ((len = in.read ()) > 0) {
                out.write (len);
            }
            in.close ();
            in = null;
            FileUtil.deleteFile (ff);
        }
        out.close ();
        out = null;
    } catch (IOException e) {
        System.err.println (e.toString ());
    }
}


private void writeBinaryObjects (List < Integer > recordIDs, List < Integer > uploadIDs, String aTempDir, BASE64Encoder encoder) throws IOException {
    int counter = 0;
    int skip = 0;
    List < Integer > allIDs = new ArrayList < Integer > ();
    allIDs.addAll (recordIDs);
    allIDs.addAll (uploadIDs);
    log.info ("writing XMLs for bytestreams of digital objects. Size = " + allIDs.size ());
    for (Integer id : allIDs) {
        if (counter > 200 * 1024 * 1024) {
            System.gc ();
            counter = 0;
        }
        DigitalObject object = em.find (DigitalObject.class, id);
        if (object.isDataExistent ()) {
            counter += object.getData ().getSize ();
            File f = new File (aTempDir + object.getId () + ".xml");
            writeBinaryData (id, object.getData (), f, encoder);
        }
        else {
            skip ++;
        }
        object = null;
    }
    em.clear ();
    System.gc ();
    log.info ("finished writing bytestreams of digital objects. skipped empty objects: " + skip);
}


-----Function Pair=207=-----==

public void save (File saveFile) throws IOException {
    boolean replace = false;
    if (saveFile == null) {
        replace = true;
        saveFile = File.createTempFile ("zodiak-", ".zip");
    }
    ZipInputStream zIn = new ZipInputStream (new FileInputStream (docFile));
    ZipOutputStream zOut = new ZipOutputStream (new FileOutputStream (saveFile));
    ZipEntry entry = null;
    while ((entry = zIn.getNextEntry ()) != null) {
        String name = entry.getName ();
        zOut.putNextEntry (entry);
        if (tempFiles.containsKey (name)) {
            FileInputStream tmpIn = new FileInputStream (tempFiles.get (name));
            copy (tmpIn, zOut);
            tmpIn.close ();
        }
        else {
            copy (zIn, zOut);
        }
        zIn.closeEntry ();
        zOut.closeEntry ();
    }
    zIn.close ();
    zOut.close ();
    if (replace) {
        saveFile.renameTo (docFile);
    }
    close ();
}


private void addFileToZip (File file, EntryConfigurationListener callback) throws IOException {
    String abs = file.getAbsolutePath ();
    abs = abs.substring (startFromLen + 1);
    ZipEntry entry = new ZipEntry (abs);
    if (callback != null) callback.configure (entry);
    output.putNextEntry (entry);
    try {
        FileInputStream fis = new FileInputStream (file);
        BufferedInputStream bis = new BufferedInputStream (fis, 2048);
        try {
            int readIn;
            while ((readIn = bis.read (buff)) > 0) output.write (buff, 0, readIn);
        } finally {
            bis.close ();
        }
    } finally {
        output.closeEntry ();
    }
}


-----Function Pair=208=-----==

public void test_getJarFile () throws MalformedURLException, IOException {
    URL url = null;
    url = createContent ("lf.jar", "missing");
    JarURLConnection connection = null;
    connection = (JarURLConnection) url.openConnection ();
    try {
        connection.connect ();
        fail ("Did not throw exception on connect");
    } catch (IOException e) {
    }
    try {
        connection.getJarFile ();
        fail ("Did not throw exception after connect");
    } catch (IOException e) {
    }
    URL invURL = createContent ("InvalidJar.jar", "Test.class");
    JarURLConnection juConn = (JarURLConnection) invURL.openConnection ();
    try {
        juConn.getJarFile ();
        fail ("IOException was not thrown.");
    } catch (java.io.IOException io) {
    }
    File resources = Support_Resources.createTempFolder ();
    Support_Resources.copyFile (resources, null, "hyts_att.jar");
    File file = new File (resources.toString () + "/hyts_att.jar");
    URL fUrl1 = new URL ("jar:file:" + file.getPath () + "!/");
    JarURLConnection con1 = (JarURLConnection) fUrl1.openConnection ();
    ZipFile jf1 = con1.getJarFile ();
    JarURLConnection con2 = (JarURLConnection) fUrl1.openConnection ();
    ZipFile jf2 = con2.getJarFile ();
    assertTrue ("file: JarFiles not the same", jf1 == jf2);
    jf1.close ();
    assertTrue ("File should exist", file.exists ());
    fUrl1 = createContent ("lf.jar", "");
    con1 = (JarURLConnection) fUrl1.openConnection ();
    jf1 = con1.getJarFile ();
    con2 = (JarURLConnection) fUrl1.openConnection ();
    jf2 = con2.getJarFile ();
    assertTrue ("http: JarFiles not the same", jf1 == jf2);
    jf1.close ();
}


public static void backupGardenia (String gardeniaHome, String backupFile) throws Exception {
    gardeniaHome = '\\' == File.separatorChar ? gardeniaHome.replace ('\\', '/') : gardeniaHome;
    gardeniaHome = gardeniaHome.endsWith ("/") ? gardeniaHome : gardeniaHome + "/";
    List allToZip = getFilesRecursive (new File (gardeniaHome + "data"));
    byte [] buffer = new byte [4096];
    FileOutputStream out = new FileOutputStream (backupFile);
    ZipOutputStream zout = new ZipOutputStream (out);
    zout.setLevel (9);
    int baseNameSize = gardeniaHome.length ();
    for (Iterator it = allToZip.iterator (); it.hasNext ();) {
        File f = (File) it.next ();
        if (f.getName ().equals ("gardenia01.lck")) continue;
        ZipEntry zipEntry = new ZipEntry (f.getCanonicalPath ().substring (baseNameSize));
        zipEntry.setTime (f.lastModified ());
        zout.putNextEntry (zipEntry);
        FileInputStream fis = new FileInputStream (f);
        int bytes = 0;
        while ((bytes = fis.read (buffer, 0, buffer.length)) > 0) {
            zout.write (buffer, 0, bytes);
        }
        fis.close ();
    }
    zout.close ();
    out.close ();
}


-----Function Pair=209=-----==

public ProgressDialog (Frame _owner, int _steps, String _title, Dimension _size) {
    super (_owner);
    totalSteps = _steps;
    setTitle (_title);
    setSize (_size);
    setModal (false);
    getContentPane ().setLayout (new java.awt.BorderLayout ());
    JPanel progressPanel = new JPanel () {
        public Insets getInsets () {
            return new Insets (15, 10, 5, 10);
        }
    }
    ;
    progressPanel.setLayout (new BoxLayout (progressPanel, BoxLayout.Y_AXIS));
    getContentPane ().add (progressPanel, BorderLayout.CENTER);
    Dimension d = new Dimension (_size.width, 20);
    progressLabel = new JLabel (_title);
    progressLabel.setAlignmentX (CENTER_ALIGNMENT);
    progressLabel.setMaximumSize (d);
    progressLabel.setPreferredSize (d);
    progressPanel.add (progressLabel);
    progressPanel.add (Box.createRigidArea (new Dimension (1, 20)));
    progressBar = new JProgressBar (0, totalSteps);
    progressBar.setStringPainted (true);
    progressLabel.setLabelFor (progressBar);
    progressBar.setAlignmentX (CENTER_ALIGNMENT);
    progressPanel.add (progressBar);
    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    setLocation ((screenSize.width - _size.width) / 2, (screenSize.height - _size.width) / 2);
    getContentPane ().add (progressPanel, BorderLayout.CENTER);
    setCursor (new Cursor (Cursor.WAIT_CURSOR));
    setVisible (true);
}


private static int zipRecurs (final File _rootDir, final File _dir, final ZipOutputStream _zos, ProgressionInterface _prog, int nbFiles, int indFile) throws IOException {
    URI root = _rootDir.toURI ();
    for (File f : _dir.listFiles ()) {
        String name = root.relativize (f.toURI ()).getPath ();
        if (f.isDirectory ()) {
            _zos.putNextEntry (new ZipEntry (name.endsWith ("/") ? name : name + "/"));
            _zos.closeEntry ();
            indFile = zipRecurs (_rootDir, f, _zos, _prog, nbFiles, indFile);
        }
        else {
            _zos.putNextEntry (new ZipEntry (name));
            FileInputStream finp = new FileInputStream (f);
            copyStream (finp, _zos, true, false);
            _zos.closeEntry ();
        }
        if (_prog != null) {
            indFile ++;
            _prog.setProgression ((int) ((indFile / (double) nbFiles) * 85) + 10);
        }
    }
    return indFile;
}


-----Function Pair=210=-----==

private void GetSiteImageFtps (ZipFile file) throws Exception {
    java.util.Enumeration files = file.entries ();
    while (files.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) files.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().endsWith (".iftp")) {
                InputStream in = file.getInputStream (entry);
                java.io.InputStreamReader r = new InputStreamReader (in, "UTF-8");
                java.io.BufferedReader br = new BufferedReader (r);
                String host_name = null;
                String s = br.readLine ();
                if (s != null) host_name = s.trim ();
                String host_remotedir = null;
                s = br.readLine ();
                if (s != null) host_remotedir = s.trim ();
                String host_remoteport = null;
                s = br.readLine ();
                if (s != null) host_remoteport = s.trim ();
                int host_port = 21;
                try {
                    host_port = (int) Float.parseFloat (host_remoteport);
                } catch (Exception e1) {
                }
                String host_username = null;
                s = br.readLine ();
                if (s != null) host_username = s.trim ();
                String host_userpassword = null;
                s = br.readLine ();
                if (s != null) host_userpassword = s.trim ();
                AddFtp4Image (host_name, host_remotedir, host_port, host_username, host_userpassword);
                try {
                    br.close ();
                } catch (Exception e1) {
                }
            }
        }
    }
}


public int process () throws TransformerException, IOException, SAXException {
    ZipInputStream zis = new ZipInputStream (input);
    final ZipOutputStream zos = new ZipOutputStream (output);
    final OutputStreamWriter osw = new OutputStreamWriter (zos);
    Thread.currentThread ().setContextClassLoader (getClass ().getClassLoader ());
    TransformerFactory tf = TransformerFactory.newInstance ();
    if (! tf.getFeature (SAXSource.FEATURE) || ! tf.getFeature (SAXResult.FEATURE)) {
        return 0;
    }
    SAXTransformerFactory saxtf = (SAXTransformerFactory) tf;
    Templates templates = null;
    if (xslt != null) {
        templates = saxtf.newTemplates (xslt);
    }
    EntryElement entryElement = getEntryElement (zos);
    ContentHandler outDocHandler = null;
    switch (outRepresentation) {
        case BYTECODE :
            outDocHandler = new OutputSlicingHandler (new ASMContentHandlerFactory (zos, computeMax), entryElement, false);
            break;
        case MULTI_XML :
            outDocHandler = new OutputSlicingHandler (new SAXWriterFactory (osw, true), entryElement, true);
            break;
        case SINGLE_XML :
            ZipEntry outputEntry = new ZipEntry (SINGLE_XML_NAME);
            zos.putNextEntry (outputEntry);
            outDocHandler = new SAXWriter (osw, false);
            break;
    }
    ContentHandler inDocHandler = null;
    if (templates == null) {
        inDocHandler = outDocHandler;
    }
    else {
        inDocHandler = new InputSlicingHandler ("class", outDocHandler, new TransformerHandlerFactory (saxtf, templates, outDocHandler));
    }
    ContentHandlerFactory inDocHandlerFactory = new SubdocumentHandlerFactory (inDocHandler);
    if (inDocHandler != null && inRepresentation != SINGLE_XML) {
        inDocHandler.startDocument ();
        inDocHandler.startElement ("", "classes", "classes", new AttributesImpl ());
    }
    int i = 0;
    ZipEntry ze = null;
    while ((ze = zis.getNextEntry ()) != null) {
        update (ze.getName (), n ++);
        if (isClassEntry (ze)) {
            processEntry (zis, ze, inDocHandlerFactory);
        }
        else {
            OutputStream os = entryElement.openEntry (getName (ze));
            copyEntry (zis, os);
            entryElement.closeEntry ();
        }
        i ++;
    }
    if (inDocHandler != null && inRepresentation != SINGLE_XML) {
        inDocHandler.endElement ("", "classes", "classes");
        inDocHandler.endDocument ();
    }
    if (outRepresentation == SINGLE_XML) {
        zos.closeEntry ();
    }
    zos.flush ();
    zos.close ();
    return i;
}


-----Function Pair=211=-----==

private void addFiles (final File work, final ZipOutputStream zipStream) throws IOException {
    File [] files = work.listFiles ();
    int cut = runnerDir.getAbsolutePath ().length () - runnerDir.getName ().length ();
    for (int i = 0; i < files.length; i ++) {
        File f = files [i];
        if (f.isDirectory ()) {
            addFiles (f, zipStream);
        }
        else if (! f.isHidden ()) {
            String fileName = f.getAbsolutePath ().substring (cut);
            zipStream.putNextEntry (new ZipEntry (fileName));
            InputStream input = new FileInputStream (f);
            byte [] buffer = new byte [1024];
            int b;
            while ((b = input.read (buffer)) != - 1) zipStream.write (buffer, 0, b);
            input.close ();
        }
    }
}


private static File recursiveFileSearch (String location, String name) {
    File found = null;
    File folder = new File (location);
    File [] listOfFiles = folder.listFiles (new FileFilter () {
        @Override
        public boolean accept (File file) {
            boolean isJPG = file.getName ().toLowerCase ().endsWith (".jpg");
            boolean isDir = file.isDirectory ();
            return isJPG || isDir;
        }
    }
    );
    for (int i = 0; i < listOfFiles.length && found == null; i ++) {
        File current = listOfFiles [i];
        if (! current.isDirectory () && current.getName ().contains (name)) {
            found = current;
            break;
        }
        else {
            found = recursiveFileSearch (current.getAbsolutePath (), name);
        }
    }
    return found;
}


-----Function Pair=212=-----==

private void GetSiteArticleFtps (ZipFile file) throws Exception {
    java.util.Enumeration files = file.entries ();
    while (files.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) files.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().endsWith (".aftp")) {
                InputStream in = file.getInputStream (entry);
                java.io.InputStreamReader r = new InputStreamReader (in, "UTF-8");
                java.io.BufferedReader br = new BufferedReader (r);
                String host_name = null;
                String s = br.readLine ();
                if (s != null) host_name = s.trim ();
                String host_remotedir = null;
                s = br.readLine ();
                if (s != null) host_remotedir = s.trim ();
                String host_remoteport = null;
                s = br.readLine ();
                if (s != null) host_remoteport = s.trim ();
                int host_port = 21;
                try {
                    host_port = (int) Float.parseFloat (host_remoteport);
                } catch (Exception e1) {
                }
                String host_username = null;
                s = br.readLine ();
                if (s != null) host_username = s.trim ();
                String host_userpassword = null;
                s = br.readLine ();
                if (s != null) host_userpassword = s.trim ();
                AddFtp4Article (host_name, host_remotedir, host_port, host_username, host_userpassword);
                try {
                    br.close ();
                } catch (Exception e1) {
                }
            }
        }
    }
}


private void saveZipArchive (Object session, ZipInputStream archiveIn, ArchivePath archive, String savePath, String outputFile, Component comp) throws IOException {
    OutputStream out = null;
    VFS vfs = VFSManager.getVFSForPath (savePath);
    long length = new File (outputFile).length ();
    try {
        out = vfs._createOutputStream (session, savePath, comp);
        out = new ZipOutputStream (out);
        ZipOutputStream archiveOut = (ZipOutputStream) out;
        boolean saved = false;
        for (;;) {
            ZipEntry next = archiveIn.getNextEntry ();
            if (next == null) break;
            Log.log (Log.DEBUG, this, "Copy entry " + next);
            if (next.getName ().equals (archive.entryName)) {
                next = new ZipEntry (archive.entryName);
                archiveOut.putNextEntry (next);
                copy (outputFile, archiveOut);
                saved = true;
            }
            else {
                archiveOut.putNextEntry (next);
                copy (archiveIn, archiveOut);
            }
            archiveOut.closeEntry ();
        }
        if (! saved) {
            ZipEntry newEntry = new ZipEntry (archive.entryName);
            newEntry.setSize (length);
            archiveOut.putNextEntry (newEntry);
            copy (outputFile, archiveOut);
            saved = true;
            archiveOut.closeEntry ();
        }
    } finally {
        IOUtilities.closeQuietly (out);
    }
}


-----Function Pair=213=-----==

private static void createJarFilesWith (ZipOutputStream out, List < String > filesFullPath) {
    byte [] data = new byte [COMPRESS_OUTPUTSTREAM_BUFFER_SIZE];
    BufferedInputStream origin = null;
    int counter = 0;
    for (Iterator < ? > i = filesFullPath.iterator (); i.hasNext ();) {
        String filename = (String) i.next ();
        try {
            addFileToJar (origin, out, data, filename);
            counter ++;
        } catch (FileNotFoundException e) {
            logger.error ("File '" + filename + "' couldn't be added to jar file because it doesn't exist file.", e);
        } catch (IOException e1) {
            logger.error ("File '" + filename + "' couldn't be added to jar file cause of an input/ouput error.", e1);
        }
    }
    try {
        out.close ();
        logger.debug ("Zip file was created and '" + counter + "' files was added succesfully.");
    } catch (IOException e) {
        logger.error ("Zip file couldn't be closed correctly cause by a input / output error.");
    }
}


public Component getTreeCellRendererComponent (JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
    super.getTreeCellRendererComponent (tree, value, sel, expanded, leaf, row, hasFocus);
    setIcon ((ImageIcon) renderIcon.get ("?"));
    if (tree.getModel ().getRoot () == value) {
        setIcon ((ImageIcon) renderIcon.get ("/"));
        try {
            setText ("datastore://" + tokenBook.getID ());
        } catch (DataBaseException dbe) {
            Core.Logger.log (dbe.getMessage (), Level.ERROR);
            dbe.printStackTrace ();
        }
        return this;
    }
    if (value.toString ().endsWith ("/")) {
        setIcon ((ImageIcon) renderIcon.get ("Folder"));
        super.setText (super.getText ().substring (0, super.getText ().length () - 1));
        return this;
    }
    if (renderIcon.containsKey (getExtension (value.toString ()))) {
        setIcon ((ImageIcon) renderIcon.get (getExtension (value.toString ())));
    }
    return this;
}


-----Function Pair=214=-----==

public static String toRelativeURL (URL base, URL target) {
    if ((base.getProtocol ().equals (target.getProtocol ())) && (base.getHost ().equals (target.getHost ()))) {
        String baseString = base.getFile ();
        String targetString = target.getFile ();
        String result = "";
        baseString = baseString.substring (0, baseString.lastIndexOf ("/") + 1);
        targetString = targetString.substring (0, targetString.lastIndexOf ("/") + 1);
        StringTokenizer baseTokens = new StringTokenizer (baseString, "/");
        StringTokenizer targetTokens = new StringTokenizer (targetString, "/");
        String nextBaseToken = "", nextTargetToken = "";
        while (baseTokens.hasMoreTokens () && targetTokens.hasMoreTokens ()) {
            nextBaseToken = baseTokens.nextToken ();
            nextTargetToken = targetTokens.nextToken ();
            if (! (nextBaseToken.equals (nextTargetToken))) {
                while (true) {
                    result = result.concat ("../");
                    if (! baseTokens.hasMoreTokens ()) {
                        break;
                    }
                    nextBaseToken = baseTokens.nextToken ();
                }
                while (true) {
                    result = result.concat (nextTargetToken + "/");
                    if (! targetTokens.hasMoreTokens ()) {
                        break;
                    }
                    nextTargetToken = targetTokens.nextToken ();
                }
                String temp = target.getFile ();
                result = result.concat (temp.substring (temp.lastIndexOf ("/") + 1, temp.length ()));
                return result;
            }
        }
        while (baseTokens.hasMoreTokens ()) {
            result = result.concat ("../");
            baseTokens.nextToken ();
        }
        while (targetTokens.hasMoreTokens ()) {
            nextTargetToken = targetTokens.nextToken ();
            result = result.concat (nextTargetToken + "/");
        }
        String temp = target.getFile ();
        result = result.concat (temp.substring (temp.lastIndexOf ("/") + 1, temp.length ()));
        return result;
    }
    return target.toString ();
}


public static ExportedCourse createFromArchive (File archive) throws ArchiveFailedException {
    String xml = null;
    List < ExportedFile > files = new ArrayList < ExportedFile > ();
    try {
        ZipFile zarchive = new ZipFile (archive);
        Enumeration < ? extends ZipEntry > entries = zarchive.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = entries.nextElement ();
            String currentEntry = entry.getName ();
            InputStream zin = zarchive.getInputStream (entry);
            byte [] buffer = new byte [zin.available ()];
            zin.read (buffer);
            if (ExportedCourse.COURSE_DESCRIPTOR.equals (currentEntry)) {
                xml = new String (buffer);
            }
            else {
                files.add (new ExportedFile (currentEntry, buffer));
            }
        }
        if (xml == null) {
            throw new ArchiveFailedException ("Supplied archive " + archive.getName () + " is not an eledge course archive: lacks course.xml");
        }
        ExportedCourse ec = new ExportedCourse (xml, files);
        return ec;
    } catch (Exception e) {
        throw new ArchiveFailedException (e);
    }
}


-----Function Pair=215=-----==

public void run () {
    super.setPriority (Thread.MIN_PRIORITY);
    double size = - 1L;
    size = Core.Repository.size ();
    String label = "Byte";
    if (size >= 1024) {
        size = size / 1024;
        label = "KB";
    }
    if (size >= 1024) {
        size = size / 1024;
        label = "MB";
    }
    if (size >= 1024) {
        size = size / 1024;
        label = "GB";
    }
    if (size >= 1024) {
        size = size / 1024;
        label = "TB";
    }
    mediaManagerInfo.setText (String.format ("%.2f ", size) + label);
    Vector < Book > files = new Vector < Book > ();
    try {
        for (Book book : Core.Database.getBooks (null)) files.add (book);
    } catch (DataBaseException dbe) {
        Core.Logger.log (dbe.getMessage (), Level.ERROR);
        dbe.printStackTrace ();
    }
    Iterable < Book > iterable = checkboxListMedia.getSelectedItems ();
    checkboxListMedia.setItems (files);
    checkboxListMedia.setSelectedItems (iterable);
}


public void save (RequirementProject _requirementProject, OutputStream _out) throws IOException, RequirementDocumentFormatException {
    ZipOutputStream zout = new ZipOutputStream (_out);
    zout.setLevel (0);
    ByteArrayOutputStream xmlBuffer = new ByteArrayOutputStream ();
    attachmentMarshaller.setZout (zout);
    writeXml (_requirementProject, xmlBuffer);
    attachmentMarshaller.setZout (null);
    if (DEBUG_ALSO_SAVE_SEPARATE_MODEL_XML) {
        IoHelper.write (xmlBuffer.toByteArray (), new File ("model_debug.xml"));
    }
    zout.setLevel (9);
    ZipEntry zipEntry = new ZipEntry (MODEL_XML_FILE_NAME);
    zout.putNextEntry (zipEntry);
    zout.write (xmlBuffer.toByteArray ());
    zout.closeEntry ();
    zout.close ();
}


-----Function Pair=216=-----==

public static void zip (File destFile, File [] files) throws IOException {
    BufferedInputStream origin = null;
    FileOutputStream dest = new FileOutputStream (destFile);
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    out.setMethod (ZipOutputStream.DEFLATED);
    byte [] data = new byte [BUFFER_SIZE];
    for (int i = 0; i < files.length; i ++) {
        if (log.isDebugEnabled ()) {
            log.debug ("Adding: " + files [i].getName ());
        }
        if (files [i].isDirectory ()) {
            if (log.isDebugEnabled ()) {
                log.debug ("Skipping directory: " + files [i]);
            }
            continue;
        }
        FileInputStream fi = new FileInputStream (files [i]);
        origin = new BufferedInputStream (fi, BUFFER_SIZE);
        ZipEntry entry = new ZipEntry (files [i].getName ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER_SIZE)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    out.flush ();
    out.close ();
}


private void parseArguments (String [] args) throws Throwable {
    File dataFile = CoverageDataFileHandler.getDefaultDataFile ();
    List filePaths = new ArrayList ();
    String baseDir = null;
    for (int i = 0; i < args.length; i ++) {
        if (args [i].equals ("--basedir")) baseDir = args [++ i];
        else if (args [i].equals ("--datafile")) dataFile = new File (args [++ i]);
        else if (args [i].equals ("--destination")) destinationDirectory = new File (args [++ i]);
        else if (args [i].equals ("--ignore")) {
            RegexUtil.addRegex (ignoreRegexes, args [++ i]);
        }
        else if (args [i].equals ("--ignoreBranches")) {
            RegexUtil.addRegex (ignoreBranchesRegexes, args [++ i]);
        }
        else if (args [i].equals ("--ignoreMethodAnnotation")) {
            ignoreMethodAnnotations.add (args [++ i]);
        }
        else if (args [i].equals ("--ignoreTrivial")) {
            ignoreTrivial = true;
        }
        else if (args [i].equals ("--includeClasses")) {
            classPattern.addIncludeClassesRegex (args [++ i]);
        }
        else if (args [i].equals ("--excludeClasses")) {
            classPattern.addExcludeClassesRegex (args [++ i]);
        }
        else if (args [i].equals ("--failOnError")) {
            logger.setFailOnError (true);
        }
        else {
            CoberturaFile coberturaFile = new CoberturaFile (baseDir, args [i]);
            filePaths.add (coberturaFile);
        }
    }
    if (dataFile.isFile ()) projectData = CoverageDataFileHandler.loadCoverageData (dataFile);
    if (projectData == null) projectData = new ProjectData ();
    System.out.println ("Instrumenting " + filePaths.size () + " " + (filePaths.size () == 1 ? "file" : "files") + (destinationDirectory != null ? " to " + destinationDirectory.getAbsoluteFile () : ""));
    Iterator iter = filePaths.iterator ();
    while (iter.hasNext ()) {
        CoberturaFile coberturaFile = (CoberturaFile) iter.next ();
        if (coberturaFile.isArchive ()) {
            addInstrumentationToArchive (coberturaFile);
        }
        else {
            addInstrumentation (coberturaFile);
        }
    }
    CoverageDataFileHandler.saveCoverageData (projectData, dataFile);
}


-----Function Pair=217=-----==

public java.util.Map < String, String > run () throws IOException {
    JarInputStream jis = new JarInputStream (this.in);
    Manifest mf = jis.getManifest ();
    Attributes atts = mf.getMainAttributes ();
    java.util.Map < String, String > matts = new HashMap < String, String > ();
    for (Object key : atts.keySet ()) matts.put (((Attributes.Name) key).toString (), (String) atts.get (key));
    this.filter.processManifest (matts);
    final ZipOutputStream zos = new ZipOutputStream (this.out);
    zos.putNextEntry (new ZipEntry ("META-INF/MANIFEST.MF"));
    writeManifest (matts, zos);
    JarEntry entry;
    while ((entry = jis.getNextJarEntry ()) != null) {
        String name = entry.getName ();
        if (! this.filter.processEntry (name)) continue;
        JarEntry newEntry = new JarEntry (name);
        zos.putNextEntry (newEntry);
        pump (jis, zos, 1024);
    }
    zos.flush ();
    this.filter.addEntries (new FileDumper () {
        public void next (String path) throws IOException {
            zos.putNextEntry (new ZipEntry (path));
        } public void write (byte [] buffer, int offset, int length) throws IOException {
            zos.write (buffer, offset, length);
        } public void close () throws IOException {
        }
    }
    );
    zos.flush ();
    zos.close ();
    jis.close ();
    return matts;
}


public String getRootFolder2Extract () {
    try {
        if (this.unzipZipFolder == null) {
            throw new Exception ("Use 'setUnzipZipFolder(String)' to specify the zip-file to unzip");
        }
        if (this.unzipDestinationFolder == null) {
            throw new Exception ("Use 'setUnzipDestinationFolder(String)' to specify the destination for unzipping");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (this.unzipZipFolder != null && this.unzipDestinationFolder != null) {
        String zipRootFolder = null;
        try {
            ZipFile zf = new ZipFile (this.unzipZipFolder);
            Enumeration < ? extends ZipEntry > zipEnum = zf.entries ();
            while (zipEnum.hasMoreElements ()) {
                ZipEntry item = (ZipEntry) zipEnum.nextElement ();
                String entryName = item.getName ();
                String fileSeperator = null;
                if (entryName.contains ("\\")) {
                    fileSeperator = "\\";
                }
                else if (entryName.contains ("/")) {
                    fileSeperator = "/";
                }
                int cut = entryName.indexOf (fileSeperator, 1);
                zipRootFolder = entryName.substring (0, cut);
                String [] zipRootFolderArr = zipRootFolder.split ("|");
                zipRootFolder = "";
                for (int i = 0; i < zipRootFolderArr.length; i ++) {
                    if (zipRootFolderArr [i].equals (fileSeperator)) {
                        zipRootFolderArr [i] = "";
                    }
                    zipRootFolder += zipRootFolderArr [i];
                }
                zipRootFolder.replace (fileSeperator, "");
                zipRootFolder.trim ();
                break;
            }
            zf.close ();
            return zipRootFolder;
        } catch (IOException e) {
            e.printStackTrace ();
        }
        return null;
    }
    else {
        return null;
    }
}


-----Function Pair=218=-----==

public void copyDirectory (File inputDir, String outputDir, boolean recursive) throws IOException {
    if (inputDir.exists ()) {
        if (inputDir.isDirectory ()) {
            File [] files = listAllFiles (inputDir, false);
            File dir = new File (outputDir);
            if (! dir.exists ()) dir.mkdir ();
            outputDir += System.getProperty ("file.separator") + inputDir.getName ();
            dir = new File (outputDir);
            if (! dir.exists ()) dir.mkdir ();
            for (int i = 0; i < files.length; i ++) copyFile (files [i], new File (dir, files [i].getName ()));
            if (recursive) {
                File [] dirs = listDirectories (inputDir, false);
                for (int i = 0; i < dirs.length; i ++) {
                    copyDirectory (dirs [i], outputDir, recursive);
                }
            }
        }
        else throw new IOException (inputDir + " is not a directory.");
    }
    else throw new IOException (inputDir + " does not exist.");
}


public void createCachePackage (OutputStream output) {
    int bytesRead = 0;
    byte [] transferBuffer = new byte [BUFFER_SIZE];
    try {
        ZipOutputStream zos = new ZipOutputStream (output);
        for (File file : cacheFolder.listFiles ()) {
            if (file.getName ().contains ("DS_Store") || file.getName ().endsWith (".svn")) continue;
            ZipEntry fileEntry = new ZipEntry (file.getName ());
            zos.putNextEntry (fileEntry);
            InputStream bis = new FileInputStream (file);
            while ((bytesRead = bis.read (transferBuffer)) != - 1) {
                zos.write (transferBuffer, 0, bytesRead);
            }
            bis.close ();
            zos.closeEntry ();
            logger.log (Level.INFO, "Wrote {0}, size is {1}", new Object [] {file.toString (), fileEntry.getSize ()});
        }
        zos.close ();
    } catch (IOException ex) {
        logger.log (Level.SEVERE, "Caught an IOException while making cache package: {0}", ex.getMessage ());
    }
}


-----Function Pair=219=-----==

public void render (Map model, HttpServletRequest request, HttpServletResponse response) throws InvocationTargetException, NoSuchMethodException, ClassNotFoundException, IllegalAccessException, InstantiationException {
    response.setContentType (getContentType ());
    response.setHeader ("Content-Disposition", "attachment; filename=GeneratedFiles.zip");
    TemplateObject to = new TemplateObject ();
    to.setEntityname ("BasisClass");
    to.setEntitypackage ("org.jprovocateur.basis.objectmodel.accessrights.impl");
    to.setServicepackage ("com.myproject.businesslayer.test");
    ApplicationContext cont = ApplicationContextProvider.getApplicationContext ();
    GenericDaoDBInt dao = (GenericDaoDBInt) cont.getBean ("genericDaoDB");
    Constructor < ? > constructur = Class.forName (to.getEntitypackage () + "." + to.getEntityname ()).getConstructor ();
    Object obj = (Object) constructur.newInstance ();
    String idProperty = dao.getIdentifier (obj);
    to.setPkName (idProperty);
    List < File > files = new ArrayList < File > ();
    files.add (generateFile ("generated/services/createService.ftl", to.getEntityname () + "CreateService.java", to));
    files.add (generateFile ("generated/services/updateService.ftl", to.getEntityname () + "UpdateService.java", to));
    files.add (generateFile ("generated/services/deleteService.ftl", to.getEntityname () + "DeleteService.java", to));
    files.add (generateFile ("generated/services/listService.ftl", to.getEntityname () + "ListService.java", to));
    files.add (generateFile ("generated/controller/dataController.ftl", "Data" + to.getEntityname () + "Controller.java", to));
    files.add (generateFile ("generated/controller/viewController.ftl", "View" + to.getEntityname () + "Controller.java", to));
    zipFiles (files, response);
}


private void extractTmpFileFromZip (GameDB currentGame, String romName) {
    if (log.isDebugEnabled ()) {
        log.debug ("extractTmpFileFromZip(GameDB currentGame, String romName)");
        log.debug ("CurrentLocation: " + currentGame.getCurrentlocation ());
        log.debug ("SourceFile: " + currentGame.getSourceFile ());
    }
    ZipFile zipFile = null;
    try {
        zipFile = new ZipFile (currentGame.getCurrentlocation ());
        Enumeration < ZipEntry > entrys = (Enumeration < ZipEntry >) zipFile.entries ();
        while (entrys.hasMoreElements ()) {
            ZipEntry entry = entrys.nextElement ();
            if (ndsFilesPattern.matcher (entry.getName ().toLowerCase ()).matches ()) {
                log.trace ("extract nds file to tmpFolder");
                String tmpPath = this.tmpFolder + File.separatorChar + entry.getName ();
                RandomAccessFile raf = new RandomAccessFile (tmpPath, "rw");
                InputStream is = zipFile.getInputStream (entry);
                byte [] buffer = new byte [512];
                int len = 0;
                while ((len = is.read (buffer)) != - 1) {
                    raf.write (buffer, 0, len);
                }
                raf.close ();
                currentGame.setCurrentlocation (tmpPath);
            }
        }
    } catch (IOException ex) {
        log.error (null, ex);
    } finally {
        try {
            zipFile.close ();
        } catch (Exception exception) {
        }
    }
}


-----Function Pair=220=-----==

private void generateXml (Presentation presentation, List < Presentation > presentationList, boolean publish) throws IOException {
    String infactDirectory = new File (generationDirectory, infactDirectoryName).getPath ();
    String xmlDir = new File (infactDirectory, "xml").getPath ();
    XmlWriter writer = XmlWriterFactory.getWriter (new File (xmlDir, "structure.xml").getPath ());
    boolean hasParticipants = presentation.getParticipants () != null;
    writer.writeHeader ();
    writer.writeStartTag ("xml");
    writer.writeStartTag ("general");
    writer.writeSimpleTag ("name", presentation.getName ());
    if (! publish) {
        writer.writeSimpleTag ("debug", "true");
    }
    if (presentation.getBgImage () != null) {
        writer.writeSimpleTag ("background", writeAttachmentToFile (presentation.getBgImage (), presentation, uploadedFilesDir, false));
    }
    writer.writeSimpleTag ("hoverColor", "#CCFFCC");
    writer.writeSimpleTag ("visitedColor", "#CCCCCC");
    String fontStr = presentation.getFont ();
    if (fontStr == null || fontStr.equals ("")) {
        fontStr = "Arial, sans-serif;";
    }
    writer.writeSimpleTag ("fonts", fontStr);
    writer.writeSimpleTag ("nodes", "nodes.swf");
    writer.writeSimpleTag ("defaultNode", "nodes.templates.DefaultNode");
    writer.writeSimpleTag ("defaultRadius", "70");
    writer.writeSimpleTag ("leafRoot", "xml/");
    writer.writeSimpleTag ("searchXML", "xml/search.xml");
    writer.writeSimpleTag ("distance", presentation.getStickDistance ());
    if (hasParticipants) {
        writer.writeSimpleTag ("participantsXML", "xml/participants.xml");
    }
    if (presentationList.size () > 1) {
        writeLanguagesTags (writer, presentation, presentationList);
    }
    writer.writeSimpleTag ("animatedBackground", booleanToString (presentation.isAnimatedBackground ()));
    writer.writeSimpleTag ("tooltip", booleanToString (presentation.isToolTip ()));
    writer.writeStartTag ("logos");
    Properties attributes = new Properties ();
    List < Logo > logoList = presentation.getLogos ();
    for (Logo logo : logoList) {
        attributes.setProperty ("url", logo.getUrl ());
        writer.writeSimpleTag ("logo", "logos/" + logo.getImage ().getId () + "-" + logo.getImage ().getName (), attributes);
    }
    writer.writeEndTag ();
    writer.writeEndTag ();
    writer.writeStartTag ("languageTexts");
    writer.writeSimpleTag ("otherLang", "Andra Språk");
    writeLocalizedTags (presentation, writer);
    writer.writeEndTag ();
    StructureWriterVisitor visitor = new StructureWriterVisitor (writer, infactDirectory, this);
    Node startNode = presentation.getStartnode ();
    startNode.accept (visitor);
    writer.writeEndTag ();
    writer.closeXmlWriter ();
    createSearchXml (infactDirectory, xmlDir, presentation);
    if (hasParticipants) {
        createParticipantsXml (xmlDir, presentation);
    }
}


private void parseZipFile () {
    InputStream is = null;
    try {
        if (USeqUtilities.USEQ_ARCHIVE.matcher (zipFile.getName ()).matches () == false) throw new IOException ("This file does not appear to be a USeq archive! " + zipFile);
        zipArchive = new ZipFile (zipFile);
        Enumeration e = zipArchive.entries ();
        archiveReadMeEntry = (ZipEntry) e.nextElement ();
        is = zipArchive.getInputStream (archiveReadMeEntry);
        archiveInfo = new ArchiveInfo (is, false);
        HashMap < String, ArrayList < DataRange > > map = new HashMap < String, ArrayList < DataRange > > ();
        while (e.hasMoreElements ()) {
            ZipEntry zipEntry = (ZipEntry) e.nextElement ();
            SliceInfo sliceInfo = new SliceInfo (zipEntry.getName ());
            if (binaryDataType == null) binaryDataType = sliceInfo.getBinaryType ();
            String chromName;
            if (maintainStrandedness) chromName = sliceInfo.getChromosome () + sliceInfo.getStrand ();
            else chromName = sliceInfo.getChromosome ();
            if (sliceInfo.getStrand ().equals (".") == false) stranded = true;
            ArrayList < DataRange > al = map.get (chromName);
            if (al == null) {
                al = new ArrayList < DataRange > ();
                map.put (chromName, al);
            }
            al.add (new DataRange (zipEntry, sliceInfo.getFirstStartPosition (), sliceInfo.getLastStartPosition ()));
        }
        Iterator < String > it = map.keySet ().iterator ();
        while (it.hasNext ()) {
            String chromName = it.next ();
            ArrayList < DataRange > al = map.get (chromName);
            DataRange [] dr = new DataRange [al.size ()];
            al.toArray (dr);
            Arrays.sort (dr);
            chromStrandRegions.put (chromName, dr);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        USeqUtilities.safeClose (is);
    }
}


-----Function Pair=221=-----==

public void zip (String zipFile) {
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
        out.putNextEntry (new ZipEntry ((new File (currentFile)).getName ()));
        String newline = System.getProperty ("line.separator");
        Element map = getDocument ().getDefaultRootElement ();
        for (int i = 0; i < map.getElementCount (); i ++) {
            Element line = map.getElement (i);
            int start = line.getStartOffset ();
            byte [] buf = (getText (start, line.getEndOffset () - start - 1) + newline).getBytes ();
            out.write (buf, 0, buf.length);
        }
        out.closeEntry ();
        out.close ();
    } catch (IOException ioe) {
        showError ("Error has occured while ziping");
    } catch (BadLocationException ble) {
        showError ("Error has occured while ziping");
    }
}


protected void loadCustomIcons () throws Exception {
    InputStream inXML = null;
    try {
        inXML = ResourceManager.getInstance ().getInputStream (CUSTOM_ICONS_RESOURCEFILE);
    } catch (Throwable exception) {
        Debug.trace ("Resource " + CUSTOM_ICONS_RESOURCEFILE + " not defined. No custom icons available.");
        return;
    }
    Debug.trace ("Custom icons available.");
    URL url;
    ImageIcon img;
    IXMLElement icon;
    IXMLParser parser = new XMLParser ();
    IXMLElement data = parser.parse (inXML);
    Vector < IXMLElement > children = data.getChildrenNamed ("icon");
    int size = children.size ();
    for (int i = 0; i < size; i ++) {
        icon = children.get (i);
        url = InstallerFrame.class.getResource (icon.getAttribute ("res"));
        img = new ImageIcon (url);
        Debug.trace ("Icon with id found: " + icon.getAttribute ("id"));
        icons.put (icon.getAttribute ("id"), img);
    }
    children = data.getChildrenNamed ("sysicon");
    size = children.size ();
    for (int i = 0; i < size; i ++) {
        icon = children.get (i);
        url = InstallerFrame.class.getResource (icon.getAttribute ("res"));
        img = new ImageIcon (url);
        UIManager.put (icon.getAttribute ("id"), img);
    }
}


-----Function Pair=222=-----==

public void moveObject (String sourceUri, String destinationUri) throws ServiceAccessException, AccessDeniedException, ObjectNotFoundException {
    if (isLinkOrCompoundDocType (sourceUri)) {
        throw new AccessDeniedException (sourceUri, "not allow move this folder!", "move document");
    }
    String destinatFolderUri = "";
    String sourceFolderUri = "";
    if (destinationUri.length () > 0) {
        destinatFolderUri = destinationUri.substring (0, destinationUri.lastIndexOf ("/"));
    }
    if (sourceUri.length () > 0) {
        sourceFolderUri = sourceUri.substring (0, sourceUri.lastIndexOf ("/"));
    }
    if (destinatFolderUri.length () <= 0 || sourceFolderUri.length () <= 0) {
        return;
    }
    Connection conn = null;
    try {
        conn = DataSourceFactory.getConnection ();
        DocumentOperationManager docOperationManager = new DocumentOperationManager (sessionContainer, conn);
        DocumentValidateManager docValidateManager = new DocumentValidateManager (sessionContainer, conn);
        if (destinatFolderUri.equals (sourceFolderUri)) {
            DmsDocument dmsDocument = getMappingDocumentByUrl (sourceUri);
            checkDocumentRight (sourceUri, dmsDocument, null, "rename");
            dmsDocument.setDocumentName (destinationUri.substring (destinationUri.lastIndexOf ("/") + 1, destinationUri.length ()));
            DmsDocumentDetailDAObject dmsDocumentDetailDAObj = new DmsDocumentDetailDAObject (sessionContainer, conn);
            List docDetailList = dmsDocumentDetailDAObj.getListByDocumentID (dmsDocument.getID ());
            if (! Utility.isEmpty (docDetailList)) {
                DmsDocumentDetail tmpDmsDocumentDetail = (DmsDocumentDetail) docDetailList.get (0);
                Integer userDefinedFieldID = tmpDmsDocumentDetail.getUserDefinedFieldID ();
                dmsDocument.setDocumentDetails (docDetailList);
                dmsDocument.setUserDefinedFieldID (userDefinedFieldID);
            }
            docOperationManager.renameRecord (dmsDocument);
        }
        else {
            DmsDocument dmsDocument = getMappingDocumentByUrl (sourceUri);
            DmsDocument dmsFolder = getMappingDocumentByUrl (destinatFolderUri);
            checkDocumentRight (sourceUri, dmsDocument, null, "move");
            DmsDocument newDoc = new DmsDocument ();
            newDoc.setDocumentName (dmsDocument.getDocumentName ());
            DmsValidation validation = docValidateManager.validateMoveAction (dmsDocument, dmsFolder, newDoc);
            if (! validation.isSuccess ()) {
                throw new ApplicationException (DmsErrorConstant.DMS_MESSAGE_CANNOT_MOVE_SUM_DOCUMENT);
            }
            if (dmsDocument != null && dmsFolder != null) {
                if (DmsDocument.FOLDER_TYPE.equals (dmsDocument.getDocumentType ()) || DmsDocument.COMPOUND_DOC_TYPE.equals (dmsDocument.getDocumentType ()) || DmsDocument.PAPER_DOC_TYPE.equals (dmsDocument.getDocumentType ())) {
                    docOperationManager.moveFolder (dmsDocument, dmsFolder, dmsFolder.getRootID ());
                }
                else {
                    docOperationManager.moveDocument (dmsDocument, dmsFolder, dmsFolder.getRootID ());
                }
            }
        }
        conn.commit ();
    } catch (SecurityException e) {
        log.error (e);
        throw new AccessDeniedException (sourceUri, e.getMessage (), "move");
    } catch (Exception e) {
        log.error (e);
        throw new AccessDeniedException (sourceUri, e.getMessage (), "move");
    } finally {
        closeConnection (conn);
    }
}


private List exportIteratedObjects (Iterator result, Map systemIdMap, XDocumentWriter writer, OpBackupMember [] members, String recursiveBy, List < Triple < String, OpBackupMember, String > > toExport) throws IOException {
    List childObjects = (recursiveBy != null) ? new ArrayList () : null;
    Map < String, String > attributes = new HashMap < String, String > ();
    while (result.hasNext ()) {
        OpSiteObject object = (OpSiteObject) result.next ();
        object = OpHibernateSource.initializeObject (OpSiteObject.class, object);
        Long id = new Long (object.getId ());
        attributes.put (ID, String.valueOf (object.getId ()));
        String systemObjectName = (String) systemIdMap.get (id);
        if (systemObjectName != null) {
            attributes.put (SYSTEM, systemObjectName);
        }
        writer.writeStartElement (O, attributes, false);
        attributes.clear ();
        OpBackupMember member = null;
        for (int i = 0; i < members.length; i ++) {
            member = members [i];
            if (member == null) {
                continue;
            }
            Object value = OpBackupLoader.getValueFromObject (object, member);
            if (member.relationship) {
                this.writeRelationshipMember (writer, value);
                if (member.backRelationshipName != null && recursiveBy != null && recursiveBy.equals (OpMember.namesToString (member.getNames ()))) {
                    Field backRelationField = OpPrototype.getAccessibleField (object.getClass (), member.backRelationshipName);
                    if (backRelationField != null) {
                        Object backRelationshipValue = OpPrototype.getFieldValue (object, backRelationField);
                        if (backRelationshipValue != null && (backRelationshipValue instanceof Collection)) {
                            childObjects.addAll ((Collection) backRelationshipValue);
                        }
                    }
                }
            }
            else {
                this.writeFieldMember (object, member, writer, value, toExport);
            }
        }
        writer.writeEndElement (O);
    }
    return childObjects;
}


-----Function Pair=223=-----==

public boolean createResource (String resourceUri) throws ServiceAccessException, AccessDeniedException, ObjectAlreadyExistsException {
    Connection conn = null;
    if (isRootOrPesonalOrPublicFolder (resourceUri)) {
        return false;
    }
    try {
        conn = DataSourceFactory.getConnection ();
        DocumentOperationManager docOperationManager = new DocumentOperationManager (sessionContainer, conn);
        RootOperationManager rootOperationManager = new RootOperationManager (sessionContainer, conn);
        DmsDocument newDocument = null;
        Integer userID = sessionContainer.getUserRecordID ();
        DmsRootDAObject rootDAO = new DmsRootDAObject (this.sessionContainer, conn);
        List rootList = rootDAO.getRootByOwnerIDAndType (userID, DmsRoot.PERSONAL_ROOT, GlobalConstant.RECORD_STATUS_ACTIVE);
        DmsRoot rootPoint = null;
        if (resourceUri.indexOf (DMS_WEBDAV_PERSONAL_ROOT_FOLDER_URL) == 0) {
            if (rootList.size () == 0) {
                rootPoint = rootOperationManager.createDefaultPersonalRootPointForUser ();
            }
            else {
                rootPoint = (DmsRoot) rootList.get (0);
            }
        }
        else if (resourceUri.indexOf (DMS_WEBDAV_PUBLIC_ROOT_FOLDER_URL) == 0) {
            String [] urlArr = TextUtility.splitString (resourceUri, "/");
            String lastDocumentName = "";
            if (urlArr.length > 3) {
                lastDocumentName = urlArr [3];
            }
            rootPoint = (DmsRoot) rootDAO.getObjectByName (lastDocumentName);
        }
        rootDAO = null;
        String [] urlArr = TextUtility.splitString (resourceUri, "/");
        Integer parentID = new Integer (0);
        String parentDocumentName = resourceUri;
        if (urlArr.length >= 4) {
            parentDocumentName = urlArr [(urlArr.length - 2)];
            DmsDocument parentDocument = null;
            String parentUrl = "";
            for (int i = 0; i < urlArr.length - 1; i ++) {
                if (i != 0) {
                    parentUrl += "/";
                }
                parentUrl += urlArr [i];
            }
            if (! DMS_WEBDAV_PERSONAL_ROOT_FOLDER_URL.equals (parentUrl)) {
                parentDocument = getMappingDocumentByUrl (parentUrl);
                parentID = parentDocument.getID ();
            }
            else {
                parentID = rootPoint.getRootFolderID ();
            }
        }
        String lastDocumentName = resourceUri;
        if (urlArr.length > 3) {
            lastDocumentName = urlArr [(urlArr.length - 1)];
        }
        DmsDocument dmsDocument = new DmsDocument ();
        dmsDocument.setDocumentName (lastDocumentName);
        dmsDocument.setRecordStatus (GlobalConstant.STATUS_ACTIVE);
        dmsDocument.setItemStatus (DmsVersion.AVAILABLE_STATUS);
        dmsDocument.setParentID (parentID);
        dmsDocument.setRootID (rootPoint.getID ());
        dmsDocument.setDocumentType (DmsDocument.FOLDER_TYPE);
        dmsDocument.setCreateType (DmsOperationConstant.DMS_CREATE_BY_SYSTEM);
        newDocument = docOperationManager.createFolder (dmsDocument);
        conn.commit ();
    } catch (Exception e) {
        log.error (e);
        throw new AccessDeniedException (resourceUri, e.getMessage (), "create");
    } finally {
        closeConnection (conn);
    }
    return true;
}


private static String diff (String name, Object desc1, Object desc2) {
    if (desc1 instanceof String) {
        if (desc2 instanceof String) {
            if (desc1.equals (desc2)) {
                return null;
            }
            return (name + ": Contents should be '" + ((String) desc1).replace ('\n', '|') + "', not '" + ((String) desc2).replace ('\n', '|') + "'");
        }
        return name + " should be a plain member / ZIP entry";
    }
    if (desc2 instanceof String) {
        return name + " should be a directory or ZIP file";
    }
    name += name.endsWith (".zip") ? '!' : '/';
    SortedMap < String, Object > entries1 = new TreeMap < String, Object > ();
    {
        Object [] oa = (Object []) desc1;
        for (int i = 0; i < oa.length;) {
            entries1.put ((String) oa [i ++], oa [i ++]);
        }
    }
    SortedMap < String, Object > entries2 = new TreeMap < String, Object > ();
    {
        Object [] oa = (Object []) desc2;
        for (int i = 0; i < oa.length;) {
            entries2.put ((String) oa [i ++], oa [i ++]);
        }
    }
    for (Iterator < Entry < String, Object > > it1 = entries1.entrySet ().iterator (), it2 = entries2.entrySet ().iterator ();;) {
        if (it1.hasNext ()) {
            Entry < String, Object > entry1 = it1.next ();
            if (it2.hasNext ()) {
                Entry < String, Object > entry2 = it2.next ();
                String name1 = entry1.getKey ();
                String name2 = entry2.getKey ();
                int cmp = name1.compareTo (name2);
                if (cmp < 0) return name + name1 + " missing";
                if (cmp > 0) return "Unexpected " + name + name2;
                String diff = diff (name + name1, entry1.getValue (), entry2.getValue ());
                if (diff != null) return diff;
            }
            else {
                return name + entry1.getKey () + " missing";
            }
        }
        else {
            if (it2.hasNext ()) {
                return "Unexpected " + name + it2.next ().getKey ();
            }
            else {
                break;
            }
        }
    }
    return null;
}


-----Function Pair=224=-----==

public static void zipDir (File zipDir, ZipOutputStream zos, File rawdatadir) throws IOException {
    if (zipDir.isFile ()) {
        int bytesIn = 0;
        byte [] readBuffer = new byte [2156];
        if (! alreadyAttached.contains (zipDir.getPath ())) {
            FileInputStream fis = new FileInputStream (zipDir);
            ZipEntry anEntry = new ZipEntry (zipDir.getPath ());
            alreadyAttached.add (zipDir.getPath ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    }
    else {
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (new File (filePath), zos, rawdatadir);
                continue;
            }
            if (! alreadyAttached.contains (getRelativePath (rawdatadir, f))) {
                FileInputStream fis = new FileInputStream (f);
                ZipEntry anEntry = new ZipEntry (getRelativePath (rawdatadir, f));
                alreadyAttached.add (getRelativePath (rawdatadir, f));
                zos.putNextEntry (anEntry);
                while ((bytesIn = fis.read (readBuffer)) != - 1) {
                    zos.write (readBuffer, 0, bytesIn);
                }
                fis.close ();
            }
        }
    }
}


public String redireccionaDirectorioSalida (String rutaSalida, String entradaFile) {
    String datoRetorno = "";
    String cadenaInvertida = "";
    String separador = "";
    int contador = 0;
    boolean estado = this.esFichero (entradaFile);
    System.out.println ("esFichero: " + estado);
    if (estado == true) {
        for (int i = entradaFile.length () - 1; i >= 0; i --) {
            Character caracter = (Character) entradaFile.charAt (i);
            cadenaInvertida += caracter;
            if (caracter == '\\') {
                contador ++;
                separador = (('\\') + "");
            }
            else if (caracter == '/') {
                contador ++;
                separador = (('/') + "");
            }
            else if (caracter == File.separatorChar) {
                contador ++;
                separador = ((File.separatorChar) + "");
            }
        }
        System.out.println ("Cadena 'ANTES':   " + entradaFile);
        System.out.println ("Cadena 'DESPUES': " + cadenaInvertida);
        System.out.println ("Total Separadores#: " + contador);
        if (contador != 0) {
            System.out.println ("Separador Aplicado: " + separador);
            String [] arrayCadenaInvertida = StringUtils.split (cadenaInvertida, separador);
            String cadenaReversa = StringUtils.reverse (arrayCadenaInvertida [0]);
            datoRetorno = cadenaReversa;
            System.out.println ("Nombre Fichero Obtenido: " + arrayCadenaInvertida [0]);
            System.out.println ("Nombre Fichero Invertido: " + datoRetorno);
        }
        else {
            datoRetorno = cadenaInvertida;
            System.out.println ("Nombre Fichero Obtenido: " + datoRetorno);
        }
    }
    datoRetorno = (rutaSalida + File.separator + datoRetorno);
    System.out.println ("Nueva Ruta Descomprimir Fichero: " + datoRetorno);
    return datoRetorno;
}


-----Function Pair=225=-----==

private static void zipFileOrDirectory (ZipOutputStream out, File fileOrDirectory, String curPath) {
    FileInputStream in = null;
    try {
        if (! fileOrDirectory.isDirectory ()) {
            byte [] buffer = new byte [4096];
            int bytes_read;
            in = new FileInputStream (fileOrDirectory);
            ZipEntry entry = new ZipEntry (curPath + fileOrDirectory.getName ());
            out.putNextEntry (entry);
            while ((bytes_read = in.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
            }
            out.closeEntry ();
        }
        else {
            File [] entries = fileOrDirectory.listFiles ();
            for (int i = 0; i < entries.length; i ++) {
                zipFileOrDirectory (out, entries [i], curPath + fileOrDirectory.getName () + "/");
            }
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (in != null) {
            try {
                in.close ();
            } catch (IOException ex) {
            }
        }
    }
}


public Map < String, String > getStoredProcesslists (Date date) {
    String filename = BASE_FILES_PATH + serverGroup + "/processlist/" + sdf.format (date) + ".zip";
    if (! new File (filename).exists ()) return null;
    Map < String, String > map = new HashMap < String, String > ();
    ZipFile zf = null;
    try {
        zf = new ZipFile (filename);
        Enumeration < ? extends ZipEntry > entries = zf.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry ze = entries.nextElement ();
            long size = ze.getSize ();
            if (size > 0) {
                BufferedReader br = new BufferedReader (new InputStreamReader (zf.getInputStream (ze)));
                StringBuilder sb = new StringBuilder ();
                String line;
                while ((line = br.readLine ()) != null) {
                    sb.append (line).append (LINE_SEPARATOR);
                }
                br.close ();
                map.put (ze.getName ().substring (0, ze.getName ().length () - 4), sb.substring (0, sb.length () - LINE_SEPARATOR.length ()));
            }
        }
        return map;
    } catch (IOException e) {
        e.printStackTrace ();
        return null;
    } finally {
        try {
            if (zf != null) zf.close ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=226=-----==

public boolean merge (WordDocument secondDoc, MergeStyle mergeStyle) throws OpenXML4JException {
    container.mergeDefaultContentType (secondDoc.container);
    TreeMap < String, String > convertingIdMap = mergeNumbering (secondDoc.getNumbering ());
    if (convertingIdMap == null) {
        logger.error ("failed in merging numbering.xml");
        return false;
    }
    TreeMap < String, String > mapOldIdToNewId = mergeImageRelationships (secondDoc);
    if (mapOldIdToNewId != null) {
        TreeMap < String, Element > treeMapStyleToForward = secondDoc.getCollectionOfStyleToForwardToNextDocument (convertingIdMap);
        if (treeMapStyleToForward == null) {
            return false;
        }
        if (! style.mergeStyle (treeMapStyleToForward, container)) {
            return false;
        }
        if (mergeStyle == MergeStyle.MERGE_AS_READ_ONLY) {
            secondDoc.removeWriteEnabledTags ();
        }
        Element firstNode = secondDoc.getDocumentBody ();
        return appendAllNodes (firstNode, mapOldIdToNewId);
    }
    else {
        return false;
    }
}


private byte [] setServerProperty (HTTPurl urlData) throws Exception {
    String out = "";
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    out = "HTTP/1.0 302 Moved Temporarily\nLocation: /settings.html\n\n";
    String [] parameter = urlData.getParameterList ();
    for (int x = 0; x < parameter.length; x ++) {
        if (! parameter [x].equals ("action") && ! parameter [x].equals ("sessionID")) {
            String value = urlData.getParameter (parameter [x]);
            if (value != null) {
                store.setServerProperty (parameter [x], value);
            }
        }
    }
    return out.getBytes ();
}


-----Function Pair=227=-----==

private static void zipDir (String dir2zip, ZipOutputStream zos, String parentDir) {
    try {
        File zipDir = new File (dir2zip);
        String [] dirList = zipDir.list ();
        byte [] readBuffer = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String filePath = f.getPath ();
                zipDir (filePath, zos, parentDir);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String fileToAdd = f.getAbsolutePath ().substring (parentDir.length () + 1);
            ZipEntry anEntry = new ZipEntry (fileToAdd);
            System.out.println ("adding: " + anEntry.getName ());
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    } catch (Exception e) {
    }
}


public static void unpackZip (File zipFile, File targetFolder, IProgressMonitor progressMonitor) throws IOException {
    targetFolder.mkdirs ();
    BufferedInputStream in = null;
    BufferedOutputStream out = null;
    ZipInputStream zIn = null;
    ZipEntry zipEntry;
    int bytesRead;
    final int bufSize = 1024;
    byte buf [] = new byte [bufSize];
    in = new BufferedInputStream (new FileInputStream (zipFile), bufSize);
    zIn = new ZipInputStream (in);
    try {
        while ((zipEntry = zIn.getNextEntry ()) != null) {
            if (! zipEntry.isDirectory ()) {
                File outFile = new File (targetFolder, zipEntry.getName ());
                if (! outFile.getParentFile ().exists ()) {
                    outFile.getParentFile ().mkdirs ();
                }
                out = new BufferedOutputStream (new FileOutputStream (outFile), bufSize);
                if (progressMonitor != null) {
                    progressMonitor.setTaskName (zipEntry.getName ());
                }
                int sleep_count = 0;
                while ((bytesRead = zIn.read (buf)) != - 1) {
                    out.write (buf, 0, bytesRead);
                    if (sleep_count >= 40) {
                        try {
                            Thread.sleep (2);
                        } catch (InterruptedException ex) {
                            ex.printStackTrace ();
                        }
                        sleep_count = 0;
                    }
                    sleep_count ++;
                    if (progressMonitor != null && progressMonitor.isCanceled ()) {
                        out.flush ();
                        out.close ();
                        zIn.close ();
                        throw new IOException ("User Cancelled");
                    }
                }
                outFile.setLastModified (zipEntry.getTime ());
                out.flush ();
                out.close ();
            }
            zIn.closeEntry ();
        }
        zIn.close ();
    } catch (IOException ex) {
        zIn.close ();
        if (out != null) {
            out.flush ();
            out.close ();
        }
        throw ex;
    }
}


-----Function Pair=228=-----==

public Map < String, Set < Object > > extractEclipseTargetProperties () throws ZipException, IOException, FileNotFoundException {
    Map < String, Set < Object > > propertiesMap = new HashMap < String, Set < Object > > ();
    InputStream jarPluginInputStream;
    String jarPluginRelativePath = eclipseInstallPlugin.getPluginLocation ().getAbsolutePath ().replace (eclipseArchiveLocation.getAbsolutePath (), "");
    jarPluginRelativePath = jarPluginRelativePath.substring (1);
    jarPluginRelativePath = jarPluginRelativePath.replace (File.separator, Messages.getString ("Characters_entry_separator"));
    ZipEntry jarPluginEntry = eclipseArchive.getEntry (jarPluginRelativePath);
    jarPluginInputStream = eclipseArchive.getInputStream (jarPluginEntry);
    JarInputStream inputStream = new JarInputStream (jarPluginInputStream);
    JarEntry entry;
    while ((entry = inputStream.getNextJarEntry ()) != null) {
        String entryName = entry.getName ();
        if (entryName.endsWith (Messages.getString ("Extensions_properties"))) {
            Properties properties = new Properties ();
            properties.load (inputStream);
            propertiesMap.put (entry.getName (), new HashSet < Object > (properties.keySet ()));
        }
    }
    inputStream.close ();
    jarPluginInputStream.close ();
    return propertiesMap;
}


private static void doZip (ZipOutputStream out, File f, String base, FilenameFilter filter) throws Exception {
    if (f.isDirectory ()) {
        File [] fl = f.listFiles (filter);
        out.putNextEntry (new ZipEntry (base + "/"));
        base = base.length () == 0 ? "" : base + "/";
        for (int i = 0; i < fl.length; i ++) {
            doZip (out, fl [i], base + fl [i].getName (), filter);
        }
    }
    else {
        out.putNextEntry (new ZipEntry (base));
        FileInputStream in = new FileInputStream (f);
        int b;
        System.out.println (base);
        while ((b = in.read ()) != - 1) {
            out.write (b);
        }
        in.close ();
    }
}


-----Function Pair=229=-----==

public void run () {
    try {
        waitForCompletion ();
    } catch (FaultType f) {
        logger.error (f);
        synchronized (status) {
            status.notifyAll ();
        }
        return;
    }
    if (AppServiceImpl.drmaaInUse || ! AppServiceImpl.globusInUse) {
        done = true;
        status.setCode (GramJob.STATUS_STAGE_OUT);
        status.setMessage ("Writing output metadata");
        if (AppServiceImpl.dbInUse) {
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException e) {
                status.setCode (GramJob.STATUS_FAILED);
                status.setMessage ("Cannot update status database after finish - " + e.getMessage ());
                logger.error (e);
                synchronized (status) {
                    status.notifyAll ();
                }
                return;
            }
        }
    }
    try {
        if (! AppServiceImpl.drmaaInUse && ! AppServiceImpl.globusInUse) {
            try {
                logger.debug ("Waiting for all outputs to be written out");
                stdoutThread.join ();
                stderrThread.join ();
                logger.debug ("All outputs successfully written out");
            } catch (InterruptedException ignore) {
            }
        }
        File stdOutFile = new File (workingDir + File.separator + "stdout.txt");
        if (! stdOutFile.exists ()) {
            throw new IOException ("Standard output missing for execution");
        }
        File stdErrFile = new File (workingDir + File.separator + "stderr.txt");
        if (! stdErrFile.exists ()) {
            throw new IOException ("Standard error missing for execution");
        }
        if (AppServiceImpl.archiveData) {
            logger.debug ("Archiving output files");
            File f = new File (workingDir);
            File [] outputFiles = f.listFiles ();
            ZipOutputStream out = new ZipOutputStream (new FileOutputStream (workingDir + File.separator + jobID + ".zip"));
            byte [] buf = new byte [1024];
            try {
                for (int i = 0; i < outputFiles.length; i ++) {
                    FileInputStream in = new FileInputStream (outputFiles [i]);
                    out.putNextEntry (new ZipEntry (outputFiles [i].getName ()));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    in.close ();
                }
                out.close ();
            } catch (IOException e) {
                logger.error (e);
                logger.error ("Error not fatal - moving on");
            }
        }
        File f = new File (workingDir);
        File [] outputFiles = f.listFiles ();
        OutputFileType [] outputFileObj = new OutputFileType [outputFiles.length - 2];
        int j = 0;
        for (int i = 0; i < outputFiles.length; i ++) {
            if (outputFiles [i].getName ().equals ("stdout.txt")) {
                outputs.setStdOut (new URI (AppServiceImpl.tomcatURL + jobID + "/stdout.txt"));
            }
            else if (outputFiles [i].getName ().equals ("stderr.txt")) {
                outputs.setStdErr (new URI (AppServiceImpl.tomcatURL + jobID + "/stderr.txt"));
            }
            else {
                OutputFileType next = new OutputFileType ();
                next.setName (outputFiles [i].getName ());
                next.setUrl (new URI (AppServiceImpl.tomcatURL + jobID + "/" + outputFiles [i].getName ()));
                outputFileObj [j ++] = next;
            }
        }
        outputs.setOutputFile (outputFileObj);
    } catch (IOException e) {
        status.setCode (GramJob.STATUS_FAILED);
        status.setMessage ("Cannot retrieve outputs after finish - " + e.getMessage ());
        logger.error (e);
        if (AppServiceImpl.dbInUse) {
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException se) {
                logger.error (se);
            }
        }
        synchronized (status) {
            status.notifyAll ();
        }
        return;
    }
    if (! AppServiceImpl.dbInUse) {
        AppServiceImpl.outputTable.put (jobID, outputs);
    }
    else {
        Connection conn = null;
        try {
            conn = DriverManager.getConnection (AppServiceImpl.dbUrl, AppServiceImpl.dbUser, AppServiceImpl.dbPasswd);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot connect to database after finish - " + e.getMessage ());
            logger.error (e);
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
        String sqlStmt = "insert into job_output(job_id, std_out, std_err) " + "values ('" + jobID + "', " + "'" + outputs.getStdOut ().toString () + "', " + "'" + outputs.getStdErr ().toString () + "');";
        Statement stmt = null;
        try {
            stmt = conn.createStatement ();
            stmt.executeUpdate (sqlStmt);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot update job output database after finish - " + e.getMessage ());
            logger.error (e);
            try {
                updateStatusInDatabase (jobID, status);
            } catch (SQLException se) {
                logger.error (se);
            }
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
        OutputFileType [] outputFile = outputs.getOutputFile ();
        for (int i = 0; i < outputFile.length; i ++) {
            sqlStmt = "insert into output_file(job_id, name, url) " + "values ('" + jobID + "', " + "'" + outputFile [i].getName () + "', " + "'" + outputFile [i].getUrl ().toString () + "');";
            try {
                stmt = conn.createStatement ();
                stmt.executeUpdate (sqlStmt);
            } catch (SQLException e) {
                status.setCode (GramJob.STATUS_FAILED);
                status.setMessage ("Cannot update output_file DB after finish - " + e.getMessage ());
                logger.error (e);
                try {
                    updateStatusInDatabase (jobID, status);
                } catch (SQLException se) {
                    logger.error (se);
                }
                synchronized (status) {
                    status.notifyAll ();
                }
                return;
            }
        }
    }
    if (terminatedOK ()) {
        status.setCode (GramJob.STATUS_DONE);
        status.setMessage ("Execution complete - " + "check outputs to verify successful execution");
    }
    else {
        status.setCode (GramJob.STATUS_FAILED);
        status.setMessage ("Execution failed");
    }
    if (AppServiceImpl.dbInUse) {
        try {
            updateStatusInDatabase (jobID, status);
        } catch (SQLException e) {
            status.setCode (GramJob.STATUS_FAILED);
            status.setMessage ("Cannot update status database after finish - " + e.getMessage ());
            logger.error (e);
            synchronized (status) {
                status.notifyAll ();
            }
            return;
        }
    }
    AppServiceImpl.jobTable.remove (jobID);
    synchronized (status) {
        status.notifyAll ();
    }
    logger.info ("Execution complete for job: " + jobID);
}


private int overlapDepth (ScheduleItem item) {
    Calendar cal = Calendar.getInstance ();
    ScheduleItem [] items = store.getScheduleArray ();
    HashMap < String, Channel > channels = store.getChannels ();
    Channel schChan = channels.get (item.getChannel ());
    String muxString = schChan.getFrequency () + "-" + schChan.getBandWidth ();
    Vector < ScheduleItem > operlapItems = new Vector < ScheduleItem > ();
    for (int x = 0; x < items.length; x ++) {
        if (items [x].toString ().equals (item.toString ()) == false) {
            if (item.isOverlapping (items [x])) {
                operlapItems.add (items [x]);
            }
        }
    }
    cal.setTime (item.getStart ());
    int duration = item.getDuration ();
    int maxCount = 0;
    for (int x = 0; x < duration; x ++) {
        HashMap < String, Integer > muxCountMap = new HashMap < String, Integer > ();
        muxCountMap.put (muxString, new Integer (1));
        for (int y = 0; y < operlapItems.size (); y ++) {
            ScheduleItem checkItem = (ScheduleItem) operlapItems.get (y);
            long slice = cal.getTime ().getTime ();
            if (slice > checkItem.getStart ().getTime () && slice < checkItem.getStop ().getTime ()) {
                Channel chackChan = channels.get (checkItem.getChannel ());
                String checkMuxString = chackChan.getFrequency () + "-" + chackChan.getBandWidth ();
                Integer muxCount = muxCountMap.get (checkMuxString);
                if (muxCount == null) {
                    muxCountMap.put (checkMuxString, new Integer (1));
                }
                else {
                    muxCountMap.put (checkMuxString, new Integer (muxCount.intValue () + 1));
                }
            }
        }
        String [] muxTotal = muxCountMap.keySet ().toArray (new String [0]);
        if (maxCount < muxTotal.length) maxCount = muxTotal.length;
        cal.add (Calendar.MINUTE, 1);
    }
    return maxCount;
}


-----Function Pair=230=-----==

private static boolean pack200 (String caption, File jarFile, File packFile) {
    System.out.println ("pack200");
    try {
        String [] cmds = new String [7];
        cmds [0] = PATH_TO_JDK + "pack200";
        cmds [1] = "--no-gzip";
        cmds [2] = "--strip-debug";
        cmds [3] = "--no-keep-file-order";
        cmds [4] = "--effort=9";
        cmds [5] = packFile.getAbsolutePath ();
        cmds [6] = jarFile.getAbsolutePath ();
        HighLevelSleep (EXEC_DELAY);
        Process proc = Runtime.getRuntime ().exec (cmds);
        ByteArrayOutputStream stdout = new ByteArrayOutputStream ();
        ByteArrayOutputStream stderr = new ByteArrayOutputStream ();
        Streams.asynchronousTransfer (proc.getInputStream (), stdout);
        Streams.asynchronousTransfer (proc.getErrorStream (), stderr);
        int exit = proc.waitFor ();
        System.out.println ("" + caption + "");
        if (stderr.size () != 0) {
            System.out.println ("" + Text.utf8 (stdout.toByteArray ()) + "");
            System.out.println ("" + Text.utf8 (stderr.toByteArray ()) + "");
        }
        if (exit != 0) {
            System.out.println ("Exit value: " + exit + "");
        }
        if (exit != 0) {
            return false;
        }
        return true;
    } catch (Exception exc) {
        System.out.println ("EXCEPTION: " + exc.getClass ().getName () + "");
        exc.printStackTrace ();
        return false;
    }
}


public String getCustomColumns (String libraryId, String category) {
    Integer libraryIdInt = new Integer (libraryId);
    String xml = "";
    try {
        LocalGENERAL_SETUP_PMT local = ((LocalGENERAL_SETUP_PMTHome) HomeFactory.getInstance ().getHome ("GENERAL_SETUP_PMT")).findByLibraryID (libraryIdInt);
        String s1 = local.getPat_Field_Cust ();
        String s2 = local.getHold_Field_Cust ();
        ejb.bprocess.util.Utility utility = ejb.bprocess.util.Utility.getInstance ();
        if (category.trim ().equals ("PATRON")) {
            xml = utility.getTestedString (s1);
        }
        else if (category.trim ().equals ("HOLDINGS")) {
            xml = utility.getTestedString (s2);
        }
    } catch (Exception exp) {
        exp.printStackTrace ();
    }
    return xml;
}


-----Function Pair=231=-----==

public static boolean bjwflate_deflopt_gz (String caption, File src, File dst, int splitSize, boolean noprep) {
    System.out.println ("bjwflate:" + splitSize + " @ " + System.currentTimeMillis ());
    File zip = new File (src.getParentFile (), src.getName () + ".zip");
    try {
        try {
            String [] cmds = new String [noprep ? 5 : 4];
            cmds [0] = BASE_DIR + "tools/BJWFlate.exe";
            cmds [1] = "-y";
            if (noprep) {
                cmds [2] = "-n";
            }
            cmds [noprep ? 3 : 2] = zip.getAbsolutePath ();
            cmds [noprep ? 4 : 3] = src.getAbsolutePath ();
            HighLevelSleep (EXEC_DELAY);
            final Process proc = Runtime.getRuntime ().exec (cmds, null);
            ByteArrayOutputStream stdout = new ByteArrayOutputStream ();
            ByteArrayOutputStream stderr = new ByteArrayOutputStream ();
            Streams.asynchronousTransfer (proc.getInputStream (), stdout);
            Streams.asynchronousTransfer (proc.getErrorStream (), stderr);
            final SimpleCountDownLatch latch = new SimpleCountDownLatch ();
            new Thread () {
                public void run () {
                    if (! latch.await (2 * 1000)) {
                        proc.destroy ();
                    }
                }
            }
            .start ();
            int exit = proc.waitFor ();
            latch.countDown ();
            if (splitSize == 4) {
                System.out.println ("" + caption + "");
            }
            if (stderr.size () != 0) {
                System.out.println ("" + Text.utf8 (stdout.toByteArray ()) + "");
                System.out.println ("" + Text.utf8 (stderr.toByteArray ()) + "");
            }
            if (exit != 0) {
                System.out.println ("Exit value: " + exit + "");
            }
            if (exit != 0) {
                return false;
            }
        } catch (Exception exc) {
            System.out.println ("EXCEPTION: " + exc.getClass ().getName () + "");
            exc.printStackTrace ();
            return false;
        }
        {
        }
        try {
            zip2gz (new FileInputStream (zip), new FileOutputStream (dst));
        } catch (IOException exc) {
            System.out.println ("EXCEPTION: " + exc.getClass ().getName () + "");
            exc.printStackTrace ();
            return false;
        }
        return true;
    } finally {
        zip.delete ();
    }
}


public static boolean copyFile (final File src, final File dst) throws FileNotFoundException {
    if (src == null || dst == null || src.equals (dst)) {
        return false;
    }
    boolean result = false;
    if (src.exists ()) {
        if (dst.exists () && ! dst.canWrite ()) {
            return false;
        }
        final FileInputStream srcStream = new FileInputStream (src);
        final FileOutputStream dstStream = new FileOutputStream (dst);
        final FileChannel srcChannel = srcStream.getChannel ();
        final FileChannel dstChannel = dstStream.getChannel ();
        FileLock dstLock = null;
        FileLock srcLock = null;
        try {
            srcLock = srcChannel.tryLock (0, Long.MAX_VALUE, true);
            dstLock = dstChannel.tryLock ();
            if (srcLock != null && dstLock != null) {
                int maxCount = 64 * 1024 * 1024 - 32 * 1024;
                long size = srcChannel.size ();
                long position = 0;
                while (position < size) {
                    position += srcChannel.transferTo (position, maxCount, dstChannel);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);
        } finally {
            if (srcChannel != null) {
                try {
                    if (srcLock != null) {
                        srcLock.release ();
                    }
                    srcChannel.close ();
                    srcStream.close ();
                } catch (IOException ex) {
                    Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);
                }
            }
            if (dstChannel != null) {
                try {
                    if (dstLock != null) {
                        dstLock.release ();
                    }
                    dstChannel.close ();
                    dstStream.close ();
                    result = true;
                } catch (IOException ex) {
                    Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);
                }
            }
        }
    }
    return result;
}


-----Function Pair=232=-----==

public void saveSolverConfigurations (Tasks task) throws SQLException, InterruptedException, InvocationTargetException, PropertyNotInDBException, PropertyTypeNotExistException, IOException, NoConnectionToDBException, ComputationMethodDoesNotExistException, ExpResultHasSolvPropertyNotInDBException, ExperimentResultNotInDBException, StatusCodeNotInDBException, ResultCodeNotInDBException, Exception {
    task.setStatus ("Checking jobs..");
    boolean yta = false;
    for (Solver solver : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (solver)) {
            if (entry.isModified () && entry.hasEmptyValues ()) {
                String [] options = {"Yes", "Yes to all", "No"};
                int userinput = JOptionPane.showOptionDialog (Tasks.getTaskView (), "The solver configuration " + entry.getName () + " has no value for a parameter which must have a value.\nDo you want to continue?", "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options [0]);
                if (userinput == 1) {
                    yta = true;
                    break;
                }
                else if (userinput == 2) {
                    return;
                }
            }
        }
        if (yta) {
            break;
        }
    }
    experimentResultCache.updateExperimentResults ();
    ArrayList < SolverConfiguration > deletedSolverConfigurations = solverConfigCache.getAllDeleted ();
    final ArrayList < ExperimentResult > deletedJobs = new ArrayList < ExperimentResult > ();
    final HashSet < Integer > scIds = new HashSet < Integer > ();
    for (SolverConfiguration sc : deletedSolverConfigurations) {
        scIds.add (sc.getId ());
    }
    for (ExperimentResult job : experimentResultCache.values ()) {
        if (scIds.contains (job.getSolverConfigId ())) {
            deletedJobs.add (job);
        }
    }
    ArrayList < SolverConfiguration > modifiedSolverConfigurations = solverConfigurationEntryModel.getModifiedSolverConfigurations ();
    yta = false;
    boolean nta = false;
    for (SolverConfiguration sc : modifiedSolverConfigurations) {
        int userinput = - 1;
        if (! yta && ! nta) {
            String [] options = {"Yes", "Yes to all", "No", "No to all"};
            userinput = JOptionPane.showOptionDialog (Tasks.getTaskView (), "The parameter values of the solver configuration " + sc.getName () + " have been changed.\nDo you want to delete the affected jobs?", "Warning", JOptionPane.DEFAULT_OPTION, JOptionPane.WARNING_MESSAGE, null, options, options [0]);
            if (userinput == 1) {
                yta = true;
            }
            else if (userinput == 3) {
                nta = true;
            }
        }
        if (! nta && (yta || userinput == 0)) {
            deletedJobs.addAll (ExperimentResultDAO.getAllBySolverConfiguration (sc));
        }
    }
    if (deletedJobs.size () > 0) {
        int notDeletableJobsCount = 0;
        for (ExperimentResult job : deletedJobs) {
            if (job.getStatus () != StatusCode.NOT_STARTED) {
                notDeletableJobsCount ++;
            }
        }
        String msg = "";
        if (notDeletableJobsCount > 0) {
            msg = "There are " + notDeletableJobsCount + " started jobs and " + (deletedJobs.size () - notDeletableJobsCount) + " jobs waiting in the database which would be deleted. ";
        }
        else {
            msg = "There are " + deletedJobs.size () + " jobs waiting in the database which would be deleted. ";
        }
        msg += "Do you want to continue?";
        int userInput = javax.swing.JOptionPane.showConfirmDialog (Tasks.getTaskView (), msg, "Jobs would be changed", javax.swing.JOptionPane.YES_NO_OPTION);
        if (userInput == 1) {
            return;
        }
        else {
            task.setStatus ("Deleting jobs..");
            ExperimentResultDAO.deleteExperimentResults (deletedJobs);
        }
    }
    task.setStatus ("Saving solver configurations..");
    List < SolverConfiguration > solverConfigurations = new LinkedList < SolverConfiguration > ();
    for (Solver s : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (s)) {
            if (entry.getSolverConfig () == null) {
                SolverConfiguration sc = new SolverConfiguration ();
                sc.setSolverBinary (entry.getSolverBinary ());
                sc.setExperiment_id (activeExperiment.getId ());
                sc.setSeed_group (entry.getSeedGroup ());
                sc.setName (entry.getName ());
                sc.setHint (entry.getHint ());
                entry.setSolverConfig (sc);
                solverConfigurations.add (sc);
            }
        }
    }
    solverConfigCache.createAll (solverConfigurations);
    List < ParameterInstance > parameterInstances = new LinkedList < ParameterInstance > ();
    for (Solver s : solverConfigurationEntryModel.getSolvers ()) {
        for (SolverConfigurationEntry entry : solverConfigurationEntryModel.getEntries (s)) {
            if (entry.getSolverConfig () == null) {
                entry.setSolverConfig (solverConfigCache.createSolverConfiguration (entry.getSolverBinary (), activeExperiment.getId (), entry.getSeedGroup (), entry.getName (), entry.getHint ()));
            }
            else {
                entry.getSolverConfig ().setSolverBinary (entry.getSolverBinary ());
                entry.getSolverConfig ().setName (entry.getName ());
                entry.getSolverConfig ().setSeed_group (entry.getSeedGroup ());
                entry.getSolverConfig ().setHint (entry.getHint ());
            }
            parameterInstances.addAll (entry.getParameterInstances ());
        }
    }
    ParameterInstanceDAO.saveBulk (parameterInstances);
    solverConfigCache.saveAll ();
    refreshGenerateJobsModel ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            Util.updateTableColumnWidth (main.tblGenerateJobs, 1);
        }
    }
    );
}


public static String [] fireQSub (String queue, String commands, String fullPathToTempDir, boolean waitAndClean) {
    String name = "tmp" + Passwords.createRandowWord (6);
    String shell = "#!/bin/sh \n" + "#$ -N " + name + " \n" + "#$ -j oe \n" + "#$ -o " + fullPathToTempDir + " \n" + "#$ -q " + queue + " \n" + "#$ -l nodes=1 \n" + commands + " \n" + "echo \"Finished!\"\n";
    System.out.print (shell);
    File shellFile = new File (fullPathToTempDir, name + ".sh");
    writeString (shell, shellFile);
    try {
        Runtime rt = Runtime.getRuntime ();
        Process p = rt.exec ("qsub " + shellFile);
        System.out.println ("Fired qsub");
        if (waitAndClean == false) return null;
        boolean wait = true;
        File dir = new File (fullPathToTempDir);
        File outputFile = null;
        long counter = 0;
        long milSec = 30000;
        ArrayList dataArrayList = new ArrayList (1000);
        System.out.print ("Waiting");
        while (wait) {
            Thread.sleep (milSec);
            if (outputFile == null) {
                String [] fileNames = dir.list ();
                for (int i = fileNames.length - 1; i >= 0; i --) {
                    if (fileNames [i].startsWith (name + ".o")) {
                        outputFile = new File (fullPathToTempDir, fileNames [i]);
                        System.out.println ("\nFound results file: " + outputFile.getName ());
                        break;
                    }
                }
            }
            if (outputFile != null) {
                String lastLine = "";
                String line;
                dataArrayList.clear ();
                BufferedReader in = new BufferedReader (new FileReader (outputFile));
                while ((line = in.readLine ()) != null) {
                    lastLine = line;
                    dataArrayList.add (line);
                }
                in.close ();
                if (lastLine.startsWith ("Finished!") || lastLine.startsWith ("cd: Too many arguments")) wait = false;
            }
            counter ++;
            System.out.print (".");
            if (counter > 57600000) {
                System.out.println ("\n    Error: shell script failed to return from qsub after " + counter / 60000 + " minutes.\nFind and kill the job: (text Nix, process number is the last digits after the .o in -> " + outputFile.getName ());
                System.exit (1);
            }
        }
        System.out.println ("\nResults are ready!");
        String [] fileNames = dir.list ();
        for (int i = fileNames.length - 1; i >= 0; i --) {
            if (fileNames [i].startsWith (name)) {
                new File (fullPathToTempDir, fileNames [i]).delete ();
                System.out.println ("Deleting-> " + fileNames [i]);
            }
        }
        System.out.println ("Time for run: " + (counter * (milSec / 1000)) + " seconds\n");
        dataArrayList.trimToSize ();
        String [] x = new String [dataArrayList.size ()];
        dataArrayList.toArray (x);
        return x;
    } catch (Exception e) {
        System.out.println ("Problem with fireQSub()");
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=233=-----==

public static void exportCards (ArrayList < Card > cards, String zipFileName) {
    try {
        FileOutputStream outZipPic = new FileOutputStream (ZIP_PIC_FILE_NAME);
        ZipOutputStream zipOutPic = new ZipOutputStream (outZipPic);
        int numPic = 0;
        ArrayList < Card > newCards = new ArrayList < Card > ();
        for (Iterator < Card > it = cards.iterator (); it.hasNext ();) {
            try {
                Card card = it.next ();
                Card newCard = new Card ();
                newCard.copy (card);
                if (card.getImgFront () != null && ! card.getImgFront ().equals ("")) {
                    File ff = new File (card.getImgFront ());
                    if (ff.exists ()) {
                        numPic ++;
                        String newFileName = addFile (ff, zipOutPic, null);
                        newCard.setImgFront (newFileName);
                    }
                }
                if (card.getImgBack () != null && ! card.getImgBack ().equals ("")) {
                    File ff = new File (card.getImgBack ());
                    if (ff.exists ()) {
                        numPic ++;
                        String newFileName = addFile (ff, zipOutPic, null);
                        newCard.setImgBack (newFileName);
                    }
                }
                newCards.add (newCard);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        if (numPic > 0) {
            zipOutPic.finish ();
            zipOutPic.close ();
        }
        outZipPic.close ();
        String xml = convertCardsToXML (newCards);
        FileOutputStream outZip = new FileOutputStream (zipFileName);
        ZipOutputStream zipOut = new ZipOutputStream (outZip);
        ZipEntry entry = new ZipEntry (XML_FILE_NAME);
        byte [] xmlBytes = xml.getBytes ("UTF-8");
        int size = xmlBytes.length;
        System.out.println ("size = " + size);
        zipOut.putNextEntry (entry);
        zipOut.write (xmlBytes);
        zipOut.closeEntry ();
        File zippicF = new File (ZIP_PIC_FILE_NAME);
        if (zippicF.exists ()) {
            addFile (zippicF, zipOut, ZIP_PIC_FILE_NAME);
        }
        zipOut.finish ();
        zipOut.close ();
        outZip.close ();
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


public static boolean decmprsFile (String source, String target) throws Exception {
    boolean result = false;
    int cnt = 0;
    byte [] buffer = new byte [BUFFER_SIZE];
    FileInputStream finput = null;
    FileOutputStream foutput = null;
    ZipInputStream zinput = null;
    String source1 = source.replace ('\\', FILE_SEPARATOR).replace ('/', FILE_SEPARATOR);
    String target1 = target.replace ('\\', FILE_SEPARATOR).replace ('/', FILE_SEPARATOR);
    File srcFile = new File (source1);
    if (srcFile.exists () && srcFile.isFile ()) {
        String target2 = EgovFileTool.createNewDirectory (target1);
        File tarFile = new File (target2);
        finput = new FileInputStream (srcFile);
        zinput = new ZipInputStream ((InputStream) finput);
        foutput = null;
        ZipEntry entry;
        try {
            while ((entry = zinput.getNextEntry ()) != null) {
                String filename = entry.getName ();
                String tempFile = EgovFileTool.createNewFile (tarFile.getAbsolutePath () + FILE_SEPARATOR + filename);
                File efile = new File (tempFile);
                foutput = new FileOutputStream (efile);
                while ((cnt = zinput.read (buffer)) != - 1) {
                    if (foutput != null) foutput.write (buffer, 0, cnt);
                }
            }
            result = true;
        } catch (Exception e) {
            throw e;
        } finally {
            if (finput != null) finput.close ();
            if (zinput != null) zinput.close ();
            if (foutput != null) foutput.close ();
        }
    }
    return result;
}


-----Function Pair=234=-----=1=

public void action (Map < String, ClassInfo > map, String...files) throws Exception {
    Remapper remapper = new Remapper (map);
    for (String file : files) {
        String newFile = file + ".br.jar";
        ZipFile zip = new ZipFile (file);
        ZipOutputStream zos = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (newFile)));
        for (Enumeration < ? extends ZipEntry > entries = zip.entries (); entries.hasMoreElements ();) {
            ZipEntry entry = entries.nextElement ();
            if (entry.isDirectory ()) {
                zos.putNextEntry (new ZipEntry (entry.getName ()));
                zos.closeEntry ();
            }
            else if (entry.getName ().endsWith (".class")) {
                ClassWriter writer = new ClassWriter (0);
                ClassNameVisitor classNameVisitor = new ClassNameVisitor (writer);
                ClassVisitor visitor = new ClassForNameFixVisitor (new RemappingClassAdapter (classNameVisitor, remapper), remapper);
                new ClassReader (zip.getInputStream (entry)).accept (visitor, 0);
                String className = classNameVisitor.getName ();
                ZipEntry newEntry = new ZipEntry (className + ".class");
                zos.putNextEntry (newEntry);
                zos.write (writer.toByteArray ());
                zos.closeEntry ();
            }
            else {
                zos.putNextEntry (new ZipEntry (entry.getName ()));
                byte [] buff = new byte [10240];
                int cnt = 0;
                InputStream is = zip.getInputStream (entry);
                while ((cnt = is.read (buff)) > 0) {
                    zos.write (buff, 0, cnt);
                }
                zos.closeEntry ();
            }
        }
        zos.close ();
    }
}


public void actionPerformed (ActionEvent e) {
    String cmd = e.getActionCommand ();
    if (cmd.equals (LOAD)) {
        if (fc == null) {
            fc = new JFileChooser (System.getProperty ("user.dir"));
            fc.addChoosableFileFilter (new ExtFileFilter ("jar", Messages.getString ("XCsiripJAVA_ARCHIVES")));
            fc.addChoosableFileFilter (new ExtFileFilter ("zip", Messages.getString ("XCsiripZIP_ARCHIVES")));
        }
        if (JFileChooser.APPROVE_OPTION == fc.showOpenDialog (this)) {
            File file = fc.getSelectedFile ();
            loadedTheme = file.getAbsolutePath ();
            se.load (loadedTheme);
        }
    }
    else if (cmd.equals (RESTORE)) {
        if (loadedTheme != null) {
            se.load (loadedTheme);
        }
        else {
            this.remove (se);
            se = null;
            se = new SkinEditor ();
            getContentPane ().add (se);
        }
    }
    else if (cmd.equals (SAVE)) {
        if (fc == null) {
            fc = new JFileChooser (System.getProperty ("user.dir"));
            fc.addChoosableFileFilter (new ExtFileFilter ("jar", Messages.getString ("XCsiripJAVA_ARCHIVES")));
            fc.addChoosableFileFilter (new ExtFileFilter ("zip", Messages.getString ("XCsiripZIP_ARCHIVES")));
        }
        String css = se.getCSS ();
        String theme = se.getTheme ();
        String saveZip = null;
        String themeName = null;
        if (JFileChooser.APPROVE_OPTION == fc.showSaveDialog (this)) {
            File file = fc.getSelectedFile ();
            saveZip = file.getAbsolutePath ();
            themeName = file.getName ();
        }
        if (saveZip != null) {
            String [] filenames = new String [] {themeName + ".css", themeName + ".theme"};
            try {
                BufferedWriter out = new BufferedWriter (new FileWriter (filenames [0]));
                out.write (css);
                out.close ();
                out = new BufferedWriter (new FileWriter (filenames [1]));
                out.write (theme);
                out.close ();
            } catch (IOException ex) {
            }
            byte [] buf = new byte [1024];
            try {
                ZipOutputStream out = new ZipOutputStream (new FileOutputStream (saveZip));
                for (int i = 0; i < filenames.length; i ++) {
                    FileInputStream in = new FileInputStream (filenames [i]);
                    out.putNextEntry (new ZipEntry (filenames [i]));
                    int len;
                    while ((len = in.read (buf)) > 0) {
                        out.write (buf, 0, len);
                    }
                    out.closeEntry ();
                    in.close ();
                }
                out.close ();
            } catch (IOException ex) {
                ex.printStackTrace ();
            }
            new File (filenames [0]).delete ();
            new File (filenames [1]).delete ();
        }
    }
    else if (cmd.equals (CANCEL)) {
        dispose ();
    }
}


-----Function Pair=235=-----==

private String readDocXmlTemplate (String srcFileName) {
    String s = "";
    try {
        File file = new File (srcFileName);
        FileInputStream fis = new FileInputStream (file);
        InputStreamReader reader = new InputStreamReader (fis, "UTF-8");
        BufferedReader br = new BufferedReader (reader);
        String str = null;
        while ((str = br.readLine ()) != null) {
            s = s + str;
        }
        reader.close ();
        br.close ();
    } catch (FileNotFoundException e) {
        System.out.println ("没有找到模板文件！");
        e.printStackTrace ();
    } catch (UnsupportedEncodingException e) {
        System.out.println ("读取模板：不支持的字符编码！");
        e.printStackTrace ();
    } catch (IOException e) {
        System.out.println ("模板IO错误！");
        e.printStackTrace ();
    }
    return s;
}


public boolean saveImpl (Document content, OutputStream out) {
    ZipOutputStream zos = null;
    if (out instanceof ZipOutputStream) zos = (ZipOutputStream) out;
    else zos = new ZipOutputStream (out);
    ZipEntry partEntry = new ZipEntry (CONTENT_TYPES_PART_NAME);
    try {
        zos.putNextEntry (partEntry);
        ByteArrayOutputStream outTemp = new ByteArrayOutputStream ();
        StreamHelper.saveXmlInStream (content, out);
        InputStream ins = new ByteArrayInputStream (outTemp.toByteArray ());
        byte [] buff = new byte [ZipHelper.READ_WRITE_FILE_BUFFER_SIZE];
        while (ins.available () > 0) {
            int resultRead = ins.read (buff);
            if (resultRead == - 1) {
                break;
            }
            else {
                zos.write (buff, 0, resultRead);
            }
        }
        zos.closeEntry ();
    } catch (IOException ioe) {
        logger.error ("Cannot write: " + CONTENT_TYPES_PART_NAME + " in Zip !", ioe);
        return false;
    }
    return true;
}


-----Function Pair=236=-----==

public static byte [] readFile (File file) throws Exception {
    if (! file.exists ()) {
        throw new FileNotFoundException ("File not found " + file.getName ());
    }
    long originalFileSize = file.length ();
    if (originalFileSize > Integer.MAX_VALUE) {
        throw new Exception ("The method supports files with maxsize of Integer.MAX_VALUE");
    }
    int fileSize = (int) originalFileSize;
    if (fileSize == 0) {
        return new byte [0];
    }
    FileInputStream fis = new FileInputStream (file);
    byte [] fileContent;
    try {
        fileContent = new byte [fileSize];
        fis.read (fileContent);
    } finally {
        fis.close ();
    }
    return fileContent;
}


public void channel (SessionStatusSignal signal) {
    String name = signal.getName ();
    if (signal.STOP.equals (signal.getStatus ())) {
        synchronized (maps) {
            Map.Entry entry;
            for (Iterator i = maps.entrySet ().iterator (); i.hasNext ();) {
                entry = (Map.Entry) i.next ();
                if (String.valueOf (entry.getKey ()).indexOf (SESSION_SEPARATOR) > 0) {
                    i.remove ();
                }
            }
        }
        curSessionName = null;
    }
    else if (signal.START_REQUEST.equals (signal.getStatus ())) {
        if (log.isDebugEnabled ()) {
            log.debug ("starting session:" + name);
        }
        curSessionName = name;
        bus.broadcast (new SessionStatusSignal (SessionStatusSignal.START, signal.getSession ()));
    }
}


-----Function Pair=237=-----==

public void buildZipFile () {
    File bdir = new File (getBeanDir ());
    File mdir = new File (sloc + psep + "META-INF");
    File zdir = new File (sloc);
    String zname = name + ".zip";
    File myZipFile = new File (zdir, zname);
    byte [] buf = new byte [1024];
    try {
        myZipFile.createNewFile ();
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (myZipFile));
        File [] mfiles = mdir.listFiles ();
        File [] bfiles = bdir.listFiles ();
        StringTokenizer dirs = new StringTokenizer (pack, "\\.");
        String dpath = "";
        out.putNextEntry (new ZipEntry ("META-INF/"));
        for (int i = 0; i < mfiles.length; i ++) {
            File cfile = new File (sloc + psep + "META-INF" + psep + mfiles [i].getName ());
            FileInputStream in = new FileInputStream (cfile);
            out.putNextEntry (new ZipEntry ("META-INF/" + mfiles [i].getName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        while (dirs.hasMoreTokens ()) {
            dpath = dpath + dirs.nextToken () + "/";
            out.putNextEntry (new ZipEntry (dpath));
        }
        for (int i = 0; i < bfiles.length; i ++) {
            File cfile = new File (getBeanDir () + psep + bfiles [i].getName ());
            FileInputStream in = new FileInputStream (cfile);
            out.putNextEntry (new ZipEntry (dpath + bfiles [i].getName ()));
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (IOException e) {
        System.out.println ("I/O Exception: " + e);
    }
}


public static String ExtractZip (String zipName, String outFolder) {
    try {
        File sourceZipFile = new File (zipName);
        File outDirectory = new File (outFolder);
        ZipFile zipFile = new ZipFile (sourceZipFile, ZipFile.OPEN_READ);
        Enumeration zipFileEntries = zipFile.entries ();
        while (zipFileEntries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) zipFileEntries.nextElement ();
            String currentEntry = entry.getName ();
            for (int X = currentEntry.length () - 1; X >= 0; X --) {
                if (currentEntry.charAt (X) == '\\' || currentEntry.charAt (X) == '/') {
                    currentEntry = currentEntry.substring (X + 1);
                    break;
                }
            }
            File destFile = new File (outDirectory, currentEntry);
            if (destFile.getParentFile () != null) destFile.getParentFile ().mkdirs ();
            if (! entry.isDirectory ()) {
                BufferedInputStream is = new BufferedInputStream (zipFile.getInputStream (entry));
                int currentByte;
                byte data [] = new byte [BUFFER];
                FileOutputStream fos = new FileOutputStream (destFile);
                BufferedOutputStream dest = new BufferedOutputStream (fos, BUFFER);
                while ((currentByte = is.read (data, 0, BUFFER)) != - 1) dest.write (data, 0, currentByte);
                dest.flush ();
                dest.close ();
                is.close ();
            }
        }
        zipFile.close ();
        return "success";
    } catch (IOException e) {
        return "Failed to extract zip: " + e.toString ();
    }
}


-----Function Pair=238=-----==

public static Map < String, ByteArrayInputStream > unPackFile (InputStream input) {
    HashMap < String, ByteArrayInputStream > inputs = new HashMap < String, ByteArrayInputStream > ();
    ZipInputStream zip_in = new ZipInputStream (input);
    try {
        while (true) {
            try {
                ZipEntry entry = zip_in.getNextEntry ();
                if (entry != null) {
                    ByteArrayInputStream bais = new ByteArrayInputStream (readBytes (zip_in));
                    inputs.put (entry.getName (), bais);
                }
                else {
                    break;
                }
            } catch (Throwable ex) {
                ex.printStackTrace ();
                break;
            }
        }
    } finally {
        try {
            zip_in.close ();
        } catch (IOException e) {
        }
    }
    return inputs;
}


private String getTemplateParam (DicomObject blobAttrs, String param, HashSet < Integer > sopHash) {
    boolean useHash = param.charAt (0) == '#';
    String value;
    if (param.endsWith ("patID")) {
        value = blobAttrs.getString (Tag.PatientID);
    }
    else if (param.endsWith ("patName")) {
        value = blobAttrs.getString (Tag.PatientName);
    }
    else if (param.endsWith ("studyIuid")) {
        value = blobAttrs.getString (Tag.StudyInstanceUID);
    }
    else if (param.endsWith ("seriesIuid")) {
        value = blobAttrs.getString (Tag.SeriesInstanceUID);
    }
    else if (param.endsWith ("sopIuid")) {
        value = blobAttrs.getString (Tag.SOPInstanceUID);
        if (useHash) {
            int hash;
            for (hash = value.hashCode (); ! sopHash.add (hash); hash ++);
            return FileUtils.toHex (hash);
        }
    }
    else {
        throw new IllegalArgumentException ("Unknown zip entry template parameter:" + param);
    }
    return useHash ? FileUtils.toHex (value == null ? - 1 : value.hashCode ()) : value;
}


-----Function Pair=239=-----==

public static int getLastLineWith (File fileName, String textToFind) throws IOException {
    String line;
    FileInputStream fis = new FileInputStream (fileName);
    BufferedReader reader = new BufferedReader (new InputStreamReader (fis));
    int lineNumber = 0;
    int toRet = - 1;
    while ((line = reader.readLine ()) != null) {
        if (Pattern.compile (textToFind).matcher (line).find ()) {
            toRet = lineNumber;
        }
        lineNumber ++;
    }
    reader.close ();
    return toRet;
}


private static List < String > getOutputFilesList (String username, String workflow) {
    String prefix = PropertyLoader.getPrefixDir ();
    File outputListFile = new File (prefix + "/users/" + username + "/" + workflow + "_files/outputFilesRemotePath.dat");
    List < String > files = new ArrayList < String > ();
    try {
        BufferedReader br = new BufferedReader (new FileReader (outputListFile));
        String line = null;
        while ((line = br.readLine ()) != null) {
            line = line.trim ();
            if (! (line.equals (""))) {
                files.add (line);
            }
        }
    } catch (Exception ex) {
        return null;
    }
    if (files.size () == 0) return null;
    return files;
}


-----Function Pair=240=-----==

public boolean zipDir (String inputDirPath, String dir2zip, ZipOutputStream zos) {
    try {
        File zipDir = new File (inputDirPath);
        String dirList [] = zipDir.list ();
        byte readBuffer [] = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String fileDirPath = f.getPath ();
                zipDir (fileDirPath, fileDirPath, zos);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String filePath = f.getPath ();
            ZipEntry anEntry = new ZipEntry (filePath);
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) zos.write (readBuffer, 0, bytesIn);
            fis.close ();
        }
        return (true);
    } catch (Exception e) {
        errMsgLog += "Problem zipping to zip file '" + dir2zip + "' in zipDir() failed.";
        lastErrMsgLog = errMsgLog;
        return (false);
    }
}


protected ArchiveState getResourcesToAdd (FileSet [] filesets, File zipFile, boolean needsUpdate) throws BuildException {
    Resource [] [] initialResources = grabResources (filesets);
    if (isEmpty (initialResources)) {
        if (needsUpdate && doUpdate) {
            return new ArchiveState (true, initialResources);
        }
        if (emptyBehavior.equals ("skip")) {
            if (doUpdate) {
                logWhenWriting (archiveType + " archive " + zipFile + " not updated because no new files were" + " included.", Project.MSG_VERBOSE);
            }
            else {
                logWhenWriting ("Warning: skipping " + archiveType + " archive " + zipFile + " because no files were included.", Project.MSG_WARN);
            }
        }
        else if (emptyBehavior.equals ("fail")) {
            throw new BuildException ("Cannot create " + archiveType + " archive " + zipFile + ": no files were included.", getLocation ());
        }
        else {
            if (! zipFile.exists ()) {
                needsUpdate = true;
            }
        }
        return new ArchiveState (needsUpdate, initialResources);
    }
    if (! zipFile.exists ()) {
        return new ArchiveState (true, initialResources);
    }
    if (needsUpdate && ! doUpdate) {
        return new ArchiveState (true, initialResources);
    }
    Resource [] [] newerResources = new Resource [filesets.length] [];
    for (int i = 0; i < filesets.length; i ++) {
        if (! (fileset instanceof ZipFileSet) || ((ZipFileSet) fileset).getSrc (getProject ()) == null) {
            File base = filesets [i].getDir (getProject ());
            for (int j = 0; j < initialResources [i].length; j ++) {
                File resourceAsFile = FILE_UTILS.resolveFile (base, initialResources [i] [j].getName ());
                if (resourceAsFile.equals (zipFile)) {
                    throw new BuildException ("A zip file cannot include " + "itself", getLocation ());
                }
            }
        }
    }
    for (int i = 0; i < filesets.length; i ++) {
        if (initialResources [i].length == 0) {
            newerResources [i] = new Resource [] {};
            continue;
        }
        FileNameMapper myMapper = new IdentityMapper ();
        if (filesets [i] instanceof ZipFileSet) {
            ZipFileSet zfs = (ZipFileSet) filesets [i];
            if (zfs.getFullpath (getProject ()) != null && ! zfs.getFullpath (getProject ()).equals ("")) {
                MergingMapper fm = new MergingMapper ();
                fm.setTo (zfs.getFullpath (getProject ()));
                myMapper = fm;
            }
            else if (zfs.getPrefix (getProject ()) != null && ! zfs.getPrefix (getProject ()).equals ("")) {
                GlobPatternMapper gm = new GlobPatternMapper ();
                gm.setFrom ("*");
                String prefix = zfs.getPrefix (getProject ());
                if (! prefix.endsWith ("/") && ! prefix.endsWith ("\\")) {
                    prefix += "/";
                }
                gm.setTo (prefix + "*");
                myMapper = gm;
            }
        }
        newerResources [i] = selectOutOfDateResources (initialResources [i], myMapper);
        needsUpdate = needsUpdate || (newerResources [i].length > 0);
        if (needsUpdate && ! doUpdate) {
            break;
        }
    }
    if (needsUpdate && ! doUpdate) {
        return new ArchiveState (true, initialResources);
    }
    return new ArchiveState (needsUpdate, newerResources);
}


-----Function Pair=241=-----==

public String [] [] getAllZipEntries (ZipFile zf, Vector zipEntryList) {
    int nEntries = zipEntryList.size ();
    String data = null, name, dataList [] [] = new String [nEntries] [];
    try {
        for (int i = 0; i < nEntries; i ++) {
            ZipEntry ze = (ZipEntry) zipEntryList.elementAt (i);
            name = ze.getName ();
            byte buf [] = new byte [(int) ze.getSize ()];
            InputStream is = zf.getInputStream (ze);
            int len = 0, off = 0;
            while (off < buf.length && (len = is.read (buf, off, buf.length - off)) >= 0) off += len;
            data = new String (buf);
            dataList [i] = new String [2];
            dataList [i] [0] = name;
            dataList [i] [1] = data;
        }
    } catch (Exception e) {
        return (null);
    }
    return (dataList);
}


private void saveInternal (File file, Collection < EdgeMappingDescriptor > descriptors, TaskMonitor monitor) throws IOException {
    if (! file.getName ().endsWith (".ov1")) {
        file = new File (file.getAbsolutePath () + ".ov1");
    }
    File graphFile = OndexPlugin.getInstance ().getOndexGraphFile ();
    File mappingFile = new File (System.getProperty ("java.io.tmpdir") + File.separator + "ondex_mapping.tsv");
    monitor.setStatus ("saving mapping descriptors...");
    monitor.setPercentCompleted (10);
    saveMapping (mappingFile, descriptors);
    File [] inFiles = new File [] {graphFile, mappingFile};
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (file));
    monitor.setStatus ("compressing...");
    for (File inFile : inFiles) {
        FileInputStream in = new FileInputStream (inFile);
        out.putNextEntry (new ZipEntry (inFile.getName ()));
        int len;
        byte [] buf = new byte [1024];
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        in.close ();
        out.closeEntry ();
    }
    out.close ();
    monitor.setPercentCompleted (95);
}


-----Function Pair=242=-----==

public void mergeConvertedFiles (SaxHandler theXmlHandler, int theEventId, Attributes theAtts) throws BpsProcessException {
    String myOutputFormat;
    String myFinalFile;
    String myHdrFile;
    RandomAccessFile myHdrFileAccess;
    int myTempElemNb;
    String myTempFile;
    String myTempFile2;
    RandomAccessFile myFinalFileAccess;
    RandomAccessFile myTempFileAccess;
    final int myBufferSize;
    byte [] myBuffer;
    int myNbRead;
    String myRequestDir;
    File myRequestDirId;
    myOutputFormat = "?";
    myFinalFile = null;
    myHdrFile = "header.ps";
    myTempElemNb = 0;
    myTempFile = null;
    myTempFile2 = null;
    myFinalFileAccess = null;
    myTempFileAccess = null;
    myBufferSize = 4096;
    myBuffer = new byte [myBufferSize];
    myNbRead = 0;
    myRequestDir = null;
    myRequestDirId = null;
    myOutputFormat = theXmlHandler.getRequestData ().getDocSet ().getOutputFormat ();
    try {
        myFinalFile = theXmlHandler.getRequestData ().getDocSet ().getGenFileName ();
        myRequestDir = theXmlHandler.getOutputDir () + File.separatorChar + theXmlHandler.getRequestData ().getBpaRequest ().getRequestNumber ().trim () + "@" + ((BpsProcess) (theXmlHandler.getJBpsThread ())).getSysParam ().getBpsManagerName ();
        myRequestDirId = new File (myRequestDir);
        if (myRequestDirId.exists () == false) myRequestDirId.mkdir ();
        if (myFinalFile.charAt (0) != '/') {
            myFinalFile = myRequestDir + File.separatorChar + myFinalFile;
        }
        else {
            myFinalFile = myFinalFile.replace ('/', '~');
            myFinalFile = myRequestDir + File.separatorChar + myFinalFile;
        }
        if (myOutputFormat.equalsIgnoreCase (DocSet.OUTPUT_FORMAT_PS)) {
            myFinalFileAccess = new RandomAccessFile (myFinalFile, "rw");
            myHdrFileAccess = new RandomAccessFile (theXmlHandler.getStaticDir () + File.separatorChar + myHdrFile, "r");
            while ((myNbRead = myHdrFileAccess.read (myBuffer, 0, myBufferSize)) != - 1) {
                myFinalFileAccess.write (myBuffer, 0, myNbRead);
            }
            myHdrFileAccess.close ();
            myTempElemNb = theXmlHandler.getRequestData ().getDocSet ().getSize ();
            for (int i = 0; i < myTempElemNb; i ++) {
                myTempFile = theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getTempFileName ();
                String myDuplexChoice = null;
                if (theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getDocsetObject ().getType () == DocsetObject.DOC) myDuplexChoice = ((Doc) (theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getDocsetObject ())).getMethod ();
                else if (theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getDocsetObject ().getType () == DocsetObject.APPDOC) myDuplexChoice = ((AppDoc) (theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getDocsetObject ())).getMethod ();
                String myStapleStatus = null;
                myStapleStatus = theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getStaplingStatus ();
                if (myDuplexChoice != null) myFinalFileAccess.writeBytes ("(" + myDuplexChoice + ") BPSDuplex\r\n");
                if (myStapleStatus != null) myFinalFileAccess.writeBytes ("(" + myStapleStatus + ") BPSStaple\r\n");
                for (int j = 0; j < theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getNbPages (); j ++) {
                    myTempFile2 = myTempFile + "." + j;
                    if (myTempFile2 != null) {
                        myTempFileAccess = new RandomAccessFile (myTempFile2, "r");
                        while ((myNbRead = myTempFileAccess.read (myBuffer, 0, myBufferSize)) != - 1) {
                            myFinalFileAccess.write (myBuffer, 0, myNbRead);
                        }
                        myTempFileAccess.close ();
                    }
                }
            }
            myFinalFileAccess.close ();
        }
        if (myOutputFormat.equalsIgnoreCase (DocSet.OUTPUT_FORMAT_PDF)) {
            myTempElemNb = theXmlHandler.getRequestData ().getDocSet ().getSize ();
            for (int i = 0; i < myTempElemNb; i ++) {
                myTempFile = theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getTempFileName ();
                for (int j = 0; j < theXmlHandler.getRequestData ().getDocSet ().getTempElem (i).getNbPages (); j ++) {
                    myTempFile2 = myTempFile + "." + j;
                    if (myTempFile2 != null) {
                        int mySnowReturn = 0;
                        System.gc ();
                    }
                }
            }
        }
        if (myOutputFormat.equalsIgnoreCase (DocSet.OUTPUT_FORMAT_TIFF)) {
            String inputDir = theXmlHandler.getRequestData ().getWorkDirectory () + File.separatorChar + "DocSet" + (theXmlHandler.getRequestData ().getSize () - 1);
            String [] myFullList = sortTiffFileList (Tools.getFileList (inputDir), theXmlHandler);
            File myOutputDir = new File (myRequestDir + File.separatorChar + theXmlHandler.getRequestData ().getDocSet ().getGenFileName ());
            myOutputDir.mkdir ();
            for (int i = 0; i < myFullList.length; i ++) {
                myTempFile = myRequestDir + File.separatorChar + theXmlHandler.getRequestData ().getDocSet ().getGenFileName () + File.separatorChar + constructTiffFilename ("" + (i + 1));
                Tools.copyFile (inputDir + File.separatorChar + myFullList [i], myTempFile);
            }
        }
        if (myOutputFormat.equalsIgnoreCase (DocSet.OUTPUT_FORMAT_THUMB)) {
            String inputDir = theXmlHandler.getRequestData ().getWorkDirectory () + File.separatorChar + "DocSet" + (theXmlHandler.getRequestData ().getSize () - 1);
            String [] myFullList = Tools.getFileList (inputDir);
            File myOutputDir = new File (myRequestDir + File.separatorChar + theXmlHandler.getRequestData ().getDocSet ().getGenFileName ());
            myOutputDir.mkdir ();
            for (int i = 0; i < myFullList.length; i ++) {
                myTempFile = myRequestDir + File.separatorChar + theXmlHandler.getRequestData ().getDocSet ().getGenFileName () + File.separatorChar + myFullList [i].substring (myFullList [i].lastIndexOf ('.') + 1);
                Tools.copyFile (inputDir + File.separatorChar + myFullList [i], myTempFile);
            }
        }
        if (myOutputFormat.equalsIgnoreCase (DocSet.OUTPUT_FORMAT_ASIS)) {
            String inputDir = theXmlHandler.getRequestData ().getWorkDirectory () + File.separatorChar + "DocSet" + (theXmlHandler.getRequestData ().getSize () - 1);
            String [] myFullList = Tools.getFileList (inputDir);
            File myOutputDir = new File (myFinalFile);
            myOutputDir.mkdir ();
            for (int i = 0; i < myFullList.length; i ++) {
                myTempFile = myFinalFile + File.separatorChar + myFullList [i];
                Tools.copyFile (inputDir + File.separatorChar + myFullList [i], myTempFile);
            }
        }
    } catch (IOException error) {
        throw (new BpsProcessException (BpsException.ERR_PROCESS_RETRY, "Error in file management for docset ending : " + error.getMessage ()));
    } catch (BpsException e) {
        throw (new BpsProcessException (BpsException.ERR_PROCESS_RETRY, "Error in file management for docset ending : " + e.getMessage ()));
    }
}


protected long processZip (Request request, List < Entry > entries, boolean recurse, int level, ZipOutputStream zos, String prefix, long sizeSoFar, int [] counter, boolean forExport, Element entriesRoot) throws Exception {
    long sizeProcessed = 0;
    Hashtable seen = new Hashtable ();
    long sizeLimit;
    if (request.isAnonymous ()) {
        sizeLimit = MEGA * getRepository ().getProperty (request.PROP_ZIPOUTPUT_ANONYMOUS_MAXSIZEMB, 100);
    }
    else {
        sizeLimit = MEGA * getRepository ().getProperty (request.PROP_ZIPOUTPUT_REGISTERED_MAXSIZEMB, 2000);
    }
    for (Entry entry : entries) {
        counter [0] ++;
        Element entryNode = null;
        if (forExport && (entriesRoot != null)) {
            entryNode = getRepository ().getXmlOutputHandler ().getEntryTag (null, entry, zos, entriesRoot.getOwnerDocument (), entriesRoot, true, level != 0);
        }
        if (entry.isGroup () && recurse) {
            Entry group = (Entry) entry;
            List < Entry > children = getEntryManager ().getChildren (request, group);
            String path = group.getName ();
            if (prefix.length () > 0) {
                path = prefix + "/" + path;
            }
            sizeProcessed += processZip (request, children, recurse, level + 1, zos, path, sizeProcessed + sizeSoFar, counter, forExport, entriesRoot);
        }
        getLogManager ().logInfo ("Zip generated size =" + sizeProcessed);
        if (! getAccessManager ().canDownload (request, entry)) {
            continue;
        }
        String path = entry.getResource ().getPath ();
        String name = getStorageManager ().getFileTail (entry);
        int cnt = 1;
        if (! forExport) {
            while (seen.get (name) != null) {
                name = (cnt ++) + "_" + name;
            }
            seen.put (name, name);
            if (prefix.length () > 0) {
                name = prefix + "/" + name;
            }
        }
        File f = new File (path);
        sizeProcessed += f.length ();
        if (sizeSoFar + sizeProcessed > sizeLimit) {
            throw new IllegalArgumentException ("Size of request has exceeded maximum size");
        }
        if (zos != null) {
            if ((entryNode != null) && forExport) {
                zos.putNextEntry (new ZipEntry (entry.getId ()));
                XmlUtil.setAttributes (entryNode, new String [] {ATTR_FILE, entry.getId (), ATTR_FILENAME, name});
            }
            else {
                ZipEntry zipEntry = new ZipEntry (name);
                zos.putNextEntry (zipEntry);
            }
            InputStream fis = getStorageManager ().getFileInputStream (path);
            try {
                IOUtil.writeTo (fis, zos);
                zos.closeEntry ();
            } finally {
                IOUtil.close (fis);
                zos.closeEntry ();
            }
        }
    }
    return sizeProcessed;
}


-----Function Pair=243=-----==

private static void addToZip (String path, String srcFile, ZipOutputStream zip) {
    File folder = new File (srcFile);
    if (folder.isDirectory ()) {
        addFolderToZip (path, srcFile, zip);
    }
    else {
        byte [] buf = new byte [1024];
        int len;
        try {
            FileInputStream in = new FileInputStream (srcFile);
            zip.putNextEntry (new ZipEntry (path + "/" + folder.getName ()));
            while ((len = in.read (buf)) > 0) {
                zip.write (buf, 0, len);
            }
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
}


private void readjustGrid () {
    int zCol = COLUMN_COUNT;
    int zRow = ROW_COUNT;
    GridLayout zGL = (GridLayout) PanelGames.getLayout ();
    if (PanelGames.isVisible ()) {
        Dimension zPrefDim = zGL.preferredLayoutSize (PanelGames);
        int zItemWidth = zPrefDim.width / zGL.getColumns ();
        int zViewWidth = SPCenter.getViewport ().getSize ().width;
        int zPotentialWidth = (int) Math.round ((double) zViewWidth / zItemWidth);
        zCol = Math.max (zPotentialWidth, 2);
        zRow = 0;
    }
    else {
        zCol = COLUMN_COUNT;
        zRow = ROW_COUNT;
    }
    zGL.setColumns (zCol);
    zGL.setRows (zRow);
    zGL.layoutContainer (PanelGames);
    updateLayout (false);
}


-----Function Pair=244=-----==

public void testGetManifest () throws Exception {
    Support_Resources.copyFile (resources, null, JAR1);
    JarFile jarFile = new JarFile (new File (resources, JAR1));
    InputStream is = jarFile.getInputStream (jarFile.getEntry (JAR1_ENTRY1));
    assertTrue (is.available () > 0);
    assertNotNull ("Error--Manifest not returned", jarFile.getManifest ());
    jarFile.close ();
    Support_Resources.copyFile (resources, null, JAR2);
    jarFile = new JarFile (new File (resources, JAR2));
    assertNull ("Error--should have returned null", jarFile.getManifest ());
    jarFile.close ();
    Support_Resources.copyFile (resources, null, JAR3);
    jarFile = new JarFile (new File (resources, JAR3));
    assertNotNull ("Should find manifest without verifying", jarFile.getManifest ());
    jarFile.close ();
    Manifest manifest = new Manifest ();
    Attributes attributes = manifest.getMainAttributes ();
    attributes.put (new Attributes.Name ("Manifest-Version"), "1.0");
    ByteArrayOutputStream manOut = new ByteArrayOutputStream ();
    manifest.write (manOut);
    byte [] manBytes = manOut.toByteArray ();
    File file = new File (Support_PlatformFile.getNewPlatformFile ("hyts_manifest1", ".jar"));
    JarOutputStream jarOut = new JarOutputStream (new FileOutputStream (file.getAbsolutePath ()));
    ZipEntry entry = new ZipEntry ("META-INF/");
    entry.setSize (0);
    jarOut.putNextEntry (entry);
    entry = new ZipEntry (JarFile.MANIFEST_NAME);
    entry.setSize (manBytes.length);
    jarOut.putNextEntry (entry);
    jarOut.write (manBytes);
    entry = new ZipEntry ("myfile");
    entry.setSize (1);
    jarOut.putNextEntry (entry);
    jarOut.write (65);
    jarOut.close ();
    JarFile jar = new JarFile (file.getAbsolutePath (), false);
    assertNotNull ("Should find manifest without verifying", jar.getManifest ());
    jar.close ();
    file.delete ();
    try {
        Support_Resources.copyFile (resources, null, JAR2);
        JarFile jF = new JarFile (new File (resources, JAR2));
        jF.close ();
        jF.getManifest ();
        fail ("IllegalStateException expected");
    } catch (IllegalStateException ise) {
    }
}


private List < ComplianceCheckType > getComplianceChecks (ApplicationType application, int statusOrder) {
    List < ComplianceCheckType > listChecks = null;
    if (application.isSetComplianceChecks () && application.isSetRecommendations ()) {
        List < RecommendationType > rules = application.getRecommendations ().getRecommendationList ();
        List < ComplianceCheckType > complianceChecks = application.getComplianceChecks ().getComplianceCheckList ();
        listChecks = new ArrayList < ComplianceCheckType > (complianceChecks.size ());
        for (RecommendationType rule : rules) {
            if ((rule.getChangeType () != ChangeTypeEnum.DELETED) && (! rule.isSetDeleted () || ! rule.getDeleted ())) {
                if (rule.isSetComplianceCheckRefs ()) {
                    OrderedDeleteableSharedIdValuePairType statusObj = this.recommendationHelper.getStatusObj (application, rule);
                    int currentStatusOrder = - 1;
                    if (statusObj != null) {
                        currentStatusOrder = statusObj.getOrder ().intValue ();
                    }
                    if (currentStatusOrder >= statusOrder) {
                        List < String > checkRefs = rule.getComplianceCheckRefs ().getComplianceCheckRefList ();
                        for (String checkRef : checkRefs) {
                            ComplianceCheckType check = this.complianceCheckHelper.getItem (complianceChecks, checkRef);
                            if (check != null) {
                                listChecks.add (check);
                            }
                        }
                    }
                }
            }
        }
    }
    else {
        listChecks = Collections.emptyList ();
    }
    return listChecks;
}


-----Function Pair=245=-----==

void test (StandardJavaFileManager fm, File f, String pkg, String [] entries) throws Exception {
    System.err.println ("Test " + f);
    try {
        if (f.isDirectory ()) {
            for (File dir : new File [] {f, f.getAbsoluteFile ()}) {
                for (String e : entries) {
                    JavaFileObject fo = fm.getJavaFileObjects (new File (dir, e)).iterator ().next ();
                    test (fo, dir, e);
                }
            }
        }
        fm.setLocation (StandardLocation.CLASS_PATH, Collections.singleton (f));
        fm.setLocation (StandardLocation.SOURCE_PATH, Collections.singleton (f.getAbsoluteFile ()));
        for (StandardLocation l : EnumSet.of (StandardLocation.CLASS_PATH, StandardLocation.SOURCE_PATH)) {
            for (JavaFileObject fo : fm.list (l, pkg, EnumSet.allOf (JavaFileObject.Kind.class), true)) {
                File dir = (l == StandardLocation.CLASS_PATH ? f : f.getAbsoluteFile ());
                char sep = (dir.isDirectory () ? File.separatorChar : '/');
                String b = fm.inferBinaryName (l, fo);
                String e = fo.getKind ().extension;
                test (fo, dir, b.replace ('.', sep) + e);
            }
        }
    } finally {
        fm.close ();
    }
}


private boolean WriteLayer (PlugInContext context, Layer layer) {
    String filename = "";
    try {
        if (noSource (layer)) {
            filename = pathToSaveNewLayerSources + normalizeName (layer.getName ()) + extToSaveNewLayerSources;
            setDataSourceQuery (layer, filename);
        }
        else {
            DataSource ds = layer.getDataSourceQuery ().getDataSource ();
            if (! ds.isWritable ()) {
                filename = pathToSaveReadOnlySources + normalizeName (layer.getName ()) + extToSaveReadOnlySources;
            }
            else {
                filename = ds.getProperties ().get ("File").toString ();
            }
        }
        DriverProperties dp = new DriverProperties ();
        dp.set ("File", filename);
        if ((filename.toLowerCase ()).endsWith (".shp")) {
            String path = new File (filename).getParent () + File.separator;
            List newLayers = new ArrayList ();
            if (! CompatibleFeatures (layer)) newLayers = splitLayer (context, layer);
            (new ShapefileWriter ()).write (layer.getFeatureCollectionWrapper (), dp);
            SaveToArchive (layer, filename);
            for (int i = 0; i < newLayers.size (); i ++) {
                Layer newLayer = (Layer) newLayers.get (i);
                String newFileName = path + normalizeName (newLayer.getName ()) + ".shp";
                setDataSourceQuery (newLayer, newFileName);
                dp.set ("File", newFileName);
                (new ShapefileWriter ()).write (newLayer.getFeatureCollectionWrapper (), dp);
                context.getWorkbenchFrame ().getOutputFrame ().addText ("Saved layer: " + newLayer.getName ());
            }
            return true;
        }
        if ((filename.toLowerCase ()).endsWith (".jml")) {
            (new JMLWriter ()).write (layer.getFeatureCollectionWrapper (), dp);
            SaveToArchive (layer, filename);
            return true;
        }
        if ((filename.toLowerCase ()).endsWith (".gml")) {
            (new GMLWriter ()).write (layer.getFeatureCollectionWrapper (), dp);
            SaveToArchive (layer, filename);
            return true;
        }
        if ((filename.toLowerCase ()).endsWith (".fme")) {
            (new FMEGMLWriter ()).write (layer.getFeatureCollectionWrapper (), dp);
            SaveToArchive (layer, filename);
            return true;
        }
        if ((filename.toLowerCase ()).endsWith (".wkt")) {
            (new WKTWriter ()).write (layer.getFeatureCollectionWrapper (), dp);
            SaveToArchive (layer, filename);
            return true;
        }
        context.getWorkbenchFrame ().getOutputFrame ().addText ("Unrecognized file type - could not save layer: " + layer.getName ());
        context.getWorkbenchFrame ().warnUser ("Warning: see output window");
        return false;
    } catch (Exception e) {
        context.getWorkbenchFrame ().warnUser ("Error: see output window");
        context.getWorkbenchFrame ().getOutputFrame ().createNewDocument ();
        context.getWorkbenchFrame ().getOutputFrame ().addText ("SaveDatasetsPlugIn:WriteLayer Exception:" + e.toString ());
        return false;
    }
}


-----Function Pair=246=-----==

private void originalLabelMouseDragged (java.awt.event.MouseEvent evt) {
    if (treeBtn.isSelected ()) {
        ImageIcon originalimage = (ImageIcon) originalLabel.getIcon ();
        int position = 0;
        BufferedImage oi = (BufferedImage) originalimage.getImage ();
        if (originalLabel.getHeight () - oi.getHeight () > 0) position = (originalLabel.getHeight () - oi.getHeight ()) / 2;
        else position = 0;
        Graphics g = originalLabel.getGraphics ();
        g.drawImage (oi, 0, position, null);
        g.setColor (Color.RED);
        drawRectangle (g, treeSelectionAreaStartX, treeSelectionAreaStartY, evt.getX (), evt.getY ());
        return;
    }
    if (brushFlag) drawMarkers (evt);
    if (eraseFlag) eraseMarkers (evt);
}


public boolean RenameProject (int index, String newname) {
    try {
        String pName = getMapFiles ().at (index).getName ();
        if (newname.trim ().equals (pName.trim ())) {
            return true;
        }
        if (newname.trim ().length () == 0) {
            errorString = "Error renaming Project : Invalid Project name";
            System.out.println (errorString);
            return false;
        }
        int fIndex = findMapIndex (newname);
        if (fIndex >= 0 && fIndex != index) {
            errorString = "Error renaming Project : Project already exists";
            System.out.println (errorString);
            return false;
        }
        setMapName (index, newname);
        getMapFiles ().at (index).setLabel (configuration.getLanguageCode (), newname);
    } catch (Exception e) {
        errorString = "Error renaming Project : ";
        errorString += "" + e.getMessage ();
        return false;
    }
    return true;
}


-----Function Pair=247=-----==

public static void unzipSingleFile (ZipFile zipFile, OutputStream os) throws IOException {
    try {
        Enumeration < ? extends ZipEntry > entries = zipFile.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = entries.nextElement ();
            if (! entry.isDirectory ()) {
                InputStream is = zipFile.getInputStream (entry);
                try {
                    copyStream (is, os);
                } finally {
                    is.close ();
                }
                return;
            }
        }
    } finally {
        zipFile.close ();
    }
}


private byte [] moveTunerDown (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex >= 0 && tunerIndex < devList.getDeviceCount () - 1) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex + 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


-----Function Pair=248=-----==

public static MArchive [] get (Properties ctx, String whereClause) {
    ArrayList list = new ArrayList ();
    PreparedStatement pstmt = null;
    String sql = "SELECT * FROM AD_Archive WHERE AD_Client_ID=?";
    if ((whereClause != null) && (whereClause.length () > 0)) {
        sql += whereClause;
    }
    sql += " ORDER BY Created";
    try {
        pstmt = DB.prepareStatement (sql);
        pstmt.setInt (1, Env.getAD_Client_ID (ctx));
        ResultSet rs = pstmt.executeQuery ();
        while (rs.next ()) {
            list.add (new MArchive (ctx, rs, null));
        }
        rs.close ();
        pstmt.close ();
        pstmt = null;
    } catch (Exception e) {
        s_log.log (Level.SEVERE, sql, e);
    }
    try {
        if (pstmt != null) {
            pstmt.close ();
        }
        pstmt = null;
    } catch (Exception e) {
        pstmt = null;
    }
    if (list.size () == 0) {
        s_log.fine (sql);
    }
    else {
        s_log.finer (sql);
    }
    MArchive [] retValue = new MArchive [list.size ()];
    list.toArray (retValue);
    return retValue;
}


public void saveZipDocument (OutputStream out, boolean includeMedia) throws Exception {
    ZipOutputStream zos = new ZipOutputStream (out);
    zos.putNextEntry (new ZipEntry (name + ".jclic"));
    saveDocument (zos);
    zos.closeEntry ();
    if (includeMedia) {
        Set set = Collections.synchronizedSet (new HashSet ());
        Iterator it = mediaBag.getElements ().iterator ();
        while (it.hasNext ()) {
            MediaBagElement mbe = (MediaBagElement) it.next ();
            if (mbe.saveFlag) {
                String fName = mbe.getFileName ();
                if (fName != null && fName.length () > 0) set.add (fName);
            }
        }
        it = set.iterator ();
        while (it.hasNext ()) {
            String fName = (String) it.next ();
            zos.putNextEntry (new ZipEntry (fName));
            zos.write (fileSystem.getBytes (fName));
            zos.closeEntry ();
        }
    }
    zos.close ();
    out.close ();
}


-----Function Pair=249=-----==

private static boolean isHostAlive (String aHost, String aPort) {
    MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "START");
    int port;
    try {
        port = Integer.parseInt (aPort);
    } catch (NumberFormatException nfe) {
        MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "ERROR: Wrong port format. - " + nfe.getMessage ());
        MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "END");
        return false;
    }
    try {
        Socket s = new Socket ();
        InetSocketAddress addr = new InetSocketAddress (aHost, port);
        s.connect (addr, 1000);
        s.close ();
    } catch (IOException e) {
        MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "ERROR: " + e.getMessage ());
        MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "END");
        return false;
    }
    MiscUtils.printlnLog (MiscUtils.class.getName () + ".isHostAlive(" + aHost + "," + aPort + ")", "END");
    return true;
}


private byte [] deleteSchedule (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/" + urlData.getServletClass ();
    StringBuffer out = new StringBuffer (4096);
    String id = urlData.getParameter ("id");
    ScheduleItem item = store.getScheduleItem (id);
    if (item != null && (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR)) {
        store.removeScheduleItem (id);
        store.saveSchedule (null);
    }
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


-----Function Pair=250=-----==

public static File copyFile (File file, String dirName) {
    File destDir = new File (dirName);
    if (! destDir.exists () || ! destDir.isDirectory ()) {
        destDir.mkdirs ();
    }
    File src = file;
    File dest = new File (dirName, src.getName ());
    try {
        if (! dest.exists ()) {
            dest.createNewFile ();
        }
        FileChannel source = new FileInputStream (src).getChannel ();
        FileChannel destination = new FileOutputStream (dest).getChannel ();
        destination.transferFrom (source, 0, source.size ());
        source.close ();
        destination.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return dest;
}


protected void closeImpl () {
    if (state == States.OPENED4INPUT) {
        for (ZipFile zipFile : zipFiles) {
            try {
                zipFile.close ();
            } catch (IOException e) {
            }
        }
    }
    else {
        for (OutputStream out : outputStreamMap.values ()) {
            try {
                out.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
        for (String zipPath : zipPathEntryMap.keySet ()) {
            try {
                ZipOutputStream zOut = new ZipOutputStream (new FileOutputStream (zipPath, false));
                ZipPathData zpd = zipPathEntryMap.get (zipPath);
                File tmpDir = new File (zpd.tmpPath);
                File [] subDirs = tmpDir.listFiles ();
                for (File subDir : subDirs) {
                    recurseTmpDir (subDir.getName (), subDir, zpd, zOut);
                }
                zOut.close ();
                deleteDirectory (tmpDir);
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
}


-----Function Pair=251=-----==

private void processLocalesInJar (Map locales, String feature, Map perFeatureLocales, boolean ignoreNewLocales) throws IOException {
    JarFile jar = new JarFile (feature);
    Enumeration files = jar.entries ();
    List localesTemp = new ArrayList ();
    perFeatureLocales.put (feature, localesTemp);
    while (files.hasMoreElements ()) {
        ZipEntry file = (ZipEntry) files.nextElement ();
        String localeString = null;
        String name = file.getName ();
        if (name.startsWith ("feature") && name.endsWith (".properties")) {
            localesTemp.add (name);
            if (name.endsWith ("feature.properties")) {
                localeString = "";
            }
            else {
                localeString = name.substring (8, name.indexOf ('.'));
            }
            if (! ignoreNewLocales && ! locales.containsKey (localeString)) {
                locales.put (localeString, new AvailableLocale (localeString));
            }
            if (locales.containsKey (localeString)) {
                AvailableLocale currentLocale = (AvailableLocale) locales.get (localeString);
                currentLocale.addFeatures (feature);
            }
        }
    }
}


public static void decompressFilesAndDirsFromByteArray (byte [] bytes, File outputFolder) throws FileNotFoundException, IOException {
    BufferedOutputStream dest = null;
    ByteArrayInputStream bArrayInStream = new ByteArrayInputStream (bytes);
    ZipInputStream zis = new ZipInputStream (bArrayInStream);
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        File targetFile = new File (outputFolder + "/" + entry.getName ());
        targetFile.mkdirs ();
        targetFile.delete ();
        FileOutputStream fos = new FileOutputStream (targetFile);
        int count;
        byte data [] = new byte [BUFFER];
        dest = new BufferedOutputStream (fos, BUFFER);
        while ((count = zis.read (data, 0, BUFFER)) != - 1) {
            dest.write (data, 0, count);
        }
        dest.flush ();
        dest.close ();
    }
    zis.close ();
}


-----Function Pair=252=-----==

public static VectorEntity importFromFile (DBConnection dbcon, File file) throws Exception {
    ZipFile zipfile = new ZipFile (file);
    Enumeration entries = zipfile.entries ();
    VectorEntity entities = new VectorEntity ();
    if (entries.hasMoreElements ()) {
        ZipEntry entry = null;
        do {
            entry = entry = (ZipEntry) entries.nextElement ();
            File temp = File.createTempFile ("entity", "zip");
            Utils.readWrite (zipfile.getInputStream (entry), new FileOutputStream (temp));
            Properties prop = new Properties ();
            prop.load (new FileInputStream (temp));
            String enrty_name = entry.getName ();
            Entity entity = (Entity) (Class.forName (entry.getName ().substring (0, entry.getName ().lastIndexOf ("."))).newInstance ().getClass ().getConstructor (new Class [] {dbcon.getClass ()}).newInstance (new Object [] {dbcon}));
            entity.copyFromProperties (prop, new VectorField ());
            entities.add (entity);
            temp.delete ();
        }
        while (entries.hasMoreElements ());
    }
    return entities;
}


private void addInstrumentationToSingleClass (File file) throws Throwable {
    logger.debug ("Instrumenting class " + file.getAbsolutePath ());
    InputStream inputStream = null;
    ClassWriter cw;
    ClassInstrumenter cv;
    try {
        inputStream = new FileInputStream (file);
        ClassReader cr = new ClassReader (inputStream);
        cw = new ClassWriter (ClassWriter.COMPUTE_MAXS);
        cv = new ClassInstrumenter (projectData, cw, ignoreRegexes, ignoreBranchesRegexes, ignoreMethodAnnotations, ignoreTrivial);
        cr.accept (cv, 0);
    } catch (Throwable t) {
        logger.warn ("Unable to instrument file " + file.getAbsolutePath (), t);
        return;
    } finally {
        inputStream = IOUtil.closeInputStream (inputStream);
    }
    OutputStream outputStream = null;
    try {
        if (cv.isInstrumented ()) {
            File outputFile;
            if (destinationDirectory == null) outputFile = file;
            else outputFile = new File (destinationDirectory, cv.getClassName ().replace ('.', File.separatorChar) + ".class");
            File parentFile = outputFile.getParentFile ();
            if (parentFile != null) {
                parentFile.mkdirs ();
            }
            byte [] instrumentedClass = cw.toByteArray ();
            outputStream = new FileOutputStream (outputFile);
            outputStream.write (instrumentedClass);
        }
    } catch (Throwable t) {
        logger.warn ("Unable to instrument file " + file.getAbsolutePath (), t);
        return;
    } finally {
        outputStream = IOUtil.closeOutputStream (outputStream);
    }
}


-----Function Pair=253=-----==

private byte [] showJavaEnviroment (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    StringBuffer biff = new StringBuffer (2048);
    NumberFormat nf = NumberFormat.getInstance ();
    Runtime r = Runtime.getRuntime ();
    long total = r.totalMemory ();
    long free = r.freeMemory ();
    long max = r.maxMemory ();
    biff.append ("HTTP/1.0 200 OK\n");
    biff.append ("Content-Type: text/plain\n");
    biff.append ("Pragma: no-cache\n");
    biff.append ("Cache-Control: no-cache\n\n");
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("System Info\n");
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("java.home: " + System.getProperty ("java.home") + "\n");
    biff.append ("java.class.path: " + "java.home" + System.getProperty ("java.class.path") + "\n");
    biff.append ("java.specification.version: " + System.getProperty ("java.specification.version") + "\n");
    biff.append ("java.specification.vendor: " + System.getProperty ("java.specification.vendor") + "\n");
    biff.append ("java.specification.name: " + System.getProperty ("java.specification.name") + "\n");
    biff.append ("java.version: " + System.getProperty ("java.version") + "\n");
    biff.append ("java.vendor: " + System.getProperty ("java.vendor") + "\n");
    biff.append ("java.vendor.url: " + System.getProperty ("java.vendor.url") + "\n");
    biff.append ("java.vm.specification.version: " + System.getProperty ("java.vm.specification.version") + "\n");
    biff.append ("java.vm.specification.vendor: " + System.getProperty ("java.vm.specification.vendor") + "\n");
    biff.append ("java.vm.specification.name: " + System.getProperty ("java.vm.specification.name") + "\n");
    biff.append ("java.vm.version: " + System.getProperty ("java.vm.version") + "\n");
    biff.append ("java.vm.vendor: " + System.getProperty ("java.vm.vendor") + "\n");
    biff.append ("java.vm.name: " + System.getProperty ("java.vm.name") + "\n");
    biff.append ("java.class.version: " + System.getProperty ("java.class.version") + "\n");
    biff.append ("os.home: " + System.getProperty ("os.name") + "\n");
    biff.append ("os.arch: " + System.getProperty ("os.arch" + "\n"));
    biff.append ("os.version: " + System.getProperty ("os.version") + "\n");
    biff.append ("user.name: " + System.getProperty ("user.name") + "\n");
    biff.append ("user.home: " + System.getProperty ("user.home") + "\n");
    biff.append ("user.dir: " + System.getProperty ("user.dir") + "\n");
    biff.append ("Runtime.maxMemory()   : " + nf.format (max) + "\n");
    biff.append ("Runtime.totalMemory() : " + nf.format (total) + "\n");
    biff.append ("Runtime.freeMemory() : " + nf.format (free) + "\n");
    biff.append ("Time Zone ID     : " + Calendar.getInstance ().getTimeZone ().getID () + "\n");
    biff.append ("Time Zone Name   : " + Calendar.getInstance ().getTimeZone ().getDisplayName () + "\n");
    biff.append ("Time Zone DST    : " + Calendar.getInstance ().getTimeZone ().getDSTSavings () + "\n");
    biff.append ("Time Zone Offset : " + Calendar.getInstance ().getTimeZone ().getRawOffset () + "\n");
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("HTTP Headers\n--------------------------------------------------------------------------\n");
    String [] headName = (String []) headers.keySet ().toArray (new String [0]);
    for (int x = 0; x < headName.length; x ++) {
        biff.append (headName [x] + " : " + (String) headers.get (headName [x]) + "\n");
    }
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("Timer Thread Status = " + store.timerStatus + "\n");
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("Threads\n--------------------------------------------------------------------------\n");
    ThreadGroup top = Thread.currentThread ().getThreadGroup ();
    StringBuffer buff = new StringBuffer ();
    while (true) {
        if (top.getParent () != null) top = top.getParent ();
        else break;
    }
    Thread [] theThreads = new Thread [top.activeCount ()];
    top.enumerate (theThreads);
    for (int i = 0; i < theThreads.length; i ++) {
        biff.append ("Thread " + i + " : " + theThreads [i].getName () + " : " + theThreads [i].toString () + " : " + theThreads [i].getState () + "\n");
        StackTraceElement [] stack = theThreads [i].getStackTrace ();
        buff.append ("Thread " + i + " : " + theThreads [i].getName () + " : " + theThreads [i].toString () + " : " + theThreads [i].getState () + "\n");
        for (int q = 0; q < stack.length; q ++) {
            buff.append (stack [q].toString () + "\n");
        }
        buff.append ("\n");
    }
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("Thread StackTrace\n--------------------------------------------------------------------------\n");
    biff.append (buff.toString ());
    biff.append ("--------------------------------------------------------------------------\n");
    biff.append ("ThreadLock Details\n--------------------------------------------------------------------------\n");
    biff.append ("Is Locked : " + ThreadLock.getInstance ().isLocked () + "\n");
    biff.append ("Has Queued Threads :  " + ThreadLock.getInstance ().hasQueuedThreads () + "\n");
    biff.append ("Queue Length : " + ThreadLock.getInstance ().getQueueLength () + "\n");
    biff.append ("--------------------------------------------------------------------------\n");
    return biff.toString ().getBytes ();
}


public void load (ObjectInputStream ois) throws IOException, ClassNotFoundException {
    MEMSIZE = ois.readInt ();
    REGSIZE = ois.readInt ();
    reg = (Registers) ois.readObject ();
    regInfo = (TreeMap < Integer, MemCellInfo >) ois.readObject ();
    memory = (Memory) ois.readObject ();
    memInfo = (TreeMap < Integer, MemCellInfo >) ois.readObject ();
    variables = (Hashtable < String, Integer >) ois.readObject ();
    constants = (Hashtable < String, Long >) ois.readObject ();
    fCarry = ois.readBoolean ();
    fOverflow = ois.readBoolean ();
    fSign = ois.readBoolean ();
    fZero = ois.readBoolean ();
    fParity = ois.readBoolean ();
    fAuxiliary = ois.readBoolean ();
    fTrap = ois.readBoolean ();
    fDirection = ois.readBoolean ();
    nextReservableAddress = ois.readInt ();
}


-----Function Pair=254=-----==

public void write (OutputStream out) throws IOException, MetsException, UnsupportedEncodingException {
    ZipOutputStream zip = new ZipOutputStream (out);
    zip.setComment ("METS archive created by DSpaceSIP");
    zip.setLevel (compression);
    zip.setMethod (ZipOutputStream.DEFLATED);
    ZipEntry me = new ZipEntry (MANIFEST_FILE);
    zip.putNextEntry (me);
    finishManifest (zip);
    zip.closeEntry ();
    for (Map.Entry < String, PackageFile > e : zipFiles.entrySet ()) {
        PackageFile pf = e.getValue ();
        ZipEntry ze = new ZipEntry (pf.zipPath);
        ze.setTime (pf.absPath.lastModified ());
        zip.putNextEntry (ze);
        copyStream (new FileInputStream (pf.absPath), zip);
        zip.closeEntry ();
    }
    zip.close ();
    zipFiles = null;
}


public static boolean deCompressCache (FileItem item) throws IOException {
    ZipInputStream zin = new ZipInputStream (new ByteArrayInputStream (item.get ()));
    ZipEntry zEntry = null;
    while ((zEntry = zin.getNextEntry ()) != null) {
        TranslationServiceAbstract service = getServiceByClassName (zEntry.getName ());
        ByteArrayOutputStream bos = new ByteArrayOutputStream ();
        int size;
        byte [] buffer = new byte [1024];
        while ((size = zin.read (buffer, 0, buffer.length)) != - 1) {
            bos.write (buffer, 0, size);
        }
        try {
            service.deCompressCache (bos.toByteArray ());
        } catch (Exception e) {
            logger.error ("Error decompressing imported translations.", e);
            return false;
        }
    }
    return true;
}


-----Function Pair=255=-----==

private void createHeading (JPanel navPanel) {
    headingPanel = null;
    int headingLines = 1;
    if (installdata.guiPrefs.modifier.containsKey ("headingLineCount")) {
        headingLines = Integer.parseInt (installdata.guiPrefs.modifier.get ("headingLineCount"));
    }
    Color back = null;
    int i = 0;
    if (installdata.guiPrefs.modifier.containsKey ("headingBackgroundColor")) {
        back = Color.decode (installdata.guiPrefs.modifier.get ("headingBackgroundColor"));
    }
    if (! isHeading (null)) {
        createHeadingCounter (back, navPanel, null);
        return;
    }
    if (installdata.guiPrefs.modifier.containsKey ("headingImageOnLeft") && (installdata.guiPrefs.modifier.get ("headingImageOnLeft").equalsIgnoreCase ("yes") || installdata.guiPrefs.modifier.get ("headingImageOnLeft").equalsIgnoreCase ("true"))) {
        imageLeft = true;
    }
    createHeadingLabels (headingLines, back);
    JPanel leftHeadingPanel = new JPanel ();
    if (back != null) {
        leftHeadingPanel.setBackground (back);
    }
    leftHeadingPanel.setLayout (new BoxLayout (leftHeadingPanel, BoxLayout.Y_AXIS));
    if (imageLeft) {
        leftHeadingPanel.setBorder (BorderFactory.createEmptyBorder (0, 0, 0, 8));
    }
    for (i = 0; i < headingLines; ++ i) {
        leftHeadingPanel.add (headingLabels [i]);
    }
    createHeadingCounter (back, navPanel, leftHeadingPanel);
    JPanel imgPanel = createHeadingIcon (back);
    JPanel northPanel = new JPanel ();
    if (back != null) {
        northPanel.setBackground (back);
    }
    northPanel.setLayout (new BoxLayout (northPanel, BoxLayout.X_AXIS));
    northPanel.setBorder (BorderFactory.createEmptyBorder (0, 12, 0, 0));
    if (imageLeft) {
        northPanel.add (imgPanel);
        northPanel.add (Box.createHorizontalGlue ());
        northPanel.add (leftHeadingPanel);
    }
    else {
        northPanel.add (leftHeadingPanel);
        northPanel.add (Box.createHorizontalGlue ());
        northPanel.add (imgPanel);
    }
    headingPanel = new JPanel (new BorderLayout ());
    headingPanel.add (northPanel);
    headingPanel.add (new JSeparator (), BorderLayout.SOUTH);
    contentPane.add (headingPanel, BorderLayout.NORTH);
}


public boolean compressFile () {
    boolean returns = false;
    try {
        int BUFFER = 2048;
        BufferedInputStream origin = null;
        FileOutputStream dest = new FileOutputStream (getFileName () + ".zipped");
        CheckedOutputStream checksum = new CheckedOutputStream (dest, new Adler32 ());
        ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (checksum));
        byte data [] = new byte [BUFFER];
        File _file = new File (getFileName ());
        FileInputStream _inFile = new FileInputStream (_file);
        origin = new BufferedInputStream (_inFile, BUFFER);
        ZipEntry entry = new ZipEntry (getFileName ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
        out.close ();
        System.out.println ("checksum: " + checksum.getChecksum ().getValue ());
        returns = true;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return returns;
}


-----Function Pair=256=-----==

private Reply doSend (ConsignJob request, PortfolioTh [] portfolios) throws Connection.Exception {
    if (portfolios == null) return doSend (request);
    try {
        if (output == null) {
            output = new ObjectOutputStream (socket.getOutputStream ());
        }
        output.reset ();
        output.writeObject (request);
        output.flush ();
        ZipOutputStream zos = getDataOutputStream ();
        for (int i = 0; i < portfolios.length; i ++) {
            String dir_name = portfolios [i].getPortfolio ().getUPLDirectoryName () + "/";
            for (int j = 0; j < portfolios [i].getFiles ().length; j ++) {
                if (portfolios [i].getFiles () [j].exists ()) {
                    String name;
                    if (portfolios [i].getDestinationNames () == null) {
                        name = portfolios [i].getFiles () [j].getName ();
                    }
                    else {
                        name = portfolios [i].getDestinationNames () [j];
                    }
                    transferFiles (dir_name, portfolios [i].getFiles () [j], name, zos);
                }
                else {
                    CLogger.status ("Adding no overwrite marker to stream <" + dir_name + "> " + portfolios [i].getFiles () [j].getName ());
                    ZipEntry marker = new ZipEntry (dir_name);
                    marker.setExtra (new byte [1]);
                    zos.putNextEntry (marker);
                    zos.closeEntry ();
                }
            }
        }
        CLogger.status ("Done sending streamed");
        doneWithDataOutputStream ();
        return (Reply) getObjectInputStream ().readObject ();
    } catch (java.lang.Exception ex) {
        _close ();
        throw new Connection.Exception ("Error sending Request with streamed: " + ex.getMessage ());
    }
}


private static void addFolderToZip (File folder, ZipOutputStream zip, String baseName) throws IOException {
    final File [] files = folder.listFiles ();
    for (File file : files) {
        if (file.isDirectory ()) {
            addFolderToZip (file, zip, baseName);
        }
        else {
            final String name = file.getAbsolutePath ().substring (baseName.length ());
            final ZipEntry zipEntry = new ZipEntry (name);
            zip.putNextEntry (zipEntry);
            final FileInputStream fileIn = new FileInputStream (file);
            StreamUtils.copy (fileIn, zip);
            StreamUtils.closeStream (fileIn);
            zip.closeEntry ();
        }
    }
}


-----Function Pair=257=-----==

private void copyFile (ApplicationType application, File dir, String fileTypeId) {
    FileTypeHelper fileHelper = new FileTypeHelper ();
    FileType fileType = fileHelper.getItem (application.getFiles ().getFileList (), fileTypeId);
    RTClientProperties props = RTClientProperties.instance ();
    String path = fileType.getPath ();
    String name = fileType.getFileName ();
    StringBuilder srcFilePath = new StringBuilder (props.getFilesDir ());
    srcFilePath.append (path);
    srcFilePath.append (File.separator);
    srcFilePath.append (name);
    StringBuilder destFilePath = new StringBuilder (dir.toString ());
    destFilePath.append (File.separator);
    destFilePath.append (fileType.getId ());
    destFilePath.append (fileType.getOrigFileName ());
    try {
        CopyFile.copyFile (srcFilePath.toString (), destFilePath.toString (), true);
        filesToZip.add (name);
    } catch (IOException ex) {
        logger.fatal ("Error copying file into place", ex);
    }
}


private void parseFile (File file) throws Exception {
    int lineNumber = 1;
    String line = null;
    BufferedReader in = null;
    try {
        in = new BufferedReader (new FileReader (file));
        List < TZDBZone > openZone = null;
        for (; (line = in.readLine ()) != null; lineNumber ++) {
            int index = line.indexOf ('#');
            if (index >= 0) {
                line = line.substring (0, index);
            }
            if (line.trim ().length () == 0) {
                continue;
            }
            StringTokenizer st = new StringTokenizer (line, " \t");
            if (openZone != null && Character.isWhitespace (line.charAt (0)) && st.hasMoreTokens ()) {
                if (parseZoneLine (st, openZone)) {
                    openZone = null;
                }
            }
            else {
                if (st.hasMoreTokens ()) {
                    String first = st.nextToken ();
                    if (first.equals ("Zone")) {
                        if (st.countTokens () < 3) {
                            printVerbose ("Invalid Zone line in file: " + file + ", line: " + line);
                            throw new IllegalArgumentException ("Invalid Zone line");
                        }
                        openZone = new ArrayList < TZDBZone > ();
                        zones.put (st.nextToken (), openZone);
                        if (parseZoneLine (st, openZone)) {
                            openZone = null;
                        }
                    }
                    else {
                        openZone = null;
                        if (first.equals ("Rule")) {
                            if (st.countTokens () < 9) {
                                printVerbose ("Invalid Rule line in file: " + file + ", line: " + line);
                                throw new IllegalArgumentException ("Invalid Rule line");
                            }
                            parseRuleLine (st);
                        }
                        else if (first.equals ("Link")) {
                            if (st.countTokens () < 2) {
                                printVerbose ("Invalid Link line in file: " + file + ", line: " + line);
                                throw new IllegalArgumentException ("Invalid Link line");
                            }
                            String realId = st.nextToken ();
                            String aliasId = st.nextToken ();
                            links.put (aliasId, realId);
                        }
                        else {
                            throw new IllegalArgumentException ("Unknown line");
                        }
                    }
                }
            }
        }
    } catch (Exception ex) {
        throw new Exception ("Failed while processing file '" + file + "' on line " + lineNumber + " '" + line + "'", ex);
    } finally {
        try {
            if (in != null) {
                in.close ();
            }
        } catch (Exception ex) {
        }
    }
}


-----Function Pair=258=-----==

void openZip (String path) {
    ZipInputStream in = null;
    ByteArrayOutputStream out;
    int nRois = 0;
    try {
        in = new ZipInputStream (new FileInputStream (path));
        byte [] buf = new byte [1024];
        int len;
        ZipEntry entry = in.getNextEntry ();
        while (entry != null) {
            String name = entry.getName ();
            if (name.endsWith (".roi")) {
                out = new ByteArrayOutputStream ();
                while ((len = in.read (buf)) > 0) out.write (buf, 0, len);
                out.close ();
                byte [] bytes = out.toByteArray ();
                RoiDecoder rd = new RoiDecoder (bytes, name);
                Roi roi = rd.getRoi ();
                if (roi != null) {
                    name = name.substring (0, name.length () - 4);
                    name = getUniqueName (name);
                    list.add (name);
                    rois.put (name, roi);
                    nRois ++;
                }
            }
            entry = in.getNextEntry ();
        }
        in.close ();
    } catch (IOException e) {
        error (e.toString ());
    }
    if (nRois == 0) error ("This ZIP archive does not appear to contain \".roi\" files");
    updateShowAll ();
}


public static void unZipFile (File inputFile, File outputDirectory) throws IOException {
    logger.debug ("unZipFile(in:" + inputFile.toString () + ", out:" + outputDirectory.toString () + ")");
    ZipFile zipFile = new ZipFile (inputFile);
    Enumeration zipEntries = zipFile.entries ();
    while (zipEntries.hasMoreElements ()) {
        ZipEntry zipEntry = (ZipEntry) zipEntries.nextElement ();
        logger.debug ("Unpacking: " + zipEntry.getName ());
        File file = new File (outputDirectory, zipEntry.getName ());
        if (zipEntry.isDirectory ()) {
            file.mkdirs ();
        }
        else {
            InputStream inputStream = zipFile.getInputStream (zipEntry);
            BufferedInputStream bis = new BufferedInputStream (inputStream);
            File dir = new File (file.getParent ());
            dir.mkdirs ();
            FileOutputStream fos = new FileOutputStream (file);
            BufferedOutputStream bos = new BufferedOutputStream (fos);
            int readByte;
            while ((readByte = bis.read ()) != - 1) {
                bos.write ((byte) readByte);
            }
            bos.close ();
            fos.close ();
        }
        logger.debug (zipEntry.getName () + " : Unpacked.");
    }
}


-----Function Pair=259=-----==

public boolean chequearMarca (int a, int m, int d) {
    boolean existe = false;
    try {
        cantidadArchivos = obtenerCantidad () + 1;
        String filenametxt = "";
        String filenamezip = "";
        int dia = 0;
        int mes = 0;
        int ano = 0;
        for (int i = 1; i < cantidadArchivos; i ++) {
            filenamezip = "recordatorio" + i + ".zip";
            filenametxt = "recordatorio" + i + ".txt";
            BufferedOutputStream dest = null;
            BufferedInputStream is = null;
            ZipEntry entry;
            ZipFile zipfile = new ZipFile (filenamezip);
            Enumeration e = zipfile.entries ();
            while (e.hasMoreElements ()) {
                entry = (ZipEntry) e.nextElement ();
                is = new BufferedInputStream (zipfile.getInputStream (entry));
                int count;
                byte data [] = new byte [buffer];
                FileOutputStream fos = new FileOutputStream (entry.getName ());
                dest = new BufferedOutputStream (fos, buffer);
                while ((count = is.read (data, 0, buffer)) != - 1) dest.write (data, 0, count);
                dest.flush ();
                dest.close ();
                is.close ();
            }
            DataInputStream input = new DataInputStream (new FileInputStream (filenametxt));
            dia = Integer.parseInt (input.readLine ());
            mes = Integer.parseInt (input.readLine ());
            ano = Integer.parseInt (input.readLine ());
            if (ano == a && mes == m && dia == d) existe = true;
            input.close ();
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog (null, "Error en: " + e.toString (), "Error", JOptionPane.ERROR_MESSAGE);
    }
    return (existe);
}


private byte [] updateTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("task_name");
    TaskCommand task = (TaskCommand) tasks.get (name);
    if (task != null) {
        String command = urlData.getParameter ("command");
        String autoRem = urlData.getParameter ("autoRemove");
        String delay = urlData.getParameter ("delay");
        String concurrentTasks = urlData.getParameter ("concurrentTasks");
        String timeToNextSchedule = urlData.getParameter ("timeToNextSchedule");
        String whenNotCapturing = urlData.getParameter ("whenNotCapturing");
        Boolean notCap = new Boolean (false);
        if ("true".equalsIgnoreCase (whenNotCapturing)) {
            notCap = new Boolean (true);
        }
        task.setWhenNotCapturing (notCap.booleanValue ());
        int timeToNext = 0;
        try {
            timeToNext = Integer.parseInt (timeToNextSchedule);
        } catch (Exception e) {
        }
        task.setTimeToNextSchedule (timeToNext);
        int conTasks = 0;
        try {
            conTasks = Integer.parseInt (concurrentTasks);
        } catch (Exception e) {
        }
        task.setConcurrent (conTasks);
        Boolean autoRemove = new Boolean (false);
        if ("true".equalsIgnoreCase (autoRem)) {
            autoRemove = new Boolean (true);
        }
        task.setAutoRemove (autoRemove.booleanValue ());
        int delayValue = 0;
        try {
            delayValue = Integer.parseInt (delay);
        } catch (Exception e) {
        }
        task.setDelay (delayValue);
        task.setCommand (command.trim ());
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


-----Function Pair=260=-----==

private byte [] getTunerList (HTTPurl urlData) throws Exception {
    boolean showID = "true".equalsIgnoreCase (urlData.getParameter ("showid"));
    showID = showID | "true".equalsIgnoreCase (urlData.getCookie ("showDeviceID"));
    if ("false".equalsIgnoreCase (urlData.getParameter ("showid"))) showID = false;
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "CardSetup.html");
    if (showID == true) template.addCookie ("showDeviceID", "true");
    else template.addCookie ("showDeviceID", "false");
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int activeDevices = devList.getActiveDeviceCount ();
    boolean testMode = "1".equals (store.getProperty ("tools.testmode"));
    String scanCommand = "";
    if (testMode == true) {
        scanCommand = "win32/device.exe -test";
    }
    else {
        scanCommand = "win32/device.exe";
    }
    System.out.println ("Running device scan command: " + scanCommand);
    Runtime runner = Runtime.getRuntime ();
    Process scan = runner.exec (scanCommand);
    TunerScanResult tuners = new TunerScanResult ();
    tuners.readInput (scan.getInputStream ());
    tuners.parseXML ();
    StringBuffer out = new StringBuffer ();
    Vector < CaptureDevice > tunersList = tuners.getResult ();
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'>");
    out.append ("<table width='100%' border='0' cellpadding='0' cellspacing='0'><tr><td><strong>Currently Selected Devices</strong></td><td align='right'>");
    if (showID) out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=false'>Hide IDs</a>");
    else out.append ("<a style='text-decoration: none; color: #FFFFFF; font-size: 12px;' href='/servlet/SystemDataRes?action=04&showid=true'>Show IDs</a>");
    out.append ("</td></tr></table></td></tr>\n");
    for (int x = 0; x < devList.getDeviceCount (); x ++) {
        CaptureDevice cd = (CaptureDevice) devList.getDevice (x);
        out.append ("<tr>");
        out.append ("<td nowrap>" + x + "</td>");
        out.append ("<td nowrap>: ");
        out.append (cd.getName ());
        if (cd.isInUse () == true) out.append (" (Active)");
        boolean isAvailable = false;
        for (int y = 0; y < tunersList.size (); y ++) {
            CaptureDevice cd2 = (CaptureDevice) tunersList.get (y);
            if (cd.getID ().equals (cd2.getID ())) {
                isAvailable = true;
                break;
            }
        }
        if (isAvailable == false) out.append (" <img border='0' alt='Not Available' title='Device Not Available' src='/images/exclaim24.png' align='absmiddle' width='22' height='24'> ");
        if (showID) out.append ("(" + cd.getID () + ")");
        out.append ("</td>\n");
        out.append ("<td nowrap width='50px'> ");
        out.append (" <a href='/servlet/SystemDataRes?action=14&tunerID=" + x + "'><img border='0' alt='DEL' src='/images/delete.png' align='absmiddle' width='24' height='24'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=15&tunerID=" + x + "'><img border='0' alt='Up' src='/images/up01.png' align='absmiddle' width='7' height='7'></a> ");
        out.append ("<a href='/servlet/SystemDataRes?action=16&tunerID=" + x + "'><img border='0' alt='Down' src='/images/down01.png' align='absmiddle' width='7' height='7'></a>");
        out.append ("</td>\n");
        out.append ("</tr>\n");
    }
    if (devList.getDeviceCount () == 0) {
        out.append ("<tr><td colspan ='3'>No devices selected</td></tr>");
    }
    int numCards = 0;
    out.append ("<tr><td colspan='3'><strong>&nbsp;</strong></td></tr>");
    out.append ("<tr><td colspan='3' style='border: 1px solid #FFFFFF;'><strong>Devices Available But Not Selected</strong></td></tr>");
    for (int x = 0; x < tunersList.size (); x ++) {
        CaptureDevice dev = (CaptureDevice) tunersList.get (x);
        boolean found = false;
        for (int y = 0; y < devList.getDeviceCount (); y ++) {
            CaptureDevice cd = (CaptureDevice) devList.getDevice (y);
            if (cd.getID ().equals (dev.getID ())) {
                found = true;
                break;
            }
        }
        if (! found) {
            out.append ("<tr>");
            out.append ("<td>&nbsp;</td>");
            out.append ("<td nowrap>" + dev.getName () + "</td>");
            out.append ("<td width='50px'><a href='/servlet/SystemDataRes?action=13&tunerID=" + URLEncoder.encode (dev.getID (), "UTF-8"));
            out.append ("&tunerName=" + URLEncoder.encode (dev.getName (), "UTF-8") + "'>");
            out.append ("<img border='0' alt='ADD' src='/images/add.png' align='absmiddle' width='24' height='24'></a></td>\n");
            out.append ("</tr>\n");
            numCards ++;
        }
    }
    if (numCards == 0) {
        out.append ("<tr><td colspan ='3'>No devices available</td></tr>");
    }
    numCards = 0;
    template.replaceAll ("$cardList", out.toString ());
    template.replaceAll ("$cardCount", new Integer (activeDevices).toString ());
    return template.getPageBytes ();
}


private String mergeSingleFile (String fromFileName, String toFileName, Element dataRootElement) throws FileNotFoundException, IOException, BarcodeException {
    List < ImageToMerge > imagesToMerge = new ArrayList < ImageToMerge > ();
    List < ImageInFile > imagesInFile = new ArrayList < ImageInFile > ();
    StoredManifest manifest = null;
    StoredStyle style = null;
    FileInputStream fis = new FileInputStream (fromFileName);
    FileOutputStream fos = new FileOutputStream (toFileName);
    ZipInputStream zi = new ZipInputStream (fis);
    ZipOutputStream zo = new ZipOutputStream (fos);
    ZipEntry ze = zi.getNextEntry ();
    XMLContent officeText = null;
    while (ze != null) {
        if (ze.getName ().endsWith (CONTENT_FILE)) {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            officeText = mergeFile (zi, zo, dataRootElement, imagesToMerge);
            for (ImageToMerge imageToMerge : imagesToMerge) imageToMerge.addToODF (zo);
        }
        else if (ze.getName ().contains (PICTURES_DIR)) {
            imagesInFile.add (new ImageInFile (ze.getName (), zi));
        }
        else if (ze.getName ().endsWith (MANIFEST_FILE)) {
            manifest = new StoredManifest (zi);
        }
        else if (ze.getName ().endsWith (STYLES_FILE)) {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            style = new StoredStyle (zi);
            zo.write (style.getData ());
        }
        else {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            moveFile (zi, zo);
        }
        zo.flush ();
        ze = zi.getNextEntry ();
    }
    if (officeText != null) {
        List < String > fileNames = new ArrayList < String > ();
        for (ImageInFile imageInFile : imagesInFile) {
            String fileName = imageInFile.getFileName ();
            if (officeText.containsImageFile (fileName) || (style != null && style.containsImageFile (fileName))) {
                ZipEntry ze1 = new ZipEntry (fileName.replace (File.pathSeparatorChar, '/'));
                zo.putNextEntry (ze1);
                zo.write (imageInFile.getData ());
                zo.flush ();
                fileNames.add (fileName);
            }
        }
        for (ImageToMerge imageToMerge : imagesToMerge) fileNames.add (imageToMerge.getImageName ());
        if (manifest != null) {
            manifest.setAllPictures (fileNames);
            ZipEntry ze1 = new ZipEntry ("META-INF/manifest.xml");
            zo.putNextEntry (ze1);
            zo.write (manifest.getData ());
            zo.flush ();
        }
    }
    zo.close ();
    zi.close ();
    fis.close ();
    fos.close ();
    return toFileName;
}


-----Function Pair=261=-----==

public void addFile (ZipOutputStream out, String filename) {
    try {
        byte [] buf = new byte [1024];
        String filePath = projHandler.getProjectPath () + File.separator + filename;
        File file = new File (filePath);
        if (file.exists ()) {
            FileInputStream fis = new FileInputStream (filePath);
            out.putNextEntry (new ZipEntry (filename));
            int len;
            while ((len = fis.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            fis.close ();
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}


public static Collection transformList (Collection toTransform, String...methodName) {
    List transformed = new LinkedList ();
    try {
        if (toTransform == null || toTransform.size () == 0) return toTransform;
        for (Object o : toTransform) {
            Object result = o;
            if (methodName == null) {
                result = o.toString ();
            }
            else {
                for (String theMethodName : methodName) {
                    Method method;
                    method = result.getClass ().getMethod (theMethodName);
                    result = method.invoke (result);
                }
            }
            transformed.add (result);
        }
        return transformed;
    } catch (Exception e) {
        return transformed;
    }
}


-----Function Pair=262=-----=1=

protected void storeDocuments () throws DocumentStoreException {
    ReportFileHome reportFileHome = null;
    try {
        Context initialContext = new InitialContext ();
        reportFileHome = (ReportFileHome) PortableRemoteObject.narrow (initialContext.lookup (ReportFileHome.COMP_NAME), ReportFileHome.class);
    } catch (Exception e) {
        throw new DocumentStoreException ("ReportFileHome could not be loaded");
    }
    int count = 0;
    String filename;
    String title, ending;
    byte [] b;
    ReportFileObject reportFileObject;
    Enumeration enumTitles;
    try {
        enumTitles = reportDocHandler.getReportDocumentTitles ().elements ();
    } catch (RemoteException re) {
        enumTitles = new Vector ().elements ();
    }
    while (enumTitles.hasMoreElements ()) {
        try {
            filename = (String) enumTitles.nextElement ();
            ending = filename.substring (filename.lastIndexOf ('.') + 1);
            title = filename.substring (0, filename.lastIndexOf ('.'));
            b = reportDocHandler.getReportDocumentStream (filename);
            if (filename.endsWith ("HTML") | filename.endsWith ("html")) {
                zipStream = new ByteArrayOutputStream ();
                ZipOutputStream zip = new ZipOutputStream (zipStream);
                ZipEntry entry = new ZipEntry (filename);
                zip.putNextEntry (entry);
                zip.write (b);
                zip.closeEntry ();
                String key;
                Set imageSet = imageByteArrays.keySet ();
                Iterator iterCharts = imageSet.iterator ();
                while (iterCharts.hasNext ()) {
                    key = (String) iterCharts.next ();
                    b = (byte []) imageByteArrays.get (key);
                    entry = new ZipEntry ("images/" + key);
                    zip.putNextEntry (entry);
                    zip.write (b);
                    zip.closeEntry ();
                }
                zip.close ();
                UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
                reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, zipStream.toByteArray (), new Date (), reportID, "ZIP");
                reportfiles.addElement (reportFileObject);
                zipStream = null;
                count ++;
            }
            else {
                UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
                reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, b, new Date (), reportID, ending);
                reportfiles.addElement (reportFileObject);
                count ++;
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    try {
        reportDocHandler.deleteDocuments ();
    } catch (RemoteException re) {
    }
    try {
        enumTitles = dataDocHandler.getDataDocumentTitles ().elements ();
    } catch (RemoteException re) {
        enumTitles = new Vector ().elements ();
    }
    while (enumTitles.hasMoreElements ()) {
        try {
            filename = (String) enumTitles.nextElement ();
            ending = filename.substring (filename.lastIndexOf ('.') + 1);
            title = filename.substring (0, filename.lastIndexOf ('.'));
            b = dataDocHandler.getDataDocumentStream (filename);
            UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
            reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, b, new Date (), reportID, ending);
            reportfiles.addElement (reportFileObject);
            count ++;
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    try {
        dataDocHandler.deleteDocuments ();
    } catch (RemoteException re) {
    }
    if (count == 0) throw new DocumentStoreException ("No document could be stored.");
}


public void toZipFile (String filePath, String outFile) {
    ArrayList fileNames = new ArrayList ();
    ArrayList files = new ArrayList ();
    try {
        File rootFile = new File (filePath);
        listFile (rootFile, fileNames, files);
        if (files != null && files.size () > 0) {
            FileOutputStream fileOut = new FileOutputStream (outFile);
            CheckedOutputStream ch = new CheckedOutputStream (fileOut, new CRC32 ());
            BufferedOutputStream bout = new BufferedOutputStream (ch);
            ZipOutputStream outputStream = new ZipOutputStream (bout);
            for (int loop = 0; loop < files.size (); loop ++) {
                FileInputStream fileIn = new FileInputStream ((File) files.get (loop));
                InputStreamReader inReader = new InputStreamReader (fileIn, "ISO8859_1");
                BufferedReader in = new BufferedReader (inReader);
                outputStream.putNextEntry (new ZipEntry ((String) fileNames.get (loop)));
                int c;
                while ((c = in.read ()) != - 1) {
                    outputStream.write (c);
                }
                fileIn.close ();
                in.close ();
                outputStream.closeEntry ();
            }
            for (int i = 0; i < files.size (); i ++) {
                File file = (File) files.get (i);
                file.delete ();
            }
            outputStream.close ();
        }
    } catch (IOException ioe) {
        ioe.printStackTrace ();
    }
}


-----Function Pair=263=-----==

private byte [] moveTunerUp (HTTPurl urlData) throws Exception {
    CaptureDeviceList devList = CaptureDeviceList.getInstance ();
    int tunerIndex = - 1;
    try {
        tunerIndex = Integer.parseInt (urlData.getParameter ("tunerID"));
        if (devList.getActiveDeviceCount () == 0) {
            if (tunerIndex > 0 && tunerIndex < devList.getDeviceCount ()) {
                CaptureDevice cap = devList.remDevice (tunerIndex);
                devList.addDeviceAt (tunerIndex - 1, cap);
                devList.saveDeviceList (null);
            }
        }
    } catch (Exception e) {
    }
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: /servlet/SystemDataRes?action=04\n\n";
    return out.getBytes ();
}


public static boolean writeHashMap (HashMap hashMap, File file) {
    try {
        PrintWriter out = new PrintWriter (new FileWriter (file));
        Iterator it = hashMap.keySet ().iterator ();
        while (it.hasNext ()) {
            Object obj = it.next ();
            out.println (obj + "\t" + hashMap.get (obj));
        }
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
    return true;
}


-----Function Pair=264=-----==

public List < String > getMediaTags (String additionalTags) throws IOException {
    List < Media > list = getMediaList ();
    Set < String > set = loadTags (list);
    if (additionalTags != null) {
        String [] splts = additionalTags.split (",");
        for (String s : splts) {
            s = s.trim ();
            if (s.length () > 0) set.add (s);
        }
    }
    List < String > tagsList = new ArrayList < String > (set.size ());
    tagsList.addAll (set);
    Collections.sort (tagsList);
    return tagsList;
}


public void internalFrameClosed (InternalFrameEvent e) {
    Iterator < Map.Entry < String, JInternalFrame > > ii = hierarchyNodeHashToInternalFrame.entrySet ().iterator ();
    while (ii.hasNext ()) {
        Map.Entry < String, JInternalFrame > next = ii.next ();
        if (next.getValue () == e.getInternalFrame ()) {
            ii.remove ();
            HierarchyNode hn_to_go = hierarchyNodeHashToHierarchyNode.remove (next.getKey ());
            if (hn_to_go != null) {
                hn_to_go.removeChildrenRepaintListener ();
                Enumeration ee = hn_to_go.children ();
                while (ee.hasMoreElements ()) {
                    HierarchyNode child = (HierarchyNode) ee.nextElement ();
                    child.getComponentModel ().removeRepaintListener ();
                }
            }
        }
    }
}


-----Function Pair=265=-----==

public String getMolSvg (int width, int height, boolean drawNumbers) throws Exception {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    Renderer2DModel r2dm = new Renderer2DModel ();
    r2dm.setDrawNumbers (drawNumbers);
    r2dm.setBackColor (backColor);
    r2dm.setShowImplicitHydrogens (false);
    r2dm.setShowEndCarbons (false);
    if (selected > - 1) {
        r2dm.setExternalHighlightColor (Color.RED);
        IAtomContainer ac = cdkmol.getAtom (selected).getBuilder ().newAtomContainer ();
        ac.addAtom (cdkmol.getAtom (selected));
        r2dm.setExternalSelectedPart (ac);
    }
    Renderer2D renderer = new Renderer2D (r2dm);
    int number = ((int) Math.sqrt (cdkmol.getAtomCount ())) + 1;
    int moleculewidth = number * 100;
    int moleculeheight = number * 100;
    if (width > - 1) {
        moleculewidth = width;
        moleculeheight = height;
    }
    if (moleculeheight < 200 || moleculewidth < 200) {
        r2dm.setIsCompact (true);
        r2dm.setBondDistance (3);
    }
    r2dm.setBackgroundDimension (new Dimension (moleculewidth, moleculeheight));
    GeometryTools.translateAllPositive (cdkmol, r2dm.getRenderingCoordinates ());
    GeometryTools.scaleMolecule (cdkmol, new Dimension (moleculewidth, moleculeheight), 0.8, r2dm.getRenderingCoordinates ());
    GeometryTools.center (cdkmol, new Dimension (moleculewidth, moleculeheight), r2dm.getRenderingCoordinates ());
    DOMImplementation domImpl = GenericDOMImplementation.getDOMImplementation ();
    Document document = domImpl.createDocument (null, "svg", null);
    SVGGraphics2D svgGenerator = new SVGGraphics2D (document);
    svgGenerator.setBackground (backColor);
    svgGenerator.setColor (backColor);
    svgGenerator.fill (new Rectangle (0, 0, moleculewidth, moleculeheight));
    renderer.paintMolecule (cdkmol, svgGenerator, false, true);
    boolean useCSS = false;
    baos = new ByteArrayOutputStream ();
    Writer outwriter = new OutputStreamWriter (baos, "UTF-8");
    StringBuffer sb = new StringBuffer ();
    svgGenerator.stream (outwriter, useCSS);
    StringTokenizer tokenizer = new StringTokenizer (baos.toString (), "\n");
    while (tokenizer.hasMoreTokens ()) {
        String name = tokenizer.nextToken ();
        if (name.length () > 4 && name.substring (0, 5).equals ("<svg ")) {
            sb.append (name.substring (0, name.length () - 1)).append (" width=\"" + moleculewidth + "\" height=\"" + moleculeheight + "\">" + "\n\r");
        }
        else {
            sb.append (name + "\n\r");
        }
    }
    return (sb.toString ());
}


private String mergeSingleFile (String fromFileName, String toFileName, Element dataRootElement) throws FileNotFoundException, IOException, BarcodeException {
    List < ImageToMerge > imagesToMerge = new ArrayList < ImageToMerge > ();
    List < ImageInFile > imagesInFile = new ArrayList < ImageInFile > ();
    StoredManifest manifest = null;
    StoredStyle style = null;
    FileInputStream fis = new FileInputStream (fromFileName);
    FileOutputStream fos = new FileOutputStream (toFileName);
    ZipInputStream zi = new ZipInputStream (fis);
    ZipOutputStream zo = new ZipOutputStream (fos);
    ZipEntry ze = zi.getNextEntry ();
    XMLContent officeText = null;
    while (ze != null) {
        if (ze.getName ().endsWith (CONTENT_FILE)) {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            officeText = mergeFile (zi, zo, dataRootElement, imagesToMerge);
            for (ImageToMerge imageToMerge : imagesToMerge) imageToMerge.addToODF (zo);
        }
        else if (ze.getName ().contains (PICTURES_DIR)) {
            imagesInFile.add (new ImageInFile (ze.getName (), zi));
        }
        else if (ze.getName ().endsWith (MANIFEST_FILE)) {
            manifest = new StoredManifest (zi);
        }
        else if (ze.getName ().endsWith (STYLES_FILE)) {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            style = new StoredStyle (zi);
            zo.write (style.getData ());
        }
        else {
            ZipEntry ze1 = new ZipEntry (ze.getName ().replace (File.pathSeparatorChar, '/'));
            zo.putNextEntry (ze1);
            moveFile (zi, zo);
        }
        zo.flush ();
        ze = zi.getNextEntry ();
    }
    if (officeText != null) {
        List < String > fileNames = new ArrayList < String > ();
        for (ImageInFile imageInFile : imagesInFile) {
            String fileName = imageInFile.getFileName ();
            if (officeText.containsImageFile (fileName) || (style != null && style.containsImageFile (fileName))) {
                ZipEntry ze1 = new ZipEntry (fileName.replace (File.pathSeparatorChar, '/'));
                zo.putNextEntry (ze1);
                zo.write (imageInFile.getData ());
                zo.flush ();
                fileNames.add (fileName);
            }
        }
        for (ImageToMerge imageToMerge : imagesToMerge) fileNames.add (imageToMerge.getImageName ());
        if (manifest != null) {
            manifest.setAllPictures (fileNames);
            ZipEntry ze1 = new ZipEntry ("META-INF/manifest.xml");
            zo.putNextEntry (ze1);
            zo.write (manifest.getData ());
            zo.flush ();
        }
    }
    zo.close ();
    zi.close ();
    fis.close ();
    fos.close ();
    return toFileName;
}


-----Function Pair=266=-----==

public static RegionTextData merge (ArrayList < RegionTextData > pdAL) {
    RegionTextData [] pdArray = new RegionTextData [pdAL.size ()];
    pdAL.toArray (pdArray);
    Arrays.sort (pdArray);
    int num = 0;
    for (int i = 0; i < pdArray.length; i ++) num += pdArray [i].sortedRegionTexts.length;
    RegionText [] concatinate = new RegionText [num];
    int index = 0;
    for (int i = 0; i < pdArray.length; i ++) {
        RegionText [] slice = pdArray [i].sortedRegionTexts;
        System.arraycopy (slice, 0, concatinate, index, slice.length);
        index += slice.length;
    }
    SliceInfo sliceInfo = pdArray [0].sliceInfo;
    RegionTextData.updateSliceInfo (concatinate, sliceInfo);
    return new RegionTextData (concatinate, sliceInfo);
}


private void spawn (Vector command) throws IOException {
    String proxy = detectProxy ();
    log ("proxy settings: " + proxy);
    String os = System.getProperty ("os.name").toLowerCase ();
    String [] command_vec;
    if (os.indexOf ("windows 9") != - 1 || os.indexOf ("windows me") != - 1) {
        command.insertElementAt ("command.com", 0);
        command.insertElementAt ("/c", 1);
    }
    command.copyInto (command_vec = new String [command.size ()]);
    log ("executing:");
    for (int i = 0; i < command_vec.length; i ++) log ("    \"" + command_vec [i] + "\"");
    Process p;
    if (proxy == null) {
        p = Runtime.getRuntime ().exec (command_vec);
    }
    else if (os.indexOf ("windows") != - 1) {
        p = Runtime.getRuntime ().exec (command_vec, new String [] {proxy});
    }
    else {
        p = Runtime.getRuntime ().exec (command_vec, dumpEnv (proxy));
    }
    BufferedReader stderr = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
    if (os.indexOf ("windows 9") != - 1 || os.indexOf ("windows me") != - 1 || applog) {
        update (1.0, "Vexi Loaded");
    }
    else {
        String s = stderr.readLine ();
        update (1.0, "Vexi Loaded");
        while (s != null) {
            log (s);
            s = stderr.readLine ();
        }
    }
    log ("exiting...");
}


-----Function Pair=267=-----==

public static void dos2unix (File file) {
    if (file.isDirectory () || ! file.exists ()) return;
    String name = file.getName ();
    boolean found = false;
    File tempFile = new File (file.getAbsolutePath () + ".tmp");
    try {
        BufferedReader in = new BufferedReader (new FileReader (file));
        BufferedWriter out = new BufferedWriter (new FileWriter (tempFile));
        int c;
        while ((c = in.read ()) != - 1) {
            if (c != '\r') out.write (c);
        }
        in.close ();
        out.close ();
        file.delete ();
        tempFile.renameTo (file);
    } catch (IOException e) {
        throw new RuntimeException (e.getClass () + e.getMessage ());
    }
}


public static String get_blogger_ssl_page (String s) throws Exception {
    System.out.println (s);
    SSLSocketFactory sslsocketfactory = (SSLSocketFactory) SSLSocketFactory.getDefault ();
    SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket ("www.blogger.com", 443);
    PrintStream outStream = new PrintStream (sslsocket.getOutputStream ());
    outStream.println (s);
    outStream.flush ();
    DataInputStream inStream = new DataInputStream (sslsocket.getInputStream ());
    StringBuffer stb = new StringBuffer ();
    int ch = ' ';
    for (ch = inStream.read (); ch > 0; ch = inStream.read ()) {
        stb.append ((char) ch);
        if (stb.indexOf ("</html>") > - 1 || stb.indexOf ("</HTML>") > - 1) break;
    }
    inStream.close ();
    outStream.close ();
    sslsocket.close ();
    return stb.toString ();
}


-----Function Pair=268=-----==

private void recursiveDeserialise (final SerialisedNode in, final DocumentNode out) {
    out.nodeName = in.nodeName;
    if (in.nodeValue == null || in.nodeValue.length == 0) {
        out.nodeValue = null;
    }
    else {
        boolean decoded = false;
        for (IDocumentCodec decoder : docObjTypes.values ()) {
            if (decoder.getType () == in.nodeType) {
                try {
                    ByteArrayInputStream bis = new ByteArrayInputStream (in.nodeValue);
                    DataInputStream dis = new DataInputStream (bis);
                    out.nodeValue = decoder.readObject (dis, in.nodeVersion);
                    dis.close ();
                    bis.close ();
                    decoded = true;
                } catch (Exception ex) {
                    logger.log (Level.SEVERE, "Error decoding value of type " + decoder.getType (), ex);
                }
            }
            if (decoded == true) break;
        }
        if (decoded == false) {
            logger.log (Level.SEVERE, "Unable to decode type {0}", in.nodeType);
        }
    }
    for (SerialisedNode subIn : in.subNodes) {
        DocumentNode subOut = new DocumentNode ("", null);
        recursiveDeserialise (subIn, subOut);
        out.subNodes.put (subOut.nodeName, subOut);
    }
}


private static OutputStream transferStream (InputStream input, int length, ExportController controller, OutputStream output, String targetName, int mode) throws IOException, CoreException {
    output = controller.getOutputStream (output, targetName, mode);
    int remaining = length;
    byte [] buffer;
    if (remaining > BUFFER_THRESHHOLD) {
        buffer = new byte [BUFFER_THRESHHOLD];
    }
    else {
        buffer = new byte [remaining];
    }
    while (remaining > 0) {
        int toRead = remaining > buffer.length ? buffer.length : remaining;
        int amount = input.read (buffer, 0, toRead);
        output.write (buffer, 0, amount);
        remaining -= amount;
    }
    input.close ();
    return output;
}


-----Function Pair=269=-----==

public void actionPerformed (java.awt.event.ActionEvent e) {
    JFileChooser fileChooser = new JFileChooser (relativePath);
    fileChooser.showSaveDialog (null);
    File chosenFile = fileChooser.getSelectedFile ();
    try {
        byte b [] = new byte [512];
        ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (chosenFile));
        HashSet < String > written = new HashSet < String > ();
        for (int i = 0; i < objects.size (); i ++) {
            OBJE obje = objects.elementAt (i);
            String fpath = obje.getFilepath ();
            int hasDrive = fpath.indexOf (":\\");
            if (hasDrive == - 1) hasDrive = fpath.indexOf (":/");
            String firstChar = fpath.substring (0, 1);
            if ((hasDrive == - 1) && (! firstChar.equals ("/"))) fpath = relativePath + fpath;
            if (! written.contains (fpath)) {
                written.add (fpath);
                System.out.println ("Added file to zip " + fpath);
                InputStream in = new FileInputStream (fpath);
                ZipEntry ze = new ZipEntry ("media/" + obje.getFilename ());
                zout.putNextEntry (ze);
                int len = 0;
                while ((len = in.read (b)) != - 1) {
                    zout.write (b, 0, len);
                }
                zout.closeEntry ();
                in.close ();
            }
        }
        zout.close ();
    } catch (IOException ie) {
        System.out.println (ie.getMessage ());
    }
}


public static Map getMap (String input) throws IOException {
    ArrayList < MapEvent > data = new ArrayList < MapEvent > ();
    ZipFile t = new ZipFile (input);
    Enumeration test = t.entries ();
    ObjectInputStream oin = null;
    Map map = null;
    while (test.hasMoreElements ()) {
        ZipEntry temp = (ZipEntry) test.nextElement ();
        InputStream is = t.getInputStream (temp);
        if (temp.getName ().equals ("mapfile.cnf")) {
            LinkedList < String > map_data = new LinkedList < String > ();
            BufferedReader br = new BufferedReader (new InputStreamReader (is));
            String line = "";
            while (true) {
                line = br.readLine ();
                if (line == null) break;
                if (! line.startsWith ("#")) {
                    map_data.add (line);
                }
            }
            map = Parser.parseMap (map_data);
        }
        else {
            oin = new ObjectInputStream (new BufferedInputStream (is));
            try {
                Object o = oin.readObject ();
                if (o instanceof MapEvent) {
                    MapEvent e = (MapEvent) o;
                    data.add (e);
                }
            } catch (ClassNotFoundException e) {
                e.printStackTrace ();
            }
        }
    }
    if (oin != null) oin.close ();
    map.setEventData (data);
    return map;
}


-----Function Pair=270=-----==

private XMLContent cloneDocument (XMLContent officeDoc, Element dataRootElement) {
    XMLContent officeText = officeDoc.findContentCalled (OFFICE_TEXT);
    int numberOfRecords = XMLUtil.getChildren (dataRootElement).size ();
    int nextRecordCount = officeText.count (NEXT_RECORD_FIELD);
    int loopCount = numberOfRecords - 1;
    if (nextRecordCount > 0) loopCount = numberOfRecords / nextRecordCount;
    List < XMLContent > cloned = new ArrayList < XMLContent > ();
    for (int i = 0; i < loopCount; i ++) {
        XMLContent pageBreak = new XMLContent ();
        pageBreak.setHeader (MAIL_MERGE_PAGE);
        XMLContent officeDocContent = officeText.clone ();
        int start = 1;
        int end = officeDocContent.getSubContents ().size ();
        XMLContent ignoreTo = officeDocContent.findContentCalled (IGNORE_TO);
        if (ignoreTo != null) start = officeDocContent.getIndexOf (ignoreTo) + 1;
        cloned.add (pageBreak);
        cloned.addAll (officeDocContent.getSubContents ().subList (start, end));
    }
    officeText.addSubContent (cloned);
    return officeText;
}


public void process (String filename) {
    StopWatch watch = new StopWatch ();
    watch.tic ();
    Console.println (Console.TARGET_MAIN, "Saving file " + filename + ".");
    Console.startProgress ("Saving file.");
    Session s = mainFrame.getSession ();
    VisualONDEXGraph vog = mainFrame.getVisualONDEXGraph ();
    VisualGDSBuilder vgb = new VisualGDSBuilder (s, vog, visible, visual);
    try {
        System.setProperty ("javax.xml.stream.XMLOutputFactory", "com.bea.xml.stream.XMLOutputFactoryBase");
        BufferedWriter writer;
        if (packed) {
            String zipname = filename + ".zip";
            ZipOutputStream zip = new ZipOutputStream (new FileOutputStream (zipname));
            File file = new File (filename);
            zip.putNextEntry (new ZipEntry (file.getName ()));
            writer = new BufferedWriter (new OutputStreamWriter (zip));
        }
        else {
            writer = new BufferedWriter (new FileWriter (filename));
        }
        XMLOutputFactory xmlof = XMLOutputFactory.newInstance ();
        XMLStreamWriter xmlw = xmlof.createXMLStreamWriter (writer);
        XmlBuilder.buildDocument (s, xmlw, vgb.getConcepts (), vgb.getRelations ());
        xmlw.flush ();
        xmlw.close ();
        writer.flush ();
        writer.close ();
    } catch (IOException ioe) {
        Console.printmsg (Console.TARGET_MAIN, ioe);
        Console.stopProgress ();
    } catch (XMLStreamException xmlse) {
        Console.printmsg (Console.TARGET_MAIN, xmlse);
        Console.stopProgress ();
    } catch (URISyntaxException urise) {
        Console.printmsg (Console.TARGET_MAIN, urise);
        Console.stopProgress ();
    }
    double time = watch.toc ();
    Console.println (Console.TARGET_MAIN, "Saving finished. - " + time + " s");
    Console.stopProgress ();
}


-----Function Pair=271=-----=1=

private static void zipFile (String filePath, ZipOutputStream zos, int storePolicy, String rootDir) throws IOException {
    File ffilePath = new File (filePath);
    String path = "";
    switch (storePolicy) {
        case STORE_FULL_PATH_IN_ZIP :
            path = ffilePath.getAbsolutePath ();
            break;
        case STORE_NAME_ONLY_IN_ZIP :
            ffilePath.getName ();
            break;
        case STORE_RELATIVE_PATH_IN_ZIP :
            File f = new File ("");
            String pathToHere = f.getAbsolutePath ();
            path = ffilePath.getAbsolutePath ();
            path = path.substring (path.indexOf (pathToHere + File.separator) + pathToHere.length ());
            break;
        case STORE_PATH_FROM_ZIP_ROOT :
            path = ffilePath.getAbsolutePath ();
            String tmpDir = rootDir + File.separator;
            path = path.substring (path.indexOf (tmpDir) + tmpDir.length ());
            break;
        default :
            break;
    }
    FileInputStream fileStream = new FileInputStream (filePath);
    BufferedInputStream bis = new BufferedInputStream (fileStream);
    ZipEntry fileEntry = new ZipEntry (path);
    zos.putNextEntry (fileEntry);
    byte [] data = new byte [BUFFER_SIZE];
    int byteCount;
    while ((byteCount = bis.read (data, 0, BUFFER_SIZE)) > - 1) zos.write (data, 0, byteCount);
}


protected void addObjectToZip (int serializerType, ZipOutputStream zipOutputStream, Object o, String name, String typeName) throws ValidationException, MarshalException, IOException, InfoException {
    ByteArrayInputStream in = null;
    ObjectOutputStream oos;
    int len;
    byte [] buf = new byte [1024];
    if (serializerType == 1) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
        oos = new ObjectOutputStream (outputStream);
        oos.writeObject (o);
        in = new ByteArrayInputStream (outputStream.toByteArray ());
    }
    else if (serializerType == 2) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
        Writer writer = null;
        try {
            String writerClassName;
            String javaVersion = System.getProperty ("java.vm.version");
            if (javaVersion.startsWith ("1.4")) {
                writerClassName = "org.apache.xalan.serialize.WriterToUTF8";
            }
            else {
                writerClassName = "com.sun.org.apache.xml.internal.serializer.WriterToUTF8";
            }
            Class writerClass = Class.forName (writerClassName);
            writer = (Writer) writerClass.getConstructor (new Class [] {OutputStream.class}).newInstance (new Object [] {outputStream});
        } catch (Exception e) {
            throw new InfoException (LanguageTraslator.traslate ("471"), e);
        }
        Marshaller.marshal (o, writer);
        in = new ByteArrayInputStream (outputStream.toByteArray ());
    }
    zipOutputStream.putNextEntry (new ZipEntry (name));
    while ((len = in.read (buf)) > 0) {
        zipOutputStream.write (buf, 0, len);
    }
    getConfiguration ().put (typeName, name);
    zipOutputStream.closeEntry ();
    in.close ();
}


-----Function Pair=272=-----==

private void gzip (FileHolder fileHolder) {
    byte [] buffer = new byte [BUFFER_SIZE];
    int bytes_read;
    if (fileHolder.selectedFileList.size () == 0) {
        return;
    }
    File destFile = new File (fileHolder.destFiles [0]);
    try {
        OutputStream outStream = new FileOutputStream (destFile);
        outStream = new GZIPOutputStream (outStream);
        File selectedFile = fileHolder.selectedFileList.get (0);
        super.currentObjBeingProcessed = selectedFile;
        this.inStream = new FileInputStream (selectedFile);
        while ((bytes_read = this.inStream.read (buffer)) != - 1) {
            outStream.write (buffer, 0, bytes_read);
        }
        outStream.close ();
        this.inStream.close ();
    } catch (IOException e) {
        errEntry.setThrowable (e);
        errEntry.setAppContext ("gzip()");
        errEntry.setAppMessage ("Error gzip'ing: " + destFile);
        logger.logError (errEntry);
    }
}


private void writeFile (InputStream zis, File file, int size) throws IOException {
    File parentFile = file.getParentFile ();
    if (! parentFile.exists ()) {
        parentFile.mkdirs ();
    }
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream (file);
        byte [] byteStream = new byte [(int) size];
        int buf = - 1;
        int rb = 0;
        while ((((int) size - rb) > 0)) {
            buf = zis.read (byteStream, rb, (int) size - rb);
            if (buf == - 1) {
                break;
            }
            rb += buf;
        }
        fos.write (byteStream);
    } catch (IOException e) {
        throw new IOException ("UNZIP_ERROR");
    } finally {
        if (fos != null) {
            fos.close ();
        }
    }
}


-----Function Pair=273=-----==

public void addToZip (String zipFilePath, String files []) throws Exception {
    File tmpFile = new File ("temp.zip");
    ZipFile zipFile = new ZipFile (new File (zipFilePath));
    ZipOutputStream zo = new ZipOutputStream (new FileOutputStream (tmpFile));
    ZipEntry entry = null;
    ZipEntry outEntry = null;
    java.util.Enumeration e = zipFile.getEntries ();
    while (e.hasMoreElements ()) {
        entry = (ZipEntry) e.nextElement ();
        outEntry = new ZipEntry (entry.getName ());
        InputStream zi = zipFile.getInputStream (entry);
        zo.putNextEntry (outEntry);
        while (true) {
            int n = zi.read (buffer);
            if (n < 0) break;
            zo.write (buffer, 0, n);
        }
        zi.close ();
        zo.closeEntry ();
    }
    for (int i = 0; i < files.length; i ++) {
        File file = new File (files [i]).getAbsoluteFile ();
        prefix = file.getParent ();
        if (! prefix.endsWith (File.separator)) prefix = prefix + File.separator;
        doZip (zo, file);
    }
    zo.close ();
    zipFile.close ();
    File oldZipFile = new File (zipFilePath);
    String zipFileName = oldZipFile.getName ();
    oldZipFile.delete ();
    tmpFile.renameTo (new File (zipFileName));
}


public static Unit GetUnit (Connection conn, ZipFile file) throws Exception {
    Unit aunit = null;
    java.util.Enumeration files = file.entries ();
    while (files.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) files.nextElement ();
        if (! entry.isDirectory ()) {
            if (entry.getName ().endsWith (".unit")) {
                InputStream in = file.getInputStream (entry);
                java.io.InputStreamReader r = new InputStreamReader (in, "UTF-8");
                java.io.BufferedReader br = new BufferedReader (r);
                String s = br.readLine ();
                String unit_name = null;
                s = br.readLine ();
                if (s != null) unit_name = s.trim ();
                String unit_code = null;
                s = br.readLine ();
                if (s != null) unit_code = s.trim ();
                String unit_address = null;
                s = br.readLine ();
                if (s != null) unit_address = s.trim ();
                String unit_email = null;
                s = br.readLine ();
                if (s != null) unit_email = s.trim ();
                String unit_attachman = null;
                s = br.readLine ();
                if (s != null) unit_attachman = s.trim ();
                String unit_zipcode = null;
                s = br.readLine ();
                if (s != null) unit_zipcode = s.trim ();
                String unit_phonenum = null;
                s = br.readLine ();
                if (s != null) unit_phonenum = s.trim ();
                String unit_mobile = null;
                s = br.readLine ();
                if (s != null) unit_mobile = s.trim ();
                try {
                    br.close ();
                } catch (Exception e1) {
                }
                aunit = Unit.GetUnitByCode (conn, unit_code);
                if (aunit == null) {
                    aunit = Unit.GetUnit (conn, unit_name, unit_code);
                    aunit.SetAddress (unit_address);
                    aunit.SetEmail (unit_email);
                    aunit.SetAddress (unit_attachman);
                    aunit.SetZipcode (unit_zipcode);
                    aunit.SetPhonenum (unit_phonenum);
                    aunit.SetMobile (unit_mobile);
                    aunit.Save (conn, true);
                }
                break;
            }
        }
    }
    return aunit;
}


-----Function Pair=274=-----==

public static void insertEmptyParaForHeadings (Document doc) {
    NodeList hNodes = doc.getDocumentElement ().getElementsByTagName ("text:h");
    for (int i = 0; i < hNodes.getLength () - 1; i ++) {
        Element hElem = (Element) hNodes.item (i);
        Element nextElem;
        Node nextNode = hElem.getNextSibling ();
        while (nextNode != null && nextNode.getNodeType () != Node.ELEMENT_NODE) {
            nextNode = nextNode.getNextSibling ();
        }
        nextElem = (Element) nextNode;
        if (nextElem != null && nextElem.getNodeName ().equals ("text:h") && hElem.hasAttribute ("text:outline-level") && nextElem.hasAttribute ("text:outline-level") && hElem.getAttribute ("text:outline-level").equals (nextElem.getAttribute ("text:outline-level"))) {
            Element para = doc.createElement ("text:p");
            hElem.getParentNode ().insertBefore (para, nextNode);
        }
    }
}


public String hlOpenAttachment_action () {
    FileInputStream fileToDownload = null;
    ServletOutputStream out = null;
    try {
        RowKey rk = getTrgAttachments ().getRowKey ();
        Attachment attachment = (Attachment) getSessionBean1 ().getFileRepositoryDP ().getObject (rk);
        java.io.File file = new java.io.File (attachment.getFilePath ());
        fileToDownload = new FileInputStream (file);
        HttpServletResponse response = (HttpServletResponse) FacesContext.getCurrentInstance ().getExternalContext ().getResponse ();
        out = response.getOutputStream ();
        response.setHeader ("Content-Disposition", "attachment; filename=\"" + file.getName () + "\"");
        response.setContentLength (fileToDownload.available ());
        int c;
        while ((c = fileToDownload.read ()) != - 1) {
            out.write (c);
        }
        out.flush ();
    } catch (Exception ex) {
        LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
    } finally {
        if (fileToDownload != null) {
            try {
                fileToDownload.close ();
            } catch (IOException ex) {
                LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException ex) {
                LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
            }
        }
    }
    return null;
}


-----Function Pair=275=-----==

public void openFile (String filename) throws ApplicationException {
    int returnVal;
    JFileChooser fc = getOpenFileChooser ();
    if (filename == null) {
        returnVal = fc.showOpenDialog (this);
    }
    else {
        fc.setSelectedFile (new File (filename));
        returnVal = JFileChooser.APPROVE_OPTION;
    }
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        if (! closeFile ()) return;
        freeze (true);
        final File file = fc.getSelectedFile ();
        if (file.canRead ()) {
            int ii = 0;
            boolean pushit = true;
            for (File recentFile : recentFiles) {
                if (ii ++ >= 4) {
                    break;
                }
                if (file.equals (recentFile)) {
                    pushit = false;
                    break;
                }
            }
            if (pushit) {
                try {
                    String desc = abbreviateFileName (file.getCanonicalPath ());
                    recentFileMenuItems.addFirst (new JMenuItem (desc));
                    recentFiles.addFirst (file);
                    constructFileMenu ();
                } catch (IOException ioe) {
                }
            }
        }
        try {
            Document doc = openDoc (file);
            String reason = "Unknown reason";
            if (doc != null) {
                final Document finaldoc = doc;
                Thread doModelPopulation = new Thread () {
                    public void run () {
                        try {
                            desktopPane.removeAll ();
                            Element component = finaldoc.getRootElement ();
                            Attribute component_name = component.getAttribute ("name");
                            if (component == null || component_name == null) throw new Exception ("Bad Component tag");
                            HierarchyNode rootHierarchyNode = XmlEngine.createCluster (InfoSec.this, component_name.getValue ());
                            hierarchy = new Hierarchy (rootHierarchyNode);
                            hierarchy.setRoot (rootHierarchyNode);
                            rootHierarchyNode.setModel (hierarchy);
                            rootHierarchyNode.getComponentModel ().setNameChangeEventListener (InfoSec.this);
                            tree.setModel (hierarchy);
                            Element schematicElement = component.getChild ("Schematic");
                            if (schematicElement == null) throw new Exception ("No schematic tag inside component");
                            XmlEngine.doChildComponents (InfoSec.this, rootHierarchyNode, schematicElement.getChildren ("ChildComponent"), schematicElement.getChildren ("Connection"), schematicElement.getChildren ("Instantiation"), false);
                            if (component.getChild ("LocalFaultData") == null) throw new Exception ("No local fault data for component");
                            XmlEngine.doLocalFaultData (rootHierarchyNode, component.getChild ("LocalFaultData"));
                            setDirty (false);
                            hierarchyNodeHashToInternalFrame.clear ();
                            hierarchyNodeHashToHierarchyNode.clear ();
                            freeze (false);
                            setStatus ("Finished loading " + file.getName ());
                        } catch (Exception e2) {
                            freeze (false);
                            new ApplicationException ("Open failed - XML not valid\n" + e2.getMessage ()).handler ();
                        }
                    }
                }
                ;
                doModelPopulation.start ();
                currentlyOpenFile = file;
            }
            else {
                setStatus ("Open failed - " + reason);
                freeze (false);
                throw new ApplicationException ("Open failed - " + reason);
            }
        } catch (ApplicationException e) {
            freeze (false);
            throw e;
        }
    }
}


public static Class < ? > getDexClass (String name, byte [] data) throws IOException {
    File fff = new File ("/tmp/jvm.class");
    if (! fff.exists ()) {
        fff.createNewFile ();
    }
    FileOutputStream fos = new FileOutputStream (fff);
    fos.write (data);
    fos.close ();
    com.google.dex.file.DexFile outputDex = new com.google.dex.file.DexFile ();
    CfOptions cf = new CfOptions ();
    ClassDefItem clazz = CfTranslator.translate (fixPath (name.replace ('.', '/') + ".class"), data, cf);
    outputDex.add (clazz);
    File tmpdir = new File (tmpdirpath + name);
    if (! tmpdir.exists ()) {
        tmpdir.mkdir ();
    }
    else {
        if (! tmpdir.isDirectory ()) {
            throw new IOException ();
        }
    }
    File apk = new File (tmpdirpath + name + "/" + name + ".apk");
    if (! apk.exists ()) {
        apk.createNewFile ();
    }
    ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (apk));
    ZipEntry classeszip = new ZipEntry ("classes.dex");
    zos.putNextEntry (classeszip);
    outputDex.writeTo (zos, null, false);
    zos.closeEntry ();
    zos.close ();
    getClassByName (apppath, "org/python/core/PyFunctionTable");
    getClassByName (apppath, "org/python/core/PyRunnable");
    Class < ? > c = getClassByName (tmpdirpath + name + "/" + name + ".apk", name.replace ('.', '/'));
    getClassByName (apppath, "org/python/core/PyFunctionTable");
    return c;
}


-----Function Pair=276=-----==

private Project loadFromZargo (File file, ProgressMgr progressMgr) throws OpenException {
    Project p = ProjectFactory.getInstance ().createProject (file.toURI ());
    try {
        progressMgr.nextPhase ();
        ArgoParser parser = new ArgoParser ();
        String argoEntry = getEntryNames (file, ".argo").iterator ().next ();
        parser.readProject (p, new InputSource (makeZipEntryUrl (toURL (file), argoEntry).toExternalForm ()));
        List memberList = parser.getMemberList ();
        LOG.info (memberList.size () + " members");
        String xmiEntry = getEntryNames (file, ".xmi").iterator ().next ();
        MemberFilePersister persister = getMemberFilePersister ("xmi");
        persister.load (p, makeZipEntryUrl (toURL (file), xmiEntry));
        List < String > entries = getEntryNames (file, null);
        for (String name : entries) {
            String ext = name.substring (name.lastIndexOf ('.') + 1);
            if (! "argo".equals (ext) && ! "xmi".equals (ext)) {
                persister = getMemberFilePersister (ext);
                LOG.info ("Loading member with " + persister.getClass ().getName ());
                persister.load (p, openZipEntry (toURL (file), name));
            }
        }
        progressMgr.nextPhase ();
        ThreadUtils.checkIfInterrupted ();
        p.postLoad ();
        return p;
    } catch (InterruptedException e) {
        return null;
    } catch (MalformedURLException e) {
        throw new OpenException (e);
    } catch (IOException e) {
        throw new OpenException (e);
    } catch (SAXException e) {
        throw new OpenException (e);
    }
}


public static void compressFiles (String newFileName, String [] inputFilePaths, String destDir) throws Exception {
    String zipPathName = destDir + "/" + newFileName + ".zip";
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (zipPathName));
    for (int i = 0; i < inputFilePaths.length; i ++) {
        File inputFile = new File (inputFilePaths [i]);
        if (inputFile.exists () && inputFile.isFile ()) {
            FileInputStream in = new FileInputStream (inputFile);
            zipOut.putNextEntry (new ZipEntry (inputFile.getName ()));
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                zipOut.write (buffer, 0, nNumber);
            }
            in.close ();
        }
    }
    zipOut.close ();
}


-----Function Pair=277=-----==

public void addPages () {
    optionsPage = new OptionsPage (Messages.ExportZipWizard_choosepath, false);
    optionsPage.setTitle (TITLE);
    addPage (optionsPage);
    sizePage = new SizePage (Messages.ExportZipWizard_setsize, this);
    sizePage.setTitle (TITLE);
    addPage (sizePage);
    imagesPage = new ThumbsPage (Messages.ExportZipWizard_images, this);
    imagesPage.setTitle (TITLE);
    if (activeDisplayAlbum != null) {
        List < IThumb > ts = activeDisplayAlbum.getThumbsWithChildren ();
        imagesPage.setThumbs (ts.toArray (new IThumb [ts.size ()]));
    }
    addPage (imagesPage);
    dialog.addPageChangedListener (new IPageChangedListener () {
        @Override
        public void pageChanged (PageChangedEvent event) {
            Object selectedPage = event.getSelectedPage ();
            if (selectedPage.equals (imagesPage)) {
                imagesPage.setPageComplete (true);
            }
        }
    }
    );
    Image img = ImageHelper.createImage (null, "/icons/exportdir_wiz.gif");
    if (img != null) {
        getShell ().setImage (img);
    }
    optionsPage.setPageComplete (false);
}


private static void pack (final URL url, final String comment, final File destFile) throws IOException {
    ZipOutputStream zipStrm = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (destFile, false)));
    try {
        zipStrm.setComment (comment);
        File file = IoUtil.url2file (url);
        if (file == null) {
            throw new IOException ("resolved URL " + url + " is not local file system location pointer");
        }
        File [] files = file.listFiles ();
        for (int i = 0; i < files.length; i ++) {
            packEntry (zipStrm, null, files [i]);
        }
    } finally {
        zipStrm.close ();
    }
}


-----Function Pair=278=-----==

private boolean convertDOCXActionParams (String [] args) {
    File dirOut = null;
    String lang = "en";
    for (int i = 1; i < args.length; i ++) {
        if (i == 1) {
            root = new File (args [i]);
            continue;
        }
        if (args [i].equalsIgnoreCase ("-d")) {
            dirOut = new File (args [++ i]);
            if (dirOut.exists () && ! dirOut.isDirectory ()) {
                throw new RuntimeException (args [i] + " is not a directory.");
            }
            if (! dirOut.exists ()) dirOut.mkdirs ();
            continue;
        }
        if (args [i].equalsIgnoreCase ("-noo")) noo = true;
        if (args [i].equalsIgnoreCase ("-l")) lang = args [++ i];
        if (args [i].equalsIgnoreCase ("-noe")) EPUBMetaData.doNotEmbedOTFFonts = true;
        if (args [i].equalsIgnoreCase ("-nopb")) BaseRenderer.noPageBreakEmit = true;
    }
    DOCX2EPUB conv = new DOCX2EPUB (root, dirOut == null ? root : dirOut);
    conv.recurse (root);
    return true;
}


public FileNameGroup (String line) {
    executable_ = false;
    recursive_ = true;
    if (line.startsWith ("(E)")) {
        line = line.substring (3);
        executable_ = true;
    }
    if (line.startsWith ("(N)")) {
        line = line.substring (3);
        recursive_ = false;
    }
    StringTokenizer tok = new StringTokenizer (new String (line), "|", true);
    originBase_ = tok.nextToken ();
    if (originBase_.endsWith ("/")) originBase_ = originBase_.substring (0, originBase_.length () - 1);
    tok.nextToken ();
    destBase_ = tok.nextToken ();
    if (destBase_.equals ("|")) destBase_ = null;
    else {
        if (destBase_.endsWith ("/")) destBase_ = destBase_.substring (0, destBase_.length () - 1);
        tok.nextToken ();
    }
    extensions_ = null;
    commonPath_ = null;
    if (tok.hasMoreTokens ()) {
        commonPath_ = tok.nextToken ();
        if (commonPath_.equals ("|")) commonPath_ = null;
        if (tok.hasMoreTokens ()) {
            if (commonPath_ != null) tok.nextToken ();
            if (tok.hasMoreTokens ()) extensions_ = tok.nextToken ();
        }
    }
}


-----Function Pair=279=-----==

public void getOWLFile (Set < String > modelsNames) throws IOException {
    ExtendedIterator modelNameIterator = connection.getAllModelNames ();
    if (! modelNameIterator.hasNext ()) {
        System.out.println ("No models to dump");
        return;
    }
    ZipOutputStream zipOut = new ZipOutputStream (new FileOutputStream (outputFile));
    zipOut.setLevel (9);
    String modelName = null;
    String fileName = null;
    OntModel ontModel = null;
    int index;
    RDFWriter writer = null;
    boolean extractSpecificModels = modelsNames.size () > 0;
    while (modelNameIterator.hasNext ()) {
        modelName = (String) modelNameIterator.next ();
        index = modelName.lastIndexOf ("/");
        fileName = modelName;
        if (index != - 1) {
            fileName = modelName.substring (index + 1, modelName.length ());
        }
        if (extractSpecificModels && ! modelsNames.contains (fileName)) {
            continue;
        }
        ontModel = ModelFactory.createOntologyModel (OntModelSpec.OWL_DL_MEM, modelMaker.openModel (modelName));
        System.out.println ("Saving model \"" + modelName + "\"");
        try {
            writer = ontModel.getWriter ("RDF/XML");
            ontModel.setNsPrefix ("", modelName + "#");
            System.out.println ("Base Namespace: " + modelName);
            writer.setProperty ("xmlbase", modelName);
            writer.setProperty ("showXmlDeclaration", "true");
            writer.setProperty ("tab", "2");
            zipOut.putNextEntry (new ZipEntry (fileName));
            writer.write (ontModel, zipOut, null);
            ontModel.close ();
            writer.setErrorHandler (this);
            zipOut.closeEntry ();
        } catch (IOException e) {
            e.printStackTrace ();
        }
        System.out.println ("DONE");
    }
    zipOut.close ();
}


private void getClassLibs () {
    String re = "lib.*?path=['\"](.*?jar)['\"]";
    Pattern p = Pattern.compile (re);
    Matcher matcher = p.matcher (classFileContents);
    int i = 0;
    while (matcher.find ()) {
        i ++;
    }
    String [] jars = new String [i];
    matcher.reset ();
    i = 0;
    while (matcher.find ()) {
        String match = matcher.group (1);
        System.out.println ("Class libs: " + i + ". " + match);
        jars [i] = match;
        i ++;
    }
    boolean addGwtServlet = true;
    jars = deleteGwtUserJar (jars, addGwtServlet);
    classLibs = jars;
}


-----Function Pair=280=-----=1=

private static void zip (File dir, File base, ZipOutputStream out) throws IOException {
    File [] files = dir.listFiles ();
    byte [] buffer = new byte [8192];
    final String FILE_SEP = System.getProperty ("file.separator");
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            zip (files [i], base, out);
        }
        else {
            FileInputStream fin = new FileInputStream (files [i]);
            ZipEntry entry = new ZipEntry (files [i].getPath ().substring (base.getPath ().length () + 1).replace (FILE_SEP, "/"));
            out.putNextEntry (entry);
            int bytes_read = 0;
            while ((bytes_read = fin.read (buffer)) != - 1) {
                out.write (buffer, 0, bytes_read);
            }
            fin.close ();
        }
    }
}


private File generateZip (Preference preference, File xml, List < Document > documents) {
    File zfile = new File (preference.getStoreLocation () + File.separator + AppConstants.DMS_ZIPFILE);
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zfile));
        FileInputStream in = new FileInputStream (xml);
        out.putNextEntry (new ZipEntry (xml.getName ()));
        int len;
        byte [] buf = new byte [1024];
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
        for (Iterator < Document > iter = documents.iterator (); iter.hasNext ();) {
            Document document = iter.next ();
            in = new FileInputStream (preference.getStoreLocation () + File.separator + document.getName ());
            out.putNextEntry (new ZipEntry (document.getName ()));
            len = 0;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.closeEntry ();
            in.close ();
        }
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
        zfile = null;
    }
    return zfile;
}


-----Function Pair=281=-----==

public void write (OutputStream out) throws IOException {
    String dir = info.getDirectory ();
    if (dir == null && info.getFiles ().length == 1) {
        String path = info.getBaseDirectory () + "/" + info.getFiles () [0].getPath ();
        writeFile (path, out);
    }
    else {
        ZipOutputStream zipOut = new ZipOutputStream (out);
        zipOut.setLevel (0);
        zipOut.setComment ("name: " + info.getName () + info.getComment () != null ? "\n comment:" + info.getComment () : "" + info.getTag () != null ? "\n tag:" + info.getTag () : "");
        FileInfo [] files = info.getFiles ();
        char separator = rtorrent.getFileSeparatoChar ();
        String remoteBaseDir = info.getBaseDirectory ();
        String remoteBasePath = remoteBaseDir + separator + dir;
        for (FileInfo fileInfo : files) {
            String remotePath = '\'' + remoteBasePath + separator + fileInfo.getPath () + '\'';
            ZipEntry entry = new ZipEntry (dir + "\\" + fileInfo.getPath ().replace (separator, '\\'));
            zipOut.putNextEntry (entry);
            writeFile (remotePath, zipOut);
        }
        zipOut.finish ();
    }
}


public Boolean compress (List < String > inFiles, String outFile, String key) throws Exception {
    Boolean flag = false;
    String tempFile = outFile;
    if (null != key && ! "".equals (key)) {
        tempFile = tempFile + "temp";
    }
    ArrayList < String > filePathList = new ArrayList < String > ();
    ArrayList < String > fileNameList = new ArrayList < String > ();
    if (inFiles != null && inFiles.size () > 0) {
        File file = null;
        for (String fileStr : inFiles) {
            file = new File (fileStr);
            filePathList.add (file.getAbsolutePath ());
            fileNameList.add (file.getName ());
        }
        makeZip (filePathList, fileNameList, tempFile);
        if (null != key && ! "".equals (key)) {
            File temp = new File (tempFile);
            AesZipFileEncrypter enc = new AesZipFileEncrypter (outFile);
            enc.addAll (temp, key);
            enc.close ();
            temp.delete ();
        }
    }
    flag = true;
    return flag;
}


-----Function Pair=282=-----==

public static void unzip (InputStream is, File destDir) throws FileNotFoundException, IOException {
    BufferedOutputStream dest = null;
    ZipInputStream zis = new ZipInputStream (new BufferedInputStream (is));
    ZipEntry entry;
    while ((entry = zis.getNextEntry ()) != null) {
        if (entry.isDirectory ()) {
            (new File (destDir, entry.getName ())).mkdirs ();
        }
        else {
            File f = new File (destDir, entry.getName ());
            f.getParentFile ().mkdirs ();
            int count;
            byte data [] = new byte [BUFFER];
            FileOutputStream fos = new FileOutputStream (f);
            dest = new BufferedOutputStream (fos, BUFFER);
            while ((count = zis.read (data, 0, BUFFER)) != - 1) {
                dest.write (data, 0, count);
            }
            dest.flush ();
            dest.close ();
        }
    }
    zis.close ();
}


protected List getVersionedFiles (File dir) throws IOException {
    File cvsDir = new File (dir, "CVS");
    File entriesFile = new File (cvsDir, "Entries");
    if (! entriesFile.exists ()) return Collections.EMPTY_LIST;
    List result = new LinkedList ();
    BufferedReader entries = new BufferedReader (new FileReader (entriesFile));
    String line;
    while ((line = entries.readLine ()) != null) {
        int beg = line.indexOf ('/');
        if (beg == - 1) continue;
        int end = line.indexOf ('/', beg + 1);
        if (end == - 1) continue;
        String filename = line.substring (beg + 1, end);
        result.add (filename);
    }
    if (includeCvsDirs) {
        result.add ("CVS/Root");
        result.add ("CVS/Repository");
        result.add ("CVS/Entries");
    }
    return result;
}


-----Function Pair=283=-----==

private static void zipDir (final File zipDir, final String parentRelativePath, final ZipOutputStream zos) throws IOException {
    if (zipDir == null || zos == null) {
        throw new IllegalArgumentException ("directory and ZipOutputStream shouldn't be null");
    }
    final File [] dirChildren = zipDir.listFiles ();
    String entry = zipDir.getName ();
    if (parentRelativePath.length () > 0) {
        entry = parentRelativePath + ZIP_FILE_SEP + zipDir.getName ();
    }
    final ZipEntry anDirectoryEntry = new ZipEntry (entry + ZIP_FILE_SEP);
    zos.putNextEntry (anDirectoryEntry);
    final byte [] readBuffer = new byte [NB_BITE];
    int bytesIn = 0;
    for (final File element : dirChildren) {
        if (element.isDirectory ()) {
            zipDir (element, entry, zos);
        }
        else {
            final FileInputStream fis = new FileInputStream (element);
            final ZipEntry anFileEntry = new ZipEntry (entry + ZIP_FILE_SEP + element.getName ());
            zos.putNextEntry (anFileEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) {
                zos.write (readBuffer, 0, bytesIn);
            }
            fis.close ();
        }
    }
}


public String btnUpload_action () {
    ResourceBundle props = ResourceBundle.getBundle ("epice");
    UploadedFile uploadedFile = fuUpload.getUploadedFile ();
    if (uploadedFile == null) {
        return null;
    }
    String uploadedFileName = uploadedFile.getOriginalName ();
    int index = uploadedFileName.lastIndexOf ('/');
    String justFileName;
    if (index >= 0) {
        justFileName = uploadedFileName.substring (index + 1);
    }
    else {
        index = uploadedFileName.lastIndexOf ('\\');
        if (index >= 0) {
            justFileName = uploadedFileName.substring (index + 1);
        }
        else {
            justFileName = uploadedFileName;
        }
    }
    String fileRepo = props.getString ("FILE_REPOSITORY");
    Attachment attachment = null;
    try {
        java.io.File tempDir = java.io.File.createTempFile ("EPICE_TMP_", "", new java.io.File (fileRepo));
        if (! tempDir.delete ()) {
            throw new IOException ();
        }
        if (! tempDir.mkdirs ()) {
            throw new IOException ();
        }
        java.io.File tempFile = new java.io.File (tempDir.getPath () + "/" + justFileName);
        uploadedFile.write (tempFile);
        attachment = attachmentDAO.createWithoutPersisting (tempDir.getName () + "/" + justFileName, getSessionBean1 ().getCurrentUser ().getEmail ());
        FileRepository fr = getSessionBean1 ().getCurrentFileRepository ();
        FileRepository fr2 = fileRepoDAO.addNewAttachment (fr, attachment);
        getSessionBean1 ().setCurrentFileRepository (fr2);
    } catch (IOException ex) {
        LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
    } catch (FileRepositoryNotExistException ex) {
        if (attachment != null) {
            getSessionBean1 ().getCurrentFileRepository ().getAttachments ().add (attachment);
        }
    } catch (Exception ex) {
        LogUtil.getLogger ().log (Level.SEVERE, Thread.currentThread ().getStackTrace () [3].getMethodName (), ex);
    }
    getSessionBean1 ().getCurrentFileRepository ().refreshDataProvider (getSessionBean1 ().getCurrentUser ());
    return null;
}


-----Function Pair=284=-----==

private void updateFile (BackUpInfoFile fileInfo, ZipOutputStream zos) {
    try {
        int bytesIn = 0;
        File file = new File (fileInfo.getPath () + fileInfo.getName () + "." + fileInfo.getType ());
        FileInputStream fis = new FileInputStream (file);
        ZipEntry anEntry = new ZipEntry (fileInfo.getId ());
        zos.putNextEntry (anEntry);
        while ((bytesIn = fis.read (BUFFER)) != - 1) {
            zos.write (BUFFER, 0, bytesIn);
        }
        fileInfo.setSize (file.length ());
        fis.close ();
    } catch (IOException e) {
        throw new BackupException (e.getMessage ());
    }
}


private void collectClassNames (File file, final Set classNames) throws Exception {
    if (isClassFile (file)) {
        byte [] bytes = ByteCodeHelper.readByteCode (file);
        ClassDescriptor descriptor = getClassDescriptor (bytes);
        classNames.add (descriptor.getName ());
    }
    else if (isJarFile (file)) {
        ZipEntryHandler collector = new ZipEntryHandler () {
            public void handleEntry (ZipEntry entry, byte [] byteCode) throws Exception {
                if (! entry.isDirectory ()) {
                    DataInputStream din = new DataInputStream (new ByteArrayInputStream (byteCode));
                    if (din.readInt () == CLASS_MAGIC) {
                        classNames.add (getClassDescriptor (byteCode).getName ());
                    }
                }
            }
        }
        ;
        ZipFileProcessor processor = new ZipFileProcessor (collector);
        processor.process (file);
    }
}


-----Function Pair=285=-----==

public static String unzipEntryToFile (ZipInputStream zin, ZipEntry entry, String location) throws IOException {
    final String filename;
    if (location == null) {
        filename = entry.getName ();
    }
    else {
        if (location.endsWith (File.separator)) filename = location + entry.getName ();
        else filename = location + File.separator + entry.getName ();
    }
    if (true || DEBUG.IO) {
        String msg = "Unzipping to " + filename + " from entry " + entry;
        Log.info (msg);
    }
    final File newFile = createFile (filename);
    final FileOutputStream out = new FileOutputStream (newFile);
    byte [] b = new byte [1024];
    int len = 0;
    int wrote = 0;
    while ((len = zin.read (b)) != - 1) {
        wrote += len;
        out.write (b, 0, len);
    }
    out.close ();
    if (DEBUG.IO) {
        Log.debug ("    Unzipped " + filename + "; wrote=" + wrote + "; size=" + entry.getSize ());
    }
    return filename;
}


private static void zipFileOrDirectory (ZipOutputStream zipOut, File file, String curPath) {
    if (file == null || zipOut == null) {
        return;
    }
    String fileName = file.getName ();
    FileInputStream in = null;
    try {
        if (file.isFile ()) {
            ZipEntry zipEntry = new ZipEntry (curPath + fileName);
            zipOut.putNextEntry (zipEntry);
            in = new FileInputStream (file);
            int bytes;
            byte [] b = new byte [1024];
            while ((bytes = in.read (b)) != - 1) {
                zipOut.write (b, 0, bytes);
            }
            zipOut.closeEntry ();
        }
        else if (file.isDirectory ()) {
            File [] files = file.listFiles ();
            if (files != null && files.length > 0) {
                for (File f : files) {
                    zipFileOrDirectory (zipOut, f, curPath + file.getName () + "/");
                }
            }
            else if (files != null && files.length == 0) {
                ZipEntry zipEntry = new ZipEntry (curPath + fileName + "/");
                zipOut.putNextEntry (zipEntry);
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (in != null) {
                in.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=286=-----==

private byte [] addTime (HTTPurl urlData) throws Exception {
    String backURL = urlData.getCookie ("backURL");
    try {
        backURL = URLDecoder.decode (backURL, "UTF-8");
    } catch (Exception e) {
    }
    if (backURL == null || backURL.length () == 0) backURL = "/servlet/ApplyTransformRes?xml=root&xsl=kb-buttons";
    ScheduleItem item = store.getScheduleItem (urlData.getParameter ("id"));
    if (item != null) {
        Calendar cal = Calendar.getInstance ();
        cal.setTime (item.getStart ());
        int startBuff = 0;
        int endBuff = 0;
        try {
            startBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.start"));
            endBuff = Integer.parseInt (store.getProperty ("Schedule.buffer.end"));
        } catch (Exception e) {
        }
        if (item.getState () != ScheduleItem.RUNNING) {
            cal.add (Calendar.MINUTE, (startBuff * - 1));
            item.setDuration (item.getDuration () + startBuff + endBuff);
            item.setStart (cal);
        }
        else {
            item.setDuration (item.getDuration () + endBuff);
        }
        store.saveSchedule (null);
    }
    StringBuffer out = new StringBuffer ();
    out.append ("HTTP/1.0 302 Moved Temporarily\n");
    out.append ("Location: " + backURL + "\n\n");
    return out.toString ().getBytes ();
}


public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


-----Function Pair=287=-----==

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    cache = null;
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.equals ("primary")) addZone (st.nextToken (), Zone.PRIMARY);
        else if (keyword.equals ("cache")) cache = new Zone (st.nextToken (), Zone.CACHE, null);
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
    }
    if (cache == null) {
        System.out.println ("no cache specified");
        System.exit (- 1);
    }
    addUDP ((short) 12345);
    addTCP ((short) 12345);
}


public static void main (String [] args) {
    JRIClassLoader mcl = JRIClassLoader.getMainLoader ();
    String nl = findNativeLibrary ("boot", false);
    if (nl == null) {
        System.err.println ("ERROR: Unable to locate native bootstrap library.");
        System.exit (1);
    }
    mcl.registerLibrary ("boot", new File (nl));
    String cp = System.getProperty ("java.class.path");
    StringTokenizer st = new StringTokenizer (cp, File.pathSeparator);
    while (st.hasMoreTokens ()) {
        String p = st.nextToken ();
        mcl.addClassPath (p);
        if (bootFile == null && (new File (p)).isFile ()) bootFile = p;
    }
    try {
        Class stage2class = mcl.findAndLinkClass ("JRIBootstrap");
        Method m = stage2class.getMethod ("bootstrap", new Class [] {String [].class});
        m.invoke (null, new Object [] {args});
    } catch (Exception rtx) {
        System.err.println ("ERROR: Unable to invoke bootstrap method in JRIBootstrap! (" + rtx + ")");
        rtx.printStackTrace ();
        System.exit (2);
    }
}


-----Function Pair=288=-----==

public int truncateSection (Message in, int maxLength, int length, int section) {
    int removed = 0;
    Record [] records = in.getSectionArray (section);
    for (int i = records.length - 1; i >= 0; i --) {
        Record r = records [i];
        removed += r.getWireLength ();
        length -= r.getWireLength ();
        in.removeRecord (section, r);
        if (length > maxLength) continue;
        else {
            for (int j = i - 1; j >= 0; j --) {
                Record r2 = records [j];
                if (! r.getName ().equals (r2.getName ()) || r.getType () != r2.getType () || r.getDClass () != r2.getDClass ()) break;
                removed += r2.getWireLength ();
                length -= r2.getWireLength ();
                in.removeRecord (section, r2);
            }
            return removed;
        }
    }
    return removed;
}


public void testEmbedded () throws Exception {
    String whichOneToRun = askWhichOneToRun ();
    String className = "org.mortbay.jetty.example." + whichOneToRun;
    Class clazz = Thread.currentThread ().getContextClassLoader ().loadClass (className);
    Object o = clazz.newInstance ();
    Method main = clazz.getMethod ("main", new Class [] {stringArrayType.getClass ()});
    String [] prompts = (String []) argMap.get (whichOneToRun);
    String [] args = new String [0];
    if (prompts != null) {
        args = new String [prompts.length];
        for (int i = 0; i < prompts.length; i ++) {
            System.err.print ("Enter arg " + i + ": " + prompts [i] + " > ");
            args [i] = reader.readLine ();
        }
    }
    Object [] methodArgs = new Object [1];
    methodArgs [0] = args;
    main.invoke (null, methodArgs);
}


-----Function Pair=289=-----=1=

public static void main (String argv []) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


public static void main (String argv []) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, (Object []) noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


-----Function Pair=290=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


-----Function Pair=291=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=292=-----==

public static int execR (String cmd) {
    try {
        String binR = u2w (rs_home + "/bin/R");
        if (isWin32) {
            binR += ".exe";
            File fin = File.createTempFile ("rboot", ".R");
            File fout = File.createTempFile ("rboot", ".tmp");
            PrintStream p = new PrintStream (new FileOutputStream (fin));
            p.println (cmd);
            p.close ();
            Process rp = Runtime.getRuntime ().exec (new String [] {binR, "CMD", "BATCH", "--no-restore", "--no-save", "--slave", fin.getAbsolutePath (), fout.getAbsolutePath ()});
            int i = rp.waitFor ();
            if (! fin.delete ()) fin.deleteOnExit ();
            if (! fout.delete ()) fout.deleteOnExit ();
            return i;
        }
        else {
            Process rp = Runtime.getRuntime ().exec (new String [] {"/bin/sh", "-c", "echo \"" + cmd + "\" |" + binR + " --no-restore --no-save --slave >/dev/null 2>&1"});
            return rp.waitFor ();
        }
    } catch (Exception e) {
        lastError = e.toString ();
        return - 1;
    }
}


protected synchronized Class loadClass (final String name, final boolean resolve) throws ClassNotFoundException {
    if (name.startsWith ("java.")) {
        System.err.println ("Adapt: loading class '" + name + "' without on the fly adaptation");
        return super.loadClass (name, resolve);
    }
    else {
        System.err.println ("Adapt: loading class '" + name + "' with on the fly adaptation");
    }
    String resource = name.replace ('.', '/') + ".class";
    InputStream is = getResourceAsStream (resource);
    byte [] b;
    try {
        ClassReader cr = new ClassReader (is);
        ClassWriter cw = new ClassWriter (0);
        ClassVisitor cv = new TraceFieldClassAdapter (cw);
        cr.accept (cv, 0);
        b = cw.toByteArray ();
    } catch (Exception e) {
        throw new ClassNotFoundException (name, e);
    }
    try {
        FileOutputStream fos = new FileOutputStream (resource + ".adapted");
        fos.write (b);
        fos.close ();
    } catch (Exception e) {
    }
    return defineClass (name, b, 0, b.length);
}


-----Function Pair=293=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=294=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=295=-----==

public void test76 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    String [] headers = reader.getHeaders ();
    Assert.assertEquals (2, headers.length);
    Assert.assertEquals ("user_id", headers [0]);
    Assert.assertEquals ("name", headers [1]);
    reader.setHeaders (null);
    Assert.assertEquals (null, reader.getHeaders ());
    Assert.assertEquals (- 1, reader.getIndex ("user_id"));
    Assert.assertEquals ("", reader.getHeader (0));
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=296=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=297=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=298=-----==

void assignPropsValues () {
    Enumeration keys = allProps.keys ();
    while (keys.hasMoreElements ()) {
        String key = (String) keys.nextElement ();
        SkinProperty p = (SkinProperty) allProps.get (key);
        String propValue = (String) romizedProps.get (key);
        if (propValue != null) {
            p.value = propValue;
        }
        else {
            if (! p.isNew) {
                missingProps.add (p);
            }
        }
    }
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=299=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=300=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=301=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=302=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=303=-----==

public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test136 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=304=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


-----Function Pair=305=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=306=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test91 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=307=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=308=-----=1=

public static void main (String argv []) {
    sun.misc.CVM.setURLConnectionDefaultUseCaches (false);
    final String s = System.getProperty ("java.class.path");
    System.out.println ("java.class.path: " + s);
    URL [] urls = new URL [1];
    URLStreamHandlerFactory factory = new Factory ();
    URLStreamHandler fileHandler = factory.createURLStreamHandler ("file");
    try {
        urls [0] = new URL ("file", "", - 1, s, fileHandler);
    } catch (MalformedURLException e) {
        throw new InternalError ();
    }
    int i;
    for (i = 0; i < Integer.parseInt (argv [0]); i ++) {
        try {
            URLClassLoader cl = new URLClassLoader (urls, null);
            Class clazz = cl.loadClass (argv [1]);
            Class [] argTypes = new Class [1];
            argTypes [0] = Class.forName ("[Ljava.lang.String;");
            Method main = clazz.getMethod ("main", argTypes);
            Object [] args = new Object [1];
            String [] arg0 = new String [argv.length - 2];
            args [0] = arg0;
            for (int j = 0; j < argv.length - 2; j ++) {
                arg0 [j] = argv [j + 2];
            }
            main.invoke (null, args);
            InputStream stream = cl.getResourceAsStream ("Test.class");
            System.out.println ("InputStream: " + stream);
            cl = null;
            clazz = null;
            main = null;
            stream = null;
            System.out.println ("Running GC #1");
            java.lang.Runtime.getRuntime ().gc ();
            System.out.println ("Running Finalizers #1");
            java.lang.Runtime.getRuntime ().runFinalization ();
            System.out.println ("Running GC #2");
            java.lang.Runtime.getRuntime ().gc ();
            System.out.println ("Running Finalizers #2");
            java.lang.Runtime.getRuntime ().runFinalization ();
            System.out.println ("Done");
        } catch (Throwable e) {
            e.printStackTrace ();
        }
    }
}


public static void main (String args []) {
    if (args.length != 2) {
        String u = "Usage: java -cp . UpgradeRomizedProperties <infile> <outfile>";
        System.out.println (u);
        System.exit (0);
    }
    Runtime rt = Runtime.getRuntime ();
    String cmd = "javac -d " + System.getProperty ("user.dir") + " " + args [0];
    int exitCode;
    try {
        Process p = rt.exec (cmd);
        exitCode = p.waitFor ();
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    Hashtable rp = new Hashtable ();
    Object [] argz = {rp};
    try {
        String cn = "com.sun.midp.chameleon.skins.resources.RomizedProperties";
        Class clazz = Class.forName (cn);
        Method loadProperties;
        loadProperties = clazz.getMethod ("load", new Class [] {Hashtable.class});
        loadProperties.invoke (null, argz);
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    Converter converter = new Converter (SkinProperty.properties, rp);
    converter.convert ();
    try {
        FileOutputStream fout = new FileOutputStream (args [1]);
        OutputStreamWriter w = new OutputStreamWriter (fout);
        writer = new PrintWriter (w);
    } catch (Exception e) {
        System.err.println (e);
        System.exit (1);
    }
    printHeader ();
    printSkinProperties ();
    printFooter ();
    writer.close ();
    reportUnknownProperties (converter.unknownProps);
    reportMissingProperties (converter.missingProps);
}


-----Function Pair=309=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test124 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setRecordDelimiter (';');
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\;2;", data);
}


-----Function Pair=310=-----==

public static final void main (String [] argv) {
    String machineName = null;
    String envName = null;
    for (int i = 0; i < argv.length; i ++) {
        machineName = argv [i].substring (0, argv [i].lastIndexOf ("."));
        envName = machineName + "Environment";
        if (new File (envName + ".java").canRead ()) {
            System.out.println ("*** Running " + envName);
            try {
                Class.forName ("examples." + envName).getMethod ("main", new Class [] {String [].class}).invoke (null, new Object [] {null});
            } catch (Exception e) {
                e.printStackTrace ();
            }
            System.out.println ("*** Completed");
        }
        else {
            System.out.println ("*** Running " + machineName);
            try {
                ((TransitionMachine) MachineConstructor.newInstance ("examples." + machineName, null)).run ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
            System.out.println ("*** Completed");
        }
    }
}


public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


-----Function Pair=311=-----==

public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=312=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


-----Function Pair=313=-----==

protected void open (File file) throws Exception {
    if (Desktop.isDesktopSupported () && Desktop.getDesktop ().isSupported (Desktop.Action.OPEN)) {
        File fixedFile = new File (file.getAbsoluteFile ().toString ()) {
            public URI toURI () {
                try {
                    return new URI ("file://" + getAbsolutePath ());
                } catch (Exception e) {
                    return super.toURI ();
                }
            }
        }
        ;
        Desktop.getDesktop ().open (fixedFile);
    }
}


public static void main (String [] args) {
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("HelloWorld.pdf"));
        document.open ();
        document.add (new Paragraph ("A Hello World PDF document."));
        document.close ();
    } catch (DocumentException e) {
        e.printStackTrace ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=314=-----==

public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


public static void Sample2 (String myField, String condition1, String condition2) throws SQLException {
    Connection connection = DriverManager.getConnection ("jdbc:postgresql://localhost/test", "user", "password");
    connection.setAutoCommit (false);
    Statement st = connection.createStatement ();
    String sql = "UPDATE myTable SET myField = '" + myField + "' WHERE myOtherField1 = '" + condition1 + "' AND myOtherField2 = '" + condition2 + "'";
    int numChanged = st.executeUpdate (sql);
    if (numChanged > 10) {
        connection.rollback ();
    }
    else {
        connection.commit ();
    }
    st.close ();
    connection.close ();
}


-----Function Pair=315=-----==

public void hyperlinkUpdate (HyperlinkEvent event) {
    URL url = event.getURL ();
    if (event.getEventType () == HyperlinkEvent.EventType.ENTERED && ! event.getDescription ().equals ("login") && ! event.getDescription ().startsWith ("copyUrl:")) {
        this.resultsText.setToolTipText (url.toString ());
    }
    else if (event.getEventType () == HyperlinkEvent.EventType.EXITED) {
        this.resultsText.setToolTipText (null);
    }
    else if (event.getEventType () == HyperlinkEvent.EventType.ACTIVATED) {
        if (event.getDescription ().equals ("login")) {
            if (this.win == null) {
                this.win = new WinLoginWindow (this, this.keys);
            }
            else {
                this.win.setVisible (true);
            }
        }
        else if (event.getDescription ().startsWith ("copyUrl:")) {
            String toCopy = event.getDescription ().replaceFirst ("copyUrl:", "");
            StringSelection data = new StringSelection (toCopy);
            Clipboard clipboard = Toolkit.getDefaultToolkit ().getSystemClipboard ();
            clipboard.setContents (data, data);
        }
        else {
            if (! Desktop.isDesktopSupported ()) {
                try {
                    Runtime.getRuntime ().exec ("firefox " + url.toString ());
                } catch (Exception ex) {
                    return;
                }
            }
            try {
                Desktop desktop = Desktop.getDesktop ();
                if (! desktop.isSupported (java.awt.Desktop.Action.BROWSE)) {
                    return;
                }
                URI uri = new URI (url.toString ());
                desktop.browse (uri);
            } catch (Exception e) {
            }
        }
    }
}


public static void unzip1 (File zipfile, File outputdir) throws IOException {
    byte [] buffer = new byte [1024];
    if (! outputdir.exists ()) {
        outputdir.mkdirs ();
    }
    ArchiveInputStream zis = new ZipArchiveInputStream (new FileInputStream (zipfile));
    ArchiveEntry ae = zis.getNextEntry ();
    while (ae != null) {
        File newFile = new File (outputdir + File.separator + ae.getName ());
        if (! newFile.getParentFile ().exists ()) newFile.getParentFile ().mkdirs ();
        if (ae.isDirectory ()) {
            if (! newFile.exists ()) newFile.mkdir ();
        }
        else {
            FileOutputStream fos = new FileOutputStream (newFile);
            int len;
            while ((len = zis.read (buffer)) > 0) {
                fos.write (buffer, 0, len);
            }
            fos.close ();
        }
        ae = zis.getNextEntry ();
    }
    zis.close ();
}


-----Function Pair=316=-----==

public Object restructure (Map destructure, String algName, String keyType) {
    try {
        String [] [] _list = this.getRestructureCandidateNames ();
        for (int _p = 0; _p < _list.length; _p ++) {
            String _s = _list [_p] [0].toLowerCase ();
            if (- 1 != _s.indexOf (algName.toLowerCase ())) {
                if (- 1 != _s.indexOf (keyType.toLowerCase ())) {
                    String [] _sa = new String [_list [_p].length - 1];
                    System.arraycopy (_list [_p], 1, _sa, 0, _sa.length);
                    Object _o = null;
                    try {
                        String _classname = _list [_p] [0];
                        _o = this.restructure (destructure, Class.forName (_classname), _sa);
                    } catch (ClassNotFoundException e) {
                    }
                    if (null != _o) {
                        return _o;
                    }
                }
            }
        }
    } catch (Exception e) {
        log.warn (".restructure(): caught & ignoring " + e);
    }
    return null;
}


private ArrayObjectInfo intropectAtomicNativeArray (Object array, ODBType type) {
    int length = OdbReflection.getArrayLength (array);
    AtomicNativeObjectInfo anoi = null;
    AbstractObjectInfo [] arrayCopy = new AbstractObjectInfo [length];
    int typeId = 0;
    for (int i = 0; i < length; i ++) {
        Object o = OdbReflection.getArrayElement (array, i);
        if (o != null) {
            typeId = ODBType.getFromClass (o.getClass ()).getId ();
            anoi = new AtomicNativeObjectInfo (o, typeId);
            arrayCopy [i] = anoi;
        }
        else {
            arrayCopy [i] = new NullNativeObjectInfo (type.getId ());
        }
    }
    ArrayObjectInfo aoi = new ArrayObjectInfo (arrayCopy, ODBType.ARRAY, type.getId ());
    return aoi;
}


-----Function Pair=317=-----==

public static boolean equalsUnordered (Object o1, Object o2, EqualsChecker checker) {
    if (o1 == null) return o2 == null;
    if (o2 == null) return false;
    if (o1 instanceof Object [] && o2 instanceof Object []) return equalsUnordered ((Object []) o1, (Object []) o2, checker);
    if (o1.getClass ().isArray () && o2.getClass ().isArray ()) {
        if (! o1.getClass ().equals (o2.getClass ())) return false;
        int len = Array.getLength (o1);
        if (len != Array.getLength (o2)) return false;
        if (len == 0) return true;
        long [] bs = new long [(len - 1) / 64 + 1];
        long mask;
        int i, j, bsIdx;
        o1Loop : for (i = 0; i < len; i ++) {
            mask = 0;
            for (j = 0; j < len; j ++) {
                bsIdx = j / 64;
                if (mask == 0) mask = 0x8000000000000000L;
                if ((bs [bsIdx] & mask) == 0 && checker.equals (Array.get (o1, i), Array.get (o2, j))) {
                    bs [bsIdx] |= mask;
                    continue o1Loop;
                }
                mask>>>= 1;
            }
            return false;
        }
        return true;
    }
    return checker.equals (o1, o2);
}


static MethodAdapter guessMethod (Class interceptedClass, String methodName, boolean isStatic, Class [] paramSignature, Object [] params) {
    ArrayList < MethodAdapter > candidates = new ArrayList < MethodAdapter > ();
    for (Class clazz = interceptedClass; clazz != null; clazz = clazz.getSuperclass ()) {
        for (Method m : clazz.getDeclaredMethods ()) {
            if (m.getName ().equals (methodName) && Modifier.isStatic (m.getModifiers ()) == isStatic) {
                candidates.add (new MethodAdapter (m));
            }
        }
    }
    List < MethodAdapter > likelyMatches = guessInvocable (paramSignature, params, candidates);
    if (likelyMatches.size () > 1) {
        throw new MultipleMethodsFoundException ("Multiple methods named \"" + methodName + "\" found on class " + interceptedClass.getName () + " matching specified parameters/signature");
    }
    else if (likelyMatches.isEmpty ()) {
        throw new NoMethodFoundException ("No method \"" + methodName + "\" found on class " + interceptedClass.getName () + " matching specified parameters/signature");
    }
    return likelyMatches.get (0);
}


-----Function Pair=318=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (String.valueOf (array [i]));
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


-----Function Pair=319=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=320=-----==

public static Object concat (Object [] arrs) {
    int totalLen = 0;
    Class commonComponentType = null;
    for (int i = 0, len = arrs.length; i < len; i ++) {
        if (arrs [i] == null) {
            continue;
        }
        int arrayLen = Array.getLength (arrs [i]);
        if (arrayLen == 0) {
            continue;
        }
        totalLen += arrayLen;
        Class componentType = arrs [i].getClass ().getComponentType ();
        commonComponentType = (commonComponentType == null) ? componentType : commonClass (commonComponentType, componentType);
    }
    if (commonComponentType == null) {
        return null;
    }
    return concat (Array.newInstance (commonComponentType, totalLen), totalLen, arrs);
}


public Class getPropertyType (String propertyName) throws BeansException {
    try {
        PropertyDescriptor pd = getPropertyDescriptorInternal (propertyName);
        if (pd != null) {
            return pd.getPropertyType ();
        }
        else {
            Object value = getPropertyInfo (propertyName);
            if (value != null) {
                return value.getClass ();
            }
            if (this.customEditors != null) {
                CustomEditorHolder editorHolder = (CustomEditorHolder) this.customEditors.get (propertyName);
                if (editorHolder == null) {
                    List strippedPaths = new LinkedList ();
                    addStrippedPropertyPaths (strippedPaths, "", propertyName);
                    for (Iterator it = strippedPaths.iterator (); it.hasNext () && editorHolder == null;) {
                        String strippedName = (String) it.next ();
                        editorHolder = (CustomEditorHolder) this.customEditors.get (strippedName);
                    }
                }
                if (editorHolder != null) {
                    return editorHolder.getRegisteredType ();
                }
            }
        }
    } catch (InvalidPropertyException ex) {
    }
    return null;
}


-----Function Pair=321=-----==

public static int lastIndexOf (double [] array, double valueToFind, int startIndex) {
    if (Arrays.isEmpty (array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    }
    else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i --) {
        if (valueToFind == array [i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}


public static < T extends Comparable < T > > void BubbleSortComparable1 (T [] num) {
    int j;
    boolean flag = true;
    T temp;
    while (flag) {
        flag = false;
        for (j = 0; j < num.length - 1; j ++) {
            if (num [j].compareTo (num [j + 1]) > 0) {
                temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                flag = true;
            }
        }
    }
}


-----Function Pair=322=-----==

private byte [] encryptPrivateKey (byte [] data, char [] password) throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException {
    byte [] key = null;
    try {
        AlgorithmParameters algParams = getAlgorithmParameters ("PBEWithSHA1AndDESede");
        SecretKey skey = getPBEKey (password);
        Cipher cipher = Cipher.getInstance ("PBEWithSHA1AndDESede");
        cipher.init (Cipher.ENCRYPT_MODE, skey, algParams);
        byte [] encryptedKey = cipher.doFinal (data);
        AlgorithmId algid = new AlgorithmId (pbeWithSHAAnd3KeyTripleDESCBC_OID, algParams);
        EncryptedPrivateKeyInfo encrInfo = new EncryptedPrivateKeyInfo (algid, encryptedKey);
        key = encrInfo.getEncoded ();
    } catch (Exception e) {
        UnrecoverableKeyException uke = new UnrecoverableKeyException ("Encrypt Private Key failed: " + e.getMessage ());
        uke.initCause (e);
        throw uke;
    }
    return key;
}


private void makeCertRequest (String dn, KeyPair rsaKeys, String reqfile) throws NoSuchAlgorithmException, IOException, NoSuchProviderException, InvalidKeyException, SignatureException {
    PKCS10CertificationRequest req = new PKCS10CertificationRequest ("SHA1WithRSA", CertificateUtility.stringToBcX509Name (dn), rsaKeys.getPublic (), null, rsaKeys.getPrivate ());
    ByteArrayOutputStream bOut = new ByteArrayOutputStream ();
    DEROutputStream dOut = new DEROutputStream (bOut);
    dOut.writeObject (req);
    dOut.close ();
    ByteArrayInputStream bIn = new ByteArrayInputStream (bOut.toByteArray ());
    DERInputStream dIn = new DERInputStream (bIn);
    PKCS10CertificationRequest req2 = new PKCS10CertificationRequest ((DERSequence) dIn.readObject ());
    boolean verify = req2.verify ();
    System.out.println ("Verify returned " + verify);
    if (verify == false) {
        System.out.println ("Aborting!");
        return;
    }
    FileOutputStream os1 = new FileOutputStream (reqfile);
    os1.write ("-----BEGIN CERTIFICATE REQUEST-----\n".getBytes ());
    os1.write (new sun.misc.BASE64Encoder ().encode (bOut.toByteArray ()).getBytes ());
    os1.write ("\n-----END CERTIFICATE REQUEST-----\n".getBytes ());
    os1.close ();
    System.out.println ("CertificationRequest '" + reqfile + "' generated succefully.");
}


-----Function Pair=323=-----==

public void loadZippedProjectMembers (URL url) throws IOException, PropertyVetoException {
    loadModelFromXMI (url);
    try {
        PGMLParser.SINGLETON.setOwnerRegistry (_UUIDRefs);
        ZipInputStream zis = new ZipInputStream (url.openStream ());
        SubInputStream sub = new SubInputStream (zis);
        ZipEntry currentEntry = null;
        while ((currentEntry = sub.getNextEntry ()) != null) {
            if (currentEntry.getName ().endsWith (".pgml")) {
                Argo.log.info ("Now going to load " + currentEntry.getName () + " from ZipInputStream");
                ArgoDiagram d = (ArgoDiagram) PGMLParser.SINGLETON.readDiagram (sub, false);
                if (d == null) System.out.println ("ERROR: Cannot load diagram " + currentEntry.getName ());
                else addMember (d);
                Argo.log.info ("Finished loading " + currentEntry.getName ());
            }
        }
        zis.close ();
    } catch (IOException e) {
        ArgoParser.SINGLETON.setLastLoadStatus (false);
        ArgoParser.SINGLETON.setLastLoadMessage (e.toString ());
        System.out.println ("Oops, something went wrong in Project.loadZippedProjectMembers() " + e);
        e.printStackTrace ();
        throw e;
    }
}


public static String mv (File f, File dest) {
    final File canonF;
    File canonDest;
    try {
        canonF = f.getCanonicalFile ();
        canonDest = dest.getCanonicalFile ();
    } catch (IOException e) {
        return ExceptionUtils.getStackTrace (e);
    }
    if (canonF.equals (canonDest)) return null;
    if (canonDest.isDirectory ()) canonDest = new File (canonDest, canonF.getName ());
    final File destF;
    if (canonDest.exists ()) return canonDest + " exists";
    else if (! canonDest.getParentFile ().exists ()) return "parent of " + canonDest + " does not exist";
    else destF = canonDest;
    if (! canonF.renameTo (destF)) {
        try {
            copyDirectory (canonF, destF);
            if (destF.exists ()) rmR (canonF);
        } catch (IOException e) {
            return ExceptionUtils.getStackTrace (e);
        }
    }
    return null;
}


-----Function Pair=324=-----==

private void doGetpineapple () {
    final RSTile walkHere = new RSTile (2774, 2748);
    final RSTile walkHereB4 = new RSTile (2768, 2747);
    if (calc.distanceTo (walkHere) > 3 && calc.tileOnMap (walkHere)) {
        status = "Walking to plant...";
        walkTile (walkHere);
        sleep (random (500, 750));
    }
    else if (! calc.tileOnMap (walkHere)) {
        status = "Walking to pineapples...";
        walkTile (walkHereB4);
        sleep (random (500, 750));
    }
    else {
        status = "Collecting pineapple...";
        final RSObject plant = objects.getNearest (4827);
        if (plant != null) {
            plant.doAction ("Pick");
            sleep (random (800, 1200));
        }
        else {
            status = "Waiting for pineapple...";
        }
    }
    while (players.getMyPlayer ().isMoving ()) sleep (100);
}


public int readFreigabe () {
    DatabaseConnection database = Datenspeicher.getDatabase ();
    if (! database.isConnected ()) database.connect ();
    Statement stmnt = database.getStatement ();
    if (stmnt == null) return 0;
    String query = "SELECT freigabe_id FROM freigabe WHERE job_id = '" + id + "'";
    try {
        ResultSet result = stmnt.executeQuery (query);
        if (! result.next ()) return 0;
        return result.getInt ("freigabe_id");
    } catch (SQLException e) {
        System.err.println ("Fehler beim laden der Freigabdaten f�r : " + id);
        e.printStackTrace ();
        return 0;
    }
}


-----Function Pair=325=-----==

public static File openURL (String uri) {
    URL fileURL = uriToURL (uri);
    File f = urlToFile (fileURL);
    if (f != null) {
        return f;
    }
    else {
        String text = readContent (fileURL);
        String [] path = fileURL.getFile ().split ("/");
        String name = path [path.length - 1];
        File temp;
        try {
            temp = File.createTempFile (FileUtils.stripExtension (name), FileUtils.ensureExtension (FileUtils.getExtension (name)));
            BufferedWriter out = new BufferedWriter (new FileWriter (temp));
            out.write (text);
            out.close ();
            return temp;
        } catch (IOException e) {
            IdeLog.logError (AptanaCorePlugin.getDefault (), StringUtils.format ("Unable to open URL {0} as file", uri), e);
            return null;
        }
    }
}


public static File [] listFiles (File baseDir, boolean recursive, FileFilter filter) {
    File [] files = baseDir.listFiles (filter);
    if (files != null && recursive) {
        NSMutableArray < File > a = new NSMutableArray < File > ();
        for (int i = files.length; i -- > 0;) {
            File currentFile = files [i];
            a.addObject (currentFile);
            if (currentFile.isDirectory ()) {
                File [] currentFiles = listFiles (currentFile, true, filter);
                a.addObjects (currentFiles);
            }
        }
        Object [] objects = a.objects ();
        files = new File [objects.length];
        System.arraycopy (objects, 0, files, 0, objects.length);
    }
    return files;
}


-----Function Pair=326=-----==

char [] getPass (String prompt) {
    System.err.print (prompt);
    System.err.flush ();
    try {
        char [] pass = Password.readPassword (System.in);
        if (pass == null) {
            error (rb.getString ("you must enter key password"));
        }
        else {
            return pass;
        }
    } catch (IOException ioe) {
        error (rb.getString ("unable to read password: ") + ioe.getMessage ());
    }
    return null;
}


public static void main (String [] args) {
    Document document = new Document ();
    try {
        PdfWriter.getInstance (document, new FileOutputStream ("HelloWorld.pdf"));
        document.open ();
        document.add (new Paragraph ("A Hello World PDF document."));
        document.close ();
    } catch (DocumentException e) {
        e.printStackTrace ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=327=-----==

static void initializeSettings (final String [] args) throws Throwable {
    System.out.println ("Initializing Settings");
    final int parameterCount = Math.min (args.length, 10);
    switch (parameterCount) {
        case 9 :
            WINDOW_Y = max (Integer.valueOf (args [8]), 0);
        case 8 :
            WINDOW_X = max (Integer.valueOf (args [7]), 0);
        case 7 :
            UPDATE_MS = max (Integer.valueOf (args [6]), 10);
        case 6 :
            PORT = Integer.valueOf (args [5]);
        case 5 :
            HOST = args [4];
        case 4 :
            SCAN_H = max (Integer.valueOf (args [3]), 1);
        case 3 :
            SCAN_W = max (Integer.valueOf (args [2]), 1);
        case 2 :
            SCAN_Y = max (Integer.valueOf (args [1]), 0);
        case 1 :
            SCAN_X = max (Integer.valueOf (args [0]), 0);
    }
    screen = new Robot ();
    scanArea = new Rectangle (SCAN_X, SCAN_Y, SCAN_W, SCAN_H);
    System.out.println ("* Settings initialization complete.");
}


public void actionPerformed (ActionEvent e) {
    Robot r;
    try {
        Rectangle bounds = new Rectangle (GrabberWindow.getWindow ().getLocationOnScreen ().x, GrabberWindow.getWindow ().getLocationOnScreen ().y, GrabberWindow.getWindow ().getWidth (), GrabberWindow.getWindow ().getHeight ());
        GrabberWindow.getWindow ().setVisible (false);
        r = new Robot ();
        BufferedImage tmpImg = r.createScreenCapture (new Rectangle (bounds.x, bounds.y, bounds.width, bounds.height));
        String dir = OptionsEngine.getOptions ().get (Options.Directory.getID ()).toString ();
        if (dir.equals ("")) {
            JFileChooser fc = new JFileChooser (lastDir);
            FileNameExtensionFilter filter = new FileNameExtensionFilter ("PNG Images", "png");
            fc.setFileFilter (filter);
            int returnVal = fc.showSaveDialog (GrabberWindow.getWindow ().getContentPane ());
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                String path = fc.getSelectedFile ().getAbsolutePath ();
                if (! path.toLowerCase ().endsWith (".png")) path += ".png";
                lastDir = path;
                ImageIO.write (tmpImg, "png", new File (path));
            }
        }
        else {
            String name = "img";
            int i = 1;
            while (new File (dir + "\\" + name + i + ".png").exists ()) i ++;
            ImageIO.write (tmpImg, "png", new File (dir + "\\" + name + i + ".png"));
        }
    } catch (AWTException e1) {
        e1.printStackTrace ();
    } catch (IOException e2) {
        e2.printStackTrace ();
    } finally {
        GrabberWindow.getWindow ().setVisible (true);
    }
}


-----Function Pair=328=-----==

public static void bubbleSort (int [] a) {
    if (a == null) {
        throw new IllegalArgumentException ("Null-pointed array");
    }
    int right = a.length - 1;
    int k = 0;
    while (right > 0) {
        k = 0;
        for (int i = 0; i <= right - 1; i ++) {
            if (a [i] > a [i + 1]) {
                k = i;
                int temp = a [i];
                a [i] = a [i + 1];
                a [i + 1] = temp;
            }
        }
        right = k;
    }
}


public static void shuffle2 (int [] a) {
    Random random = new Random ();
    random.nextInt ();
    for (int i = a.length - 1; i >= 1; i --) {
        int j = random.nextInt (i + 1);
        int tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


-----Function Pair=329=-----==

ArrayList < Move > generateScoredMoves (Board boardState) {
    clearMoveArrays ();
    ScoreFactory fac = new ScoreFactory ();
    HashMap < Piece, Square > movablePieces;
    if (boardState.getTurn () == Color.WHITE) {
        movablePieces = boardState.getWhitePieces ();
    }
    else {
        movablePieces = boardState.getBlackPieces ();
    }
    Set < Piece > movablePieceSet = movablePieces.keySet ();
    for (Piece p : movablePieceSet) {
        Square position = movablePieces.get (p);
        generateMovesForPieceHelper (p, position, boardState.getBoard ());
    }
    int currScore = boardState.getScore ();
    for (Move m : this.nonCapturingMoves) {
        m.setScore (currScore);
    }
    for (Move m : this.kingCapturingMoves) {
        m.setScore (ScoreFactory.YOU_WIN);
    }
    for (Move m : this.capturingMoves) {
        try {
            boardState.move (m);
            int score = boardState.getScore ();
            if (boardState.getTurn () == Color.BLACK) m.setScore (- score);
            else m.setScore (score);
            boardState.undo ();
        } catch (IllegalMoveException e) {
            e.printStackTrace ();
            System.exit (0);
        }
    }
    sortCapturingMoves ();
    return consolidateMoveArrays ();
}


public static Object callMethod3 (Object object, String methodName, Object params [], Class [] types) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    Method method = null;
    Class < ? > myClass = object.getClass ();
    NoSuchMethodException ex = null;
    while (method == null && myClass != null) {
        try {
            method = myClass.getDeclaredMethod (methodName, types);
        } catch (NoSuchMethodException e) {
            ex = e;
            myClass = myClass.getSuperclass ();
        }
    }
    if (method == null) throw ex;
    Object returnVal = method.invoke (object, params);
    return returnVal;
}


-----Function Pair=330=-----==

public static List < P2P > degenerateInfoString (String msg) {
    msg = msg.trim ();
    ArrayList < P2P > list = new ArrayList < P2P > ();
    StringTokenizer tokens = new StringTokenizer (msg, "#");
    while (tokens.hasMoreTokens ()) {
        String token = tokens.nextToken ();
        String numbers [] = token.split ("-");
        P2P p2p = new P2P ();
        Point p1 = new Point (Integer.parseInt (numbers [0]), Integer.parseInt (numbers [1]));
        Point p2 = new Point (Integer.parseInt (numbers [2]), Integer.parseInt (numbers [3]));
        p2p.p1 = p1;
        p2p.p2 = p2;
        list.add (p2p);
    }
    return list;
}


public static String downloadWebpage2 (String address) throws MalformedURLException, IOException {
    URL url = new URL (address);
    HttpURLConnection conn = (HttpURLConnection) url.openConnection ();
    HttpURLConnection.setFollowRedirects (true);
    String encoding = conn.getContentEncoding ();
    InputStream is = null;
    if (encoding != null && encoding.equalsIgnoreCase ("gzip")) {
        is = new GZIPInputStream (conn.getInputStream ());
    }
    else if (encoding != null && encoding.equalsIgnoreCase ("deflate")) {
        is = new InflaterInputStream (conn.getInputStream ());
    }
    else {
        is = conn.getInputStream ();
    }
    BufferedReader br = new BufferedReader (new InputStreamReader (is));
    String line;
    String page = "";
    while ((line = br.readLine ()) != null) {
        page += line + "\n";
    }
    br.close ();
    return page;
}


-----Function Pair=331=-----==

public int findSmiliesCountBytypeId (short typeid) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("select count(*) from Smilies as s where s.typeid=?");
        query.setParameter (0, typeid);
        List list = query.list ();
        tr.commit ();
        if (list != null && list.size () > 0) {
            return (Integer) list.get (0);
        }
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return 0;
}


public static List < AttachmentRef > getAttachmentId (long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from AttachmentRef R where R.key=?";
        Query q = s.createQuery (query);
        q.setLong (0, txId);
        List < AttachmentRef > ret = q.list ();
        s.getTransaction ().commit ();
        return ret;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=332=-----==

public static void fixModuleSequence (String usrlogin, String tab) throws DbException {
    Db db = null;
    Connection conn = null;
    String sql = "";
    try {
        db = new Db ();
        conn = db.getConnection ();
        conn.setAutoCommit (false);
        Statement stmt = db.getStatement ();
        boolean fix = true;
        if (fix) {
            Vector v = new Vector ();
            sql = "SELECT module_id FROM user_module_template WHERE tab_id = '" + tab + "' AND user_login = '" + usrlogin + "'";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                String module_id = rs.getString ("module_id");
                v.addElement (module_id);
            }
            for (int i = 0; i < v.size (); i ++) {
                String module_id = (String) v.elementAt (i);
                sql = "UPDATE user_module_template SET sequence = " + Integer.toString (i + 1) + " WHERE module_id = '" + module_id + "' AND tab_id = '" + tab + "' AND user_login = '" + usrlogin + "'";
                stmt.executeUpdate (sql);
            }
        }
        conn.commit ();
    } catch (SQLException ex) {
        try {
            conn.rollback ();
        } catch (SQLException exr) {
        }
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


public ResponseXML getLocationInfo (int userId, int groupId, double lattitude, double longitude) {
    Connection conn = null;
    CallableStatement csmt = null;
    ResultSet rst = null;
    ResponseXML resXML = new ResponseXML ();
    Data data = new Data ();
    List < LocationInfo > list = new ArrayList < LocationInfo > ();
    try {
        String sql = "call location_get(?, ?, ?, ?);";
        conn = getConnection ();
        csmt = conn.prepareCall (sql);
        csmt.setInt (1, userId);
        csmt.setInt (2, groupId);
        csmt.setDouble (3, lattitude);
        csmt.setDouble (4, longitude);
        rst = csmt.executeQuery ();
        while (rst.next ()) {
            resXML.setCode (rst.getString ("code"));
            if (rst.getString ("code").equals (Constant.CODE_LOCATION_LIST_SUCCESS)) {
                LocationInfo locationInfo = new LocationInfo ();
                locationInfo.setCreateDateAndTime (rst.getTimestamp ("createdateandtime").getTime ());
                locationInfo.setUserName (rst.getString ("user_name"));
                locationInfo.setLattitude (rst.getDouble ("latitude"));
                locationInfo.setLongitude (rst.getDouble ("longitude"));
                list.add (locationInfo);
            }
        }
        data.setLocationInfo (list.toArray (new LocationInfo [0]));
        resXML.setData (data);
    } catch (SQLException ex) {
        log.error ("[getLocationInfo]", ex);
    } finally {
        endProsess (conn, null, csmt, rst);
    }
    return resXML;
}


-----Function Pair=333=-----==

public boolean actualizarDatosFinal (int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {
    int intResult = 0;
    String sql = "UPDATE jugadorxdivxronda " + " SET resultado = ?, puntajeRonda = ? " + " WHERE jugadorxDivision_idJugadorxDivision = " + idJugadorDiv + " AND ronda_numeroRonda = " + idRonda;
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        populatePreparedStatementActFinal (unjxdxr);
        intResult = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (intResult > 0);
}


public RestServiceResult listUserForExerciseGroup (RestServiceResult serviceResult, Long nExerciseGroupId) {
    List < CoUserExer2Group > listUserGroup = null;
    List < MaUser > listUser = new ArrayList < MaUser > ();
    try {
        Query query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_USER_EXER2_GROUP, CoUserExer2Group.class);
        query.setParameter (1, nExerciseGroupId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        listUserGroup = query.getResultList ();
        serviceResult.setObjResult (listUserGroup);
        if (listUserGroup.size () == 0) {
            serviceResult.setMessage (bundle.getString ("user.list.notFound"));
        }
        else {
            for (Iterator < CoUserExer2Group > iterator = listUserGroup.iterator (); iterator.hasNext ();) {
                CoUserExer2Group CoUserExer2Group = (CoUserExer2Group) iterator.next ();
                listUser.add (CoUserExer2Group.getMaUser ());
            }
            Object [] arrayParam = {listUser.size ()};
            serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.list.success"), arrayParam));
        }
        serviceResult.setObjResult (listUser);
    } catch (Exception e) {
        serviceResult.setError (true);
        log.info ("Error buscando el estado para usuarios por grupo ");
    }
    return serviceResult;
}


-----Function Pair=334=-----==

synchronized boolean setIgnoreChanList (int favId, String chanList) {
    String qry = "REPLACE INTO ignore_chan_favs (id, chanlist) VALUES (?, ?)";
    PreparedStatement s = null;
    try {
        s = conn.prepareStatement (qry);
        s.setInt (1, favId);
        s.setString (2, chanList);
        s.executeUpdate ();
    } catch (SQLException e) {
        e.printStackTrace (System.out);
        return false;
    } finally {
        if (s != null) try {
            s.close ();
        } catch (SQLException e) {
            e.printStackTrace (System.out);
        }
    }
    return true;
}


synchronized Map < Integer, String > getIgnoreLists () {
    String qry = "SELECT id, chanlist FROM ignore_chan_favs";
    Statement s = null;
    ResultSet r = null;
    Map < Integer, String > map = new HashMap < Integer, String > ();
    try {
        s = conn.createStatement ();
        r = s.executeQuery (qry);
        while (r.next ()) map.put (r.getInt (1), r.getString (2));
    } catch (SQLException e) {
        e.printStackTrace (System.out);
    } finally {
        try {
            if (r != null) r.close ();
            if (s != null) s.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return map;
}


-----Function Pair=335=-----==

protected boolean store (Context context) throws DataStoreException, ServletException {
    Connection db = context.getConnection ();
    Statement st = null;
    String q = null;
    Integer subscriber = context.getValueAsInteger ("subscriber");
    int amount = 0;
    if (subscriber == null) {
        throw new DataAuthException ("Don't know who moderator is");
    }
    Object response = context.get ("Response");
    if (response == null) {
        throw new DataStoreException ("Don't know what to moderate");
    }
    else {
        Context scratch = (Context) context.clone ();
        TableDescriptor.getDescriptor ("response", "response", scratch).fetch (scratch);
        Integer author = scratch.getValueAsInteger ("author");
        if (subscriber.equals (author)) {
            throw new SelfModerationException ("You may not moderate your own responses");
        }
    }
    context.put ("moderator", subscriber);
    context.put ("moderated", response);
    if (db != null) {
        try {
            st = db.createStatement ();
            q = "select mods from subscriber where subscriber = " + subscriber.toString ();
            ResultSet r = st.executeQuery (q);
            if (r.next ()) {
                if (r.getInt ("mods") < 1) {
                    throw new DataAuthException ("You have no moderation points left");
                }
            }
            else {
                throw new DataAuthException ("Don't know who moderator is");
            }
            Object reason = context.get ("reason");
            q = "select score from modreason where modreason = " + reason;
            r = st.executeQuery (q);
            if (r.next ()) {
                amount = r.getInt ("score");
                context.put ("amount", new Integer (amount));
            }
            else {
                throw new DataStoreException ("Don't recognise reason (" + reason + ") to moderate");
            }
            context.put (keyField, null);
            if (super.store (context, db)) {
                db.setAutoCommit (false);
                q = "update RESPONSE set Moderation = " + "( select sum( Amount) from MODERATION " + "where Moderated = " + response + ") " + "where Response = " + response;
                st.executeUpdate (q);
                q = "update subscriber set mods = mods - 1 " + "where subscriber = " + subscriber;
                st.executeUpdate (q);
                q = "select author from response " + "where response = " + response;
                r = st.executeQuery (q);
                if (r.next ()) {
                    int author = r.getInt ("author");
                    if (author != 0) {
                        int points = - 1;
                        if (amount > 0) {
                            points = 1;
                        }
                        StringBuffer qb = new StringBuffer ("update subscriber ");
                        qb.append ("set score = score + ").append (amount);
                        qb.append (", mods = mods + ").append (points);
                        qb.append (" where subscriber = ").append (author);
                        st.executeUpdate (qb.toString ());
                    }
                }
                db.commit ();
            }
        } catch (Exception e) {
            try {
                db.rollback ();
            } catch (Exception whoops) {
                throw new DataStoreException ("Shouldn't happen: " + "failed to back out " + "failed insert: " + whoops.getMessage ());
            }
            throw new DataStoreException ("Failed to store moderation: " + e.getMessage ());
        } finally {
            if (st != null) {
                try {
                    st.close ();
                } catch (Exception noclose) {
                }
                context.releaseConnection (db);
            }
        }
    }
    return true;
}


public String processAssociation (Element root, DTSPermission permit) throws SQLException, XMLException, PermissionException {
    String operation = root.getAttribute (OPERATION);
    NodeList children = root.getChildNodes ();
    int len = children.getLength ();
    Node node = children.item (0);
    Entry entry = getEntry (node, permit);
    if (! entry.hasResult ()) {
        return getFalseResult ();
    }
    if (entry.mode.equals (SYNONYM) && operation.equals ("ADD")) {
        return addSynonym (entry);
    }
    if (! entry.mode.equals (SYNONYM) && operation.equals ("ADD")) {
        return addConceptTermAssociation (entry, children);
    }
    if (! entry.mode.equals (SYNONYM) && operation.equals ("DELETE")) {
        return deleteConceptTermAssociation (entry);
    }
    String statement = getDAO ().getStatement (TABLE_KEY, operation + "_" + entry.mode + "_ASSOCIATION");
    statement = getDAO ().getStatement (statement, 1, String.valueOf (entry.fromGID));
    statement = getDAO ().getStatement (statement, 2, String.valueOf (entry.associationGID));
    statement = getDAO ().getStatement (statement, 3, String.valueOf (entry.toGID));
    statement = getDAO ().getStatement (statement, 4, "'" + String.valueOf (entry.preferredFlag) + "'");
    WFPlugin wf = entry.getWF (this);
    char attrType = (entry.mode.equals (SYNONYM)) ? WFPlugin.ATTR_SYNONYM : WFPlugin.ATTR_ASSOCIATION;
    char editType = WFPlugin.EDIT_ADD;
    if (operation.equals ("UPDATE")) {
        editType = WFPlugin.EDIT_UPDATE;
    }
    else if (operation.equals ("DELETE")) {
        editType = WFPlugin.EDIT_DELETE;
    }
    conn.setAutoCommit (false);
    int defaultLevel = conn.getTransactionIsolation ();
    conn.setTransactionIsolation (Connection.TRANSACTION_READ_COMMITTED);
    int result = - 1;
    try {
        result = keepAliveStmt.executeUpdate (statement);
        if (result != 1) {
            conn.rollback ();
            return getFalseResult ();
        }
        wf.update (entry.fromId, entry.fromNamespaceId, permit, attrType, editType);
        conn.commit ();
        return getTrueResult ();
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } finally {
        conn.setTransactionIsolation (defaultLevel);
        conn.setAutoCommit (true);
    }
}


-----Function Pair=336=-----==

public int delete (BusinessObject o) throws DAOException {
    int delete = 0;
    Account acc = (Account) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("DELETE_ACCOUNT"));
        pst.setInt (1, acc.getId ());
        delete = pst.executeUpdate ();
        if (delete <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (delete > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return delete;
}


public void add (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            String sql = "insert into ClassLinkTypes (LinkName, LinkType) " + "values ('" + name + "', " + USER_LINK + ")";
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            stmt.executeUpdate (sql);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=337=-----==

public int create (BusinessObject o) throws DAOException {
    int insert = 0;
    int id = 0;
    Bill bill = (Bill) o;
    try {
        PreparedStatement pst = connection.prepareStatement (XMLGetQuery.getQuery ("INSERT_BILL"));
        pst.setDate (1, new java.sql.Date (bill.getDate ().getTime ()));
        pst.setInt (2, bill.getIdAccount ());
        insert = pst.executeUpdate ();
        if (insert <= 0) {
            connection.rollback ();
            throw new DAOException ("Number of rows <= 0");
        }
        else if (insert > 1) {
            connection.rollback ();
            throw new DAOException ("Number of rows > 1");
        }
        Statement st = connection.createStatement ();
        ResultSet rs = st.executeQuery ("select max(id) from bill");
        rs.next ();
        id = rs.getInt (1);
        connection.commit ();
    } catch (SQLException e) {
        Log.write (e.getMessage ());
        throw new DAOException ("A SQLException has occured");
    } catch (NullPointerException npe) {
        Log.write (npe.getMessage ());
        throw new DAOException ("Connection null");
    }
    return id;
}


private final void loadProtocols (String descrId, DFAgentDescription dfd, Map allProtocols) throws SQLException {
    if (allProtocols != null) {
        List protos = (List) allProtocols.get (descrId);
        if (protos != null) {
            Iterator it = protos.iterator ();
            while (it.hasNext ()) {
                dfd.addProtocols ((String) it.next ());
            }
        }
    }
    else {
        PreparedStatements pss = getPreparedStatements ();
        pss.stm_selProtocols.setString (1, descrId);
        ResultSet rs = pss.stm_selProtocols.executeQuery ();
        while (rs.next ()) {
            dfd.addProtocols (rs.getString (PROTOCOL));
        }
        closeResultSet (rs);
    }
}


-----Function Pair=338=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public RestServiceResult update (RestServiceResult serviceResult, CoExercises2 coExercises2, String sDeliveryDate) {
    CoExercises2DAO coExercises2DAO = new CoExercises2DAO ();
    Long nExerciseId = coExercises2.getExerciseId ();
    try {
        EntityManagerHelper.beginTransaction ();
        coExercises2DAO.update (coExercises2);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coExercises2);
        Object [] args = {coExercises2.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises2.update.success"), args));
        this.addDeliveryDate (nExerciseId, sDeliveryDate);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio s2: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises2.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=339=-----==

public BusinessObject getObject (Object primaryKey, Connection connection) throws SQLException {
    SQLDialect dialect = getDatabase ().getSQLDialect ();
    PreparedStatement statement = connection.prepareStatement (sqlConstants.get ("SELECT_OBJECT_SQL"));
    try {
        ResultSet resultSet;
        int i;
        statement.setObject (1, primaryKey);
        resultSet = statement.executeQuery ();
        if (! resultSet.next ()) {
            return null;
        }
        int contentID;
        String name;
        String description;
        int ownerID;
        Integer categoryID;
        Date validDate;
        Date invalidDate;
        boolean validForever;
        VersionRef version;
        Date lastModified;
        Integer modifiedBy;
        Integer workflowID;
        i = 0;
        contentID = resultSet.getInt (++ i);
        name = resultSet.getString (++ i);
        description = resultSet.getString (++ i);
        ownerID = resultSet.getInt (++ i);
        categoryID = new Integer (resultSet.getInt (++ i));
        validDate = dialect.getDate (resultSet, ++ i);
        invalidDate = dialect.getDate (resultSet, ++ i);
        validForever = resultSet.getInt (++ i) != 0;
        version = VersionRef.parse (resultSet.getString (++ i));
        lastModified = dialect.getDate (resultSet, ++ i);
        modifiedBy = (Integer) resultSet.getObject (++ i);
        workflowID = (Integer) resultSet.getObject (++ i);
        statement.close ();
        LiveContent liveContent = new LiveContent (contentID, name, description, lastModified, ownerID, categoryID, validDate, invalidDate, validForever, version, modifiedBy, workflowID);
        try {
            liveContent.setFieldMap (loadFieldMap (primaryKey, connection));
        } catch (IOException e) {
            throw new SQLException ("Error reading from text field: " + e);
        }
        return liveContent;
    } finally {
        statement.close ();
    }
}


public List searchObject2 (SearchObject so) throws SQLException {
    List result = new ArrayList ();
    Connection conn = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;
    try {
        if (dbConnection == null) {
            DatabaseConn dbConn = new DatabaseConn ();
            conn = dbConn.getConnection ();
        }
        else {
            conn = dbConnection;
        }
        String sql = this.searchSql;
        List condList = so.getConditionList ();
        if (condList != null && condList.size () > 0) sql = sql + " and (";
        for (int j = 0; condList != null && j < condList.size (); j ++) {
            List itemList = ((Condition) condList.get (j)).getConditionItemList ();
            if (condList.size () != 1) sql = sql + " (";
            sql = sql + " 1=1 ";
            System.out.println (itemList.size () + "itemList");
            for (int k = 0; k < itemList.size (); k ++) {
                ConditionItem item = (ConditionItem) itemList.get (k);
                String name = item.getName ();
                String opt = item.getOpt ();
                String val = item.getVal ();
                if (opt.compareToIgnoreCase ("LIKE") == 0) val = "%" + val + "%";
                MappingItem mappingItem = this.getMappingItem (name);
                if (mappingItem != null) {
                    if (opt.compareToIgnoreCase ("LIKE") == 0 && mappingItem.getType () == MappingItem.STRING) {
                        sql = sql + " and lower(" + mappingItem.getFieldName () + ") " + opt + " '" + val.toLowerCase () + "' ";
                    }
                    else {
                        if (mappingItem.getType () == MappingItem.INT) {
                            sql = sql + " and " + mappingItem.getFieldName () + " " + opt + " " + val + " ";
                        }
                        else if (mappingItem.getType () == MappingItem.DATE) {
                            sql = sql + " and char(" + mappingItem.getFieldName () + ") " + opt + " '" + val + "' ";
                        }
                        else {
                            sql = sql + " and " + mappingItem.getFieldName () + " " + opt + " '" + val + "' ";
                        }
                    }
                }
            }
            if (condList.size () != 1 && j == condList.size () - 1) sql = sql + ") ";
            else if (condList.size () != 1 && j < condList.size () - 1) sql = sql + ") or ";
        }
        if (condList != null && condList.size () > 0) sql = sql + " ) ";
        List orderByList = so.getOrderByList ();
        Map orderFormMap = so.getOrderFormMap ();
        if (orderByList != null && orderByList.size () > 0) {
            System.out.println ("====================1=====================");
            sql = sql + " ORDER BY ";
            Iterator it = orderByList.iterator ();
            String name = null;
            while (it.hasNext ()) {
                String o = (String) it.next ();
                name = o;
                System.out.println ("====================2=====================");
                MappingItem mappingItem = this.getMappingItem (name);
                if (! it.hasNext ()) {
                    sql = sql + mappingItem.getFieldName () + orderFormMap.get (name);
                }
                else {
                    sql = sql + mappingItem.getFieldName () + orderFormMap.get (name) + ", ";
                }
            }
        }
        System.out.println ("Search sql:" + sql);
        stmt = conn.prepareStatement (sql);
        System.out.println (sql);
        rs = stmt.executeQuery ();
        while (rs.next ()) {
            Object obj = search (rs);
            result.add (obj);
        }
    } catch (Exception e) {
        e.printStackTrace ();
        throw new SQLException (e.getMessage ());
    } finally {
        if (rs != null) {
            rs.close ();
            rs = null;
        }
        if (stmt != null) {
            stmt.close ();
            stmt = null;
        }
        if (dbConnection == null && conn != null) {
            conn.close ();
            conn = null;
        }
    }
    return result;
}


-----Function Pair=340=-----==

private void update (Connection c) throws SQLException {
    if (! m_fromDb) throw new IllegalStateException ("The record does not exists in the database");
    StringBuffer sqlText = new StringBuffer ("UPDATE ifServices SET ");
    char comma = ' ';
    if ((m_changed & CHANGED_IFINDEX) == CHANGED_IFINDEX) {
        sqlText.append (comma).append ("ifIndex = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_STATUS) == CHANGED_STATUS) {
        sqlText.append (comma).append ("status = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_LASTGOOD) == CHANGED_LASTGOOD) {
        sqlText.append (comma).append ("lastGood = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_LASTFAIL) == CHANGED_LASTFAIL) {
        sqlText.append (comma).append ("lastFail = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_SOURCE) == CHANGED_SOURCE) {
        sqlText.append (comma).append ("source = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_NOTIFY) == CHANGED_NOTIFY) {
        sqlText.append (comma).append ("notify = ?");
        comma = ',';
    }
    if ((m_changed & CHANGED_QUALIFIER) == CHANGED_QUALIFIER) {
        sqlText.append (comma).append ("qualifier = ?");
        comma = ',';
    }
    sqlText.append (" WHERE nodeID = ? AND ipAddr = ? AND serviceID = ? and status <> 'D'");
    log ().debug ("DbIfServiceEntry.update: SQL update statment = " + sqlText.toString ());
    PreparedStatement stmt = null;
    final DBUtils d = new DBUtils (getClass ());
    try {
        stmt = c.prepareStatement (sqlText.toString ());
        d.watch (stmt);
        sqlText = null;
        int ndx = 1;
        if ((m_changed & CHANGED_IFINDEX) == CHANGED_IFINDEX) {
            if (m_ifIndex == - 1) stmt.setNull (ndx ++, Types.INTEGER);
            else stmt.setInt (ndx ++, m_ifIndex);
        }
        if ((m_changed & CHANGED_STATUS) == CHANGED_STATUS) {
            if (m_status != STATUS_UNKNOWN) stmt.setString (ndx ++, new String (new char [] {m_status}));
            else stmt.setNull (ndx ++, Types.CHAR);
        }
        if ((m_changed & CHANGED_LASTGOOD) == CHANGED_LASTGOOD) {
            if (m_lastGood != null) {
                stmt.setTimestamp (ndx ++, m_lastGood);
            }
            else stmt.setNull (ndx ++, Types.TIMESTAMP);
        }
        if ((m_changed & CHANGED_LASTFAIL) == CHANGED_LASTFAIL) {
            if (m_lastFail != null) {
                stmt.setTimestamp (ndx ++, m_lastFail);
            }
            else stmt.setNull (ndx ++, Types.TIMESTAMP);
        }
        if ((m_changed & CHANGED_SOURCE) == CHANGED_SOURCE) {
            if (m_source == SOURCE_UNKNOWN) stmt.setNull (ndx ++, Types.CHAR);
            else stmt.setString (ndx ++, new String (new char [] {m_source}));
        }
        if ((m_changed & CHANGED_NOTIFY) == CHANGED_NOTIFY) {
            if (m_notify == NOTIFY_UNKNOWN) stmt.setNull (ndx ++, Types.CHAR);
            else stmt.setString (ndx ++, new String (new char [] {m_notify}));
        }
        stmt.setInt (ndx ++, m_nodeId);
        stmt.setString (ndx ++, m_ipAddr.getHostAddress ());
        stmt.setInt (ndx ++, m_serviceId);
        int rc = stmt.executeUpdate ();
        log ().debug ("DbIfServiceEntry.update: update result = " + rc);
    } finally {
        d.cleanUp ();
    }
    m_changed = 0;
}


public String queryAclByUUID (String uuid) throws SQLException {
    String sAcl = "";
    PreparedStatement st = null;
    String sUuid = Val.chkStr (uuid);
    try {
        String sAdminTable = getResourceTableName ();
        String sSql = "SELECT ACL FROM " + sAdminTable + " WHERE DOCUUID=?";
        logExpression (sSql);
        Connection con = returnConnection ().getJdbcConnection ();
        st = con.prepareStatement (sSql);
        st.setString (1, sUuid);
        ResultSet rs = st.executeQuery ();
        if (rs.next ()) {
            sAcl = Val.chkStr (rs.getString (1));
        }
    } finally {
        closeStatement (st);
    }
    return sAcl;
}


-----Function Pair=341=-----==

public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=342=-----==

public boolean doShowAdmin () throws SecurityException, RemoteException, TimmonBackEndException {
    if (! logged_in_ && ! showLoginDialog ()) return (false);
    String old_username = null;
    String old_password = null;
    int retry_count = 0;
    while (! doCheckRight (TimmonConstants.RIGHTS_ADMIN)) {
        old_username = getUsername ();
        old_password = getPassword ();
        try {
            logout ();
        } catch (Exception e) {
            if (Debug.DEBUG) Debug.println ("exc", Debug.getStackTrace (e));
        }
        JOptionPane.showMessageDialog (null, resources_.getString ("admin.not_admin_user.text", "The user you logged on is not an admin user"), resources_.getString ("admin.not_admin_user.title", "No Admin User"), JOptionPane.ERROR_MESSAGE);
        if (showLoginDialog ()) break;
        if (retry_count >= 3) break;
        retry_count ++;
    }
    if (retry_count < 3) {
        JPanel panel = new JPanel ();
        panel.setLayout (new BoxLayout (panel, BoxLayout.Y_AXIS));
        JButton user_admin = new JButton (resources_.getString ("admin.users.title", "Admin Users..."));
        user_admin.setAlignmentX (JButton.CENTER_ALIGNMENT);
        user_admin.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                try {
                    JDialog dlg = new SQLUserAdmin (null, SQLBackEnd.this);
                    dlg.setVisible (true);
                } catch (Exception exc) {
                    if (Debug.DEBUG) Debug.println ("exc", Debug.getStackTrace (exc));
                    JOptionPane.showMessageDialog (null, exc.getMessage ());
                }
            }
        }
        );
        panel.add (user_admin);
        panel.add (Box.createGlue ());
        JButton group_admin = new JButton (resources_.getString ("admin.groups.title", "Admin Groups..."));
        group_admin.setAlignmentX (JButton.CENTER_ALIGNMENT);
        group_admin.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent e) {
                try {
                    JDialog dlg = new SQLGroupAdmin (null, SQLBackEnd.this);
                    dlg.setVisible (true);
                } catch (Exception exc) {
                    if (Debug.DEBUG) Debug.println ("exc", Debug.getStackTrace (exc));
                    JOptionPane.showMessageDialog (null, exc.getMessage ());
                }
            }
        }
        );
        panel.add (group_admin);
        final JOptionPane optionPane = new JOptionPane (panel, JOptionPane.PLAIN_MESSAGE);
        final JDialog dialog = new JDialog ((Frame) null, resources_.getString ("admin.main.title", "SQL Admin"));
        final Object lock = new Object ();
        dialog.setContentPane (optionPane);
        dialog.pack ();
        dialog.setVisible (true);
        optionPane.addPropertyChangeListener (new PropertyChangeListener () {
            public void propertyChange (PropertyChangeEvent e) {
                String prop = e.getPropertyName ();
                if (dialog.isVisible () && (e.getSource () == optionPane) && (prop.equals (JOptionPane.VALUE_PROPERTY))) {
                    dialog.setVisible (false);
                    synchronized (lock) {
                        lock.notifyAll ();
                    }
                }
            }
        }
        );
        synchronized (lock) {
            try {
                lock.wait ();
            } catch (InterruptedException e1) {
            }
        }
    }
    try {
        if ((old_username == null) || (old_password == null)) {
            logout ();
            return (true);
        }
        try {
            login (old_username, old_password);
        } catch (Exception exc) {
            logout ();
            JOptionPane.showMessageDialog (null, "Could not logout as system user, user is now anonymous!", "Login Warning", JOptionPane.WARNING_MESSAGE);
        }
    } catch (Exception exc) {
        if (Debug.DEBUG) Debug.println ("Admin Error", exc + Debug.getStackTrace (exc));
        JOptionPane.showMessageDialog (null, exc.getMessage (), "Admin Error", JOptionPane.ERROR_MESSAGE);
    }
    return (true);
}


public void updateSuccessfullyMsg (long theSeqNum, String theMbxTarget, String theUserTarget) throws org.epo.jdist.dl.JDistException {
    String IN_PROCESS_MSGS = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_TABLENAME_PRP);
    String SEQNUM = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_COLUMN_SEQNUM_PRP);
    String STATUS = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_COLUMN_STATUS_PRP);
    String UPDATETS = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_COLUMN_UPDATETS_PRP);
    String MBXTARGET = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_COLUMN_MBXTARGET_PRP);
    String USERTARGET = checkGetProperty (getSysParam ().getProperties (), JDistSysParam.DB_INPROCESS_COLUMN_USERTARGET_PRP);
    Timestamp myUpdateTS = new Timestamp (System.currentTimeMillis ());
    String mySqlQuery = "UPDATE " + IN_PROCESS_MSGS + " SET " + STATUS + "=1 , " + UPDATETS + "={ts '" + myUpdateTS + "'}," + MBXTARGET + "='" + theMbxTarget + "'," + USERTARGET + "='" + theUserTarget + "' WHERE (" + STATUS + "=0) AND (" + SEQNUM + "=" + theSeqNum + ")";
    try {
        setAutoCommit (true);
        createStatement ();
        getStatement ().executeUpdate (mySqlQuery);
    } catch (SQLException se) {
        throw new JDistException (JDistException.ERR_DB_SQL, se.getMessage ());
    }
}


-----Function Pair=343=-----==

public int insert (String sql) {
    int id = 0;
    Connection conn = null;
    Statement stmt = null;
    Transaction tran = null;
    try {
        Session session = SessionFactory.getSession ();
        tran = session.beginTransaction ();
        conn = session.connection ();
        stmt = conn.createStatement ();
        stmt.setEscapeProcessing (false);
        int rows = stmt.executeUpdate (sql);
        if (rows > 0) {
            ResultSet rs = stmt.executeQuery ("SELECT last_insert_id()");
            if (rs.next ()) {
                id = rs.getInt (1);
            }
            rs.close ();
            rs = null;
        }
        tran.commit ();
    } catch (SQLException e) {
        tran.rollback ();
        e.printStackTrace ();
    } finally {
        try {
            if (tran != null) {
                tran = null;
            }
            if (stmt != null) {
                stmt.close ();
                stmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return id;
}


private void bumpAllRowsUp (Statement stmt, int id, int row) throws SQLException {
    ResultSet rs = null;
    try {
        String sql = "select max(Rank) from InstructionGroups " + "where InstructionId = " + id + " and Rank >= " + row;
        rs = stmt.executeQuery (sql);
        if (rs.next () == true) {
            int num = rs.getInt (1);
            for (int i = row; i < num; ++ i) {
                stmt.executeUpdate ("update InstructionGroups set Rank = " + i + " where InstructionId = " + id + "   and Rank = " + (i + 1));
            }
        }
    } finally {
        if (rs != null) rs.close ();
    }
}


-----Function Pair=344=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            Address address = new Address ();
            address.setCity ("Addison");
            address.setStreet ("Preston Road 1121");
            address.setPerson (person);
            person.getAddresses ().add (0, address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private ReplEvent eventFromBlob (Blob blob) throws THLException {
    ReplEvent retval;
    try {
        long metricID = 0L;
        byte [] bytes = blob.getBytes (1L, (int) blob.length ());
        ByteArrayInputStream baib = new ByteArrayInputStream (bytes);
        ObjectInputStream ois = new ObjectInputStream (baib);
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) metricID = runtime.getMonitor ().startCPUEvent (ReplicatorMonitor.CPU_DB_DESERIAL);
        retval = (ReplEvent) ois.readObject ();
        if (runtime != null && runtime.getMonitor ().getDetailEnabled ()) runtime.getMonitor ().stopCPUEvent (ReplicatorMonitor.CPU_DB_DESERIAL, metricID);
        return retval;
    } catch (Exception e) {
        throw new THLException (e);
    }
}


-----Function Pair=345=-----==

public int addExecuteInstruction (String exeString) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            String sql = "insert into Instructions (Type, ExecuteString, Operator) " + "values (3, '" + exeString + "', 0)";
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            stmt.executeUpdate (sql);
            return getCurrentId (stmt);
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public static Timestamp getLastModifiedByExperimentId (int id) throws NoConnectionToDBException, SQLException {
    PreparedStatement st = DatabaseConnector.getInstance ().getConn ().prepareStatement ("select MAX(date_modified) AS ermodified FROM " + table + " WHERE Experiment_idExperiment = ?");
    st.setInt (1, id);
    ResultSet rs = st.executeQuery ();
    rs.next ();
    Timestamp res = rs.getTimestamp (1);
    if (res == null) {
        res = new Timestamp (0);
    }
    else {
        res.setTime (res.getTime () + 1);
    }
    rs.close ();
    st.close ();
    return res;
}


-----Function Pair=346=-----==

public Account getAccount (long uid, String acctName) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Account R where R.ownerId=? and R.accountName=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setString (1, CHelper.encrypt (acctName));
        Account a = (Account) q.uniqueResult ();
        s.getTransaction ().commit ();
        return a;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


private boolean existsTable (EboContext ctx, String schemaName, String tableName) throws SQLException {
    Connection cn = null;
    ResultSet rslt = null;
    PreparedStatement pstm = null;
    try {
        cn = ctx.getDedicatedConnectionData ();
        pstm = cn.prepareStatement ("select count(*) from information_schema.tables where table_name=? and table_schema=? " + "and table_type='BASE TABLE'");
        pstm.setString (1, tableName.toLowerCase ());
        pstm.setString (2, schemaName.toLowerCase ());
        rslt = pstm.executeQuery ();
        if (rslt.next ()) {
            if (rslt.getInt (1) > 0) {
                return true;
            }
        }
        return false;
    } catch (SQLException e) {
        cn.rollback ();
        throw (e);
    } finally {
        try {
            if (rslt != null) {
                rslt.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (pstm != null) {
                pstm.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (cn != null) {
                cn.close ();
            }
        } catch (Exception e) {
        }
    }
}


-----Function Pair=347=-----==

public Account getAccountFromNumber (long uid, String acctNum) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Account R where R.ownerId=? and R.accountNumber=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setString (1, CHelper.encrypt (acctNum));
        Account a = (Account) q.uniqueResult ();
        s.getTransaction ().commit ();
        return a;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public List < Leilao > getLeiloes () throws SQLException {
    List < Leilao > leiloes = new ArrayList < Leilao > ();
    Connection conn = null;
    try {
        conn = connectionFactory.getConnection (true);
        Statement stmt = conn.createStatement ();
        String sqlSelect = "SELECT * FROM Leilao";
        ResultSet rs = stmt.executeQuery (sqlSelect);
        Leilao leilaoList = null;
        while (rs.next ()) {
            leilaoList = new Leilao ();
            leilaoList.setIdLeilao (rs.getInt ("idleilao"));
            leilaoList.setDataInicio (Utils.getDateFormat (rs.getString ("datainicio"), "yyyy-MM-dd"));
            leilaoList.setDataFim (Utils.getDateFormat (rs.getString ("datafim"), "yyyy-MM-dd"));
            leiloes.add (leilaoList);
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    } finally {
        conn.close ();
    }
    return leiloes;
}


-----Function Pair=348=-----==

public static ArrayList < ExperimentResultEx > getExtendedExperimentResultsFromExperimentResults (List < ExperimentResult > results) throws NoConnectionToDBException, SQLException {
    ArrayList < ExperimentResultEx > resx = new ArrayList < ExperimentResultEx > ();
    if (results.isEmpty ()) {
        return resx;
    }
    HashMap < Integer, ExperimentResult > resultMap = new HashMap < Integer, ExperimentResult > ();
    String constTable = "(";
    for (ExperimentResult er : results) {
        resultMap.put (er.getId (), er);
        constTable += "" + er.getId () + ",";
    }
    constTable = constTable.substring (0, constTable.length () - 1) + ")";
    Statement st = DatabaseConnector.getInstance ().getConn ().createStatement ();
    ResultSet rs = st.executeQuery ("SELECT idJob, startTime, solverOutput, launcherOutput, watcherOutput, verifierOutput FROM " + table + " JOIN " + outputTable + " ON (idJob = ExperimentResults_idJob) WHERE idJob IN " + constTable);
    while (rs.next ()) {
        Timestamp startTime = null;
        try {
            startTime = rs.getTimestamp (2);
        } catch (Exception e) {
        }
        ExperimentResult er = resultMap.get (rs.getInt (1));
        ExperimentResultEx erx = createExperimentResult (er.getRun (), er.getPriority (), er.getComputeQueue (), er.getStatus (), er.getResultCode (), er.getSeed (), er.getResultTime (), er.getSolverConfigId (), er.getExperimentId (), er.getInstanceId (), startTime, er.getCPUTimeLimit (), er.getMemoryLimit (), er.getWallClockTimeLimit (), er.getStackSizeLimit (), rs.getBytes (3), rs.getBytes (4), rs.getBytes (5), rs.getBytes (6));
        erx.setResultTime (er.getResultTime ());
        erx.setSolverExitCode (er.getSolverExitCode ());
        erx.setVerifierExitCode (er.getVerifierExitCode ());
        erx.setWatcherExitCode (er.getWatcherExitCode ());
        resx.add (erx);
    }
    rs.close ();
    st.close ();
    return resx;
}


public void createAndSendAnnouncementForUser (Announcement announcement, Long nUserId, Long nAnnouncementType) {
    DataManagerAgAnnouncement dataManagerAgAnnouncement = new DataManagerAgAnnouncement ();
    AgAnnouncement agAnnouncement = dataManagerAgAnnouncement.buildAgAnnouncement (announcement);
    RestServiceResult serviceResult = dataManagerAgAnnouncement.create (new RestServiceResult (), agAnnouncement);
    if (! serviceResult.isError ()) dataManagerAgAnnouncement.addAgAnnouncementUser (agAnnouncement, nUserId);
    AnnouncementEvent announcementEvent = new AnnouncementEvent ();
    jade.util.leap.List arrayUsersId = new jade.util.leap.ArrayList ();
    jade.util.leap.List listAnnouncement = new jade.util.leap.ArrayList ();
    arrayUsersId.add (nUserId.toString ());
    listAnnouncement.add (announcement);
    announcementEvent.setArrayUsersId (arrayUsersId);
    announcementEvent.setTypeEvent (nAnnouncementType);
    announcementEvent.setListAnnouncement (listAnnouncement);
    try {
        JadeGateway.execute (announcementEvent);
    } catch (Exception e) {
        e.printStackTrace ();
        log.info ("Error al enviarle el mensaje al usuario: " + nUserId);
    }
    log.info ("retorna el objeto announcementEvent...");
}


-----Function Pair=349=-----==

public FrostMessageObject retrieveMessageByMessageId (Board board, String msgId, boolean withContent, boolean withAttachments, boolean showDeleted) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    String sql = "SELECT " + "primkey,messageid,inreplyto,msgdatetime,msgindex,fromname,subject,recipient," + "signaturestatus,publickey,isdeleted,isnew,isreplied,isjunk,isflagged,isstarred," + "hasfileattachment,hasboardattachment,idlinepos,idlinelen";
    sql += " FROM " + getMessageTableName () + " WHERE board=? AND messageid=?";
    PreparedStatement ps = db.prepareStatement (sql);
    ps.setInt (1, board.getPrimaryKey ().intValue ());
    ps.setString (2, msgId);
    ResultSet rs = ps.executeQuery ();
    FrostMessageObject mo = null;
    if (rs.next ()) {
        mo = resultSetToFrostMessageObject (rs, board, withContent, withAttachments);
    }
    rs.close ();
    ps.close ();
    return mo;
}


public User getUser (Long portalUserId, AuthSession authSession) {
    if (portalUserId == null) {
        return null;
    }
    DatabaseAdapter db = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        db = DatabaseAdapter.getInstance ();
        String sql = "select a.ID_USER,a.ID_FIRM,a.FIRST_NAME,a.MIDDLE_NAME,a.LAST_NAME, " + "       a.DATE_START_WORK,a.DATE_FIRE,a.ADDRESS,a.TELEPHONE,a.EMAIL, a.IS_DELETED " + "from   WM_LIST_USER a " + "where  a.ID_USER=? and a.IS_DELETED=0 and a.ID_FIRM in ";
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                String idList = authSession.getGrantedCompanyId ();
                sql += " (" + idList + ") ";
                break;
            default :
                sql += "(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)";
                break;
        }
        ps = db.prepareStatement (sql);
        int num = 1;
        ps.setLong (num ++, portalUserId);
        switch (db.getFamaly ()) {
            case DatabaseManager.MYSQL_FAMALY :
                break;
            default :
                ps.setString (num ++, authSession.getUserLogin ());
                break;
        }
        rs = ps.executeQuery ();
        UserBean beanPortal = null;
        if (rs.next ()) {
            beanPortal = loadPortalUserFromResultSet (rs);
            final Company company = InternalDaoFactory.getInternalCompanyDao ().getCompany (beanPortal.getCompanyId (), authSession);
            if (company != null) beanPortal.setCompanyName (company.getName ());
            else beanPortal.setCompanyName ("Warning. Company not found");
        }
        return beanPortal;
    } catch (Exception e) {
        String es = "Error load portal user for id: " + portalUserId;
        throw new IllegalStateException (es, e);
    } finally {
        DatabaseManager.close (db, rs, ps);
        db = null;
        rs = null;
        ps = null;
    }
}


-----Function Pair=350=-----==

public int getNewMessageCount (Board board, int maxDaysBack) throws SQLException {
    AppLayerDatabase db = AppLayerDatabase.getInstance ();
    PreparedStatement ps;
    if (maxDaysBack < 0) {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM " + getMessageTableName () + " WHERE board=? AND isnew=TRUE AND isvalid=TRUE");
        ps.setInt (1, board.getPrimaryKey ().intValue ());
    }
    else {
        ps = db.prepareStatement ("SELECT COUNT(primkey) FROM " + getMessageTableName () + " WHERE msgdatetime>=? AND board=? AND isnew=TRUE AND isvalid=TRUE");
        LocalDate localDate = new LocalDate (DateTimeZone.UTC).minusDays (maxDaysBack);
        ps.setLong (1, localDate.toDateMidnight (DateTimeZone.UTC).getMillis ());
        ps.setInt (2, board.getPrimaryKey ().intValue ());
    }
    int count = 0;
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        count = rs.getInt (1);
    }
    rs.close ();
    ps.close ();
    return count;
}


public void updateUserForSuccesfulLogin (String username) throws Exception {
    Session session = null;
    Transaction tx = null;
    Users us = new Users ();
    try {
        setUp ();
        session = HibernateUtil.getSessionFactory ().openSession ();
        tx = session.beginTransaction ();
        List tmpUsers = this.session.createCriteria (Users.class).add (Restrictions.eq ("user_name", username)).list ();
        for (Iterator iter = tmpUsers.iterator (); iter.hasNext ();) {
            us = (Users) iter.next ();
            if (tmpUsers.size () == 1) {
                us.setLast_successful_login (((new Date ()).toString ()));
                session.update (us);
            }
            tx.commit ();
            session.close ();
        }
    } catch (Exception e) {
        logger.error ("EXCEPTION While update user", e);
        session.getTransaction ().rollback ();
        session.close ();
        throw e;
    }
}


-----Function Pair=351=-----==

public IllnessStatsListDocument getDiagnosisMedicalStatsReport () {
    IllnessStatsListDocument doc = null;
    ResultSet rsReport = null;
    try {
        helper = new DBHelper ();
        PreparedStatement psReport = helper.prepareStatement (SQL.getDiagnosisMedicalStatsReport ());
        rsReport = psReport.executeQuery ();
        doc = IllnessStatsListDocument.Factory.newInstance ();
        doc.addNewIllnessStatsList ();
        while (rsReport.next ()) {
            MedicalIllness m = doc.getIllnessStatsList ().addNewStats ();
            m.setName (rsReport.getString ("NAME"));
            m.setTitle (rsReport.getString ("TITLE"));
            m.setSurname (rsReport.getString ("SURNAME"));
            m.setCount (new BigInteger (String.valueOf (rsReport.getInt ("COUNT"))));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsReport != null) {
                rsReport.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


public static void main (String [] args) throws ClassNotFoundException, SQLException {
    SQLBasedStore store = new SQLBasedStore ();
    PreparedStatement statement = null;
    try {
        store.ensureConnection ();
        statement = store.m_connection.prepareStatement ("insert into fs.post (id, forum, tid, qid, pid, question, posted_date, type, text, author) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
        statement.setNull (1, Types.NUMERIC);
        statement.setString (2, "www.experts-exchange.com");
        statement.setString (3, "Java Programming");
        statement.setString (4, "22096757");
        statement.setString (5, "0");
        statement.setLong (6, 41);
        statement.setTimestamp (7, new Timestamp (System.currentTimeMillis ()));
        statement.setString (8, "Question");
        statement.setString (9, "text");
        statement.setString (10, "huzefaq");
        int count = statement.executeUpdate ();
        if (0 == count) throw new SQLException ("Nothing updated.");
        ResultSet keys = statement.getGeneratedKeys ();
        try {
            if (keys.next ()) {
                System.out.println (keys.getLong (1));
            }
            else throw new SQLException ("No key found.");
        } finally {
            try {
                keys.close ();
            } catch (SQLException _) {
            }
        }
        store.m_connection.commit ();
    } finally {
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
        store.close ();
    }
}


-----Function Pair=352=-----==

public Object [] [] finishBatch (Object [] [] data, int len) throws KETLTransformException {
    int result = 0;
    try {
        if (this.mBatchData && (this.mBatchCounter >= this.miCommitSize || (len == BatchManager.LASTBATCH && this.mBatchCounter > 0))) {
            boolean errorsOccured = false;
            Savepoint savepoint = null;
            try {
                if (this.supportsSetSavepoint) {
                    savepoint = this.mcDBConnection.setSavepoint ();
                }
                Exception e1 = null;
                int [] res = null;
                try {
                    res = this.stmt.executeBatch ();
                    if (this.supportsReleaseSavepoint && savepoint != null) {
                        this.mcDBConnection.releaseSavepoint (savepoint);
                    }
                } catch (BatchUpdateException e) {
                    if (savepoint != null) this.mcDBConnection.rollback (savepoint);
                    else res = e.getUpdateCounts ();
                    e1 = e;
                    errorsOccured = true;
                }
                if (errorsOccured && res == null) {
                    for (int i = 0; i < this.mBatchLog.size (); i ++) {
                        if (this.miRetryBatch == 0) this.incrementErrorCount (e1 == null ? new KETLTransformException ("Failed to submit record " + (i + 1 + this.miInsertCount)) : new KETLTransformException (e1), (Object []) this.mBatchLog.get (i), i + 1 + this.miInsertCount);
                        else this.mFailedBatchElements.add (i);
                    }
                }
                else {
                    int rLen = res.length;
                    for (int i = 0; i < rLen; i ++) {
                        if (res [i] == Statement.EXECUTE_FAILED) {
                            this.mFailedBatchElements.add (i);
                            if (this.miRetryBatch == 0) this.incrementErrorCount (e1 == null ? new KETLTransformException ("Failed to submit record " + (i + 1 + this.miInsertCount)) : new KETLTransformException (e1), (Object []) this.mBatchLog.get (rLen), i + 1 + this.miInsertCount);
                        }
                        else {
                            result += res [i] >= 0 ? res [i] : 1;
                        }
                    }
                }
            } catch (SQLException e) {
                throw new KETLTransformException (e);
            }
            if (errorsOccured && this.miRetryBatch > 0) {
                result = this.retryBatch ();
            }
            this.clearBatchLogBatch ();
            this.miInsertCount += this.mBatchCounter;
            this.mBatchCounter = 0;
            if (this.mIncrementalCommit) this.mcDBConnection.commit ();
            this.executePostBatchStatements ();
            this.firePreBatch = true;
        }
        else if (this.mBatchData == false) {
            if (this.mIncrementalCommit) this.mcDBConnection.commit ();
        }
    } catch (SQLException e) {
        throw new KETLTransformException (e);
    }
    return data;
}


public static Vector retrieveTemplate (String usrlogin, String tab) throws DbException {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        String role = "";
        {
            sql = r.reset ().add ("user_role").add ("user_login", usrlogin).getSQLSelect ("users");
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                role = rs.getString (1);
            }
        }
        sql = "SELECT m.module_id, m.module_title, m.module_class, u.module_custom_title, u.column_number " + "FROM module m, user_module_template u " + "WHERE m.module_id = u.module_id " + "AND u.user_login = '" + role + "' " + "AND u.tab_id = '" + tab + "' order by u.sequence";
        ResultSet rs = stmt.executeQuery (sql);
        Vector v = new Vector ();
        while (rs.next ()) {
            String id = rs.getString ("module_id");
            String title = rs.getString ("module_title");
            String mclass = rs.getString ("module_class");
            String custom_title = rs.getString ("module_custom_title");
            int col = rs.getInt ("column_number");
            if (custom_title == null || "".equals (custom_title)) custom_title = title;
            v.addElement (new Module2 (id, title, mclass, custom_title, col));
        }
        return v;
    } catch (SQLException ex) {
        throw new DbException (ex.getMessage () + ": " + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=353=-----==

public Data get_out_1 (SyrupConnection con) throws Exception {
    try {
        EndPoint p = sqlImpl ().queryFunctions ().readInEndPoint ("1", false, con);
        if (p.data != null) {
            sqlImpl ().updateFunctions ().updateInLink ("1", false, null, con);
            sqlImpl ().loggingFunctions ().log ("1", LogEntry.EVENT | LogEntry.OUT_1, con);
            sqlImpl ().updateFunctions ().checkAndUpdateDone ("1", con);
            con.commit ();
            return p.data;
        }
        else {
            throw new Exception ("out1 is empty");
        }
    } finally {
        con.rollback ();
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        System.out.println ("*** insert ***");
        insert (entityManagerFactory);
        System.out.println ("*** query ***");
        query (entityManagerFactory);
        System.out.println ("*** update ***");
        update (entityManagerFactory);
        System.out.println ("*** query with parameter ***");
        querywithparameter (entityManagerFactory);
        System.out.println ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        System.out.println ("*** finished ***");
    }
}


-----Function Pair=354=-----==

public List < Budget > getBudgets (long uid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Budget R where R.uid=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        List < Budget > l = Collections.checkedList (q.list (), Budget.class);
        s.getTransaction ().commit ();
        return l;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public void lock (String oid, String key) throws PersisterException {
    String lock = getLock (oid);
    if (lock == null) {
        throw new PersisterException ("Object does not exist: OID = " + oid);
    }
    else if (! NULL.equals (lock) && (! lock.equals (key))) {
        throw new PersisterException ("The object is currently locked with another key: OID = " + oid + ", LOCK = " + lock + ", KEY = " + key);
    }
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("update " + _table_name + " set " + _key_col + " = ?, " + _ts_col + " = ? where " + _oid_col + " = ?");
        ps.setString (1, key);
        ps.setLong (2, System.currentTimeMillis ());
        ps.setString (3, oid);
        ps.executeUpdate ();
    } catch (Throwable th) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (Throwable th2) {
            }
        }
        throw new PersisterException ("Failed to lock object: OID = " + oid + ", KEY = " + key, th);
    } finally {
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=355=-----==

public TimeSlot delete (Integer idModel) throws TechnicalException {
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        String hql = "delete from RecurrenceRule where elementId = :id";
        Query query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        hql = "delete from TimeSlot where id = :id";
        query = session.createQuery (hql);
        query.setInteger ("id", idModel.intValue ());
        query.executeUpdate ();
        transaction.commit ();
        return null;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    }
}


private void doDeleteTask (HttpSession session) {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        String task_id = getParam ("task_id");
        sql = "DELETE FROM planner_task WHERE task_id = '" + task_id + "'";
        stmt.executeUpdate (sql);
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
    } catch (SQLException ex) {
        System.out.println (ex.getMessage () + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=356=-----==

public boolean lockDigitalObject (String uuid, Long id, String description) throws DatabaseException {
    PreparedStatement updateSt = null;
    boolean successful = false;
    try {
        if (id != null) {
            updateSt = getConnection ().prepareStatement (INSERT_NEW_DIGITAL_OBJECTS_LOCK);
            updateSt.setString (1, uuid);
            updateSt.setString (2, description);
            updateSt.setLong (3, id);
        }
        else {
            updateSt = getConnection ().prepareStatement (UPDATE_DIGITAL_OBJECTS_TIMESTAMP_DESCRIPTION);
            updateSt.setString (1, description);
            updateSt.setString (2, uuid);
        }
    } catch (SQLException e) {
        LOGGER.error ("Could not get insert statement", e);
    } finally {
        closeConnection ();
    }
    int modified = 0;
    try {
        modified = updateSt.executeUpdate ();
        if (modified == 1) {
            getConnection ().commit ();
            LOGGER.debug ("DB has been updated. Queries: \"" + updateSt + "\"");
            successful = true;
        }
        else {
            getConnection ().rollback ();
            LOGGER.error ("DB has not been updated -> rollback! Queries: \"" + updateSt + "\"");
            successful = false;
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + updateSt, e);
    } finally {
        closeConnection ();
    }
    return successful;
}


public int batchTransactionUpdate (List < String > queryStrLisyt, Connection con) throws Exception {
    int ret = 0;
    Statement stmt;
    if (con != null) {
        con.setAutoCommit (false);
        stmt = con.createStatement ();
        try {
            stmt.executeUpdate ("START TRANSACTION;");
            for (int i = 0; i < queryStrLisyt.size (); i ++) {
                stmt.addBatch (queryStrLisyt.get (i));
            }
            int [] updateCounts = stmt.executeBatch ();
            for (int i = 0; i < updateCounts.length; i ++) {
                FileLogger.debug ("batch update result:" + updateCounts [i] + ", Statement.SUCCESS_NO_INFO" + Statement.SUCCESS_NO_INFO);
                if (updateCounts [i] == Statement.SUCCESS_NO_INFO || updateCounts [i] > 0) {
                    ret ++;
                }
                else if (updateCounts [i] == Statement.EXECUTE_FAILED);
                {
                    throw new Exception ("query failed, while process batch update");
                }
            }
            con.commit ();
        } catch (Exception e) {
            ret = 0;
            FileLogger.debug (e.getMessage ());
            con.rollback ();
        } finally {
            con.setAutoCommit (true);
            stmt.close ();
        }
    }
    return ret;
}


-----Function Pair=357=-----==

public boolean hasChildUser () {
    boolean flag = false;
    OrganizeType orgType = new OrganizeType (this.organizeTypeID);
    try {
        Vector vChildType = orgType.getChildOrganizeType ();
        int nNum = vChildType.size ();
        if (nNum > 0) {
            for (int i = 0; i < nNum; i ++) {
                OrganizeType childType = (OrganizeType) vChildType.get (i);
                if (childType.getOrganizeTypeID ().equals (OrganizeType.USER)) {
                    flag = true;
                    break;
                }
            }
        }
    } catch (Exception e) {
    }
    return flag;
}


public boolean isSave (String name) {
    Session sessionSave = null;
    Query querySave = null;
    Transaction trSave = null;
    boolean issave = false;
    try {
        sessionSave = HibernateUtil.getSessionFactory ().getCurrentSession ();
        trSave = sessionSave.beginTransaction ();
        querySave = sessionSave.createQuery ("from Attachtypes as a where a.extension like :extension");
        querySave.setString ("extension", name);
        List list = querySave.list ();
        if (list == null || list.size () == 0) {
            issave = true;
        }
        trSave.commit ();
    } catch (HibernateException he) {
        if (trSave != null) trSave.rollback ();
        trSave = null;
        he.printStackTrace ();
    }
    return issave;
}


-----Function Pair=358=-----==

public void deleteUser (String userID) throws XregistryException {
    try {
        userID = Utils.canonicalizeDN (userID);
        Connection connection = context.createConnection ();
        connection.setAutoCommit (false);
        try {
            PreparedStatement statement1 = connection.prepareStatement (DELETE_USER_SQL_MAIN);
            statement1.setString (1, userID);
            statement1.executeUpdate ();
            PreparedStatement statement2 = connection.prepareStatement (DELETE_USER_SQL_DEPEND);
            statement2.setString (1, userID);
            statement2.executeUpdate ();
            connection.commit ();
            Collection < Group > groupList = groups.values ();
            for (Group group : groupList) {
                group.removeUser (userID);
            }
            log.info ("Delete User " + userID);
        } catch (SQLException e) {
            connection.rollback ();
            throw new XregistryException (e);
        } finally {
            context.closeConnection (connection);
        }
    } catch (SQLException e) {
        throw new XregistryException (e);
    }
}


public RestServiceResult create (RestServiceResult serviceResult, CoExercises1 coExercises1, String sDeliveryDate) {
    CoExercises1DAO coExercises1DAO = new CoExercises1DAO ();
    try {
        Long nSequence = getSequence ("sq_co_exercises1");
        coExercises1.setExerciseId (nSequence);
        EntityManagerHelper.beginTransaction ();
        coExercises1DAO.save (coExercises1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coExercises1);
        log.info ("Ejercicio S1 creado con �xito: " + coExercises1.getExerciseName ());
        Object [] arrayParam = {coExercises1.getExerciseName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.create.success"), arrayParam));
        serviceResult.setId (nSequence);
        this.addDeliveryDate (nSequence, sDeliveryDate);
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercises1.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=359=-----==

public String findByAll (RecyclebinForm recyclebinForm, int timeoffset) {
    StringBuffer querStr = new StringBuffer ("from jrun_threads as t left join jrun_forums as f on t.fid=f.fid left join jrun_posts as p on p.tid=t.tid left join jrun_threadsmod as m on t.tid=m.tid where p.first=1 and m.action='DEL' ");
    querStr.append (" and t.displayorder=-1 ");
    if (recyclebinForm.getInforum () != - 1 && recyclebinForm.getInforum () > 0) {
        querStr.append (" and t.fid = " + recyclebinForm.getInforum ());
    }
    if (recyclebinForm.getAuthors () != null && ! recyclebinForm.getAuthors ().equals ("")) {
        String [] authors = recyclebinForm.getAuthors ().split (",");
        String author = "";
        for (int i = 0; i < authors.length; i ++) {
            author += ",'" + authors [i] + "'";
        }
        if (author.length () > 0) {
            author = author.substring (1);
        }
        querStr.append (" and t.author in (" + author + ")");
    }
    if (recyclebinForm.getKeywords () != null && ! recyclebinForm.getKeywords ().equals ("")) {
        String [] keywords = recyclebinForm.getKeywords ().split (",");
        for (int i = 0; i < keywords.length; i ++) {
            querStr.append (" and (t.subject like '%" + keywords [i] + "%' or ");
        }
        querStr.delete (querStr.length () - 3, querStr.length ());
        querStr.append (") ");
    }
    if (recyclebinForm.getAdmins () != null && ! recyclebinForm.getAdmins ().equals ("")) {
        String [] authors = recyclebinForm.getAdmins ().split (",");
        String author = "";
        for (int i = 0; i < authors.length; i ++) {
            author += ",'" + authors [i] + "'";
        }
        if (author.length () > 0) {
            author = author.substring (1);
        }
        querStr.append (" and m.username in (" + author + ")");
    }
    if (recyclebinForm.getPstarttime () != null && ! recyclebinForm.getPstarttime ().equals ("")) {
        if (Common.datecheck (recyclebinForm.getPstarttime ())) {
            int time = Common.dataToInteger (recyclebinForm.getPstarttime (), "yyyy-MM-dd") - timeoffset;
            querStr.append (" and t.dateline > " + time);
        }
    }
    if (recyclebinForm.getPendtime () != null && ! recyclebinForm.getPendtime ().equals ("")) {
        if (Common.datecheck (recyclebinForm.getPendtime ())) {
            int time = Common.dataToInteger (recyclebinForm.getPendtime (), "yyyy-MM-dd") - timeoffset;
            querStr.append (" and t.dateline < " + time);
        }
    }
    if (recyclebinForm.getMstarttime () != null && ! recyclebinForm.getMstarttime ().equals ("")) {
        if (Common.datecheck (recyclebinForm.getMstarttime ())) {
            int time = Common.dataToInteger (recyclebinForm.getMstarttime (), "yyyy-MM-dd") - timeoffset;
            querStr.append (" and m.dateline > " + time);
        }
    }
    if (recyclebinForm.getMendtime () != null && ! recyclebinForm.getMendtime ().equals ("")) {
        if (Common.datecheck (recyclebinForm.getMendtime ())) {
            int time = Common.dataToInteger (recyclebinForm.getMendtime (), "yyyy-MM-dd") - timeoffset;
            querStr.append (" and m.dateline < " + time);
        }
    }
    querStr.append (" order by t.tid ");
    return querStr.toString ();
}


public Hashtable getBarometerData (int currentPilot) throws SQLException {
    Hashtable result = new Hashtable ();
    Calendar aYearAgo = new GregorianCalendar ();
    aYearAgo.set (Calendar.YEAR, aYearAgo.get (Calendar.YEAR) - 1);
    long then = aYearAgo.getTime ().getTime ();
    int flights = 0;
    int minutes = 0;
    Statement stmt = conn.getStatement ();
    ResultSet rs = stmt.executeQuery ("select motortid, slaebetid, svaevetid from flyvning where " + "flyvning.dato > " + then + " and " + "flyvning.kaptajn = " + "'Y' and " + "pilot_id = " + currentPilot);
    try {
        while (rs.next ()) {
            flights ++;
            minutes = minutes + rs.getInt (1) + rs.getInt (2) + rs.getInt (3);
            if (false) log.debug ("MiscDB.getBarometerData(): flights = " + flights + "\nminutes = " + minutes);
        }
    } catch (SQLException sqle) {
        log.debug (sqle);
        throw sqle;
    }
    result.put ("flights", new Integer (flights));
    result.put ("minutes", new Integer (minutes));
    return result;
}


-----Function Pair=360=-----==

private void getdata (HttpSession session, Hashtable periodData, String schema_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("period_schema_code");
        r.add ("path_no");
        r.add ("period_root_id", schema_id);
        sql = r.getSQLSelect ("period_root");
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) {
            periodData.put ("code", rs.getString ("period_schema_code"));
            periodData.put ("path_no", new Integer (rs.getInt ("path_no")));
            periodData.put ("id", schema_id);
        }
    } finally {
        if (db != null) db.close ();
    }
}


public YearOfStudy findByName (String yosName, String academicYearName) throws DBConnectionException, SelectException {
    YearOfStudy yos = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (YearOfStudyDAO.TABLE_NAME + " yos"));
    tablesFrom.add (new SQLWord (HolidaysDAO.TABLE_NAME + " h"));
    tablesFrom.add (new SQLWord (AcademicYearDAO.TABLE_NAME + " ay"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("yos.YEAR_STUDY_NAME", yosName);
    critWhere.addCriterion ("ay.ACADEMIC_YEAR_NAME", academicYearName);
    critWhere.addCriterion ("h.ACADEMIC_YEAR_ID", new SQLWord ("ay.ACADEMIC_YEAR_ID"));
    critWhere.addCriterion ("h.YEAR_STUDY_ID", new SQLWord ("yos.YEAR_STUDY_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                yos = new YearOfStudy (result.getString ("YEAR_STUDY_NAME"));
                yos.setAcaYear (null);
                yos.setDescription (result.getString ("YEAR_STUDY_DESCRIPTION"));
                yos.setDurationSession (result.getFloat ("YEAR_STUDY_DURATION_SESSION"));
                yos.setGroupList (null);
                yos.setHolidays (null);
                yos.setId (result.getInt ("YEAR_STUDY_ID"));
                yos.setNbSessionPM (result.getInt ("YEAR_STUDY_NB_SESSIONPM"));
                yos.setNbSessionsAM (result.getInt ("YEAR_STUDY_NB_SESSIONAM"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return yos;
}


-----Function Pair=361=-----==

public boolean addForum (Forums forum) {
    boolean flag = false;
    if (forum != null) {
        Session session = null;
        Transaction tran = null;
        try {
            session = HibernateUtil.getSessionFactory ().getCurrentSession ();
            tran = session.beginTransaction ();
            session.save (forum);
            flag = true;
            tran.commit ();
        } catch (HibernateException e) {
            flag = false;
            if (tran != null) {
                tran.rollback ();
            }
            e.printStackTrace ();
        }
    }
    return flag;
}


public ArrayList < OpenIDItem > getIdentities (String id) throws DatabaseException {
    PreparedStatement selectSt = null;
    ArrayList < OpenIDItem > retList = new ArrayList < OpenIDItem > ();
    try {
        selectSt = getConnection ().prepareStatement (SELECT_IDENTITIES_STATEMENT);
        selectSt.setLong (1, Long.parseLong (id));
    } catch (SQLException e) {
        LOGGER.error ("Could not get select statement", e);
    }
    try {
        ResultSet rs = selectSt.executeQuery ();
        while (rs.next ()) {
            retList.add (new OpenIDItem (rs.getString ("identity"), rs.getString ("id")));
        }
    } catch (SQLException e) {
        LOGGER.error ("Query: " + selectSt, e);
    } finally {
        closeConnection ();
    }
    return retList;
}


-----Function Pair=362=-----==

protected int transferOwnership (TransferOwnershipRequest request, String uuid, String newOwner) throws ImsServiceException, SQLException {
    PreparedStatement st = null;
    try {
        this.authorize (request, uuid);
        int ownerID = this.queryOwnerByUsername (newOwner);
        if (ownerID == - 1) {
            throw new ImsServiceException ("Unrecognized publisher: " + newOwner);
        }
        StringBuilder sql = new StringBuilder ();
        sql.append ("UPDATE ").append (this.getResourceTableName ());
        sql.append (" SET OWNER=? WHERE DOCUUID=?");
        logExpression (sql.toString ());
        Connection con = returnConnection ().getJdbcConnection ();
        st = con.prepareStatement (sql.toString ());
        st.setInt (1, ownerID);
        st.setString (2, uuid);
        int nRows = st.executeUpdate ();
        if (nRows > 0) {
            request.setActionStatus (ImsRequest.ACTION_STATUS_REPLACED);
        }
        return nRows;
    } finally {
        closeStatement (st);
    }
}


public void executeSelect (String tableName, Vector vField, Field fieldID) throws Throwable {
    log.info ("<<<<<< ApplicDBManager.executeSelect >>>>>> Begin ");
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        conn = getConnection ();
        String listColDB = "";
        for (int i = 0; i < vField.size (); i ++) {
            if (i != 0) listColDB += ", ";
            listColDB += ((Field) vField.elementAt (i)).getID ();
        }
        String query = " SELECT " + listColDB + "   FROM " + tableName + "  WHERE " + fieldID.getID () + " = " + fieldID.getValue ();
        log.info ("<<<<<< ApplicDBManager.executeSelect query = '" + query + "'");
        stmt = conn.createStatement ();
        rs = stmt.executeQuery (query);
        if (rs.next ()) {
            for (int i = 0; i < vField.size (); i ++) setFieldValueFromResultSet (rs, i + 1, (Field) vField.elementAt (i));
        }
        log.info ("<<<<<< ApplicDBManager.executeSelect >>>>>>  End ");
    } catch (Exception e) {
        manageException (e, "executeSelect");
    } finally {
        closeQueryObjects (rs, stmt);
        closeConnection (conn);
    }
}


-----Function Pair=363=-----==

private long doesRecordExist (String table, String uuid) throws SQLException {
    long id = - 1;
    PreparedStatement st = null;
    try {
        Connection con = returnConnection ().getJdbcConnection ();
        String sSql = "SELECT ID FROM " + table + " WHERE DOCUUID=?";
        logExpression (sSql);
        st = con.prepareStatement (sSql);
        st.setString (1, uuid);
        ResultSet rs = st.executeQuery ();
        if (rs.next ()) {
            id = rs.getLong (1);
        }
    } finally {
        closeStatement (st);
    }
    return id;
}


public void testFilter () throws Exception {
    Session s;
    Transaction tx;
    s = openSession ();
    tx = s.beginTransaction ();
    s.createQuery ("delete Forest").executeUpdate ();
    Forest f1 = new Forest ();
    f1.setLength (2);
    s.persist (f1);
    Forest f2 = new Forest ();
    f2.setLength (20);
    s.persist (f2);
    Forest f3 = new Forest ();
    f3.setLength (200);
    s.persist (f3);
    tx.commit ();
    s.close ();
    s = openSession ();
    tx = s.beginTransaction ();
    s.enableFilter ("betweenLength").setParameter ("minLength", 5).setParameter ("maxLength", 50);
    long count = ((Long) s.createQuery ("select count(*) from Forest").iterate ().next ()).intValue ();
    assertEquals (1, count);
    s.disableFilter ("betweenLength");
    s.enableFilter ("minLength").setParameter ("minLength", 5);
    count = ((Long) s.createQuery ("select count(*) from Forest").iterate ().next ()).longValue ();
    assertEquals (2l, count);
    s.disableFilter ("minLength");
    tx.rollback ();
    s.close ();
}


-----Function Pair=364=-----==

public SessionType store (SessionType obj) throws InsertException, DBConnectionException, XmlIOException {
    SessionType toReturn = null;
    Statement stmt = OracleJDBConnector.getInstance ().getStatement ();
    List < Object > values = new ArrayList < Object > ();
    values.add (0);
    values.add (obj.getName ());
    values.add (obj.getEquivTuto ());
    values.add (obj.getAcronym ());
    try {
        stmt.executeUpdate (new InsertQuery (TABLE_NAME, values).toString ());
        toReturn = findByAcronym (obj.getAcronym ());
        stmt.getConnection ().commit ();
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            stmt.getConnection ().rollback ();
        } catch (SQLException e1) {
            throw new DBConnectionException (TABLE_NAME + " Rollback Exception :", e1);
        }
        throw new InsertException (TABLE_NAME + " Insert Exception :", e);
    }
    return toReturn;
}


public RestServiceResult delete (RestServiceResult serviceResult, ToHandbook toHandbook) {
    try {
        log.info ("Eliminando anotaci�n libreta: " + toHandbook.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_HANDBOOK);
        query.setParameter (1, toHandbook.getHandbookId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toHandbook);
        Object [] arrayParam = {toHandbook.getTitle ()};
        log.info ("Libreta eliminado con �xito: " + toHandbook.getTitle ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el Libreta: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toHandbook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=365=-----==

public String getDOBOUid (String boName) {
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        String sql = "select objUID from DO_BO where type = '" + getType () + "' and sqlStr = ? ";
        PreparedStatement pstmt = con.prepareStatement (sql);
        pstmt.setString (1, boName);
        ResultSet rs = pstmt.executeQuery ();
        String boUid = null;
        if (rs.next ()) {
            boUid = rs.getString (1);
        }
        return boUid;
    } catch (SQLException ex1) {
        ex1.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
    return null;
}


public boolean contains (String word) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select count(1) from Dictionary where Word = '" + word + "'";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            if (rs.next () == false) throw new SQLException ("No rows returned for count(1) query");
            else {
                int num = rs.getInt (1);
                if (num == 0) return false;
                else return true;
            }
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=366=-----==

public void testMissingParameter0016 () throws Exception {
    Statement stmt = con.createStatement ();
    stmt.executeUpdate ("create table #t0016 " + "  (i  integer  not null,      " + "   s  char(10) not null)      ");
    final int rowsToAdd = 20;
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        String sql = "insert into #t0016 values (" + i + ", 'row" + i + "')";
        count += stmt.executeUpdate (sql);
    }
    stmt.close ();
    assertEquals (count, rowsToAdd);
    PreparedStatement pstmt = con.prepareStatement ("select s from #t0016 where i=? and s=?");
    try {
        pstmt.executeQuery ();
        assertTrue ("Failed to throw exception", false);
    } catch (SQLException e) {
        assertTrue ("07000".equals (e.getSQLState ()) && (e.getMessage ().indexOf ('1') >= 0 || e.getMessage ().indexOf ('2') >= 0));
    }
    pstmt.clearParameters ();
    try {
        pstmt.setInt (1, 7);
        pstmt.setString (2, "row7");
        pstmt.clearParameters ();
        pstmt.executeQuery ();
        assertTrue ("Failed to throw exception", false);
    } catch (SQLException e) {
        assertTrue ("07000".equals (e.getSQLState ()) && (e.getMessage ().indexOf ('1') >= 0 || e.getMessage ().indexOf ('2') >= 0));
    }
    pstmt.clearParameters ();
    try {
        pstmt.setInt (1, 7);
        pstmt.executeQuery ();
        assertTrue ("Failed to throw exception", false);
    } catch (SQLException e) {
        assertTrue ("07000".equals (e.getSQLState ()) && e.getMessage ().indexOf ('2') >= 0);
    }
    pstmt.clearParameters ();
    try {
        pstmt.setString (2, "row7");
        pstmt.executeQuery ();
        assertTrue ("Failed to throw exception", false);
    } catch (SQLException e) {
        assertTrue ("07000".equals (e.getSQLState ()) && e.getMessage ().indexOf ('1') >= 0);
    }
    pstmt.close ();
}


public Integer getAcDataCustomerCount (Integer customerId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (AcDataCustomer.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" data.id = '" + customerId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=367=-----==

public List < FieldVO > findTableFields (String tableName) {
    List < FieldVO > fieldVOs = new ArrayList < FieldVO > ();
    String sql = "SHOW FIELDS FROM " + tableName;
    Connection conn = null;
    PreparedStatement pstmt = null;
    ResultSet rs = null;
    Transaction transaction = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        transaction = session.beginTransaction ();
        conn = session.connection ();
        pstmt = conn.prepareStatement (sql);
        rs = pstmt.executeQuery ();
        FieldVO fieldVO = null;
        while (rs.next ()) {
            fieldVO = new FieldVO ();
            fieldVO.setField (rs.getString ("Field"));
            fieldVO.setType (rs.getString ("Type"));
            fieldVO.setAllowNull (rs.getString ("Null"));
            fieldVO.setKey (rs.getString ("Key"));
            fieldVO.setDefaultValue (rs.getString ("Default"));
            fieldVO.setExtra (rs.getString ("Extra"));
            fieldVOs.add (fieldVO);
        }
        transaction.commit ();
    } catch (Exception exception) {
        exception.printStackTrace ();
        if (transaction != null) {
            transaction.rollback ();
        }
    } finally {
        try {
            if (transaction != null) {
                transaction = null;
            }
            if (rs != null) {
                rs.close ();
                rs = null;
            }
            if (pstmt != null) {
                pstmt.close ();
                pstmt = null;
            }
            if (conn != null) {
                conn.close ();
                conn = null;
            }
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
    return fieldVOs;
}


public RestServiceResult listCourseForUser (RestServiceResult serviceResult, Long nUserId) {
    MaUser maUser = new MaUserDAO ().findById (nUserId);
    EntityManagerHelper.refresh (maUser);
    Set < CoCourse > set = new HashSet < CoCourse > ();
    List < CoCourse > listCourse = new ArrayList < CoCourse > ();
    if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_STUDENT)) {
        List < CoCourseUser > list = new ArrayList < CoCourseUser > (maUser.getCoCourseUsers ());
        for (CoCourseUser coCourseUser : list) {
            set.add (coCourseUser.getCoCourse ());
        }
    }
    else if (maUser.getMaRole ().getRoleId ().equals (Common.ROLE_ID_TEACHER)) {
        set = maUser.getCoCoursesForUserId ();
    }
    if (set.size () == 0) {
        serviceResult.setMessage (bundle.getString ("course.list.notFound"));
    }
    else {
        listCourse.addAll (set);
        Object [] array = {listCourse.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("course.list.success"), array));
    }
    serviceResult.setObjResult (listCourse);
    return serviceResult;
}


-----Function Pair=368=-----==

public void testDatetimeRounding1 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 990);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 990);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr1 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr1 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr1");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public void incluir (Cliente cliente) throws Exception {
    Connection connection = criaConexao (false);
    String sql = "insert into cliente select nextval('sq_cliente') as cod_cliente, ? as nome,  ? as sexo, ?";
    PreparedStatement stmt = null;
    try {
        stmt = connection.prepareStatement (sql);
        stmt.setString (1, cliente.getNome ());
        stmt.setString (2, cliente.getSexo ());
        stmt.setInt (3, cliente.getCidade ().getCodCidade ());
        int retorno = stmt.executeUpdate ();
        if (retorno == 0) {
            connection.rollback ();
            throw new SQLException ("Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!");
        }
        connection.commit ();
    } catch (SQLException e) {
        connection.rollback ();
        throw e;
    } finally {
        try {
            stmt.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
}


-----Function Pair=369=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nSingleTextId) {
    List < CoSingleTextCheckList > listCoSingleTextCheckList = null;
    Query query = EntityManagerHelper.getEntityManager ().createNativeQuery (Statements.SELECT_CO_SINGLE_TEXT_CHECK_LIST, CoSingleTextCheckList.class);
    query.setParameter (1, nSingleTextId);
    query.setHint (QueryHints.REFRESH, HintValues.TRUE);
    listCoSingleTextCheckList = query.getResultList ();
    if (listCoSingleTextCheckList == null || listCoSingleTextCheckList.size () == 0) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("checkListStudent.search.notFound"));
    }
    else {
        Object [] arrayParam = {listCoSingleTextCheckList.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.search.success"), arrayParam));
        serviceResult.setObjResult (listCoSingleTextCheckList);
        serviceResult.setNumResult (listCoSingleTextCheckList.size ());
    }
    return serviceResult;
}


public Product searchProductById (Integer id) throws PersistenceException {
    logger.info ("Searching product by Id...");
    EntityManager em = getEntityManager ();
    Product product = null;
    try {
        em.getTransaction ().begin ();
        product = em.find (Product.class, id);
        em.getTransaction ().commit ();
    } catch (Exception ex) {
        String error = "Error searching product by Id: " + ex.getMessage ();
        logger.error (error);
        em.getTransaction ().rollback ();
        throw new PersistenceException (ex);
    } finally {
        em.close ();
    }
    logger.info ("Product " + product.getName () + " found.");
    return product;
}


-----Function Pair=370=-----==

public HashMap getAllRoless () throws Exception {
    HashMap roleMap = new HashMap (2, 10);
    Roles roles = new Roles ();
    Transaction tx = null;
    try {
        setUp ();
    } catch (Exception e) {
        logger.error ("EXCEPTION While setUP", e);
    }
    try {
        tx = this.session.beginTransaction ();
        List tmpRoles = this.session.createCriteria (Roles.class).list ();
        for (Iterator iter = tmpRoles.iterator (); iter.hasNext ();) {
            roles = (Roles) iter.next ();
            roleMap.put (roles.getId (), roles);
        }
        tx.commit ();
        this.session.close ();
    } catch (Exception e) {
        logger.error ("EXCEPTION While getting employee list", e);
        this.session.getTransaction ().rollback ();
        this.session.close ();
        throw e;
    }
    return roleMap;
}


public String render (Transferable transferable) {
    Object object = null;
    try {
        if (transferable != null) {
            object = transferable.getTransferData (DBEntityDataFlavor.dbEntityDataFlavor ());
            DBEntity entity = (DBEntity) object;
            SingleTableSelectStatement st = new SingleTableSelectStatement (entity);
            try {
                return SQLFormatter.format (st.getSelectString (this.conn.getMetaData ())) + ";";
            } catch (Exception e1) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e1, "Exception caught while dropping");
            }
        }
    } catch (UnsupportedFlavorException e) {
        try {
            return transferable.getTransferData (DataFlavor.stringFlavor).toString () + ";";
        } catch (UnsupportedFlavorException e1) {
            try {
                DataFlavor [] f = transferable.getTransferDataFlavors ();
                if (f != null && f.length > 0) return transferable.getTransferData (f [0]).toString ();
                else return "";
            } catch (UnsupportedFlavorException e2) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e2, "Exception caught while dropping");
            } catch (IOException e3) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e3, "Exception caught while dropping");
            }
        } catch (IOException e4) {
            ExceptionManagerFactory.getExceptionManager ().manageException (e4, "Exception caught while dropping");
        }
    } catch (IOException e5) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e5, "Exception caught while dropping");
    }
    return "";
}


-----Function Pair=371=-----==

private static void putExtendComplexType (SchemaGenTableToItemType item, DbTableType table1) throws Exception {
    if (item.getTableToItemCount () != 0) {
        DbTableType t = new DbTableType ();
        DbTableType temp1 = DatabaseManager.getTableFromStructure (dbSchema, item.getTableName ());
        t.setPrimaryKey (temp1.getPrimaryKey ());
        for (int i = 0; i < temp1.getFieldsCount (); i ++) {
            DbFieldType f = temp1.getFields (i);
            if (isFk (item, temp1, f, null) == null) t.addFields (f);
        }
        t.setName (temp1.getName () + "_EXTEND");
        createComplexTypeItem (t);
        for (int j = 0; j < item.getTableToItemCount (); j ++) {
            SchemaGenTableToItemType ti = item.getTableToItem (j);
            DbTableType temp = DatabaseManager.getTableFromStructure (dbSchema, ti.getTableName ());
            String nameItemTemp = null;
            String baseTemp = StringTools.capitalizeString (ti.getTableName ());
            if (ti.getTableToItemCount () == 0) {
                nameItemTemp = lowerFirstChar (baseTemp) + SIMPLE_ITEM;
                extendCode += "            Get" + baseTemp + "Item " + baseTemp + "Object = " + "Get" + baseTemp + "Item.getInstance(adapter, tempItem" + countTempParam + ".item." + findRelateKey (table1, ti.getTableName ()) + " );\n" + "            if (" + baseTemp + "Object!=null && " + baseTemp + "Object.item!=null)\n" + "                " + nameItemTemp + " = " + baseTemp + "Object.item;\n";
            }
            else {
                String base = StringTools.capitalizeString (table1.getName ());
                String classNameItemTemp = baseTemp + "For" + base + EXTEND_ITEM_TYPE;
                nameItemTemp = lowerFirstChar (baseTemp) + EXTEND_ITEM;
                extendCode += "            " + nameItemTemp + " = _get" + baseTemp + EXTEND_ITEM + "(adapter, tempItem" + countTempParam + ".item." + findRelateKey (table1, ti.getTableName ()) + " );\n";
                extendCodeImport += "import " + config.getJavaPackageXmlSchema () + '.' + classNameItemTemp + ";\n";
                extendCodeProc += "    private " + classNameItemTemp + " _get" + baseTemp + EXTEND_ITEM + "(" + db.getFactoryMethod () + " adapter, Long id) " + putExceptionDefinition () + "    {\n" + "" + "    }\n" + "\n";
                for (int l = 0; l < temp.getFieldsCount (); l ++) {
                    DbFieldType field = temp.getFields (l);
                    boolean isNotFk = true;
                    for (int n = 0; n < temp.getImportedKeysCount (); n ++) {
                        DbImportedPKColumnType fk = temp.getImportedKeys (n);
                        if (field.getName ().equals (fk.getFkColumnName ())) {
                            isNotFk = false;
                            break;
                        }
                    }
                    if (isNotFk) {
                        String pf = StringTools.capitalizeString (field.getName ());
                        String nameItem = lowerFirstChar (StringTools.capitalizeString (temp.getName ())) + EXTEND_ITEM;
                        extendCode += "            " + nameItem + ".set" + pf + "( tempItem" + countTempParam + ".item.get" + pf + "() );\n";
                    }
                }
            }
            putExtendComplexType (ti, item.getTableName ());
        }
    }
}


public Flight get (int id, int currentPilot) throws Exception, SQLException {
    ResultSet rs = null;
    Flight _flight = new Flight ();
    try {
        Statement stmt = conn.getStatement ();
        rs = stmt.executeQuery ("select id, nr, dato, flytype_id, startart, slaebetid, " + "motortid, svaevetid, distance, " + "startsted_id, landingssted_id, " + "note, straek, udelanding, kaptajn, instruktoer, " + "forsaede, passager, afbrudtstart " + "from flyvning " + "where pilot_id = " + currentPilot + " " + "and id = " + id);
        if (rs.next ()) {
            _flight.id = rs.getInt (1);
            _flight.nr = rs.getInt (2);
            _flight.dato = new java.util.Date (rs.getLong (3));
            _flight.flytype_id = rs.getInt (4);
            _flight.startart = rs.getString (5);
            _flight.slaebetid = rs.getInt (6);
            _flight.motortid = rs.getInt (7);
            _flight.svaevetid = rs.getInt (8);
            _flight.distance = rs.getInt (9);
            _flight.startsted_id = rs.getInt (10);
            _flight.landingssted_id = rs.getInt (11);
            _flight.note = rs.getString (12);
            _flight.straek = convertFromString (rs.getString (13));
            _flight.udelanding = convertFromString (rs.getString (14));
            _flight.kaptajn = convertFromString (rs.getString (15));
            _flight.instruktoer = convertFromString (rs.getString (16));
            _flight.forsaede = convertFromString (rs.getString (17));
            _flight.passager = convertFromString (rs.getString (18));
            _flight.afbrudtstart = convertFromString (rs.getString (19));
        }
        else _flight = null;
        stmt.close ();
    } catch (SQLException sqle) {
        log.error (sqle);
        _flight = null;
        throw sqle;
    } catch (Exception e) {
        log.error (e);
        _flight = null;
        throw e;
    } finally {
        rs = null;
    }
    return _flight;
}


-----Function Pair=372=-----==

protected void cleanMap () {
    synchronized (session) {
        Transaction tx = session.beginTransaction ();
        try {
            session.createQuery ("delete LearningFilterItem where length(searchString)>" + maxWordLength).setCacheable (false).executeUpdate ();
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in cleanMap: ", e);
            tx.rollback ();
        }
        List < Long > deleteList = new LinkedList < Long > ();
        tx = session.beginTransaction ();
        try {
            SQLQuery query = session.createSQLQuery ("select id FROM LEARNING_FILTER_ITEM");
            query.addScalar ("id", Hibernate.LONG).setCacheable (false);
            List < ? > list = query.list ();
            if (list.size () > maxItems) {
                double ratio = (maxItems * 0.75) / list.size ();
                for (Object object : list) {
                    Long l = (Long) object;
                    if (Math.random () > ratio) {
                        deleteList.add (l);
                    }
                }
            }
            tx.commit ();
        } catch (HibernateException e) {
            log.warn ("Exception in cleanMap: ", e);
            tx.rollback ();
        }
        if (deleteList.size () > 0) {
            long [] ids = new long [deleteList.size ()];
            int index = 0;
            for (Long l : deleteList) {
                ids [index] = l;
                index ++;
            }
            fastDeleteItemsByID (ids);
        }
    }
    fireDataChange (PART.ITEMS);
}


public void testCharsets () throws Exception {
    if (versionMeetsMinimum (4, 1)) {
        try {
            Properties props = new Properties ();
            props.setProperty ("useUnicode", "true");
            props.setProperty ("characterEncoding", "UTF-8");
            Connection utfConn = getConnectionWithProps (props);
            this.stmt = utfConn.createStatement ();
            this.stmt.executeUpdate ("DROP TABLE IF EXISTS t1");
            this.stmt.executeUpdate ("CREATE TABLE t1 (" + "comment CHAR(32) ASCII NOT NULL," + "koi8_ru_f CHAR(32) CHARACTER SET koi8r NOT NULL" + ") CHARSET=latin5");
            this.stmt.executeUpdate ("ALTER TABLE t1 CHANGE comment comment CHAR(32) CHARACTER SET latin2 NOT NULL");
            this.stmt.executeUpdate ("ALTER TABLE t1 ADD latin5_f CHAR(32) NOT NULL");
            this.stmt.executeUpdate ("ALTER TABLE t1 CHARSET=latin2");
            this.stmt.executeUpdate ("ALTER TABLE t1 ADD latin2_f CHAR(32) NOT NULL");
            this.stmt.executeUpdate ("ALTER TABLE t1 DROP latin2_f, DROP latin5_f");
            this.stmt.executeUpdate ("INSERT INTO t1 (koi8_ru_f,comment) VALUES ('a','LAT SMALL A')");
            String cyrillicSmallA = "а";
            this.stmt.executeUpdate ("INSERT INTO t1 (koi8_ru_f,comment) VALUES ('" + cyrillicSmallA + "','CYR SMALL A')");
            this.stmt.executeUpdate ("ALTER TABLE t1 ADD utf8_f CHAR(32) CHARACTER SET utf8 NOT NULL");
            this.stmt.executeUpdate ("UPDATE t1 SET utf8_f=CONVERT(koi8_ru_f USING utf8)");
            this.stmt.executeUpdate ("SET CHARACTER SET koi8r");
            this.rs = this.stmt.executeQuery ("SELECT * FROM t1");
            ResultSetMetaData rsmd = this.rs.getMetaData ();
            int numColumns = rsmd.getColumnCount ();
            for (int i = 0; i < numColumns; i ++) {
                System.out.print (rsmd.getColumnName (i + 1));
                System.out.print ("\t\t");
            }
            System.out.println ();
            while (this.rs.next ()) {
                System.out.println (this.rs.getString (1) + "\t\t" + this.rs.getString (2) + "\t\t" + this.rs.getString (3));
                if (this.rs.getString (1).equals ("CYR SMALL A")) {
                    this.rs.getString (2);
                }
            }
            System.out.println ();
            this.stmt.executeUpdate ("SET NAMES utf8");
            this.rs = this.stmt.executeQuery ("SELECT _koi8r 0xC1;");
            rsmd = this.rs.getMetaData ();
            numColumns = rsmd.getColumnCount ();
            for (int i = 0; i < numColumns; i ++) {
                System.out.print (rsmd.getColumnName (i + 1));
                System.out.print ("\t\t");
            }
            System.out.println ();
            while (this.rs.next ()) {
                System.out.println (this.rs.getString (1).equals ("а") + "\t\t");
                System.out.println (new String (this.rs.getBytes (1), "KOI8_R"));
            }
            char [] c = new char [] {0xd0b0};
            System.out.println (new String (c));
            System.out.println ("а");
        } finally {
        }
    }
}


-----Function Pair=373=-----==

private Vector getHotBarItems () {
    Vector items = new Vector ();
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        conn = dbMan.getPOSConnection ();
        stmt = conn.createStatement ();
        if (stmt.execute ("select * from (SELECT * FROM " + strPOSPrefix + "hotbar WHERE hb_register = '" + getHostName () + "' AND hb_cashier = '" + dbMan.getPOSUser () + "' and hb_building = '" + settings.get (DBSettings.MAIN_BUILDING) + "' ) " + strPOSPrefix + "hotbar inner join (SELECT * FROM " + strPOSPrefix + "items WHERE item_visible = '1') " + strPOSPrefix + "items on ( " + strPOSPrefix + "hotbar.hb_itemid = " + strPOSPrefix + "items.item_id ) order by hb_count desc ")) {
            rs = stmt.getResultSet ();
            while (rs.next ()) {
                OrderItem single;
                int id = rs.getInt ("item_id");
                String name = rs.getString ("item_name");
                String desc = rs.getString ("item_description");
                String category = rs.getString ("item_category");
                String build = rs.getString ("item_building");
                double price = rs.getDouble ("item_price");
                double redPrice = rs.getDouble ("item_reducedprice");
                boolean free = (rs.getString ("item_allowfree").compareTo ("1") == 0);
                boolean reduced = (rs.getString ("item_allowreduced").compareTo ("1") == 0);
                boolean typeA = (rs.getString ("item_istypea").compareTo ("1") == 0);
                int freeBL = rs.getInt ("item_fr_bl");
                single = new OrderItem (id, name, desc, category, build, price, redPrice, free, reduced, typeA, freeBL);
                if (single.completeItem ()) items.add (single);
            }
        }
    } catch (SQLException sqlEx) {
        System.err.println ("SQLException: " + sqlEx.getMessage ());
        System.err.println ("SQLState: " + sqlEx.getSQLState ());
        System.err.println ("VendorError: " + sqlEx.getErrorCode ());
        return null;
    } catch (Exception e) {
        System.err.println ("Exception: " + e.getMessage ());
        System.err.println (e);
        return null;
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (SQLException sqlEx) {
                rs = null;
            }
            if (stmt != null) {
                try {
                    stmt.close ();
                } catch (SQLException sqlEx) {
                    stmt = null;
                }
            }
        }
    }
    return items;
}


public static Vector getIntakeStatus (String student_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        Hashtable statusList = new Hashtable ();
        {
            sql = "select status_id, status_name from study_status";
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                statusList.put (rs.getString (1), rs.getString (2));
            }
        }
        Vector v = new Vector ();
        {
            r.clear ();
            r.add ("sta.student_id", student_id);
            r.add ("sta.session_id", r.unquote ("ses.session_id"));
            r.add ("sta.batch_id", r.unquote ("ses2.session_id"));
            r.add ("sc.student_id", r.unquote ("sta.student_id"));
            r.add ("sta.session_id");
            r.add ("sta.batch_id");
            r.add ("sta.repeat_no");
            r.add ("sta.status");
            r.add ("ses.session_name");
            r.add ("ses2.session_name as batch_session");
            r.add ("sc.period_root_id as period_scheme");
            sql = r.getSQLSelect ("student_course sc, student_status sta, session ses, session ses2", "ses.start_date");
            ResultSet rs = stmt.executeQuery (sql);
            while (rs.next ()) {
                Hashtable h = new Hashtable ();
                h.put ("session_id", rs.getString ("session_id"));
                h.put ("batch_id", rs.getString ("batch_id"));
                h.put ("repeat_no", new Integer (rs.getInt ("repeat_no")));
                String s = rs.getString ("status");
                h.put ("status_id", s != null ? s : "active");
                s = statusList.get (s) != null ? (String) statusList.get (s) : "ACTIVE";
                h.put ("status_name", s);
                h.put ("session_name", rs.getString ("session_name"));
                h.put ("batch_session", rs.getString ("batch_session"));
                h.put ("period_scheme", rs.getString ("period_scheme"));
                v.addElement (h);
            }
        }
        for (int i = 0; i < v.size (); i ++) {
            Hashtable h = (Hashtable) v.elementAt (i);
            String period_scheme = (String) h.get ("period_scheme");
            String batch_id = (String) h.get ("batch_id");
            String session_id = (String) h.get ("session_id");
            sql = "select i.period_id " + "from intake_batch i " + "where i.period_root_id = '" + period_scheme + "' " + "and i.intake_session = '" + batch_id + "' " + "and i.session_id = '" + session_id + "' ";
            ResultSet rs = stmt.executeQuery (sql);
            if (rs.next ()) {
                String period_id = rs.getString (1);
                h.put ("period_id", period_id);
                createPeriodName (h);
            }
        }
        boolean canSetRepeat = true;
        for (int i = v.size () - 1; i > - 1; i --) {
            Hashtable h = (Hashtable) v.elementAt (i);
            int repeat_no = ((Integer) h.get ("repeat_no")).intValue ();
            h.put ("canSetRepeat", new Boolean (canSetRepeat));
            if (repeat_no > 0) {
                canSetRepeat = false;
            }
        }
        return v;
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=374=-----==

public void delUser (User user) throws SQLException, IOException, ClassNotFoundException {
    String dbUserID;
    String stockSymbol;
    Statement stmt = con.createStatement ();
    try {
        con.setAutoCommit (false);
        dbUserID = user.getUserID ();
        if (getUser (dbUserID) != null) {
            ResultSet rs1 = stmt.executeQuery ("SELECT userID, symbol " + "FROM UserStocks WHERE userID = '" + dbUserID + "'");
            while (rs1.next ()) {
                try {
                    stockSymbol = rs1.getString ("symbol");
                    delUserStocks (dbUserID, stockSymbol);
                } catch (SQLException ex) {
                    throw new SQLException ("Deletion of user stock holding failed: " + ex.getMessage ());
                }
            }
            try {
                stmt.executeUpdate ("DELETE FROM Users WHERE " + "userID = '" + dbUserID + "'");
            } catch (SQLException ex) {
                throw new SQLException ("User deletion failed: " + ex.getMessage ());
            }
        }
        else throw new IOException ("User not found in database - cannot delete.");
        try {
            con.commit ();
        } catch (SQLException ex) {
            throw new SQLException ("Transaction commit failed: " + ex.getMessage ());
        }
    } catch (SQLException ex) {
        try {
            con.rollback ();
        } catch (SQLException sqx) {
            throw new SQLException ("Transaction failed then rollback failed: " + sqx.getMessage ());
        }
        throw new SQLException ("Transaction failed; was rolled back: " + ex.getMessage ());
    }
    stmt.close ();
}


private static void translateModel (Class translateClass, int modelRefId, IBaseModel model, ServiceCall call) {
    try {
        if (model.getClass ().equals (translateClass)) {
            try {
                String translation = getReference ().getTranslation (userLanguageRefId, modelRefId, Converter.convertDisplayString (model.getValue (modelRefId)), model.getId (), call);
                if (translation != null) {
                    model.setValue (modelRefId, translation);
                }
            } catch (Exception ex) {
                Log.exception (ex);
            }
        }
    } catch (Exception ex) {
        Log.exception (ex);
    }
}


-----Function Pair=375=-----==

private static void delete (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query2 = entityManager.createQuery ("DELETE FROM Address a");
        query2.executeUpdate ();
        Query query = entityManager.createQuery ("DELETE FROM Person p");
        query.executeUpdate ();
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public RestServiceResult update (RestServiceResult serviceResult, CoScoreQuestion coScoreQuestion) {
    CoScoreQuestionDAO coScoreQuestionDAO = new CoScoreQuestionDAO ();
    try {
        log.info ("Actualizando la calificaci�n para la pregunta: " + coScoreQuestion.getScore ());
        EntityManagerHelper.beginTransaction ();
        coScoreQuestionDAO.update (coScoreQuestion);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coScoreQuestion);
        Object [] arrayParam = {coScoreQuestion.getMaUser ().getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("coScoreQuestion.update.success"), arrayParam));
        log.info ("Se actualizo la calificaci�n con �xito para el usuario: " + coScoreQuestion.getMaUser ().getUserName ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la t�cnica: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


-----Function Pair=376=-----==

public void testNotBetweenQuery () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 NOT BETWEEN 1 AND 3").getResultList ();
        assertEquals (0, result.size ());
        result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE 2 NOT BETWEEN 3 AND 4").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


public void testTrueFalse () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        List result = em.createQuery ("SELECT P.firstName FROM " + Person.class.getName () + " P WHERE false = True").getResultList ();
        assertEquals (0, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=377=-----==

private static void updateandquerywithjpa (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        Query inMemoryQuery = entityManager.createQuery ("SELECT p FROM Person p WHERE p.firstName LIKE :name");
        inMemoryQuery.setParameter ("name", "%-1");
        Collection < Person > imqCollection = (Collection < Person >) inMemoryQuery.getResultList ();
        for (Person person : imqCollection) {
            System.out.println ("found: " + person);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public List < Members > findMembersByHql (String hql, int startrow, int maxrows) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery (hql);
        query.setFirstResult (startrow);
        query.setMaxResults (maxrows);
        List < Members > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=378=-----==

public Object [] executeBatch (String query) throws DException {
    Object [] parsedQuery = null;
    try {
        parsedQuery = (Object []) Parser.parseBatch (query);
    } catch (DException ex) {
        PrintHandler.print (query, verboseUser, ex);
        throw ex;
    }
    Object [] result = new Object [parsedQuery.length];
    for (int i = 0; i < result.length; i ++) {
        PrintHandler.print (" " + parsedQuery [i].toString ());
        if (parsedQuery [i] instanceof insertstatement) {
            if (super.userSession.getTransactionAccessMode ().equals ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            insertstatement in = (insertstatement) parsedQuery [i];
            _StatementExecutionContext sec = getStatementExecutionContext ();
            in.run (sec);
            ParameterInfo [] parameterInfo = in.getParameterInfo ();
            if (parameterInfo != null && parameterInfo.length > 0) {
                ParameterMetaData parameterMetaData = new ParameterMetaData (query, parameterInfo);
                QueryInfo qi = new QueryInfo (parsedQuery [i].toString (), QueryInfo.INSERT, parameterMetaData);
                result [i] = qi;
            }
            else {
                QueryInfo qi = new QueryInfo (parsedQuery [i].toString (), QueryInfo.INSERT, null);
                result [i] = qi;
            }
        }
        else if (parsedQuery [i] instanceof updatestatementsearched) {
            if (super.userSession.getTransactionAccessMode ().equals ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            updatestatementsearched up = (updatestatementsearched) parsedQuery [i];
            _StatementExecutionContext sec = getStatementExecutionContext ();
            up.run (sec);
            ParameterInfo [] parameterInfo = up.getParameterInfo ();
            if (parameterInfo != null && parameterInfo.length > 0) {
                ParameterMetaData parameterMetaData = new ParameterMetaData (query, parameterInfo);
                QueryInfo qu = new QueryInfo (parsedQuery [i].toString (), QueryInfo.UPDATE, parameterMetaData);
                result [i] = qu;
            }
            else {
                QueryInfo qu = new QueryInfo (parsedQuery [i].toString (), QueryInfo.UPDATE, null);
                result [i] = qu;
            }
        }
        else if (parsedQuery [i] instanceof deletestatementsearched) {
            if (super.userSession.getTransactionAccessMode ().equals ("Read Only")) throw new DException ("DSE1184", (Object []) null);
            deletestatementsearched ds = (deletestatementsearched) parsedQuery [i];
            _StatementExecutionContext sec = getStatementExecutionContext ();
            ds.run (sec);
            ParameterInfo [] parameterInfo = ds.getParameterInfo ();
            if (parameterInfo != null && parameterInfo.length > 0) {
                ParameterMetaData parameterMetaData = new ParameterMetaData (query, parameterInfo);
                QueryInfo qd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.DELETE, parameterMetaData);
                result [i] = qd;
            }
            else {
                QueryInfo qd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.DELETE, null);
                result [i] = qd;
            }
        }
        else if (parsedQuery [i] instanceof queryexpression) {
            queryexpression qs = (queryexpression) parsedQuery [i];
            qs.checkSemantic (this, true);
            ParameterInfo [] parameterInfo = qs.getParameterInfo ();
            if (parameterInfo != null && parameterInfo.length > 0) {
                ParameterMetaData parameterMetaData = new ParameterMetaData (query, parameterInfo);
                QueryInfo qsd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.SELECT, parameterMetaData);
                result [i] = qsd;
            }
            else {
                QueryInfo qsd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.SELECT, null);
                result [i] = qsd;
            }
        }
        else if (parsedQuery [i] instanceof SQLcontrolstatement) {
            SQLcontrolstatement cs = (SQLcontrolstatement) parsedQuery [i];
            _StatementExecutionContext sec = getStatementExecutionContext ();
            cs.run (sec);
            ParameterInfo [] parameterInfo = cs.getParameterInfo ();
            if (parameterInfo != null && parameterInfo.length > 0) {
                ParameterMetaData parameterMetaData = new ParameterMetaData (query, parameterInfo);
                QueryInfo qsd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.CALLSTATEMENT, parameterMetaData);
                result [i] = qsd;
            }
            else {
                QueryInfo qsd = new QueryInfo (parsedQuery [i].toString (), QueryInfo.CALLSTATEMENT, null);
                result [i] = qsd;
            }
        }
        else {
            if (parsedQuery [i] instanceof SQLsessionstatement) {
                _StatementExecutionContext sec = getStatementExecutionContext ();
                ((SQLsessionstatement) parsedQuery [i]).run (sec);
            }
            else if (parsedQuery [i] instanceof SQLschemastatement) {
                commit ();
                _ServerSession ss = getSystemServerSession ();
                _DataDictionary dd = getDataDictionary ();
                dd.lockDDL ();
                try {
                    try {
                        ((StatementExecuter) parsedQuery [i]).run (this);
                    } catch (DException ex) {
                        dd.restoreGeneratedKeys ();
                        ss.rollback ();
                        throw ex;
                    }
                    if (! (parsedQuery [i] instanceof dropdatabasestatement)) ss.commit ();
                } finally {
                    dd.releaseDDL ();
                }
                saveModeHandler.write (saveModeSessionId, parsedQuery [i]);
            }
            else if (parsedQuery [i] instanceof SQLdatastatement) {
                throw new DException ("DSE8090", null);
            }
            else if (parsedQuery [i] instanceof declarecursor) {
                declarecursor ds = (declarecursor) parsedQuery [i];
                _StatementExecutionContext sec = getStatementExecutionContext ();
                ds.run (sec);
            }
            else if (parsedQuery [i] instanceof SQLtransactionstatement) {
                SQLtransactionstatement sts = (SQLtransactionstatement) parsedQuery [i];
                sts.run (this);
                saveModeHandler.write (saveModeSessionId, parsedQuery [i]);
            }
            else ((StatementExecuter) parsedQuery [i]).run (this);
            result [i] = new QueryInfo (parsedQuery [i].toString (), QueryInfo.OTHERS, null);
        }
    }
    return result;
}


private void doUpdateTaskX (HttpSession session) {
    Db db = null;
    Connection conn = null;
    String sql = "";
    String user = (String) session.getAttribute ("_portal_login");
    String id = getParam ("task_id");
    String task_description = getParam ("description");
    String year1 = getParam ("year1");
    String month1 = getParam ("month1");
    String day1 = getParam ("day1");
    String hour1 = getParam ("hour1");
    String minute1 = getParam ("minute1");
    String hour2 = getParam ("hour2");
    String minute2 = getParam ("minute2");
    int ispublic = ! "".equals (getParam ("public")) ? Integer.parseInt (getParam ("public")) : 1;
    String task_date = year1 + "-" + fmt (month1) + "-" + fmt (day1);
    String [] invitelist = request.getParameterValues ("invitelist");
    try {
        db = new Db ();
        conn = db.getConnection ();
        Statement stmt = db.getStatement ();
        conn.setAutoCommit (false);
        SQLRenderer r = new SQLRenderer ();
        {
            sql = "UPDATE planner_task SET task_description = '" + task_description + "', " + "task_date = '" + task_date + " WHERE task_id = '" + id + "'";
            stmt.executeUpdate (sql);
        }
        {
            sql = "DELETE FROM planner_task_invite WHERE task_id = '" + id + "' ";
            stmt.executeUpdate (sql);
        }
        if (invitelist != null) {
            for (int i = 0; i < invitelist.length; i ++) {
                r = new SQLRenderer ();
                r.add ("task_id", id);
                r.add ("user_id", invitelist [i]);
                r.add ("inviter_id", user);
                r.add ("allow_edit", 0);
                sql = r.getSQLInsert ("planner_task_invite");
                stmt.executeUpdate (sql);
            }
        }
        conn.commit ();
    } catch (DbException dbex) {
        System.out.println (dbex.getMessage ());
    } catch (SQLException ex) {
        if (conn != null) {
            try {
                conn.rollback ();
            } catch (SQLException rex) {
            }
        }
        System.out.println (ex.getMessage () + sql);
    } finally {
        if (db != null) db.close ();
    }
}


-----Function Pair=379=-----==

public YearOfStudy findByName (String yosName, String academicYearName) throws DBConnectionException, SelectException {
    YearOfStudy yos = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (YearOfStudyDAO.TABLE_NAME + " yos"));
    tablesFrom.add (new SQLWord (HolidaysDAO.TABLE_NAME + " h"));
    tablesFrom.add (new SQLWord (AcademicYearDAO.TABLE_NAME + " ay"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("yos.YEAR_STUDY_NAME", yosName);
    critWhere.addCriterion ("ay.ACADEMIC_YEAR_NAME", academicYearName);
    critWhere.addCriterion ("h.ACADEMIC_YEAR_ID", new SQLWord ("ay.ACADEMIC_YEAR_ID"));
    critWhere.addCriterion ("h.YEAR_STUDY_ID", new SQLWord ("yos.YEAR_STUDY_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                yos = new YearOfStudy (result.getString ("YEAR_STUDY_NAME"));
                yos.setAcaYear (null);
                yos.setDescription (result.getString ("YEAR_STUDY_DESCRIPTION"));
                yos.setDurationSession (result.getFloat ("YEAR_STUDY_DURATION_SESSION"));
                yos.setGroupList (null);
                yos.setHolidays (null);
                yos.setId (result.getInt ("YEAR_STUDY_ID"));
                yos.setNbSessionPM (result.getInt ("YEAR_STUDY_NB_SESSIONPM"));
                yos.setNbSessionsAM (result.getInt ("YEAR_STUDY_NB_SESSIONAM"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return yos;
}


public void setGrantsOnParent (String newSchema) {
    PreparedStatement ps = null;
    ResultSet rs = null;
    Connection parentcon = null;
    boBuildDB dbd;
    try {
        boRepository parentRepository = p_ctx.getBoSession ().getRepository ();
        if (parentRepository != null) {
            parentcon = p_ctx.getConnectionDef ();
            ps = parentcon.prepareStatement ("select tablename from ngtdic where objecttype = 'T'");
            rs = ps.executeQuery ();
            while (rs.next ()) {
                String dml = "grant select, insert, update, delete, references on " + rs.getString (1) + " to " + newSchema;
                executeDDL (dml, parentRepository.getName ());
            }
        }
    } catch (Exception e) {
    } finally {
        try {
            if (rs != null) {
                rs.close ();
            }
        } catch (Exception e) {
        }
        try {
            if (ps != null) {
                ps.close ();
            }
        } catch (Exception e) {
        }
    }
}


-----Function Pair=380=-----==

private void academic_save (HttpSession session) throws Exception {
    Hashtable info = new Hashtable ();
    info.put ("applicant_id", getParam ("applicant_id"));
    Vector examInfo = (Vector) session.getAttribute ("examInfo");
    for (int i = 0; i < examInfo.size (); i ++) {
        Hashtable exam = (Hashtable) examInfo.elementAt (i);
        String exam_id = (String) exam.get ("id");
        Vector subjects = (Vector) exam.get ("subjects");
        for (int k = 0; k < subjects.size (); k ++) {
            Hashtable subject = (Hashtable) subjects.elementAt (k);
            String subject_id = (String) subject.get ("id");
            info.put (subject_id, getParam (subject_id));
        }
    }
    ExamResultData.save (examInfo, info);
}


public void testPrimaryKeyReal0024 () throws Exception {
    Float d [] = {new Float (- 1.0), new Float (1234.543), new Float (0.0), new Float (1), new Float (- 2.0), new Float (0.14), new Float (0.79), new Float (1000000.12345), new Float (- 1000000.12345), new Float (1000000), new Float (- 1000000), new Float (3.4E+38), new Float (3.4E-38)};
    Connection cx = getConnection ();
    dropTable ("#t0024");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("" + "create table #t0024                  " + "  (pk   real not null,             " + "   type char(30) not null,          " + "   b    bit,                        " + "   str  char(30) not null,          " + "   t int identity(1,1), " + "    primary key (pk, type))    ");
    PreparedStatement pStmt = cx.prepareStatement ("insert into #t0024 (pk, type, b, str) values(?, 'prepared', 0, ?)");
    for (int i = 0; i < d.length; i ++) {
        pStmt.setFloat (1, d [i].floatValue ());
        pStmt.setString (2, (d [i]).toString ());
        int preparedCount = pStmt.executeUpdate ();
        assertTrue (preparedCount == 1);
        int adhocCount = stmt.executeUpdate ("" + "insert into #t0024        " + " (pk, type, b, str)      " + " values(" + "   " + d [i] + ",         " + "       'adhoc',          " + "       1,                " + "   '" + d [i] + "')       ");
        assertTrue (adhocCount == 1);
    }
    int count = 0;
    ResultSet rs = stmt.executeQuery ("select * from #t0024 where type='prepared' order by t");
    assertNotNull (rs);
    while (rs.next ()) {
        String s1 = d [count].toString ().trim ();
        String s2 = ("" + rs.getFloat ("pk")).trim ();
        assertTrue (s1.equalsIgnoreCase (s2));
        count ++;
    }
    assertTrue (count == d.length);
    count = 0;
    rs = stmt.executeQuery ("select * from #t0024 where type='adhoc' order by t");
    while (rs.next ()) {
        String s1 = d [count].toString ().trim ();
        String s2 = ("" + rs.getFloat ("pk")).trim ();
        assertTrue (s1.equalsIgnoreCase (s2));
        count ++;
    }
    assertTrue (count == d.length);
}


-----Function Pair=381=-----==

public void testForBrowse0014 () throws Exception {
    Connection cx = getConnection ();
    dropTable ("#t0014");
    Statement stmt = cx.createStatement ();
    stmt.executeUpdate ("create table #t0014 (i integer not null)");
    PreparedStatement pStmt = cx.prepareStatement ("insert into #t0014 values (?)");
    final int rowsToAdd = 100;
    int count = 0;
    for (int i = 1; i <= rowsToAdd; i ++) {
        pStmt.setInt (1, i);
        count += pStmt.executeUpdate ();
    }
    assertTrue (count == rowsToAdd);
    pStmt = cx.prepareStatement ("select i from #t0014 for browse");
    ResultSet rs = pStmt.executeQuery ();
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        int n = rs.getInt ("i");
        count ++;
    }
    assertTrue (count == rowsToAdd);
    rs = stmt.executeQuery ("select * from #t0014");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        int n = rs.getInt ("i");
        count ++;
    }
    assertTrue (count == rowsToAdd);
    rs = stmt.executeQuery ("select * from #t0014");
    assertNotNull (rs);
    count = 0;
    while (rs.next () && count < 5) {
        int n = rs.getInt ("i");
        count ++;
    }
    assertTrue (count == 5);
    rs = stmt.executeQuery ("select * from #t0014");
    assertNotNull (rs);
    count = 0;
    while (rs.next ()) {
        int n = rs.getInt ("i");
        count ++;
    }
    assertTrue (count == rowsToAdd);
}


private void checkNotify (Message msg, Filter filter, SendBuffer msgsender) {
    DBConnection con = getConnection ();
    try {
        Vector nrVect = new Vector ();
        Vector addrVect = new Vector ();
        PreparedStatement stmt = con.prepareStatement ("select recipient, type, split_max from msg_Filter_Forward" + " where filterID=?");
        ResultSet rs = con.executeQuery (stmt, null);
        while (rs.next ()) {
            switch (rs.getInt ("type")) {
                case 1 :
                    addrVect.add (rs.getString ("recipient"));
                case 2 :
                    nrVect.add (rs.getString ("recipient"));
            }
        }
        rs.close ();
        rs = null;
        con.reset ();
        String mobilenr = UserManager.getUserManager ().findUser (userid).getContactInfo ().getMobileNumber ();
        msgsender.sendMsgAsSMS (msg, (String []) nrVect.toArray (new String [nrVect.size ()]), mobilenr, filter.maxNumberOfSMS);
        msgsender.forwardEmail (msg, (String []) addrVect.toArray (new String [addrVect.size ()]));
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        releaseConnection (con);
    }
}


-----Function Pair=382=-----==

private String addVoucher (String voucher) throws UserDBException {
    try {
        _replaced = currentUser.addVoucher (voucher);
        if (_replaced != null) {
            updateVouchersPS.setString (1, currentUser.getVouchers ());
            updateVouchersPS.setString (2, currentUser.getName ());
            if (updateVouchersPS.executeUpdate () != 1) {
                throw new UserDBException ("updateVouchers had no effect");
            }
            currentInputProvider.incrementNVouches ();
            updateNVouchesPS.setInt (1, (currentInputProvider.getNVouches ()));
            updateNVouchesPS.setString (2, voucher);
            if (updateNVouchesPS.executeUpdate () != 1) {
                throw new UserDBException ("updateNVouches had no effect");
            }
            if (! _replaced.equals (voucher)) {
                queryNVouchesPS.setString (1, _replaced);
                rs = queryNVouchesPS.executeQuery ();
                rs.next ();
                _nVouches = rs.getInt ("nvouches") - 1;
                queryNComplaintsPS.setString (1, _replaced);
                rs = queryNComplaintsPS.executeQuery ();
                rs.next ();
                if ((_nVouches == 0) && (rs.getInt ("ncomplaints") == 0)) {
                    deleteInputProviderPS.setString (1, _replaced);
                    if (deleteInputProviderPS.executeUpdate () != 1) {
                        throw new UserDBException ("deleteInputProvider had no effect");
                    }
                }
                else {
                    updateNVouchesPS.setInt (1, _nVouches);
                    updateNVouchesPS.setString (2, _replaced);
                    if (updateNVouchesPS.executeUpdate () != 1) {
                        throw new UserDBException ("updateNVouches had no effect");
                    }
                }
            }
        }
        return _replaced;
    } catch (Exception e) {
        throw new UserDBException (e.getMessage ());
    }
}


private Integer getAcct (String key) throws AdempiereUserError {
    log.fine (key);
    int C_ElementValue_ID = m_nap.getC_ElementValue_ID (key.toUpperCase ());
    if (C_ElementValue_ID == 0) {
        throw new AdempiereUserError ("Account not defined: " + key);
    }
    MAccount vc = MAccount.getDefault (m_as, true);
    vc.setAD_Org_ID (0);
    vc.setAccount_ID (C_ElementValue_ID);
    if (! vc.save ()) {
        throw new AdempiereUserError ("Not Saved - Key=" + key + ", C_ElementValue_ID=" + C_ElementValue_ID);
    }
    int C_ValidCombination_ID = vc.getC_ValidCombination_ID ();
    if (C_ValidCombination_ID == 0) {
        throw new AdempiereUserError ("No account - Key=" + key + ", C_ElementValue_ID=" + C_ElementValue_ID);
    }
    return C_ValidCombination_ID;
}


-----Function Pair=383=-----==

public static Hashtable getEnrollmentInfo (String student_id) throws Exception {
    String session_id = SessionData.getCurrentSessionId ();
    boolean isExist = false;
    Db db = null;
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        String sql = "select batch_id from student_status where session_id = '" + session_id + "' " + "and student_id = '" + student_id + "'";
        ResultSet rs = stmt.executeQuery (sql);
        if (rs.next ()) isExist = true;
    } finally {
        if (db != null) db.close ();
    }
    if (isExist) return getEnrollmentInfo1 (student_id, session_id);
    else return getEnrollmentInfo2 (student_id);
}


private final void loadOntologies (String descrId, DFAgentDescription dfd, Map allOntologies) throws SQLException {
    if (allOntologies != null) {
        List ontos = (List) allOntologies.get (descrId);
        if (ontos != null) {
            Iterator it = ontos.iterator ();
            while (it.hasNext ()) {
                dfd.addOntologies ((String) it.next ());
            }
        }
    }
    else {
        PreparedStatements pss = getPreparedStatements ();
        pss.stm_selOntologies.setString (1, descrId);
        ResultSet rs = pss.stm_selOntologies.executeQuery ();
        while (rs.next ()) {
            dfd.addOntologies (rs.getString (ONTOLOGY));
        }
        closeResultSet (rs);
    }
}


-----Function Pair=384=-----==

private static void executeStatement (Connection conn, int lineNumber, String sqlStatement) throws MigrationException {
    Statement st = null;
    try {
        st = conn.createStatement ();
        st.execute (sqlStatement);
    } catch (SQLException e) {
        throw new MigrationException ("Failed to execute SQL line #" + lineNumber + ": " + sqlStatement, e);
    } finally {
        if (st != null) try {
            st.close ();
        } catch (SQLException e) {
            logger.log (Level.WARNING, "Failed to close statement, might be leaking them", e);
        }
    }
}


public static int executeUpdateQuery (Query q, Session em) throws Exception {
    Transaction t = null;
    int ret = - 1;
    try {
        t = em.beginTransaction ();
        ret = q.executeUpdate ();
        t.commit ();
        return ret;
    } catch (Exception e) {
        try {
            t.rollback ();
        } catch (Exception ee) {
        }
        throw e;
    }
}


-----Function Pair=385=-----==

public static Biodata getBiodata (String student_id) throws Exception {
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("b.phone_no_permanent");
        r.add ("b.phone_no");
        r.add ("b.phone_mobile");
        r.add ("disability");
        r.add ("g.code");
        r.add ("g.gender_name");
        r.add ("m.code");
        r.add ("m.status_name");
        r.add ("re.code");
        r.add ("re.religion_name");
        r.add ("r.code");
        r.add ("r.race_name");
        r.add ("n.code");
        r.add ("n.nationality_name");
        r.add ("b.birth_date");
        r.add ("b.icno");
        r.add ("b.guardian_name");
        r.add ("b.guardian_address1");
        r.add ("b.guardian_address2");
        r.add ("s.name");
        r.add ("b.student_id", student_id);
        r.add ("g.code", r.unquote ("b.gender"));
        r.add ("m.code", r.unquote ("b.marriage_status"));
        r.add ("re.code", r.unquote ("b.religion"));
        r.add ("r.code", r.unquote ("b.race"));
        r.add ("n.code", r.unquote ("b.nationality"));
        r.add ("b.student_id", r.unquote ("s.id"));
        sql = r.getSQLSelect ("student s,student_biodata b, race_code r, nationality_code n, religion_code re, marital_code m, gender_code g");
        ResultSet rs = stmt.executeQuery (sql);
        Biodata biodata = new Biodata ();
        if (rs.next ()) {
            biodata.setPhoneNumberPermanent (rs.getString (1));
            biodata.setPhoneNumber (rs.getString (2));
            biodata.setPhoneMobile (rs.getString (3));
            String disability = rs.getString (4);
            biodata.setDisability ("1".equals (disability) ? false : true);
            Code gender = new GenderCode ();
            gender.setCode (rs.getString (5));
            gender.setName (rs.getString (6));
            biodata.setGender (gender);
            Code marital = new MaritalCode ();
            marital.setCode (rs.getString (7));
            marital.setName (rs.getString (8));
            biodata.setMaritalStatus (marital);
            Code religion = new ReligionCode ();
            religion.setCode (rs.getString (9));
            religion.setName (rs.getString (10));
            biodata.setReligion (religion);
            Code race = new RaceCode ();
            race.setCode (rs.getString (11));
            race.setName (rs.getString (12));
            biodata.setRace (race);
            Code nationality = new NationalityCode ();
            nationality.setCode (rs.getString (13));
            nationality.setName (rs.getString (14));
            biodata.setNationality (nationality);
            biodata.setGuardianName (rs.getString ("guardian_name"));
            biodata.setGuardianAddress1 (rs.getString ("guardian_address1"));
            biodata.setGuardianAddress2 (rs.getString ("guardian_address2"));
            biodata.setBirthDate (Db.getDate (rs, "birth_date"));
            biodata.setIcno (Db.getString (rs, "icno"));
            biodata.setName (Db.getString (rs, "name"));
        }
        else {
        }
        return biodata;
    } finally {
        if (db != null) db.close ();
    }
}


public SukuData deletePerson (int pid) {
    SukuData res = new SukuData ();
    String sqlrlang = "delete from relationlanguage where rid in " + "(select rid from relation where pid = ?)";
    String sqlrnoti = "delete from relationnotice where rid in " + "(select rid from relation where pid = ?)";
    String sqlr = "delete from relation where rid in " + "(select rid from relation where pid = ?)";
    String sqlul = "delete from unitlanguage where pid = ?";
    String sqlun = "delete from unitnotice where pid = ? ";
    String sqlu = "delete from unit where pid=?";
    try {
        PreparedStatement pst = con.prepareStatement (sqlrlang);
        pst.setInt (1, pid);
        int lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] relationlanguage count:" + lukuri);
        pst.close ();
        pst = con.prepareStatement (sqlrnoti);
        pst.setInt (1, pid);
        lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] relationnotice count:" + lukuri);
        pst.close ();
        pst = con.prepareStatement (sqlr);
        pst.setInt (1, pid);
        lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] relation count:" + lukuri);
        pst.close ();
        pst = con.prepareStatement (sqlul);
        pst.setInt (1, pid);
        lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] unitlanguage count:" + lukuri);
        pst.close ();
        pst = con.prepareStatement (sqlun);
        pst.setInt (1, pid);
        lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] unitnotice count:" + lukuri);
        pst.close ();
        pst = con.prepareStatement (sqlu);
        pst.setInt (1, pid);
        lukuri = pst.executeUpdate ();
        logger.fine ("Deleted [" + pid + "] unit count:" + lukuri);
        pst.close ();
    } catch (SQLException e) {
        res.resu = e.getMessage ();
        logger.log (Level.WARNING, "Deleting person " + pid, e);
        e.printStackTrace ();
    }
    return res;
}


-----Function Pair=386=-----==

public boolean updateBookmark (BookmarkReference bookmark) throws SQLException {
    Object [] bindVariables = new Object [5];
    int [] types = new int [5];
    types [0] = Types.VARCHAR;
    types [1] = Types.BOOLEAN;
    types [2] = Types.VARCHAR;
    types [2] = Types.VARCHAR;
    types [4] = Types.BIGINT;
    bindVariables [0] = bookmark.getName ();
    bindVariables [1] = Boolean.valueOf (bookmark.isFavorite ());
    bindVariables [2] = bookmark.getPath ();
    ColorLabel colorLabel = bookmark.getColorLabel ();
    bindVariables [3] = colorLabel == null ? null : colorLabel.name ();
    bindVariables [4] = new Long (bookmark.getId ());
    PreparedStatement preparedStatement = null;
    try {
        preparedStatement = embeddedConnection.prepareStatement (BOOKMARK_UPDATE_LITE);
        for (int i = 0; i < bindVariables.length; i ++) {
            if (bindVariables [i] == null) {
                preparedStatement.setNull (i + 1, types [i]);
            }
            else {
                preparedStatement.setObject (i + 1, bindVariables [i]);
            }
        }
        int affected = preparedStatement.executeUpdate ();
        return affected == 1;
    } finally {
        if (preparedStatement != null) {
            try {
                preparedStatement.close ();
            } catch (SQLException ignored) {
            }
        }
    }
}


public Collection < PersisterRecord > getObjects (Class cls) throws PersisterException {
    List < PersisterRecord > list = new ArrayList < PersisterRecord > ();
    Connection conn = null;
    PreparedStatement ps = null;
    ResultSet rs = null;
    Serializable obj = null;
    try {
        conn = _ds.getConnection ();
        conn.setAutoCommit (true);
        ps = conn.prepareStatement ("select " + _data_col + "," + _ts_col + " from " + _table_name);
        rs = ps.executeQuery ();
        while (rs.next ()) {
            obj = deserialize (rs.getBinaryStream (_data_col));
            if (rs.wasNull ()) {
                continue;
            }
            long ts = rs.getLong (_ts_col);
            if (rs.wasNull ()) {
                continue;
            }
            if ((cls == null) || ! cls.isAssignableFrom (obj.getClass ())) {
                continue;
            }
            list.add (new PersisterRecord (obj, ts));
        }
        return list;
    } catch (Throwable th) {
        throw new PersisterException ("Failed to get objects from DB", th);
    } finally {
        if (rs != null) {
            try {
                rs.close ();
            } catch (Throwable th) {
            }
        }
        if (ps != null) {
            try {
                ps.close ();
            } catch (Throwable th) {
            }
        }
        if (conn != null) {
            try {
                conn.close ();
            } catch (Throwable th) {
            }
        }
    }
}


-----Function Pair=387=-----==

public static void delete (String name) {
    Session session = sessionFactory.openSession ();
    session.getTransaction ().begin ();
    Transaction tx = null;
    try {
        tx = session.beginTransaction ();
        String hql = "delete from de.anhquan.demo.hibernate.helloworld.Order where name = :name";
        Query query = session.createQuery (hql);
        query.setParameter ("name", name);
        int row = query.executeUpdate ();
        if (row == 0) {
            System.out.println ("Doesn't deleted any row!");
        }
        else {
            System.out.println ("Deleted Row: " + row);
        }
        tx.commit ();
    } catch (RuntimeException e) {
        if (tx != null && tx.isActive ()) {
            try {
                tx.rollback ();
            } catch (HibernateException e1) {
                System.out.println ("Error rolling back transaction");
            }
            throw e;
        }
    }
}


public double getSumaPuntosRivales (int idPareo, int idDivision) {
    double puntaje = 0;
    String sql;
    try {
        sql = " SELECT SUM(C.puntajeTotal) " + " FROM jugadorxDivision C " + " WHERE C.divisionxTorneo_idDivisionxTorneo = " + idDivision + " AND C.numeroId IN (SELECT DISTINCT A.idPareoRival " + " FROM jugadorxdivxronda A, jugadorxDivision B " + " WHERE A.idPareo = " + idPareo + " AND B.divisionxTorneo_idDivisionxTorneo = " + idDivision + " AND A.jugadorxDivision_idJugadorxDivision = B.idJugadorxDivision)";
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            puntaje = populatePuntaje (resultSet);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return puntaje;
}


-----Function Pair=388=-----==

public String getClobString (String fieldName) throws DataException {
    java.io.Reader is = this.getClobStream (fieldName);
    if (is == null) {
        return null;
    }
    FastStringBuffer fsb = FastStringBuffer.getInstance ();
    try {
        char [] buf = new char [1024];
        int bytesRead;
        while ((bytesRead = is.read (buf)) != - 1) {
            fsb.append (buf, 0, bytesRead);
        }
        return fsb.toString ();
    } catch (java.io.IOException ex) {
        throw new DataException ("I/O Exception reading Character Stream");
    } finally {
        fsb.release ();
    }
}


public Collection < String > listKeys (String table) {
    Collection < String > result = new ArrayList < String > ();
    ResultSet rs = null;
    try {
        DatabaseMetaData dbm = getConnection ().getMetaData ();
        rs = dbm.getPrimaryKeys (null, null, table);
        while (rs.next ()) {
            String str = rs.getString ("COLUMN_NAME");
            result.add (str);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return result;
}


-----Function Pair=389=-----==

public WardListDocument getWardList (String hospitalNo) {
    ResultSet rsList = null;
    WardListDocument doc = null;
    try {
        helper = new DBHelper ();
        doc = WardListDocument.Factory.newInstance ();
        doc.addNewWardList ();
        PreparedStatement psList = helper.prepareStatement (SQL.getWardList ());
        psList.setString (1, hospitalNo);
        rsList = psList.executeQuery ();
        while (rsList.next ()) {
            Ward i = doc.getWardList ().addNewWard ();
            i.setWard (rsList.getString ("WARD"));
            i.setWardno (rsList.getString ("WARDNO"));
            i.setWardDescription (rsList.getString ("WARDDESCRIPTION"));
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (rsList != null) {
                rsList.close ();
            }
            if (helper != null) {
                helper.cleanup ();
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    return doc;
}


public Integer getAllProjectTodoCount (int projectId, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("select count(*) from ");
        hqlSB.append (DoTodo.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        if (filters != null && filters.length != 0) {
            hqlSB.append (" and ");
        }
        else {
            hqlSB.append (" where ");
        }
        hqlSB.append (" doProject.id = '" + projectId + "'");
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=390=-----==

public void setSuspended (String jobid) {
    Session session = sessionFactory.openSession ();
    Transaction tx = session.beginTransaction ();
    try {
        Query update = session.createQuery ("update Task task " + "set task.suspended = :suspended" + " where task.jobid = :jobid");
        update.setParameter ("suspended", "yes");
        update.setParameter ("jobid", jobid);
        update.executeUpdate ();
        session.flush ();
        session.clear ();
        tx.commit ();
    } catch (RuntimeException e) {
        tx.rollback ();
        e.printStackTrace ();
    } finally {
        session.close ();
    }
}


public Onlinetime findOnlinetimeById (int onlinetimeId) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Onlinetime onlinetime = (Onlinetime) session.get (Onlinetime.class, onlinetimeId);
        tr.commit ();
        return onlinetime;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=391=-----==

public Enumeration getSubscriptions () {
    Vector subscriptions = new Vector ();
    StringACLCodec codec = new StringACLCodec ();
    ResultSet rs = null;
    try {
        rs = getPreparedStatements ().stm_selSubscriptions.executeQuery ();
        while (rs.next ()) {
            String base64Str = rs.getString ("aclm");
            String aclmStr = new String (Base64.decodeBase64 (base64Str.getBytes ("US-ASCII")), "US-ASCII");
            ACLMessage aclm = codec.decode (aclmStr.getBytes (), ACLCodec.DEFAULT_CHARSET);
            subscriptions.add (sr.createSubscription (aclm));
        }
    } catch (Exception e) {
        if (logger.isLoggable (Logger.SEVERE)) logger.log (Logger.SEVERE, "Error retrieving subscriptions from the database", e);
    } finally {
        closeResultSet (rs);
    }
    return subscriptions.elements ();
}


public ArrayList getAllMsg (String name, String group) {
    System.out.println ("Getting mail for user: " + name + ",Group: " + group);
    ArrayList aList = new ArrayList ();
    mail mail = null;
    PreparedStatement pstmt;
    try {
        pstmt = getCon ().prepareStatement ("select * from mail where toid = ? and gname = ?");
        pstmt.setString (1, name);
        pstmt.setString (2, group);
        ResultSet rs = pstmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                mail = new mail (rs.getInt ("pmid"), rs.getString ("title"), rs.getString ("fromid"), rs.getString ("stat"), rs.getString ("pmdatetime"));
                aList.add (mail);
            }
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    }
    return aList;
}


-----Function Pair=392=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName (person.getFirstName () + "-1");
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public boolean actualizarEstadoEliminacion (int idTorneo) {
    int intResult = 0;
    String sql = "UPDATE torneo " + " SET  terminado = 3 WHERE idTorneo= " + idTorneo;
    try {
        connection = conexionBD.getConnection ();
        connection.setAutoCommit (false);
        ps = connection.prepareStatement (sql);
        intResult = ps.executeUpdate ();
        connection.commit ();
    } catch (SQLException ex) {
        ex.printStackTrace ();
        try {
            connection.rollback ();
        } catch (SQLException exe) {
            exe.printStackTrace ();
        }
    } finally {
        conexionBD.close (ps);
        conexionBD.close (connection);
    }
    return (intResult > 0);
}


-----Function Pair=393=-----==

public RestServiceResult search (RestServiceResult serviceResult, Long nPostagId) {
    MaPostag maPostag = new MaPostagDAO ().findById (nPostagId);
    if (maPostag == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("postag.search.notFound"));
    }
    else {
        List < MaPostag > list = new ArrayList < MaPostag > ();
        EntityManagerHelper.refresh (maPostag);
        list.add (maPostag);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("postag.search.success"), arrayParam));
        serviceResult.setObjResult (list);
    }
    return serviceResult;
}


public RestServiceResult search (RestServiceResult serviceResult, Long nCheckListFormId) {
    MaSingleTextCheckList maSingleTextCheckList = new MaSingleTextCheckListDAO ().findById (nCheckListFormId);
    if (maSingleTextCheckList == null) {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("checkList.search.notFound"));
    }
    else {
        List < MaSingleTextCheckList > list = new ArrayList < MaSingleTextCheckList > ();
        EntityManagerHelper.refresh (maSingleTextCheckList);
        list.add (maSingleTextCheckList);
        Object [] arrayParam = {list.size ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.search.success"), arrayParam));
        serviceResult.setObjResult (list);
        serviceResult.setNumResult (list.size ());
    }
    return serviceResult;
}


-----Function Pair=394=-----==

public Collection returnOpts (Collection opt_collect, Collection role_res_opt_collect) {
    Collection opt_collect_isOpt = new ArrayList ();
    Iterator opt_iterator = opt_collect.iterator ();
    if (role_res_opt_collect == null) {
        return opt_collect;
    }
    Iterator perm_iterator = role_res_opt_collect.iterator ();
    long opt_id = - 1;
    long perm_opt_id = 0;
    while (opt_iterator.hasNext ()) {
        Operation opt = (Operation) opt_iterator.next ();
        opt_id = opt.getId ();
        while (perm_iterator.hasNext ()) {
            RolePermission role_perm = (RolePermission) perm_iterator.next ();
            perm_opt_id = role_perm.getResopid ();
            if (perm_opt_id == opt_id) {
                opt.setOpt (true);
                break;
            }
        }
        perm_iterator = role_res_opt_collect.iterator ();
        opt_collect_isOpt.add (opt);
    }
    return opt_collect_isOpt;
}


public synchronized RemoteFileState storeFetched (RemoteFileState in, MirrorReturn fetched, Exception exOrNull) throws Exception {
    _logger.trace ("Storing as fetched (" + in.filename + ")");
    if (trialRun) return in;
    Db db = getDb ();
    try {
        db.begin ();
        boolean success = (fetched != null);
        Integer localFileStateId = null;
        if (fetched != null) {
            localFileStateId = fetched.local.local_file_state_id;
        }
        if (success) {
            in.state = FileStates.SUCCESS;
        }
        else {
            if (exOrNull == null) {
                in.state = FileStates.FAILURE;
            }
            else {
                in.state = FileStates.ERROR_RETRY;
                in.retry_count ++;
            }
        }
        ps_update.setInt (1, in.state.getId ());
        ps_update.setInt (2, in.retry_count);
        ps_update.setLong (3, in.last_modified);
        String m = null;
        if (exOrNull != null) m = exOrNull.getMessage ();
        ps_update.setString (4, m);
        ps_update.setObject (5, localFileStateId);
        ps_update.setInt (6, in.remote_file_state_id);
        db.executeUpdate (ps_update);
        updateMetadataInTx (in);
        return in;
    } catch (Exception e) {
        db.rollback ();
        throw e;
    } finally {
        db.commitUnless ();
    }
}


-----Function Pair=395=-----==

public ArrayList < jugador > listarJugadoresxDivision (int idDivision) {
    ArrayList < jugador > todosJugadores = new ArrayList < jugador > ();
    try {
        String sql = " SELECT * FROM jugador A, jugadorxdivision B" + " WHERE A.idJugador = B.jugador_idJugador " + " AND divisionxTorneo_idDivisionxTorneo = " + idDivision;
        connection = conexionBD.getConnection ();
        statement = connection.createStatement ();
        resultSet = statement.executeQuery (sql);
        while (resultSet.next ()) {
            this.elJugador = new jugador ();
            populateJugadores (resultSet);
            todosJugadores.add (this.elJugador);
        }
    } catch (SQLException ex) {
        ex.printStackTrace ();
    } finally {
        conexionBD.close (resultSet);
        conexionBD.close (statement);
        conexionBD.close (connection);
    }
    return todosJugadores;
}


private static void executeSQLScript () {
    File f = new File (System.getProperty ("user.dir") + "/resources/umc.sql");
    if (f.exists ()) {
        Connection con = null;
        PreparedStatement pre_stmt = null;
        try {
            Class.forName ("org.sqlite.JDBC");
            con = DriverManager.getConnection ("jdbc:sqlite:database/umc.db", "", "");
            BufferedReader br = new BufferedReader (new FileReader (f));
            String line = "";
            con.setAutoCommit (false);
            while ((line = br.readLine ()) != null) {
                if (! line.equals ("") && ! line.startsWith ("--") && ! line.contains ("--")) {
                    log.debug (line);
                    pre_stmt = con.prepareStatement (line);
                    pre_stmt.executeUpdate ();
                }
            }
            con.commit ();
            File dest = new File (f.getAbsolutePath () + ".executed");
            if (dest.exists ()) dest.delete ();
            f.renameTo (dest);
            f.delete ();
        } catch (Throwable exc) {
            log.error ("Fehler bei Ausführung der SQL Datei", exc);
            try {
                con.rollback ();
            } catch (SQLException exc1) {
            }
        } finally {
            try {
                if (pre_stmt != null) pre_stmt.close ();
                if (con != null) con.close ();
            } catch (SQLException exc2) {
                log.error ("Fehler bei Ausführung von SQL Datei", exc2);
            }
        }
    }
}


-----Function Pair=396=-----==

public List < Map < String, Object > > prepareCallForList (String sql, Object obj []) {
    if (debug) System.out.println (sql);
    Connection connection = null;
    connection = this.getConnection ();
    CallableStatement cstmt = null;
    try {
        if (connection != null && ! connection.isClosed ()) {
            cstmt = connection.prepareCall (sql);
            for (int i = 0; i < obj.length; i ++) {
                cstmt.setString (i + 1, obj [i].toString ());
            }
            cstmt.executeQuery ();
            if (cstmt.getMoreResults ()) {
                return this.resultSetToMapList (cstmt.getResultSet ());
            }
            return this.resultSetToMapList (cstmt.getResultSet ());
        }
    } catch (SQLException e) {
        log.error ("执行查询语句错误！", e);
        System.out.println (sql);
        System.out.println ("执行查询语句错误！");
    } finally {
        try {
            cstmt.close ();
            connection.close ();
        } catch (SQLException e) {
            log.error ("未能正确关闭数据库连接！", e);
            System.out.println ("未能正确关闭数据库连接！");
        }
    }
    return null;
}


private static void insert (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Order order = new Order ();
        order.setClient ("Henry Ford");
        OrderItem item1 = new OrderItem ();
        item1.setArticle ("wheel");
        item1.setQuantity (100);
        item1.setPrice (10);
        item1.setOrder (order);
        order.getItems ().add (item1);
        OrderItem item2 = new OrderItem ();
        item2.setArticle ("front window");
        item2.setQuantity (30);
        item2.setPrice (70);
        item2.setOrder (order);
        order.getItems ().add (item2);
        entityManager.persist (order);
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=397=-----==

public int importMbox (String sMboxFilePath) throws FileNotFoundException, IOException, MessagingException {
    MimeMessage oMsg;
    InputStream oMsgStrm;
    Session oSession = ((DBStore) getStore ()).getSession ();
    MboxFile oInputMbox = new MboxFile (sMboxFilePath, MboxFile.READ_ONLY);
    final int iMsgCount = oInputMbox.getMessageCount ();
    for (int m = 0; m < iMsgCount; m ++) {
        oMsgStrm = oInputMbox.getMessageAsStream (m);
        oMsg = new MimeMessage (oSession, oMsgStrm);
        appendMessage (oMsg);
        oMsgStrm.close ();
    }
    oInputMbox.close ();
    return iMsgCount;
}


public Atividade insertAtividade (Atividade atividade) throws SQLException {
    Connection conn = null;
    String insert = "insert into Atividade (idatividade, requerente_idrequerente, datacriacao, datatermino, valor, tipoatividade, descricao, fase_idfase, estado) " + "values " + "(nextval('seq_atividade'), " + atividade.getRequerente ().getIdRequerente () + ", " + "'" + atividade.getDataCriacao () + "', '" + atividade.getDataTermino () + "', '" + atividade.getValor () + "', '" + atividade.getTipoAtividade ().getIdTipoAtividade () + "', '" + atividade.getDescricao () + "', " + atividade.getFaseIdFase () + ", " + atividade.getEstado () + ")";
    try {
        conn = connectionFactory.getConnection (true);
        conn.setAutoCommit (false);
        Statement stmt = conn.createStatement ();
        Integer result = stmt.executeUpdate (insert);
        if (result == 1) {
            String sqlSelect = "select last_value from seq_atividade";
            ResultSet rs = stmt.executeQuery (sqlSelect);
            while (rs.next ()) {
                atividade.setIdAtividade (rs.getInt ("last_value"));
            }
        }
        conn.commit ();
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } finally {
        conn.close ();
    }
    return null;
}


-----Function Pair=398=-----==

public static void ZipFiles (File zipfile, File [] files) throws IOException {
    byte [] buffer = new byte [1024];
    FileOutputStream fos = new FileOutputStream (zipfile);
    ZipOutputStream zos = new ZipOutputStream (fos);
    for (int i = 0; i < files.length; i ++) {
        File src = files [i];
        FileInputStream fis = new FileInputStream (src);
        ZipEntry entry = new ZipEntry (src.getName ());
        zos.putNextEntry (entry);
        int length;
        while ((length = fis.read (buffer)) > 0) {
            zos.write (buffer, 0, length);
        }
        zos.closeEntry ();
        fis.close ();
    }
    zos.close ();
}


public List getAllProjectCustomerPagination (Integer customerId, int offset, int limit, String sort, String order, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        StringBuffer hqlSB = new StringBuffer ();
        hqlSB.append ("from ");
        hqlSB.append (DoProjectCustomer.class.getName ());
        hqlSB.append (" where ");
        hqlSB.append (" doCustomer.id = '" + customerId + "' and");
        hqlSB.append (" doProject.id in (");
        hqlSB.append (" select data.id from ");
        hqlSB.append (AcDataProject.class.getName ());
        hqlSB.append (getWhereStatement (filters));
        hqlSB.append (") order by " + sort + " " + order);
        Query queryObject = getSession ().createQuery (hqlSB.toString ());
        queryObject.setFirstResult (offset);
        queryObject.setMaxResults (limit);
        List rtn = queryObject.list ();
        tx.commit ();
        return rtn;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=399=-----==

public boolean copy (long id) {
    boolean bool = false;
    this.result = null;
    Connection conn = null;
    Object vo = null;
    try {
        PojoParser parser = PojoParser.getInstances ();
        conn = ConnectUtil.getConnect ();
        conn.setAutoCommit (false);
        String sql = SqlUtil.getInsertSql (this.getCls ());
        vo = this.findById (conn, "select * from " + parser.getTableName (cls) + " where " + parser.getPriamryKey (cls) + "=" + id);
        String pk = parser.getPriamryKey (cls);
        this.getClass ().getMethod ("set" + SqlUtil.getFieldName (pk), new Class [] {long.class}).invoke (vo, new Object [] {0});
        PreparedStatement ps = conn.prepareStatement (sql);
        setPsParams (ps, vo);
        ps.executeUpdate ();
        ps.close ();
        conn.commit ();
        bool = true;
    } catch (Exception e) {
        try {
            conn.rollback ();
        } catch (Exception ex) {
        }
        this.result = e.getMessage ();
    } finally {
        this.closeConnectWithTransaction (conn);
    }
    return bool;
}


private void populateProperties (int limit, Element propSet, long gid, int namespaceId, StringBuffer response, boolean wfplugin) throws SQLException {
    if (! wfplugin && propSet == null) {
        return;
    }
    if (PERFORMANCE_DEBUG) {
        timer.start ();
    }
    String allAttr = (propSet == null) ? null : propSet.getAttribute ("all");
    boolean all_attrs = wfplugin || ((allAttr != null) && allAttr.toString ().equals (trueAttribute ()));
    String elements = "properties";
    String statement = null;
    if (all_attrs) {
        statement = getDAO ().getStatement (PropertyTypeDb.TABLE_KEY, "GET_TERM_PROPERTY_ALL");
        statement = getDAO ().getStatement (statement, 1, String.valueOf (gid));
        statement = getDAO ().getStatement (statement, 2, String.valueOf (limit));
        buildProperties (limit, statement, namespaceId, response, false);
    }
    else {
        List termList = new ArrayList ();
        getPropertyValueIds (propSet, termList);
        buildProperties (limit, gid, namespaceId, response, termList, "TERM");
    }
    if (PERFORMANCE_DEBUG) {
        timer.stop ();
        System.out.println ("populating properties: " + timer.read ());
    }
}


-----Function Pair=400=-----==

private boolean doTransaction (String statement, Statement st, int id, int namespaceId, DTSPermission permit, char attrType, char editType) throws SQLException {
    int defaultLevel = conn.getTransactionIsolation ();
    conn.setAutoCommit (false);
    conn.setTransactionIsolation (Connection.TRANSACTION_READ_COMMITTED);
    boolean success = false;
    int result = 0;
    try {
        if (editType == WFPlugin.EDIT_DELETE) {
            getTermWF (permit).update (id, namespaceId, permit, attrType, editType);
        }
        if (statement == null) {
            result = ((PreparedStatement) st).executeUpdate ();
        }
        else {
            result = st.executeUpdate (statement);
        }
        success = (result == 1) ? true : false;
        if (! success) {
            conn.rollback ();
            return success;
        }
        if (editType != WFPlugin.EDIT_DELETE) {
            getTermWF (permit).update (id, namespaceId, permit, attrType, editType);
        }
        conn.commit ();
        return success;
    } catch (SQLException e) {
        conn.rollback ();
        throw e;
    } catch (Exception e) {
        conn.rollback ();
        throw new SQLException ("unable to update concept: id " + id + " namespaceId: " + namespaceId + " edit mode:" + editType);
    } finally {
        conn.setTransactionIsolation (defaultLevel);
        conn.setAutoCommit (true);
    }
}


public boolean checkGlobalConstraint (Document d, GlobalConstraint gc) {
    try {
        String queryString = "SELECT sum(" + gc.attributeName + ") " + "FROM " + gc.tableName + " " + "WHERE " + gc.condition;
        SqlDb d2 = (SqlDb) d;
        Statement stm1 = getConnection ().createStatement ();
        Statement stm2 = d2.getConnection ().createStatement ();
        Chrono.setMode (Chrono.QUERY_MODE);
        ResultSet rs1 = stm1.executeQuery (queryString);
        ResultSet rs2 = stm2.executeQuery (queryString);
        rs1.next ();
        rs2.next ();
        int val1 = Integer.parseInt (rs1.getString (1));
        int val2 = Integer.parseInt (rs2.getString (1));
        Chrono.setMode (Chrono.CPU_MODE);
        stm1.close ();
        stm2.close ();
        return (Math.abs (val1 - val2) <= gc.distortion);
    } catch (Exception e) {
        logger.fatal (e);
        return false;
    }
}


