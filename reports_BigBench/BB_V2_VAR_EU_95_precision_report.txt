Found 27/400 pairs as clones in the BCB
-----Function Pair=1=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.SaveccmDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.SaveccmDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            Switch model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, SwitchEditPart.MODEL_ID, SaveccmDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (se.mdh.mrtc.saveccm.swi.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (se.mdh.mrtc.saveccm.swi.diagram.part.SaveccmDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        SaveccmDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.SudokuDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.SudokuDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            Puzzle model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, PuzzleEditPart.MODEL_ID, SudokuDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (no.uia.sudoku.diagram.part.SudokuDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (no.uia.sudoku.diagram.part.SudokuDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                SudokuDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        SudokuDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=2=-----==

static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


-----Function Pair=3=-----==

private ScrollingGraphicalViewer createGraphicalViewer (final Composite parent) {
    final ScrollingGraphicalViewer viewer = new ScrollingGraphicalViewer ();
    viewer.createControl (parent);
    _root = new EditRootEditPart ();
    viewer.setRootEditPart (_root);
    getEditDomain ().addViewer (viewer);
    getSite ().setSelectionProvider (viewer);
    viewer.setEditPartFactory (getEditPartFactory ());
    final KeyHandler keyHandler = new GraphicalViewerKeyHandler (viewer) {
        @SuppressWarnings ("unchecked")
        @Override
        public boolean keyPressed (final KeyEvent event) {
            if (event.stateMask == SWT.MOD1 && event.keyCode == SWT.DEL) {
                final List < ? extends EditorPart > objects = viewer.getSelectedEditParts ();
                if (objects == null || objects.isEmpty ()) return true;
                final GroupRequest deleteReq = new GroupRequest (RequestConstants.REQ_DELETE);
                final CompoundCommand compoundCmd = new CompoundCommand ("Delete");
                for (int i = 0; i < objects.size (); i ++) {
                    final EditPart object = (EditPart) objects.get (i);
                    deleteReq.setEditParts (object);
                    final Command cmd = object.getCommand (deleteReq);
                    if (cmd != null) compoundCmd.add (cmd);
                }
                getCommandStack ().execute (compoundCmd);
                return true;
            }
            if (event.stateMask == SWT.MOD3 && (event.keyCode == SWT.ARROW_DOWN || event.keyCode == SWT.ARROW_LEFT || event.keyCode == SWT.ARROW_RIGHT || event.keyCode == SWT.ARROW_UP)) {
                final List < ? extends EditorPart > objects = viewer.getSelectedEditParts ();
                if (objects == null || objects.isEmpty ()) return true;
                final GroupRequest moveReq = new ChangeBoundsRequest (RequestConstants.REQ_MOVE);
                final CompoundCommand compoundCmd = new CompoundCommand ("Move");
                for (int i = 0; i < objects.size (); i ++) {
                    final EditPart object = (EditPart) objects.get (i);
                    moveReq.setEditParts (object);
                    final LocationCommand cmd = (LocationCommand) object.getCommand (moveReq);
                    if (cmd != null) {
                        cmd.setLocation (new Point (event.keyCode == SWT.ARROW_LEFT ? - 1 : event.keyCode == SWT.ARROW_RIGHT ? 1 : 0, event.keyCode == SWT.ARROW_DOWN ? 1 : event.keyCode == SWT.ARROW_UP ? - 1 : 0));
                        cmd.setRelative (true);
                        compoundCmd.add (cmd);
                    }
                }
                getCommandStack ().execute (compoundCmd);
                return true;
            }
            return super.keyPressed (event);
        }
    }
    ;
    keyHandler.put (KeyStroke.getPressed (SWT.F2, 0), getActionRegistry ().getAction (GEFActionConstants.DIRECT_EDIT));
    viewer.setKeyHandler (keyHandler);
    viewer.setContents (getEditorInput ().getAdapter (NamedUuidEntity.class));
    viewer.addDropTargetListener (createTransferDropTargetListener (viewer));
    return viewer;
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorAbstractNavigatorItem) {
        return;
    }
    se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorAbstractNavigatorItem abstractNavigatorItem = (se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorItem) {
        navigatorView = ((se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorGroup) {
        se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorGroup navigatorGroup = (se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorItem) {
            navigatorView = ((se.mdh.mrtc.save.taEditor.diagram.navigator.TaEditorNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=4=-----==

public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


public static View findView (DiagramEditPart diagramEditPart, EObject targetElement, LazyElement2ViewMap lazyElement2ViewMap) {
    boolean hasStructuralURI = false;
    if (targetElement.eResource () instanceof XMLResource) {
        hasStructuralURI = ((XMLResource) targetElement.eResource ()).getID (targetElement) == null;
    }
    View view = null;
    if (hasStructuralURI && ! lazyElement2ViewMap.getElement2ViewMap ().isEmpty ()) {
        view = (View) lazyElement2ViewMap.getElement2ViewMap ().get (targetElement);
    }
    else if (findElementsInDiagramByID (diagramEditPart, targetElement, lazyElement2ViewMap.editPartTmpHolder) > 0) {
        EditPart editPart = (EditPart) lazyElement2ViewMap.editPartTmpHolder.get (0);
        lazyElement2ViewMap.editPartTmpHolder.clear ();
        view = editPart.getModel () instanceof View ? (View) editPart.getModel () : null;
    }
    return (view == null) ? diagramEditPart.getDiagramView () : view;
}


-----Function Pair=5=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=6=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof EcoreModelAbstractNavigatorItem) {
        return;
    }
    EcoreModelAbstractNavigatorItem abstractNavigatorItem = (EcoreModelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof EcoreModelNavigatorItem) {
        navigatorView = ((EcoreModelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof EcoreModelNavigatorGroup) {
        EcoreModelNavigatorGroup navigatorGroup = (EcoreModelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof EcoreModelNavigatorItem) {
            navigatorView = ((EcoreModelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof MathAbstractNavigatorItem) {
        return;
    }
    MathAbstractNavigatorItem abstractNavigatorItem = (MathAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof MathNavigatorItem) {
        navigatorView = ((MathNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof MathNavigatorGroup) {
        MathNavigatorGroup navigatorGroup = (MathNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof MathNavigatorItem) {
            navigatorView = ((MathNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=7=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.DrlModelDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.DrlModelDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            FinalInfProduct model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, FinalInfProductEditPart.MODEL_ID, DrlModelDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (org.spbu.pldoctoolkit.graph.diagram.fproduct.part.DrlModelDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (org.spbu.pldoctoolkit.graph.diagram.fproduct.part.DrlModelDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                DrlModelDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        DrlModelDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (EJBTool.deployment.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, EJBTool.deployment.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            EJBTool.Root model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, EJBTool.deployment.edit.parts.DeplyomentViewEditPart.MODEL_ID, EJBTool.deployment.part.EJBToolDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (EJBTool.deployment.part.EJBToolDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (EJBTool.deployment.part.EJBToolDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                EJBTool.deployment.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        EJBTool.deployment.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=8=-----==

static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


static Map buildElement2ViewMap (View parentView, Map element2ViewMap, Set elements) {
    if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    if (parentView.isSetElement () && ! element2ViewMap.containsKey (parentView.getElement ()) && elements.contains (parentView.getElement ())) {
        element2ViewMap.put (parentView.getElement (), parentView);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getChildren ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    for (Iterator it = parentView.getSourceEdges ().iterator (); it.hasNext ();) {
        buildElement2ViewMap ((View) it.next (), element2ViewMap, elements);
        if (elements.size () == element2ViewMap.size ()) return element2ViewMap;
    }
    return element2ViewMap;
}


-----Function Pair=9=-----==

public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


public final Map getElement2ViewMap () {
    if (element2ViewMap == null) {
        element2ViewMap = new HashMap ();
        for (Iterator it = elementSet.iterator (); it.hasNext ();) {
            EObject element = (EObject) it.next ();
            if (element instanceof View) {
                View view = (View) element;
                if (view.getDiagram () == scope.getDiagram ()) {
                    element2ViewMap.put (element, element);
                }
            }
        }
        buildElement2ViewMap (scope, element2ViewMap, elementSet);
    }
    return element2ViewMap;
}


-----Function Pair=10=-----==

private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


private static int findElementsInDiagramByID (DiagramEditPart diagramPart, EObject element, List editPartCollector) {
    IDiagramGraphicalViewer viewer = (IDiagramGraphicalViewer) diagramPart.getViewer ();
    final int intialNumOfEditParts = editPartCollector.size ();
    if (element instanceof View) {
        EditPart editPart = (EditPart) viewer.getEditPartRegistry ().get (element);
        if (editPart != null) {
            editPartCollector.add (editPart);
            return 1;
        }
    }
    String elementID = EMFCoreUtil.getProxyID (element);
    List associatedParts = viewer.findEditPartsForElement (elementID, IGraphicalEditPart.class);
    for (Iterator editPartIt = associatedParts.iterator (); editPartIt.hasNext ();) {
        EditPart nextPart = (EditPart) editPartIt.next ();
        EditPart parentPart = nextPart.getParent ();
        while (parentPart != null && ! associatedParts.contains (parentPart)) {
            parentPart = parentPart.getParent ();
        }
        if (parentPart == null) {
            editPartCollector.add (nextPart);
        }
    }
    if (intialNumOfEditParts == editPartCollector.size ()) {
        if (! associatedParts.isEmpty ()) {
            editPartCollector.add (associatedParts.iterator ().next ());
        }
        else {
            if (element.eContainer () != null) {
                return findElementsInDiagramByID (diagramPart, element.eContainer (), editPartCollector);
            }
        }
    }
    return editPartCollector.size () - intialNumOfEditParts;
}


-----Function Pair=11=-----==

public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof edu.toronto.cs.openome_model.diagram.navigator.Openome_modelAbstractNavigatorItem) {
        return;
    }
    edu.toronto.cs.openome_model.diagram.navigator.Openome_modelAbstractNavigatorItem abstractNavigatorItem = (edu.toronto.cs.openome_model.diagram.navigator.Openome_modelAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorItem) {
        navigatorView = ((edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorGroup) {
        edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorGroup navigatorGroup = (edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorItem) {
            navigatorView = ((edu.toronto.cs.openome_model.diagram.navigator.Openome_modelNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


public void activateEditor (IWorkbenchPage aPage, IStructuredSelection aSelection) {
    if (aSelection == null || aSelection.isEmpty ()) {
        return;
    }
    if (false == aSelection.getFirstElement () instanceof EcoreAbstractNavigatorItem) {
        return;
    }
    EcoreAbstractNavigatorItem abstractNavigatorItem = (EcoreAbstractNavigatorItem) aSelection.getFirstElement ();
    View navigatorView = null;
    if (abstractNavigatorItem instanceof EcoreNavigatorItem) {
        navigatorView = ((EcoreNavigatorItem) abstractNavigatorItem).getView ();
    }
    else if (abstractNavigatorItem instanceof EcoreNavigatorGroup) {
        EcoreNavigatorGroup navigatorGroup = (EcoreNavigatorGroup) abstractNavigatorItem;
        if (navigatorGroup.getParent () instanceof EcoreNavigatorItem) {
            navigatorView = ((EcoreNavigatorItem) navigatorGroup.getParent ()).getView ();
        }
    }
    if (navigatorView == null) {
        return;
    }
    IEditorInput editorInput = getEditorInput (navigatorView.getDiagram ());
    IEditorPart editor = aPage.findEditor (editorInput);
    if (editor == null) {
        return;
    }
    aPage.bringToTop (editor);
    if (editor instanceof DiagramEditor) {
        DiagramEditor diagramEditor = (DiagramEditor) editor;
        ResourceSet diagramEditorResourceSet = diagramEditor.getEditingDomain ().getResourceSet ();
        EObject selectedView = diagramEditorResourceSet.getEObject (EcoreUtil.getURI (navigatorView), true);
        if (selectedView == null) {
            return;
        }
        GraphicalViewer graphicalViewer = (GraphicalViewer) diagramEditor.getAdapter (GraphicalViewer.class);
        EditPart selectedEditPart = (EditPart) graphicalViewer.getEditPartRegistry ().get (selectedView);
        if (selectedEditPart != null) {
            graphicalViewer.select (selectedEditPart);
        }
    }
}


-----Function Pair=12=-----==

public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (EJBTool.deployment.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, EJBTool.deployment.part.Messages.EJBToolDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            EJBTool.Root model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, EJBTool.deployment.edit.parts.DeplyomentViewEditPart.MODEL_ID, EJBTool.deployment.part.EJBToolDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (EJBTool.deployment.part.EJBToolDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (EJBTool.deployment.part.EJBToolDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                EJBTool.deployment.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        EJBTool.deployment.part.EJBToolDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


public static Resource createDiagram (URI diagramURI, URI modelURI, IProgressMonitor progressMonitor) {
    TransactionalEditingDomain editingDomain = GMFEditingDomainFactory.INSTANCE.createEditingDomain ();
    progressMonitor.beginTask (Messages.OverviewMapsDiagramEditorUtil_CreateDiagramProgressTask, 3);
    final Resource diagramResource = editingDomain.getResourceSet ().createResource (diagramURI);
    final Resource modelResource = editingDomain.getResourceSet ().createResource (modelURI);
    final String diagramName = diagramURI.lastSegment ();
    AbstractTransactionalCommand command = new AbstractTransactionalCommand (editingDomain, Messages.OverviewMapsDiagramEditorUtil_CreateDiagramCommandLabel, Collections.EMPTY_LIST) {
        protected CommandResult doExecuteWithResult (IProgressMonitor monitor, IAdaptable info) throws ExecutionException {
            LinkedMapContainer model = createInitialModel ();
            attachModelToResource (model, modelResource);
            Diagram diagram = ViewService.createDiagram (model, LinkedMapContainerEditPart.MODEL_ID, OverviewMapsDiagramEditorPlugin.DIAGRAM_PREFERENCES_HINT);
            if (diagram != null) {
                diagramResource.getContents ().add (diagram);
                diagram.setName (diagramName);
                diagram.setElement (model);
            }
            try {
                modelResource.save (de.mpiwg.vspace.maps.diagram.part.OverviewMapsDiagramEditorUtil.getSaveOptions ());
                diagramResource.save (de.mpiwg.vspace.maps.diagram.part.OverviewMapsDiagramEditorUtil.getSaveOptions ());
            } catch (IOException e) {
                OverviewMapsDiagramEditorPlugin.getInstance ().logError ("Unable to store model and diagram resources", e);
            }
            return CommandResult.newOKCommandResult ();
        }
    }
    ;
    try {
        OperationHistoryFactory.getOperationHistory ().execute (command, new SubProgressMonitor (progressMonitor, 1), null);
    } catch (ExecutionException e) {
        OverviewMapsDiagramEditorPlugin.getInstance ().logError ("Unable to create model and diagram", e);
    }
    setCharset (WorkspaceSynchronizer.getFile (modelResource));
    setCharset (WorkspaceSynchronizer.getFile (diagramResource));
    return diagramResource;
}


-----Function Pair=13=-----==

public boolean splitRecord (String input, String [] fields) {
    int index = 0;
    int ifield = 0;
    Matcher m = delimPattern.matcher (input);
    boolean tabDelim = delimPattern.pattern ().equals ("\t");
    char quote = '"';
    int len = input.length ();
    int index0 = index;
    int qend = - 1;
    while (ifield < fields.length && index < len) {
        while (index < len && (! tabDelim && Character.isWhitespace (input.charAt (index)))) index ++;
        if (index == len) break;
        int i1;
        if (input.charAt (index) == quote) {
            index = index + 1;
            index0 = index;
            i1 = input.indexOf (quote, index);
            if (i1 == - 1) {
                System.err.println ("unclosed quote: " + input);
                continue;
            }
            while (i1 + 1 < input.length () && input.charAt (i1 + 1) == quote) {
                i1 = input.indexOf (quote, i1 + 2);
                if (i1 == - 1) throw new IllegalArgumentException ("unclosed quote");
            }
            index = i1 + 1;
            qend = i1;
            if (index == len) {
                fields [ifield] = input.substring (index0, qend);
                ifield ++;
            }
        }
        else {
            if (m.find (index)) {
                if (qend == - 1) index0 = index;
                index = m.start ();
                if (qend == - 1) {
                    fields [ifield] = input.substring (index0, index);
                }
                else if (qend < index0) {
                    return false;
                }
                else {
                    fields [ifield] = input.substring (index0, qend).replaceAll ("\"\"", "\"");
                    qend = - 1;
                }
                index = m.end ();
                index0 = index;
                ifield ++;
            }
            else if (ifield == fields.length - 1) {
                if (qend == - 1) {
                    fields [ifield] = input.substring (index0);
                }
                else {
                    fields [ifield] = input.substring (index0, qend);
                }
                ifield ++;
                index = len;
            }
            else {
                fields [ifield] = input.substring (index0);
                return false;
            }
        }
    }
    if (index == len && ifield == fields.length - 1 && ! delimPattern.toString ().equals (" ")) {
        fields [ifield] = "";
        ifield ++;
    }
    return (ifield == fields.length && index == len);
}


public final Raster getRaster (int x, int y, int w, int h) {
    if (w == 0 || h == 0) {
        return null;
    }
    WritableRaster raster = saved;
    if (raster == null || raster.getWidth () < w || raster.getHeight () < h) {
        raster = getCachedRaster (dataModel, w, h);
        saved = raster;
        raster = raster.createWritableChild (raster.getMinX (), raster.getMinY (), w, h, 0, 0, null);
    }
    DataBufferInt rasterDB = (DataBufferInt) raster.getDataBuffer ();
    int [] pixels = rasterDB.getBankData () [0];
    int off = rasterDB.getOffset ();
    int scanlineStride = ((SinglePixelPackedSampleModel) raster.getSampleModel ()).getScanlineStride ();
    int adjust = scanlineStride - w;
    fillRaster (pixels, off, adjust, x, y, w, h);
    GraphicsUtil.coerceData (raster, dataModel, model.isAlphaPremultiplied ());
    return raster;
}


-----Function Pair=14=-----==

private void initScreen () {
    try {
        in = new FileInputStream ("/dev/tty");
        out = new FileOutputStream ("/dev/tty");
    } catch (IOException e) {
        System.out.println ("initScreen fails: " + e.getMessage ());
    }
    locateCursor ();
    write ("\033[999;999H\033[6n");
    read ();
    read ();
    int height = 0;
    for (;;) {
        int ch = read ();
        if (ch == ';') break;
        height = height * 10 + ch - '0';
    }
    int width = 0;
    for (;;) {
        int ch = read ();
        if (ch == 'R') break;
        width = width * 10 + ch - '0';
    }
    blanks = new byte [width];
    for (int i = 0, n = blanks.length; i < n; ++ i) blanks [i] = blank;
    keystrokes = new byte [width];
    kIndex = 0;
    kCount = 0;
    write ("\033[?7h");
    write ("\033[" + (cursorY) + ";" + 0 + "H");
}


private void read () throws SQLException {
    data.reset ();
    int type = data.readByte ();
    data.readShortInt ();
    this.parentPageId = data.readInt ();
    onlyPosition = (type & Page.FLAG_LAST) == 0;
    int indexId = data.readVarInt ();
    if (indexId != index.getId ()) {
        throw Message.getSQLException (ErrorCode.FILE_CORRUPTED_1, "page:" + getPos () + " expected index:" + index.getId () + "got:" + indexId);
    }
    rowCount = data.readInt ();
    entryCount = data.readShortInt ();
    if (! PageStore.STORE_BTREE_ROWCOUNT) {
        rowCount = UNKNOWN_ROWCOUNT;
    }
    childPageIds = new int [entryCount + 1];
    childPageIds [entryCount] = data.readInt ();
    rows = PageStore.newSearchRows (entryCount);
    offsets = MemoryUtils.newIntArray (entryCount);
    for (int i = 0; i < entryCount; i ++) {
        childPageIds [i] = data.readInt ();
        offsets [i] = data.readShortInt ();
    }
    check ();
    start = data.length ();
    written = true;
}


-----Function Pair=15=-----==

public void getYValues () {
    if (! table2) {
        t1 = (int) time1.getValue ();
        t2 = (int) time2.getValue ();
    }
    Double sum = 0.0;
    int sizeX = data.size ();
    int sizeY = ((ArrayList) data.get (0)).size ();
    yvalues = new double [sizeX];
    t1 = t1 - 1;
    t2 = t2 - 1;
    if (! table2) {
        if (t1 < 0 || t1 > (sizeY - 1)) {
            System.out.print ("Initial time is out of range.");
            if (t1 < 0) {
                time1.setValue (1);
                t1 = 0;
            }
            else if (t1 > (sizeY - 1)) {
                time1.setValue (sizeY);
                t1 = sizeY - 1;
            }
        }
        if (t2 < 0 || t2 > (sizeY - 1)) {
            System.out.print ("Final time is out of range.");
            if (t2 < 0) {
                time2.setValue (1);
                t2 = 0;
            }
            else if (t2 > (sizeY - 1)) {
                time2.setValue (sizeY);
                t2 = sizeY - 1;
            }
        }
    }
    for (int i = 0; i < sizeX; i ++) {
        for (int j = t1; j <= t2; j ++) {
            sum = sum + ((Double) ((ArrayList) data.get (i)).get (j)).doubleValue ();
        }
        yvalues [i] = sum.doubleValue () / (abs (t2 - t1) + 1);
        sum = (Double) 0.0;
    }
}


public void complete () {
    if (mTableInserted == true) {
        mergeInsertedTables ();
        mTableInserted = false;
    }
    if (mAutoFillEmptyCells == true) {
        fillEmptyMatrixCells ();
    }
    if (alternatingRowAttributes != null) {
        Properties even = new Properties ();
        Properties odd = new Properties ();
        String name;
        String [] value;
        for (Iterator iterator = alternatingRowAttributes.keySet ().iterator (); iterator.hasNext ();) {
            name = String.valueOf (iterator.next ());
            value = (String []) alternatingRowAttributes.get (name);
            even.setProperty (name, value [0]);
            odd.setProperty (name, value [1]);
        }
        Row row;
        for (int i = lastHeaderRow + 1; i < rows.size (); i ++) {
            row = (Row) rows.get (i);
            row.setMarkupAttributes (i % 2 == 0 ? even : odd);
        }
    }
}


-----Function Pair=16=-----==

public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


public NewInterpolationExploration () {
    super (true);
    currentTextSize = TEXT_SIZE;
    currentMathSize = MATH_SIZE;
    currentLabelFont = LABEL_FONT;
    currentFieldFont = FIELD_FONT;
    graphicsPanel = new ClickableMathPainterPanel ();
    graphicsPanel.addMathPainterPanelListener (this);
    contentSettingsPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Content Settings", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    contentSettingsPanel.setLayout (contentSettingsPanelLayout);
    plotLabelLbl.setFont (LABEL_FONT);
    plotLabelTFd.setFont (FIELD_FONT);
    scalingLbl.setFont (LABEL_FONT);
    scalingTFd.setFont (FIELD_FONT);
    plotColorBtn.setButtonFont (LABEL_FONT);
    dataColorBtn.setButtonFont (LABEL_FONT);
    degreeLbl.setFont (LABEL_FONT);
    lagrangianCBx.setFont (LABEL_FONT);
    addPointRBtn.setFont (LABEL_FONT);
    deletePointRBtn.setFont (LABEL_FONT);
    lagrangianCBx.setFont (LABEL_FONT);
    xNMeshLbl.setFont (LABEL_FONT);
    localStylesBtn.setFont (LABEL_FONT);
    degreeTFd.setFont (FIELD_FONT);
    xNMeshTFd.setFont (FIELD_FONT);
    degreeTFd.setEditable (! lagrangian);
    degreeTFd.addKeyListener (this);
    xNMeshTFd.addKeyListener (this);
    plotLabelTFd.addKeyListener (this);
    scalingTFd.addKeyListener (this);
    lagrangianCBx.addItemListener (this);
    localStylesBtn.addActionListener (this);
    addPointRBtn.addActionListener (this);
    deletePointRBtn.addActionListener (this);
    clickActionBGp.add (addPointRBtn);
    clickActionBGp.add (deletePointRBtn);
    contentSettingsPanelLayout.add (degreeLbl, contentSettingsPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (degreeTFd, contentSettingsPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (lagrangianCBx, contentSettingsPanel, 2, 0, 2, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (addPointRBtn, contentSettingsPanel, 0, 1, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (deletePointRBtn, contentSettingsPanel, 2, 1, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (xNMeshLbl, contentSettingsPanel, 0, 2, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    contentSettingsPanelLayout.add (xNMeshTFd, contentSettingsPanel, 1, 2, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    contentSettingsPanelLayout.add (localStylesBtn, contentSettingsPanel, 1, 3, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Visual Settings", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    windowSettingsPanel.setLayout (windowSettingsPanelLayout);
    windowXMinLbl.setFont (LABEL_FONT);
    windowXMaxLbl.setFont (LABEL_FONT);
    windowYMinLbl.setFont (LABEL_FONT);
    windowYMaxLbl.setFont (LABEL_FONT);
    globalStylesBtn.setFont (LABEL_FONT);
    windowXMinTFd.setFont (FIELD_FONT);
    windowXMaxTFd.setFont (FIELD_FONT);
    windowYMinTFd.setFont (FIELD_FONT);
    windowYMaxTFd.setFont (FIELD_FONT);
    windowSettingsPanelLayout.add (windowXMinLbl, windowSettingsPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowXMinTFd, windowSettingsPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowXMaxLbl, windowSettingsPanel, 2, 0, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowXMaxTFd, windowSettingsPanel, 3, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowYMinLbl, windowSettingsPanel, 0, 1, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowYMinTFd, windowSettingsPanel, 1, 1, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (windowYMaxLbl, windowSettingsPanel, 2, 1, 1, 1, 100, 100, ExtendedGridBagLayout.NONE, ExtendedGridBagLayout.EAST);
    windowSettingsPanelLayout.add (windowYMaxTFd, windowSettingsPanel, 3, 1, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowSettingsPanelLayout.add (globalStylesBtn, windowSettingsPanel, 1, 2, 2, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    windowXMinTFd.addKeyListener (this);
    windowXMaxTFd.addKeyListener (this);
    windowYMinTFd.addKeyListener (this);
    windowYMaxTFd.addKeyListener (this);
    globalStylesBtn.addActionListener (this);
    controlPanel.setBorder (BorderFactory.createTitledBorder (BorderFactory.createEtchedBorder (EtchedBorder.RAISED), "Controls", TitledBorder.DEFAULT_JUSTIFICATION, TitledBorder.DEFAULT_POSITION, LABEL_FONT));
    controlPanel.setLayout (controlPanelLayout);
    drawCurvesBtn.setFont (LABEL_FONT);
    eraseCurvesBtn.setFont (LABEL_FONT);
    autoscaleBtn.setFont (LABEL_FONT);
    controlPanelLayout.add (drawCurvesBtn, controlPanel, 0, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    controlPanelLayout.add (eraseCurvesBtn, controlPanel, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    controlPanelLayout.add (autoscaleBtn, controlPanel, 2, 0, 1, 1, 100, 100, ExtendedGridBagLayout.HORIZONTAL, ExtendedGridBagLayout.CENTER);
    drawCurvesBtn.addActionListener (this);
    eraseCurvesBtn.addActionListener (this);
    autoscaleBtn.addActionListener (this);
    this.setLayout (mainPanelLayout);
    mainPanelLayout.add (contentSettingsPanel, this, 0, 0, 1, 1, 10, 100, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (windowSettingsPanel, this, 0, 1, 1, 1, 10, 10, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (graphicsPanel, this, 1, 0, 1, 1, 100, 100, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    mainPanelLayout.add (controlPanel, this, 1, 1, 1, 1, 100, 10, ExtendedGridBagLayout.BOTH, ExtendedGridBagLayout.CENTER);
    textPlusBtn.setFont (LABEL_FONT);
    textMinusBtn.setFont (LABEL_FONT);
    textPlusBtn.addActionListener (this);
    textMinusBtn.addActionListener (this);
}


-----Function Pair=17=-----==

private static Object jsConstructor (Context cx, Scriptable scope, Object [] args) {
    if (args.length == 0) return new NativeArray (0);
    if (cx.getLanguageVersion () == Context.VERSION_1_2) {
        return new NativeArray (args);
    }
    else {
        Object arg0 = args [0];
        if (args.length > 1 || ! (arg0 instanceof Number)) {
            return new NativeArray (args);
        }
        else {
            long len = ScriptRuntime.toUint32 (arg0);
            if (len != ((Number) arg0).doubleValue ()) {
                String msg = ScriptRuntime.getMessage0 ("msg.arraylength.bad");
                throw ScriptRuntime.constructError ("RangeError", msg);
            }
            return new NativeArray (len);
        }
    }
}


protected void sortIndices () {
    if (indices == null) return;
    else if (this.size == 0) {
        this.size = indices.length;
        this.maxSortedIndex = - 1;
    }
    for (int i = maxSortedIndex + 1; i < size; i ++) {
        for (int j = i; j > 0; j --) {
            if (indices [j] < indices [j - 1]) {
                int f;
                f = indices [j];
                indices [j] = indices [j - 1];
                indices [j - 1] = f;
                if (values != null) {
                    double v;
                    v = values [j];
                    values [j] = values [j - 1];
                    values [j - 1] = v;
                }
            }
        }
    }
    removeDuplicates (0);
    maxSortedIndex = size - 1;
}


-----Function Pair=18=-----==

public ActFeature () {
    super ("ActFeature", "Sonar processing, feature extraction");
    System.out.println ("ActFeature costructor");
    K = 0;
    for (int i = 0; i < MAXK; i ++) {
        w [i] = wm [i] = r [i] = 0;
    }
    mt [0] [0] = 1;
    mt [0] [1] = 0;
    mt [1] [0] = 0;
    mt [1] [1] = 1;
    CovS [0] [0] = 100;
    CovS [0] [1] = 0;
    CovS [0] [2] = 0;
    CovS [1] [0] = 0;
    CovS [1] [1] = 100;
    CovS [1] [2] = 0;
    CovS [2] [0] = 0;
    CovS [2] [1] = 0;
    CovS [2] [2] = (float) 10;
    invCovS [0] [0] = 0;
    invCovS [0] [1] = 0;
    invCovS [0] [2] = 0;
    invCovS [1] [0] = 0;
    invCovS [1] [1] = 0;
    invCovS [1] [2] = 0;
    invCovS [2] [0] = 0;
    invCovS [2] [1] = 0;
    invCovS [2] [2] = 0;
    GradS [0] [0] = 1;
    GradS [0] [1] = 0;
    GradS [0] [2] = 0;
    GradS [1] [0] = 0;
    GradS [1] [1] = 1;
    GradS [1] [2] = 0;
    GradS [2] [0] = 0;
    GradS [2] [1] = 0;
    GradS [2] [2] = 1;
    CovZ [0] [0] = 0;
    CovZ [0] [1] = 0;
    CovZ [0] [2] = 0;
    CovZ [1] [0] = 0;
    CovZ [1] [1] = 0;
    CovZ [1] [2] = 0;
    CovZ [2] [0] = 0;
    CovZ [2] [1] = 0;
    CovZ [2] [2] = 0;
    GradU [0] [0] = 0;
    GradU [0] [1] = 0;
    GradU [1] [0] = 0;
    GradU [1] [1] = 0;
    GradU [2] [0] = 0;
    GradU [2] [1] = 0;
    CovU [0] [0] = 100 * epsilon;
    CovU [0] [1] = 0;
    CovU [1] [0] = 0;
    CovU [1] [1] = 100 * epsilon;
    lr [0] = - 686;
    lw [0] = 0;
    lr [1] = 370;
    lw [1] = 900;
    lr [2] = 686;
    lw [2] = 0;
    lr [3] = - 370;
    lw [3] = 900;
}


public synchronized boolean removeTopLayer () {
    if (layerSize > 0) {
        params [topLayer] = null;
        layerSize --;
        topLayer = layerSize - 1;
        if (layerSize <= 0) {
            controller.clearTopLayerContents ();
            snapshotListModel.clear ();
        }
        else {
            updateContents ();
        }
        return true;
    }
    return false;
}


-----Function Pair=19=-----==

public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


public synchronized void itemStateChanged (ItemEvent e) {
    Object source = e.getItemSelectable ();
    if (e.getSource () == checkInverse) {
        if (checkInverse.isSelected ()) {
            inverse = true;
        }
        if (! checkInverse.isSelected ()) {
            inverse = false;
        }
    }
    if (e.getSource () == checkAxes) {
        if (checkAxes.isSelected ()) {
            axes = true;
        }
        if (! checkAxes.isSelected ()) {
            axes = false;
        }
    }
    pic2.newDisplayMode ();
    imageRegion.repaint ();
    super.requestFocus ();
    if (! thread.isAlive ()) {
        thread = new TurnThread (pic2, imageRegion);
        thread.start ();
    }
}


-----Function Pair=20=-----==

private void paintAxes (Graphics2D g) {
    int maxWidth = 0, fontHeight = fm.getHeight ();
    Rectangle bounds = canvas.getBounds ();
    double pos = labelstep * Math.ceil (miny / labelstep);
    String label;
    graphBounds.y = HANDLE_SIZE / 2;
    graphBounds.height = bounds.height - HANDLE_SIZE - fontHeight - 5;
    g.setColor (Color.black);
    while (pos <= maxy) {
        label = vFormat.format (pos);
        int w = fm.stringWidth (label);
        if (w > maxWidth) maxWidth = w;
        g.drawString (label, 0, graphBounds.y + ((int) ((maxy - pos) * graphBounds.height / (maxy - miny))) + fontHeight / 2);
        pos += labelstep;
    }
    graphBounds.x = maxWidth + 5;
    graphBounds.width = bounds.width - maxWidth - 5 - HANDLE_SIZE / 2;
    pos = labelstep * Math.ceil (miny / labelstep);
    while (pos <= maxy) {
        int v = graphBounds.y + ((int) ((maxy - pos) * graphBounds.height / (maxy - miny)));
        g.drawLine (graphBounds.x - 3, v, graphBounds.x, v);
        pos += labelstep;
    }
    for (int i = 0; i < 10; i ++) {
        label = hFormat.format (0.1 * i);
        int h = graphBounds.x + (i * graphBounds.width) / 10;
        g.drawLine (h, graphBounds.y + graphBounds.height, h, graphBounds.y + graphBounds.height + 3);
        g.drawString (label, h - fm.stringWidth (label) / 2, bounds.height);
    }
    g.drawLine (graphBounds.x, 0, graphBounds.x, graphBounds.y + graphBounds.height);
    g.drawLine (graphBounds.x, graphBounds.y + graphBounds.height, graphBounds.x + graphBounds.width, graphBounds.y + graphBounds.height);
    positionHandles (graphBounds);
}


private File makeArchive (String filename) throws IOException {
    LineNumberReader files = new LineNumberReader (new FileReader (filelist_));
    String line = files.readLine ();
    if (line == null) {
        files.close ();
        throw new IOException (VAGlobals.i18n ("VAArchiver_EmptyFilelist"));
    }
    File zip = new File (filename);
    File parent = zip.getParentFile ();
    if ((parent != null) && (! parent.canWrite ())) throw new IOException (zip + VAGlobals.i18n ("VAArchiver_NotWritten"));
    ZipOutputStream stream = new ZipOutputStream (new GZIPOutputStream (licenseKeySupport_.encodeStream (new FileOutputStream (zip), encodeKey_)));
    stream.setLevel (0);
    Vector archiveExeList = new Vector ();
    FileNameGroup fileNameGroup = null;
    ObjectOutputStream infos = new ObjectOutputStream (archiveInfos_);
    Vector scripts = new Vector ();
    while (line != null) {
        if ((! line.trim ().equals ("")) && (! line.trim ().startsWith ("#"))) {
            if (line.trim ().startsWith ("{")) {
                String script = addScript (files, scripts);
                if (script != null) archiveExeList.add ("[SCRIPT]" + script);
                line = files.readLine ();
                continue;
            }
            fileNameGroup = new FileNameGroup (line);
            File file = new File (convertToLocalPath (fileNameGroup.getOrigin ()));
            String entryName = fileNameGroup.getDestination ();
            if (! checkVaiPath (entryName)) throw new IOException (VAGlobals.i18n ("VAArchiver_InvalidPathInFilelist") + files.getLineNumber () + "): " + entryName);
            if (fileNameGroup.isExecutable ()) {
                archiveExeList.add (entryName);
            }
            FileFilter filter = null;
            try {
                filter = fileNameGroup.getFileFilter ();
            } catch (IllegalArgumentException iae) {
                throw new IOException (VAGlobals.i18n ("VAArchiver_InFilelist") + files.getLineNumber () + "): " + iae.getMessage ());
            }
            addToArchive (stream, file, filter, entryName, fileNameGroup.isRecursive () ? Integer.MAX_VALUE : 1);
        }
        line = files.readLine ();
    }
    stream.close ();
    files.close ();
    infos.writeInt (archivecount_);
    infos.writeObject (scripts);
    infos.writeObject (archiveExeList);
    infos.flush ();
    return zip;
}


-----Function Pair=21=-----==

public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


private int readEOL (boolean isFirstEOL) {
    if (fillBits == 0) {
        int next12Bits = nextNBits (12);
        if (isFirstEOL && next12Bits == 0) {
            if (nextNBits (4) == 1) {
                fillBits = 1;
                return 1;
            }
        }
        if (next12Bits != 1) {
            throw new RuntimeException (MessageLocalization.getComposedMessage ("scanline.must.begin.with.eol.code.word"));
        }
    }
    else if (fillBits == 1) {
        int bitsLeft = 8 - bitPointer;
        if (nextNBits (bitsLeft) != 0) {
            throw new RuntimeException (MessageLocalization.getComposedMessage ("all.fill.bits.preceding.eol.code.must.be.0"));
        }
        if (bitsLeft < 4) {
            if (nextNBits (8) != 0) {
                throw new RuntimeException (MessageLocalization.getComposedMessage ("all.fill.bits.preceding.eol.code.must.be.0"));
            }
        }
        int n;
        while ((n = nextNBits (8)) != 1) {
            if (n != 0) {
                throw new RuntimeException (MessageLocalization.getComposedMessage ("all.fill.bits.preceding.eol.code.must.be.0"));
            }
        }
    }
    if (oneD == 0) {
        return 1;
    }
    else {
        return nextLesserThan8Bits (1);
    }
}


-----Function Pair=22=-----==

public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


public Interactive () {
    theGraph = new JDrawEditor (JDrawEditor.MODE_PLAY);
    try {
        theGraph.loadFile ("interactive.jdw");
    } catch (IOException e) {
        JOptionPane.showMessageDialog (this, e.getMessage (), "Error loading file", JOptionPane.ERROR_MESSAGE);
        System.exit (1);
    }
    btn1 = getObject ("Button1");
    btn2 = getObject ("Button2");
    checkbox = getObject ("Checkbox");
    textArea = (JDLabel) getObject ("textArea");
    addText ("");
    btn1.addValueListener (this);
    btn2.addValueListener (this);
    checkbox.addValueListener (this);
    setContentPane (theGraph);
    setTitle ("Interactive");
}


-----Function Pair=23=-----==

public void actionPerformed (ActionEvent e) {
    JComboBox cb = (JComboBox) e.getSource ();
    if (cb == lutChoice) {
        String name = (String) cb.getSelectedItem ();
        for (int i = 0; i < lutName.length; i ++) {
            if (name.equals (lutName [i])) {
                lutNr = i;
                break;
            }
        }
        pic2.setLut ();
    }
    else if (cb == displayChoice) {
        String name = (String) cb.getSelectedItem ();
        for (int i = 0; i < displayName.length; i ++) if (name.equals (displayName [i])) {
            displayMode = i;
            break;
        }
        pic2.setLut ();
    }
    pause = false;
    pic2.cube.initTextsAndDrawColors (imageRegion);
    pic2.newDisplayMode ();
    imageRegion.repaint ();
    super.requestFocus ();
    if (! thread.isAlive ()) {
        thread = new TurnThread (pic2, imageRegion);
        thread.start ();
    }
}


private void init (DistanceMatrix m) {
    numClusters = m.getSize ();
    distance = m.getClonedDistances ();
    for (int i = 0; i < numClusters; i ++) {
        Node tmp = NodeFactory.createNode ();
        tmp.setIdentifier (m.getIdentifier (i));
        getRoot ().addChild (tmp);
    }
    alias = new int [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        alias [i] = i;
    }
    height = new double [numClusters];
    oc = new int [numClusters];
    for (int i = 0; i < numClusters; i ++) {
        height [i] = 0.0;
        oc [i] = 1;
    }
}


-----Function Pair=24=-----==

public synchronized void dots () {
    for (int i = pixels.length - 1; i >= 0; i --) {
        pixels [i] = 0;
        pixelsZ [i] = 1000;
    }
    for (int row = 0; row < 255; row ++) {
        for (int col = 0; col < 255; col ++) {
            int i = row * 256 + col;
            PlotVal p0 = plotList [i];
            if (p0 != null) {
                tr.transform (p0);
                int x = tr.X, y = tr.Y, z = tr.Z;
                int c0 = (lutNr == ORIGINAL) ? p0.color : getLutColor (p0);
                if ((x & ~ 511) == 0 && (y & ~ 511) == 0) {
                    int pos = (y << 9) | x;
                    if (z < pixelsZ [pos]) {
                        pixelsZ [pos] = z;
                        if (light > 0) {
                            tr.x = p0.dx;
                            tr.y = p0.dy;
                            tr.z = p0.dz;
                            tr.xyzPos_ ();
                            float l = light * (- tr.X / (float) p0.len) + 1;
                            int r = (int) Math.min (255, l * ((c0>> 16) & 0xff));
                            int g = (int) Math.min (255, l * ((c0>> 8) & 0xff));
                            int b = (int) Math.min (255, l * (c0 & 0xff));
                            pixels [pos] = 0xff000000 | (r << 16) | (g << 8) | b;
                        }
                        else pixels [pos] = c0;
                    }
                }
            }
        }
    }
    image = Toolkit.getDefaultToolkit ().createImage (source);
    imageRegion.setImage (image);
}


private void weightAndPlaceClasses () {
    int rows = getRows ();
    for (int curRow = _maxPackageRank; curRow < rows; curRow ++) {
        xPos = getHGap () / 2;
        ClassdiagramNode [] rowObject = getObjectsInRow (curRow);
        for (int i = 0; i < rowObject.length; i ++) {
            if (curRow == _maxPackageRank) {
                int nDownlinks = rowObject [i].getDownlinks ().size ();
                rowObject [i].setWeight ((nDownlinks > 0) ? (1 / nDownlinks) : 2);
            }
            else {
                Vector uplinks = rowObject [i].getUplinks ();
                int nUplinks = uplinks.size ();
                if (nUplinks > 0) {
                    float average_col = 0;
                    for (int j = 0; j < uplinks.size (); j ++) {
                        average_col += ((ClassdiagramNode) (uplinks.elementAt (j))).getColumn ();
                    }
                    average_col /= nUplinks;
                    rowObject [i].setWeight (average_col);
                }
                else {
                    rowObject [i].setWeight (1000);
                }
            }
        }
        int [] pos = new int [rowObject.length];
        for (int i = 0; i < pos.length; i ++) {
            pos [i] = i;
        }
        boolean swapped = true;
        while (swapped) {
            swapped = false;
            for (int i = 0; i < pos.length - 1; i ++) {
                if (rowObject [pos [i]].getWeight () > rowObject [pos [i + 1]].getWeight ()) {
                    int temp = pos [i];
                    pos [i] = pos [i + 1];
                    pos [i + 1] = temp;
                    swapped = true;
                }
            }
        }
        for (int i = 0; i < pos.length; i ++) {
            rowObject [pos [i]].setColumn (i);
            if ((i > _vMax) && (rowObject [pos [i]].getUplinks ().size () == 0) && (rowObject [pos [i]].getDownlinks ().size () == 0)) {
                if (getColumns (rows - 1) > _vMax) {
                    rows ++;
                }
                rowObject [pos [i]].setRank (rows - 1);
            }
            else {
                rowObject [pos [i]].setLocation (new Point (xPos, yPos));
                xPos += rowObject [pos [i]].getSize ().getWidth () + getHGap ();
            }
        }
        yPos += getRowHeight (curRow) + getVGap ();
    }
}


-----Function Pair=25=-----==

void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


void buildIncludeRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing filename in INCLUDE");
    String file_name = pst.nextToken ();
    LineNumberReader old_in = in;
    try {
        in = new LineNumberReader (new FileReader (file_name));
    } catch (java.io.FileNotFoundException e) {
        in = new LineNumberReader (new FileReader (inDir + file_name));
    }
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (isTemplateLine (inLine)) {
            region.addElement (buildTemplateRegion (inLine));
        }
        else {
            if (DEBUG) System.out.println ("adding line to region :" + inLine);
            region.addElement (inLine);
        }
    }
    in = old_in;
}


-----Function Pair=26=-----==

ImageData [] loadFromByteStream () {
    try {
        readSignature ();
        PngChunkReader chunkReader = new PngChunkReader (inputStream);
        headerChunk = chunkReader.getIhdrChunk ();
        int width = headerChunk.getWidth (), height = headerChunk.getHeight ();
        if (width <= 0 || height <= 0) SWT.error (SWT.ERROR_INVALID_IMAGE);
        int imageSize = getAlignedBytesPerRow () * height;
        data = new byte [imageSize];
        imageData = ImageData.internal_new (width, height, headerChunk.getSwtBitsPerPixel (), new PaletteData (0, 0, 0), 4, data, 0, null, null, - 1, - 1, SWT.IMAGE_PNG, 0, 0, 0, 0);
        if (headerChunk.usesDirectColor ()) {
            imageData.palette = headerChunk.getPaletteData ();
        }
        while (chunkReader.hasMoreChunks ()) {
            readNextChunk (chunkReader);
        }
        return new ImageData [] {imageData};
    } catch (IOException e) {
        SWT.error (SWT.ERROR_INVALID_IMAGE);
        return null;
    }
}


void run (String [] args) {
    String [] cmd = null;
    for (int i = 0; i < args.length; i ++) {
        if (args [i].equals (commandArg)) {
            int cmdLen = args.length - i - 1;
            cmd = new String [cmdLen];
            for (int j = 0; j < cmdLen; j ++) cmd [j] = args [++ i];
            break;
        }
    }
    try {
        Properties props = System.getProperties ();
        props.put ("org.omg.CORBA.ORBClass", "com.sun.corba.se.impl.orb.ORBImpl");
        orb = (ORB) ORB.init (args, props);
        if (cmd != null) executeCommand (cmd);
        else {
            BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
            System.out.println (CorbaResourceUtil.getText ("servertool.banner"));
            while (true) {
                cmd = readCommand (in);
                if (cmd != null) executeCommand (cmd);
                else printAvailableCommands ();
            }
        }
    } catch (Exception ex) {
        System.out.println (CorbaResourceUtil.getText ("servertool.usage", "servertool"));
        System.out.println ();
        ex.printStackTrace ();
    }
}


-----Function Pair=27=-----==

public String push (String message) {
    String result = null;
    if (message != null && ! message.trim ().equals ("")) {
        Class stringClass = message.getClass ();
        String [] data = message.split ("\\s+");
        Class [] argTypes = new Class [data.length - 1];
        for (int i = 0; i < argTypes.length; i ++) {
            argTypes [i] = stringClass;
        }
        Object [] args = new Object [data.length - 1];
        for (int i = 0; i < args.length; i ++) {
            args [i] = data [i + 1];
        }
        try {
            Method m = cmds.getClass ().getMethod (data [0], argTypes);
            if (m == null) {
                StringBuffer err = new StringBuffer ();
                err.append ("no method named '");
                err.append (data [0]);
                err.append ("' taking ");
                err.append (data.length - 1);
                err.append (" strings as arguments");
                throw new NoSuchMethodException (err.toString ());
            }
            Object o = m.invoke (cmds, args);
            if (o == null) {
                result = "OK";
            }
            else {
                result = o.toString ();
            }
        } catch (Throwable t) {
            t.printStackTrace ();
            result = "ERR: " + t.toString ();
        }
    }
    return result;
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=28=-----==

public static Collection findMedialAxisCollection (Collection features, FeatureSchema featureSchema) {
    ArrayList < Feature > medialAxisLineStringFeatures = new ArrayList < Feature > ();
    boolean allreadyAllLines = true;
    for (Iterator j = features.iterator (); j.hasNext ();) {
        Feature f = (Feature) j.next ();
        if (f.getGeometry ().getNumPoints () != 2) {
            allreadyAllLines = false;
            break;
        }
    }
    if (allreadyAllLines) return features;
    Collection combinedFeatures = GeoUtils.combineOverlappingFeatures (features, featureSchema);
    for (Iterator j = combinedFeatures.iterator (); j.hasNext ();) {
        CoordinateList coordinateList = new CoordinateList ();
        Feature f = (Feature) j.next ();
        Geometry geo = f.getGeometry ();
        coordinateList.add (geo.getCoordinates (), true);
        CoordinateList coordList = GeoUtils.ConvexHullWrap (coordinateList);
        if (coordList.size () == coordinateList.size ()) coordList = coordinateList;
        else {
            int sideOne = coordList.indexOf (coordinateList.getCoordinate (0));
            if (sideOne > 0) {
                Coordinate [] p = coordList.toCoordinateArray ();
                for (int k = 0; k < sideOne; k ++) {
                    int n = p.length - 2;
                    Coordinate t = p [0];
                    for (int i = 0; i < n; i ++) p [i] = p [i + 1];
                    p [n] = t;
                }
                p [p.length - 1] = p [0];
                coordList = new CoordinateList ();
                for (int k = 0; k < p.length; k ++) coordList.add (p [k], true);
            }
        }
        LineString medialAxis = GeoUtils.findMedialAxis (coordList.toCoordinateArray ());
        Feature newFeature = new BasicFeature (featureSchema);
        if (featureSchema.hasAttribute ("ASHS_ID") && geo.getUserData () != null) {
            String id = (String) geo.getUserData ();
            newFeature.setAttribute ("ASHS_ID", id);
            geo.setUserData (null);
        }
        newFeature.setGeometry (medialAxis);
        medialAxisLineStringFeatures.add (newFeature);
    }
    return medialAxisLineStringFeatures;
}


public boolean Execute (String name, String args) {
    String fullname;
    String p_fullname;
    String line = args;
    if (args.length () != 0) {
        if (args.charAt (0) != ' ') {
            line = ' ' + line;
        }
    }
    if ((name.substring (1).equals (":") || name.substring (1).equals (":\\")) && StringHelper.isalpha (name.charAt (0))) {
        if (! Dos_files.DOS_SetDrive ((short) (name.toUpperCase ().charAt (0) - 'A'))) {
            WriteOut (Msg.get ("SHELL_EXECUTE_DRIVE_NOT_FOUND"), new Object [] {new Character (name.toUpperCase ().charAt (0))});
        }
        return true;
    }
    p_fullname = Which (name);
    if (p_fullname == null) return false;
    fullname = p_fullname;
    int extension = fullname.lastIndexOf ('.');
    String sExtension = "";
    if (extension >= 0) {
        sExtension = fullname.substring (extension).toLowerCase ();
    }
    else {
        String temp_name = fullname + ".COM";
        String temp_fullname = Which (temp_name);
        if (temp_fullname != null) {
            sExtension = ".com";
            fullname = temp_fullname;
        }
        else {
            temp_name = fullname + ".EXE";
            temp_fullname = Which (temp_name);
            temp_fullname = Which (temp_name);
            if (temp_fullname != null) {
                sExtension = ".exe";
                fullname = temp_fullname;
            }
            else {
                temp_name = fullname + ".BAT";
                temp_fullname = Which (temp_name);
                temp_fullname = Which (temp_name);
                if (temp_fullname != null) {
                    sExtension = ".bat";
                    fullname = temp_fullname;
                }
                else {
                    return false;
                }
            }
        }
    }
    if (sExtension.equalsIgnoreCase (".bat")) {
        boolean temp_echo = echo;
        if (bf != null && ! call) bf.close ();
        bf = new BatchFile (this, fullname, name, line);
        echo = temp_echo;
    }
    else {
        if (! sExtension.equalsIgnoreCase (".com") && ! sExtension.equalsIgnoreCase (".exe")) return false;
        CPU_Regs.reg_esp.word (CPU_Regs.reg_esp.word () - 0x200);
        Dos_ParamBlock block = new Dos_ParamBlock (CPU.Segs_SSphys + CPU_Regs.reg_esp.word ());
        block.Clear ();
        int file_name = CPU_Regs.RealMakeSegSS (CPU_Regs.reg_esp.word () + 0x20);
        Memory.MEM_BlockWrite (Memory.Real2Phys (file_name), fullname, fullname.length () + 1);
        full_arguments = line;
        byte [] cmdtail = new byte [128];
        cmdtail [0] = (byte) line.length ();
        StringHelper.strcpy (cmdtail, 1, line);
        cmdtail [line.length () + 1] = 0xd;
        Memory.MEM_BlockWrite (CPU.Segs_SSphys + CPU_Regs.reg_esp.word () + 0x100, cmdtail, 128);
        ShortRef add = new ShortRef (0);
        String tailBuffer = StringHelper.toString (cmdtail, 1, cmdtail.length - 1);
        Dos_files.FCB_Parsename (Dos.dos.psp (), 0x5C, (short) 0x00, tailBuffer, add);
        Dos_files.FCB_Parsename (Dos.dos.psp (), 0x6C, (short) 0x00, tailBuffer.substring (add.value), add);
        block.exec.fcb1 = Memory.RealMake (Dos.dos.psp (), 0x5C);
        block.exec.fcb2 = Memory.RealMake (Dos.dos.psp (), 0x6C);
        block.exec.cmdtail = CPU_Regs.RealMakeSegSS (CPU_Regs.reg_esp.word () + 0x100);
        block.SaveData ();
        CPU_Regs.reg_eax.word (0x4b00);
        CPU_Regs.SegSet16DS ((int) CPU.Segs_SSval);
        CPU_Regs.reg_edx.word (Memory.RealOff (file_name));
        CPU_Regs.SegSet16ES ((int) CPU.Segs_SSval);
        CPU_Regs.reg_ebx.word (CPU_Regs.reg_esp.word ());
        CPU_Regs.SETFLAGBIT (CPU_Regs.IF, false);
        Callback.CALLBACK_RunRealInt (0x21);
        CPU_Regs.reg_esp.word (CPU_Regs.reg_esp.word () + 0x200);
    }
    return true;
}


-----Function Pair=29=-----==

void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) {
        if (value.length > 0) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
        else System.out.println ("doing conditional " + arg + " " + op + " <NO ARGUMENT TOKEN FOUND>");
    }
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=30=-----==

public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


public static void main (String [] args) throws IOException {
    if (args.length < 2) {
        System.out.println ("Usage: java GenerateFromTemplate [-debug] <input> <output> {<var>=<value>}");
        return;
    }
    int argc = args.length;
    if (args [0].equals ("-debug")) {
        DEBUG = true;
        argc --;
        for (int i = 0; i < argc; i ++) args [i] = args [i + 1];
    }
    int limit = argc;
    argc = 2;
    for (int i = 2; i < limit; i ++) {
        if (args [i].indexOf ("=") < 0) args [argc - 1] = args [argc - 1] + " " + args [i];
        else {
            args [argc ++] = args [i];
        }
    }
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    if (DEBUG) System.out.println ("in:" + args [0] + "\nout:" + args [1]);
    try {
        if (args [0].indexOf (File.separator) != - 1) inDir = args [0].substring (0, args [0].lastIndexOf (File.separator) + 1);
        else inDir = "";
        inStream = new FileInputStream (args [0]);
        outStream = new FileOutputStream (args [1]);
        String [] vars = new String [argc - 2];
        String [] vals = new String [argc - 2];
        for (int i = 2; i < argc; i ++) {
            String arg = args [i];
            int pos = arg.indexOf ("=");
            vars [i - 2] = arg.substring (0, pos);
            vals [i - 2] = arg.substring (pos + 1);
            if (DEBUG) System.out.println (vars [i - 2] + " = " + vals [i - 2]);
        }
        GenerateFromTemplate gft = new GenerateFromTemplate (inStream, outStream);
        gft.setSubst (vars, vals);
        gft.generateOutputFromTemplate ();
    } finally {
        try {
            inStream.close ();
            outStream.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=31=-----==

String substitute (String input, String var, String value) throws IOException {
    StringBuffer out = new StringBuffer ();
    int varlen = var.length ();
    int oidx = 0;
    for (;;) {
        int idx = input.indexOf (var, oidx);
        if (idx == - 1) break;
        out.append (input.substring (oidx, idx));
        idx += varlen;
        out.append (value);
        oidx = idx;
    }
    out.append (input.substring (oidx));
    return out.toString ();
}


protected static void complexSqrt (float Re, float Im, float [] result) {
    float absRe, absIm, w, r;
    if ((Re == 0.0f) && (Im == 0.0f)) {
        result [0] = 0.0f;
        result [1] = 0.0f;
    }
    else {
        absRe = Math.abs (Re);
        absIm = Math.abs (Im);
        if (absRe >= absIm) {
            r = absIm / absRe;
            w = (float) (Math.sqrt (absRe) * Math.sqrt (0.5f * (1.0f + Math.sqrt (1.0f + r * r))));
        }
        else {
            r = absRe / absIm;
            w = (float) (Math.sqrt (absIm) * Math.sqrt (0.5f * (r + Math.sqrt (1.0f + r * r))));
        }
        if (Re >= 0.0) {
            result [0] = w;
            result [1] = Im / (2.0f * w);
        }
        else {
            result [1] = (Im >= 0.0f) ? w : - w;
            result [0] = Im / (2.0f * result [1]);
        }
    }
}


-----Function Pair=32=-----==

public OrdersTO doTrade () throws Exception {
    QuoteTO quote = getQuote (idPaper);
    currTime ++;
    if (quote == null) return null;
    double preco = quote.getClose ();
    if (currTime < PERIODO) {
        novo_dia (preco, dias);
        return createOrdemTO (0, preco, true);
    }
    else {
        int v;
        if (ifr (dias) < 70) v = VOLUME;
        else if (ifr (dias) > 70) v = - 1 * VOLUME;
        else v = 0;
        novo_dia (preco, dias);
        return createOrdemTO (Math.abs (v), dias [PERIODO - 1], v > 0 ? true : false);
    }
}


public void doClearBreakpoint (String command, String [] args) {
    if (args.length == 0) {
        user.bpset.clearBreakpoint ();
        jdp_console.writeOutput ("breakpoint cleared");
    }
    else if (args [0].equals ("all")) {
        user.bpset.clearAllBreakpoint ();
        jdp_console.writeOutput ("all breakpoints cleared");
    }
    else {
        try {
            int addr = parseHex32 (args [0]);
            breakpoint bp = user.bpset.lookup (addr);
            if (bp != null) {
                user.bpset.clearBreakpoint (bp);
                jdp_console.writeOutput ("breakpoint cleared");
            }
            else jdp_console.writeOutput ("no breakpoint at " + args [0]);
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("Clear breakpoint: please specify hex address");
        }
    }
}


-----Function Pair=33=-----==

void processEvalRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("doing eval");
    PrintWriter old_out = out;
    StringWriter sw = new StringWriter ();
    out = new PrintWriter (sw);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) region.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
    out = old_out;
    if (DEBUG) System.out.println ("doing eval: evaluating\n" + sw);
    LineNumberReader old_in = in;
    in = new LineNumberReader (new StringReader (sw.toString ()));
    String inLine;
    for (inLine = readLine (); inLine != null; inLine = readLine ()) {
        if (DEBUG) System.out.println ("from input:" + inLine);
        if (! isTemplateLine (inLine)) {
            if (DEBUG) System.out.println ("not template line, continuing...");
            out.print (inLine + "\n");
            continue;
        }
        Vector newRegion = buildTemplateRegion (inLine);
        processTemplateRegion (newRegion);
    }
    in = old_in;
}


public static final String replaceIgnoreCase (String line, String oldString, String newString) {
    if (line == null) {
        return null;
    }
    oldString = filterAfterDB (oldString);
    String lcLine = line.toLowerCase ();
    String lcOldString = oldString.toLowerCase ();
    int i = 0;
    if ((i = lcLine.indexOf (lcOldString, i)) >= 0) {
        char [] line2 = line.toCharArray ();
        char [] newString2 = newString.toCharArray ();
        int oLength = oldString.length ();
        StringBuffer buf = new StringBuffer (line2.length);
        buf.append (line2, 0, i).append (newString2);
        i += oLength;
        int j = i;
        while ((i = lcLine.indexOf (lcOldString, i)) > 0) {
            buf.append (line2, j, i - j).append (newString2);
            i += oLength;
            j = i;
        }
        buf.append (line2, j, line2.length - j);
        return buf.toString ();
    }
    return line;
}


-----Function Pair=34=-----=1=

void bubbleSort (int [] a) {
    int i = 0;
    int j = a.length - 1;
    int aux = 0;
    int stop = 0;
    while (stop == 0) {
        stop = 1;
        i = 0;
        while (i < j) {
            if (a [i] > a [i + 1]) {
                aux = a [i];
                a [i] = a [i + 1];
                a [i + 1] = aux;
                stop = 0;
            }
            i = i + 1;
        }
        j = j - 1;
    }
}


public static void bubbleSort (int [] polje) {
    boolean swapped;
    int temp;
    int n = polje.length;
    do {
        swapped = false;
        n --;
        for (int i = 0; i < n - 1; i ++) {
            if (polje [i] > polje [i + 1]) {
                temp = polje [i];
                polje [i] = polje [i + 1];
                polje [i + 1] = temp;
                swapped = true;
            }
        }
    }
    while (swapped);
}


-----Function Pair=35=-----==

void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


void processCondRegion (Vector region) throws IOException {
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing argument in IF");
    String arg = pst.nextToken ();
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing operation in IF");
    String op = pst.nextToken ();
    String [] value = new String [pst.countTokens ()];
    for (int i = 0; i < value.length; i ++) value [i] = pst.nextToken ();
    if (DEBUG) System.out.println ("doing conditional " + arg + " " + op + " " + value [0]);
    Vector newRegion = (Vector) region.elementAt (1);
    if (! evaluateConditional (arg, op, value)) {
        if (region.size () > 2) newRegion = (Vector) region.elementAt (2);
        else newRegion = new Vector ();
        if (DEBUG) System.out.println ("condition is false");
    }
    else {
        if (DEBUG) System.out.println ("condition is true");
    }
    for (int j = 0; j < newRegion.size (); j ++) {
        try {
            String currentLine = (String) newRegion.elementAt (j);
            out.print (currentLine + "\n");
        } catch (ClassCastException e) {
            Vector tmpRegion = (Vector) newRegion.elementAt (j);
            processTemplateRegion (tmpRegion);
        }
    }
}


-----Function Pair=36=-----==

public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


public int countTokens () {
    int count = 0;
    int pos = curPos;
    while (pos < maxPos) {
        while (pos < maxPos && delim.indexOf (str.charAt (pos)) >= 0) pos ++;
        if (pos >= maxPos) break;
        if (str.charAt (pos) == '\"') {
            int start = ++ pos;
            boolean quoted = false;
            while (quoted || str.charAt (pos) != '\"') {
                quoted = ! quoted && str.charAt (pos) == '\\';
                pos ++;
                if (pos >= maxPos) throw new UnterminatedStringException ();
            }
            pos ++;
        }
        else {
            int start = pos;
            while (pos < maxPos && delim.indexOf (str.charAt (pos)) < 0) pos ++;
        }
        count ++;
    }
    return count;
}


-----Function Pair=37=-----==

protected void decodeNextScanline (byte [] buffer, int lineOffset, int bitOffset) {
    int bits = 0;
    int code = 0;
    int isT = 0;
    int current;
    int entry;
    int twoBits;
    boolean isWhite = true;
    changingElemSize = 0;
    while (bitOffset < w) {
        while (isWhite) {
            current = nextNBits (10);
            entry = white [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x0f;
            if (bits == 12) {
                twoBits = nextLesserThan8Bits (2);
                current = ((current << 2) & 0x000c) | twoBits;
                entry = additionalMakeup [current];
                bits = (entry>>> 1) & 0x07;
                code = (entry>>> 4) & 0x0fff;
                bitOffset += code;
                updatePointer (4 - bits);
            }
            else if (bits == 0) {
                throw new RuntimeException ("Invalid code encountered.");
            }
            else if (bits == 15) {
                throw new RuntimeException ("EOL code word encountered in White run.");
            }
            else {
                code = (entry>>> 5) & 0x07ff;
                bitOffset += code;
                updatePointer (10 - bits);
                if (isT == 0) {
                    isWhite = false;
                    currChangingElems [changingElemSize ++] = bitOffset;
                }
            }
        }
        if (bitOffset == w) {
            if (compression == 2) {
                advancePointer ();
            }
            break;
        }
        while (isWhite == false) {
            current = nextLesserThan8Bits (4);
            entry = initBlack [current];
            isT = entry & 0x0001;
            bits = (entry>>> 1) & 0x000f;
            code = (entry>>> 5) & 0x07ff;
            if (code == 100) {
                current = nextNBits (9);
                entry = black [current];
                isT = entry & 0x0001;
                bits = (entry>>> 1) & 0x000f;
                code = (entry>>> 5) & 0x07ff;
                if (bits == 12) {
                    updatePointer (5);
                    current = nextLesserThan8Bits (4);
                    entry = additionalMakeup [current];
                    bits = (entry>>> 1) & 0x07;
                    code = (entry>>> 4) & 0x0fff;
                    setToBlack (buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer (4 - bits);
                }
                else if (bits == 15) {
                    throw new RuntimeException ("EOL code word encountered in Black run.");
                }
                else {
                    setToBlack (buffer, lineOffset, bitOffset, code);
                    bitOffset += code;
                    updatePointer (9 - bits);
                    if (isT == 0) {
                        isWhite = true;
                        currChangingElems [changingElemSize ++] = bitOffset;
                    }
                }
            }
            else if (code == 200) {
                current = nextLesserThan8Bits (2);
                entry = twoBitBlack [current];
                code = (entry>>> 5) & 0x07ff;
                bits = (entry>>> 1) & 0x0f;
                setToBlack (buffer, lineOffset, bitOffset, code);
                bitOffset += code;
                updatePointer (2 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
            else {
                setToBlack (buffer, lineOffset, bitOffset, code);
                bitOffset += code;
                updatePointer (4 - bits);
                isWhite = true;
                currChangingElems [changingElemSize ++] = bitOffset;
            }
        }
        if (bitOffset == w) {
            if (compression == 2) {
                advancePointer ();
            }
            break;
        }
    }
    currChangingElems [changingElemSize ++] = bitOffset;
}


private static synchronized double swe_julday (int year, int month, int day, double hour, boolean calType) {
    Trace.level ++;
    Trace.trace (Trace.level, "SweDate.julday(int, int, int, double, boolean)");
    double jd;
    double u, u0, u1, u2;
    u = year;
    if (month < 3) {
        u -= 1;
    }
    u0 = u + 4712.0;
    u1 = month + 1.0;
    if (u1 < 4) {
        u1 += 12.0;
    }
    jd = SMath.floor (u0 * 365.25) + SMath.floor (30.6 * u1 + 0.000001) + day + hour / 24.0 - 63.5;
    if (calType == SE_GREG_CAL) {
        u2 = SMath.floor (SMath.abs (u) / 100) - SMath.floor (SMath.abs (u) / 400);
        if (u < 0.0) {
            u2 = - u2;
        }
        jd = jd - u2 + 2;
        if ((u < 0.0) && (u / 100 == SMath.floor (u / 100)) && (u / 400 != SMath.floor (u / 400))) {
            jd -= 1;
        }
    }
    Trace.level --;
    return jd;
}


-----Function Pair=38=-----==

private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


private int evalTerm (StreamTokenizer st) throws IOException {
    int val = evalFactor (st);
    int token = st.nextToken ();
    while (token == '*' || token == '/' || token == '%' || token == '&') {
        int t = evalFactor (st);
        switch (token) {
            case '*' :
                val *= t;
                break;
            case '/' :
                val /= t;
                break;
            case '%' :
                val %= t;
                break;
            case '&' :
                val &= t;
                break;
            default :
                throw new IOException ("Invalid token");
        }
        token = st.nextToken ();
    }
    st.pushBack ();
    return val;
}


-----Function Pair=39=-----==

void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


void processCountRegion (Vector region) throws IOException {
    if (DEBUG) System.out.println ("params=\"" + params + "\"");
    QuotedStringTokenizer pst = new QuotedStringTokenizer (params);
    if (! pst.hasMoreTokens ()) throw new IOException ("Missing var name in COUNT");
    String var_name = pst.nextToken ();
    int count = 0;
    while (pst.hasMoreTokens ()) {
        String v_i = pst.nextToken ();
        int dotdot = v_i.indexOf ("..");
        if (dotdot != - 1 && dotdot == v_i.lastIndexOf ("..")) {
            int start = Integer.parseInt (v_i.substring (0, dotdot));
            int end = Integer.parseInt (v_i.substring (dotdot + 2));
            for (int j = start; j <= end; j ++) count ++;
        }
        else count ++;
    }
    String value = Integer.toString (count);
    if (DEBUG) System.out.println ("doing count with varname " + var_name + " on values :" + params.substring (var_name.length () + 1) + "; count=" + value);
    for (int j = 1; j < region.size (); j ++) {
        try {
            String currentLine = (String) region.elementAt (j);
            String result = substitute (currentLine, var_name, value);
            out.print (result + "\n");
        } catch (ClassCastException e) {
            Vector oldRegion = (Vector) region.elementAt (j);
            Vector newRegion = substituteInRegion (oldRegion, var_name, value);
            processTemplateRegion (newRegion);
        }
    }
}


-----Function Pair=40=-----==

private void printStatistics (final OctTree octTree) {
    System.out.println ("Number of nodes: " + nodes.size ());
    double attrSum = 0.0;
    for (Node node : nodes) {
        for (Edge edge : attrEdges.get (node)) {
            attrSum += edge.weight;
        }
    }
    System.out.println ("Overall attraction: " + attrSum);
    double meanAttrEnergy = 0.0;
    for (Node node : nodes) meanAttrEnergy += getAttractionEnergy (node);
    meanAttrEnergy = (attrExponent == 0.0) ? Math.exp (meanAttrEnergy / attrSum) : Math.pow (meanAttrEnergy * attrExponent / attrSum, 1.0 / attrExponent);
    System.out.println ("Weighted mean of attraction energy: " + meanAttrEnergy);
    double repuSum = 0.0, repuSquareSum = 0.0;
    for (Node node : nodes) {
        repuSum += node.weight;
        repuSquareSum += node.weight * node.weight;
    }
    repuSum = repuSum * repuSum - repuSquareSum;
    System.out.println ("Overall repulsion: " + repuSum);
    double meanRepuEnergy = 0.0;
    for (Node node : nodes) meanRepuEnergy += getRepulsionEnergy (node, octTree);
    meanRepuEnergy /= repuFactor;
    meanRepuEnergy = (repuExponent == 0.0) ? Math.exp (- meanRepuEnergy / repuSum) : Math.pow (- meanRepuEnergy * repuExponent / repuSum, 1.0 / repuExponent);
    System.out.println ("Weighted mean of repulsion energy: " + meanRepuEnergy);
    System.out.println ("Mean attraction / mean repulsion: " + meanAttrEnergy / meanRepuEnergy);
}


public static void generateKeys2 (int keySize, Path publicKey, Path privateKey) throws NoSuchAlgorithmException, IOException {
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance ("RSA");
    keyGen.initialize (keySize);
    KeyPair keyPair = keyGen.generateKeyPair ();
    PublicKey pubkey = keyPair.getPublic ();
    PrivateKey privkey = keyPair.getPrivate ();
    Files.createDirectories (publicKey.getParent ());
    Files.createFile (publicKey);
    Files.createDirectories (privateKey.getParent ());
    Files.createFile (privateKey);
    ObjectOutputStream oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (publicKey.toFile ())));
    oout.writeObject (pubkey);
    oout.close ();
    oout = new ObjectOutputStream (new BufferedOutputStream (new FileOutputStream (privateKey.toFile ())));
    oout.writeObject (privkey);
    oout.close ();
}


-----Function Pair=41=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=42=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=43=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=44=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=45=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=46=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=47=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=48=-----=1=

public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


public static void BubbleSortShort2 (short [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                short temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=49=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=50=-----==

public void createDistJar (DistJarConfig distJarConfig, boolean includeUserCredentials) throws IOException, IncorrectKeyException, IllegalAccessException, NoSuchAlgorithmException, KeyStoreException, CertificateException, VisitPCException, ClassNotFoundException, InstantiationException {
    Properties configProperties = new Properties ();
    if (distJarConfig.serverName != null && distJarConfig.serverName.trim ().length () > 0 && distJarConfig.serverPort > 0) {
        checkServerReachable (distJarConfig.serverName, distJarConfig.serverPort, 30000);
        checkServerNotOnLocalSubnet (distJarConfig.serverName);
    }
    if (! new File (distJarConfig.distJarDialogConfig.outputPath).isDirectory ()) {
        throw new IOException (distJarConfig.distJarDialogConfig.outputPath + " jar file output directory not found.");
    }
    File configPropertiesFile = new File (distJarConfig.configDir, SimpleConfigHelper.JAR_CONFIG_FILENAME);
    if (distJarConfig.pm != null) {
        distJarConfig.pm.setMinimum (0);
        distJarConfig.pm.setMaximum (6);
        distJarConfig.pm.setProgress (1);
    }
    if (distJarConfig.tmpDir.isDirectory ()) {
        removeDirectory (distJarConfig.tmpDir);
    }
    if (! distJarConfig.tmpDir.mkdir ()) {
        throw new IOException ("Unable to create the " + distJarConfig.tmpDir + " directory.");
    }
    JarIt jarIt = new JarIt (distJarConfig.visitPCJarFile.getAbsolutePath (), distJarConfig.tmpDir.getAbsolutePath ());
    jarIt.decompress ();
    if (distJarConfig.pm != null) {
        distJarConfig.pm.setProgress (2);
    }
    removeDirectory (distJarConfig.srvMgrDir);
    if (! distJarConfig.distJarDialogConfig.jarTypeList.equals (DistJarDialogConfig.VNC_DEST_CLIENT)) {
        removeDirectory (distJarConfig.vncServerDir);
    }
    if (! distJarConfig.configDir.mkdir ()) {
        throw new IOException ("Unable to create the " + distJarConfig.configDir + " directory.");
    }
    addGenericConfig (distJarConfig.distJarDialogConfig, configProperties, distJarConfig.configDir, SimpleConfigHelper.OBFUSRACTION_KEY);
    if (distJarConfig.trustStoreFile != null && distJarConfig.trustStoreFile.trim ().length () > 0) {
        String trustStoreFilename = copyTrustStoreFile (distJarConfig.trustStoreFile, distJarConfig.configDir.getAbsolutePath ());
        configProperties.put (SimpleConfigHelper.CLIENT_TRUSTSTORE_FILE_KEY, SimpleConfigHelper.JAR_CONFIG_PATH + trustStoreFilename);
    }
    copyEmbeddedConfigFile (distJarConfig.embeddedConfigFile, distJarConfig.configDir, distJarConfig.defaultEncryptKey, SimpleConfigHelper.OBFUSRACTION_KEY, includeUserCredentials, distJarConfig.distJarDialogConfig.clearPCName);
    File manifestDir = new File (distJarConfig.tmpDir, "META-INF");
    File manifestFile = new File (manifestDir, "MANIFEST.MF");
    if (! manifestFile.isFile ()) {
        throw new IOException (manifestFile + " file not found.");
    }
    BufferedWriter bw = new BufferedWriter (new FileWriter (manifestFile));
    bw.write ("Manifest-Version: 1.0" + System.getProperty ("line.separator"));
    bw.write ("Main-Class: " + distJarConfig.startupClass + System.getProperty ("line.separator"));
    bw.close ();
    if (distJarConfig.pm != null) {
        distJarConfig.pm.setProgress (3);
    }
    Vector < String > configFileList = new Vector < String > ();
    File destFile = new File (distJarConfig.configDir, "." + distJarConfig.embeddedConfigFile);
    configFileList.add (SimpleConfigHelper.JAR_CONFIG_PATH + destFile.getName ());
    if (distJarConfig.distJarDialogConfig.logoFile != null && distJarConfig.distJarDialogConfig.logoFile.length () > 0) {
        File lcf = new File (distJarConfig.distJarDialogConfig.logoFile);
        configProperties.put (SimpleConfigHelper.LOGO_IMAGE_FILE_KEY, SimpleConfigHelper.JAR_CONFIG_PATH + lcf.getName ());
    }
    if (distJarConfig.distJarDialogConfig.smallLogoFile != null && distJarConfig.distJarDialogConfig.smallLogoFile.length () > 0) {
        File slcf = new File (distJarConfig.distJarDialogConfig.smallLogoFile);
        configProperties.put (SimpleConfigHelper.SMALL_LOGO_IMAGE_FILE_KEY, SimpleConfigHelper.JAR_CONFIG_PATH + slcf.getName ());
    }
    bw = new BufferedWriter (new FileWriter (configPropertiesFile));
    int index = 0;
    StringBuffer strBuffer = new StringBuffer ();
    for (String configFile : configFileList) {
        if (index == 0) {
            strBuffer.append (configFile);
        }
        else {
            strBuffer.append ("\t" + configFile);
        }
        index ++;
    }
    configProperties.put (SimpleConfigHelper.FILES_KEY, strBuffer.toString ());
    configProperties.store (bw, distJarConfig.embeddedConfigFile);
    bw.close ();
    if (distJarConfig.distJarDialogConfig.jarTypeList.equals (DistJarDialogConfig.VNC_DEST_CLIENT)) {
        if (PlatformHandler.GetOSName ().startsWith ("Windows")) {
            File srcFile = VNCDestClient.GetVNCServerINI ();
            if (! srcFile.isFile ()) {
                throw new IOException (srcFile + " file not found.");
            }
            destFile = new File (distJarConfig.tmpDir.toString () + "\\visitpc\\destclient\\vncserver\\win\\ultravnc.ini");
            if (! destFile.isFile ()) {
                throw new IOException (destFile + " file not found.");
            }
            if (! destFile.delete ()) {
                throw new IOException ("Failed to delete " + destFile);
            }
            FileIO.CopyFile (srcFile.getAbsolutePath (), destFile.getAbsolutePath ());
        }
    }
    try {
        if (distJarConfig.pm != null) {
            distJarConfig.pm.setProgress (4);
        }
        jarIt.createJar (distJarConfig.tmpDir, distJarConfig.jarFile.toString ());
        if (distJarConfig.pm != null) {
            distJarConfig.pm.setProgress (5);
        }
        if (distJarConfig.webServerConfig != null) {
            copyToWebServer (distJarConfig);
        }
    } finally {
        if (distJarConfig.pm != null) {
            distJarConfig.pm.setProgress (6);
        }
    }
}


private JPanel _makePanel () {
    JPanel panel = new JPanel ();
    GridBagLayout gridbag = new GridBagLayout ();
    GridBagConstraints c = new GridBagConstraints ();
    panel.setLayout (gridbag);
    c.fill = GridBagConstraints.HORIZONTAL;
    Insets labelInsets = new Insets (5, 10, 0, 10);
    c.weightx = 0.0;
    c.gridwidth = 1;
    c.insets = labelInsets;
    _jarAll = new JCheckBox (new AbstractAction ("Jar All files") {
        public void actionPerformed (ActionEvent e) {
            _toggleClassOptions ();
            _jarClasses.setEnabled (! _jarAll.isSelected ());
            _jarSources.setEnabled (! _jarAll.isSelected ());
            _okButton.setEnabled (_jarSources.isSelected () || _jarClasses.isSelected () || _jarAll.isSelected ());
        }
    }
    );
    c.weightx = 0.0;
    c.gridwidth = GridBagConstraints.REMAINDER;
    c.insets = labelInsets;
    gridbag.setConstraints (_jarAll, c);
    panel.add (_jarAll);
    _jarSources = new JCheckBox (new AbstractAction ("Jar source files") {
        public void actionPerformed (ActionEvent e) {
            _jarAll.setEnabled (! _jarSources.isSelected ());
            _okButton.setEnabled (_jarSources.isSelected () || _jarClasses.isSelected () || _jarAll.isSelected ());
        }
    }
    );
    c.weightx = 0.0;
    c.gridwidth = 1;
    c.insets = labelInsets;
    gridbag.setConstraints (_jarSources, c);
    panel.add (_jarSources);
    c.weightx = 1.0;
    c.gridwidth = GridBagConstraints.REMAINDER;
    c.insets = labelInsets;
    c.fill = GridBagConstraints.HORIZONTAL;
    JPanel jarClassesPanel = _makeClassesPanel ();
    gridbag.setConstraints (jarClassesPanel, c);
    panel.add (jarClassesPanel);
    _cantJarClassesLabel = new JLabel ("<html><center>A build directory must be specified in order to jar class files,<br>and the project needs to be compiled.</center></html>", SwingConstants.CENTER);
    c.gridx = 0;
    c.anchor = GridBagConstraints.WEST;
    c.fill = GridBagConstraints.HORIZONTAL;
    gridbag.setConstraints (jarClassesPanel, c);
    panel.add (_cantJarClassesLabel);
    _toggleClassOptions ();
    c.gridx = 0;
    c.gridwidth = 1;
    c.insets = labelInsets;
    JLabel label = new JLabel ("Jar File");
    label.setToolTipText ("The file that the jar should be written to.");
    gridbag.setConstraints (label, c);
    panel.add (label);
    c.weightx = 1.0;
    c.gridx = 0;
    c.gridwidth = GridBagConstraints.REMAINDER;
    c.insets = labelInsets;
    JPanel jarFilePanel = _makeJarFileSelector ();
    gridbag.setConstraints (jarFilePanel, c);
    panel.add (jarFilePanel);
    return panel;
}


-----Function Pair=51=-----==

public static Boolean copyDir (File oSource, File oDestination) {
    try {
        if (oSource.exists ()) {
            if (oSource.isDirectory ()) {
                if (! oDestination.exists ()) {
                    oDestination.mkdir ();
                }
                String [] children = oSource.list ();
                for (int i = 0; i < children.length; i ++) {
                    copyDir (new File (oSource, children [i]), new File (oDestination, children [i]));
                }
            }
            else {
                InputStream in = new FileInputStream (oSource);
                OutputStream out = new FileOutputStream (oDestination);
                byte [] buf = new byte [1024];
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                in.close ();
                out.close ();
            }
            return true;
        }
    } catch (IOException oException) {
        throw new FilesystemException (oException.getMessage (), oSource.getName (), oException);
    }
    return false;
}


private static void writeLngFile (Vector pairs, String outFile, boolean onelang) throws BuildException {
    try {
        FileOutputStream ostream = new FileOutputStream (outFile);
        DataOutputStream dos = new DataOutputStream (ostream);
        int size = pairs.size ();
        dos.writeShort (size);
        for (int i = 0; i < size; i ++) {
            String [] pair = (String []) pairs.elementAt (i);
            dos.writeUTF (keyToShortKey (pair [0]));
            dos.writeUTF (pair [1]);
        }
        dos.flush ();
        ostream.close ();
    } catch (Exception e) {
        throw new BuildException (e);
    }
}


-----Function Pair=52=-----==

private void settingsLoadMenuItemActionPerformed (java.awt.event.ActionEvent evt) {
    JFileChooser fc = new JFileChooser ();
    if (settingsFile != null) {
        fc.setSelectedFile (settingsFile);
    }
    else {
        fc.setSelectedFile (DEFAULT_SETTINGS_FILE);
    }
    int returnVal = fc.showOpenDialog (this);
    if (returnVal == JFileChooser.APPROVE_OPTION) {
        File file = fc.getSelectedFile ();
        try {
            loadSettings (file);
        } catch (Exception ex) {
            Logger.getLogger (MainFrame.class.getName ()).log (Level.SEVERE, "Could not load settings from \"" + file + "\"", ex);
        }
    }
}


public boolean renameItem (int position, String newName, boolean copy) {
    try {
        if (items == null || position <= 0 || position > items.length) return false;
        if (ftp != null && ftp.isLoggedIn ()) {
            boolean ok;
            if (copy) {
                notify (s (R.string.not_supported), Commander.OPERATION_FAILED);
                return false;
            }
            synchronized (ftp) {
                ok = ftp.rename (getItemName (position, false), newName);
            }
            notify (null, ok ? Commander.OPERATION_COMPLETED_REFRESH_REQUIRED : Commander.OPERATION_FAILED);
            return ok;
        }
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=53=-----==

public void createProject (String projectName, URI location) {
    IProject newProject = ResourcesPlugin.getWorkspace ().getRoot ().getProject (projectName);
    if (! newProject.exists ()) {
        URI projectLocation = location;
        IProjectDescription desc = newProject.getWorkspace ().newProjectDescription (newProject.getName ());
        if (location != null && ResourcesPlugin.getWorkspace ().getRoot ().getLocationURI ().equals (location)) {
            projectLocation = null;
        }
        desc.setLocationURI (projectLocation);
        try {
            newProject.create (desc, null);
            if (! newProject.isOpen ()) {
                newProject.open (null);
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}


public static List < File > checkAndUnzipTo (File zipFile, File destFolder, Checksum checksum) {
    try {
        byte [] fileDigest = Checksums.md5 (zipFile);
        String fileDigestString = Arrays.toString (fileDigest);
        if (! fileDigestString.equals (checksum.getValue ())) {
            log.warning ("[checkAndUnzipTo] WARNING: The calculated checksum of the zip file is NOT equal to the passed checksum. File might be corrupted!");
            log.warning ("[checkAndUnzipTo] Checksum Algorithm: " + checksum.getAlgorithm ());
            log.warning ("[checkAndUnzipTo] Passed checksum: " + checksum.getValue ());
            log.warning ("[checkAndUnzipTo] Calculated checksum: " + fileDigestString);
        }
        else {
            log.info ("[checkAndUnzipTo] Success!! Checksum correct!");
        }
        return unzipTo (zipFile, destFolder);
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=54=-----==

public void actionPerformed (ActionEvent e) {
    if (stop.getText ().equals ("Pause")) {
        stop.setText ("Start");
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            backup [r] [c] = b [r] [c].getText ();
            b [r] [c].setText (" ");
        }
        canUpdateTimer = false;
    }
    else {
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            b [r] [c].setText (backup [r] [c]);
        }
        stop.setText ("Pause");
        canUpdateTimer = true;
    }
}


public void actionPerformed (ActionEvent e) {
    if (stop.getText ().equals ("Pause")) {
        stop.setText ("Start");
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            backup [r] [c] = b [r] [c].getText ();
            b [r] [c].setText (" ");
        }
        canUpdateTimer = false;
    }
    else {
        for (int r = 0; r < 9; r ++) for (int c = 0; c < 9; c ++) {
            b [r] [c].setText (backup [r] [c]);
        }
        stop.setText ("Pause");
        canUpdateTimer = true;
    }
}


-----Function Pair=55=-----==

public String wikify (String s, WikiPageHandler handler) {
    s = s.replace ("\\\\[", "_BRACKETOPEN_");
    if (getReplaceNewlineWithP ()) {
        s = s.replaceAll ("\r\n\r\n", "\n<p>\n");
        s = s.replaceAll ("\r\r", "\n<p>\n");
    }
    s = s.replaceAll ("'''''([^']+)'''''", "<b><i>$1</i></b>");
    s = s.replaceAll ("'''([^']+)'''", "<b>$1</b>");
    s = s.replaceAll ("''([^']+)''", "<i>$1</i>");
    Pattern pattern;
    Matcher matcher;
    pattern = Pattern.compile ("\\[\\[([^\\]|]+)\\|?([^\\]]*)\\]\\]");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String name = matcher.group (1);
        String label = matcher.group (2);
        int start = matcher.start (0);
        int end = matcher.end (0);
        String link;
        if (handler == null) {
            if (label.trim ().length () == 0) {
                label = name;
            }
            link = "<a href=\"" + name + "\">" + label + "</a>";
        }
        else {
            link = handler.getWikiLink (this, name, label);
        }
        s = s.substring (0, start) + link + s.substring (end);
        matcher = pattern.matcher (s);
    }
    int cnt = 0;
    pattern = Pattern.compile ("\\[([^\\]]+)\\]");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String name = matcher.group (1).trim ();
        int idx = name.indexOf (" ");
        int start = matcher.start (0);
        int end = matcher.end (0);
        if (idx > 0) {
            String label = name.substring (idx);
            name = name.substring (0, idx);
            String ahref = "<a title=\"" + name + "\" class=\"wiki-link-external\" target=\"externalpage\" href=\"" + name + "\">";
            s = s.substring (0, start) + ahref + label + "</a>" + s.substring (end);
        }
        else {
            cnt ++;
            String ahref = "<a title=\"" + name + "\" class=\"wiki-link-external\" target=\"externalpage\" href=\"" + name + "\">";
            s = s.substring (0, start) + ahref + "_BRACKETOPEN_" + cnt + "_BRACKETCLOSE_</a>" + s.substring (end);
        }
        matcher = pattern.matcher (s);
    }
    List headings = new ArrayList ();
    pattern = Pattern.compile ("(?m)^\\s*(==+)([^=]+)(==+)\\s*$");
    matcher = pattern.matcher (s);
    while (matcher.find ()) {
        String prefix = matcher.group (1).trim ();
        String label = matcher.group (2).trim ();
        int start = matcher.start (0);
        int end = matcher.end (0);
        int level = prefix.length ();
        String value;
        if (label.startsWith ("{{")) {
            value = "<div class=\"wiki-h" + level + "\">" + label + "</div>";
        }
        else {
            value = "<a name=\"" + label + "\"></a><div class=\"wiki-h" + level + "\">" + label + "</div>";
            headings.add (new Object [] {new Integer (level), label});
        }
        s = s.substring (0, start) + value + s.substring (end);
        matcher = pattern.matcher (s);
    }
    int ulCnt = 0;
    int olCnt = 0;
    StringBuffer buff = new StringBuffer ();
    for (String line : (List < String >) StringUtil.split (s, "\n", false, false)) {
        String tline = line.trim ();
        if (tline.equals ("----")) {
            buff.append ("<hr>");
            buff.append ("\n");
            continue;
        }
        int starCnt = 0;
        while (tline.startsWith ("*")) {
            tline = tline.substring (1);
            starCnt ++;
        }
        if (starCnt > 0) {
            if (starCnt > ulCnt) {
                while (starCnt > ulCnt) {
                    buff.append ("<ul>\n");
                    ulCnt ++;
                }
            }
            else {
                while ((starCnt < ulCnt) && (ulCnt > 0)) {
                    buff.append ("</ul>\n");
                    ulCnt --;
                }
            }
            buff.append ("<li> ");
            buff.append (tline);
            buff.append ("</li> ");
            buff.append ("\n");
            continue;
        }
        while (ulCnt > 0) {
            buff.append ("</ul>\n");
            ulCnt --;
        }
        int hashCnt = 0;
        while (tline.startsWith ("#")) {
            tline = tline.substring (1);
            hashCnt ++;
        }
        if (hashCnt > 0) {
            if (hashCnt > olCnt) {
                while (hashCnt > olCnt) {
                    buff.append ("<ol>\n");
                    olCnt ++;
                }
            }
            else {
                while ((hashCnt < olCnt) && (olCnt > 0)) {
                    buff.append ("</ol>\n");
                    olCnt --;
                }
            }
            buff.append ("<li> ");
            buff.append (tline);
            buff.append ("\n");
            continue;
        }
        while (olCnt > 0) {
            buff.append ("</ol>\n");
            olCnt --;
        }
        buff.append (line);
        buff.append ("\n");
    }
    while (ulCnt > 0) {
        buff.append ("</ul>\n");
        ulCnt --;
    }
    while (olCnt > 0) {
        buff.append ("</ol>\n");
        olCnt --;
    }
    s = buff.toString ();
    StringBuffer sb = new StringBuffer ();
    int baseIdx = 0;
    while (true) {
        int idx1 = s.indexOf ("{{", baseIdx);
        if (idx1 < 0) {
            sb.append (s.substring (baseIdx));
            break;
        }
        int idx2 = s.indexOf ("}}", idx1);
        if (idx2 <= idx1) {
            sb.append (s.substring (baseIdx));
            break;
        }
        sb.append (s.substring (baseIdx, idx1));
        String property = s.substring (idx1 + 2, idx2);
        baseIdx = idx2 + 2;
        if (property.equals ("noheading")) {
            makeHeadings = false;
        }
        else {
            String value = null;
            if (handler != null) {
                value = handler.getWikiPropertyValue (this, property);
            }
            if (value == null) {
                value = "Unknown property:" + property;
            }
            sb.append (value);
        }
    }
    s = sb.toString ();
    sb = new StringBuffer ();
    while (true) {
        int idx1 = s.indexOf ("<block");
        if (idx1 < 0) {
            break;
        }
        int idx2 = s.indexOf (">", idx1);
        if (idx2 < 0) {
            break;
        }
        int idx3 = s.indexOf ("</block>", idx2);
        if (idx3 < 0) {
            break;
        }
        String first = s.substring (0, idx1);
        String attrs = s.substring (idx1 + 6, idx2);
        String inner = s.substring (idx2 + 1, idx3);
        Hashtable props = StringUtil.parseHtmlProperties (attrs);
        boolean open = Misc.getProperty (props, "open", true);
        String title = Misc.getProperty (props, "title", "");
        sb.append (first);
        sb.append (HtmlUtil.makeShowHideBlock (title, inner, open, HtmlUtil.cssClass ("wiki-blockheader"), HtmlUtil.cssClass ("wiki-block")));
        s = s.substring (idx3 + "</block>".length ());
    }
    sb.append (s);
    s = sb.toString ();
    s = s.replace ("_BRACKETOPEN_", "[");
    s = s.replace ("_BRACKETCLOSE_", "]");
    if (getMakeHeadings ()) {
        if (headings.size () >= 2) {
            StringBuffer toc = new StringBuffer ();
            makeHeadings (headings, toc, - 1, "");
            String block = HtmlUtil.makeShowHideBlock ("Contents", toc.toString (), true, HtmlUtil.cssClass ("wiki-tocheader"), HtmlUtil.cssClass ("wiki-toc"));
            floatBoxes.add (block);
            String blocks = "<table class=\"wiki-toc-wrapper\" align=\"right\" width=\"30%\"><tr><td>" + StringUtil.join ("<br>", floatBoxes) + "</td></tr></table>";
            s = blocks + s;
        }
    }
    if (categoryLinks.size () > 0) {
        s = s + HtmlUtil.div ("<b>Categories:</b> " + StringUtil.join ("&nbsp;|&nbsp; ", categoryLinks), HtmlUtil.cssClass ("wiki-categories"));
    }
    return s;
}


protected void applyPullRules (JNode sourceNode, JNode targetNode) {
    try {
        for (JControlModel.PullRule pullRule : getControlModel ().getPullRules ()) {
            if (pullRule.getSourceGetFeature ().getFeatureMethod () != null && pullRule.getSourceGetFeature ().getFeatureClass ().isInstance (sourceNode) && pullRule.getTargetPutFeature ().getFeatureMethod () != null && pullRule.getTargetPutFeature ().getFeatureClass ().isInstance (targetNode) && sourcePatternDictionary.isMarkedUp (pullRule.getSourceMarkup (), pullRule.getSourceParentMarkup (), sourceNode) && targetPatternDictionary.isMarkedUp (pullRule.getTargetMarkup (), pullRule.getTargetParentMarkup (), targetNode)) {
                if (pullRule.getEqualityFeature () != null) {
                    Method equalityFeatureMethod = pullRule.getEqualityFeature ().getFeatureMethod ();
                    Object value1 = equalityFeatureMethod.invoke (sourceNode, NO_ARGUMENTS);
                    Object value2 = equalityFeatureMethod.invoke (targetNode, NO_ARGUMENTS);
                    if (value1 == null ? value2 != null : ! value1.equals (value2)) {
                        continue;
                    }
                }
                Method sourceGetMethod = pullRule.getSourceGetFeature ().getFeatureMethod ();
                Object value = sourceGetMethod.invoke (sourceNode, NO_ARGUMENTS);
                Method targetPutMethod = pullRule.getTargetPutFeature ().getFeatureMethod ();
                if (! sourceGetMethod.getReturnType ().isArray () || targetPutMethod.getParameterTypes () [0].isAssignableFrom (sourceGetMethod.getReturnType ())) {
                    if (value instanceof String) {
                        String stringValue = (String) value;
                        stringValue = getControlModel ().getFacadeHelper ().applyFormatRules (stringValue);
                        Pattern sourceTransfer = pullRule.getSourceTransfer ();
                        if (sourceTransfer != null) {
                            String oldStringValue = (String) sourceGetMethod.invoke (targetNode, NO_ARGUMENTS);
                            if (oldStringValue != null) {
                                Matcher sourceMatcher = sourceTransfer.matcher (stringValue);
                                Matcher targetMatcher = sourceTransfer.matcher (oldStringValue);
                                if (sourceMatcher.groupCount () >= 1 && targetMatcher.groupCount () >= 1) {
                                    StringBuilder result = new StringBuilder ();
                                    int index = 0;
                                    int sourceStart = 0;
                                    int targetStart = 0;
                                    if (sourceTransfer.pattern ().startsWith ("(\\s*<!--")) {
                                        sourceStart = getStartIndex (stringValue);
                                        targetStart = getStartIndex (oldStringValue);
                                    }
                                    for (boolean match = sourceMatcher.find (sourceStart) && targetMatcher.find (targetStart); match; match = sourceMatcher.find () && targetMatcher.find ()) {
                                        result.append (stringValue.substring (index, sourceMatcher.start (1)));
                                        result.append (targetMatcher.group (1));
                                        index = sourceMatcher.end (1);
                                    }
                                    if (result.length () == 0) {
                                        stringValue = null;
                                    }
                                    else {
                                        result.append (stringValue.substring (index));
                                        stringValue = result.toString ();
                                    }
                                }
                                else {
                                    stringValue = null;
                                }
                            }
                        }
                        value = stringValue;
                    }
                    if (value != null || targetPutMethod.getName ().equals ("setInitializer") || targetPutMethod.getName ().equals ("setSuperclass") || targetPutMethod.getName ().equals ("setExceptions")) {
                        Object oldValue = sourceGetMethod.invoke (targetNode, NO_ARGUMENTS);
                        if (value == null ? oldValue == null : value.equals (oldValue)) {
                            continue;
                        }
                        else if (value instanceof Object [] && oldValue instanceof Object [] && Arrays.equals ((Object []) value, (Object []) oldValue)) {
                            continue;
                        }
                        else if (targetPutMethod.getName ().equals ("setSuperclass")) {
                            if (oldValue != null && value != null && ((String) oldValue).trim ().equals (((String) value).trim ())) {
                                continue;
                            }
                        }
                        if (sourceGetMethod.getName ().equals ("getReturnType") && getControlModel ().getBlockPattern () != null && ((JMethod) targetNode).getComment () != null && getControlModel ().getBlockPattern ().matcher (((JMethod) targetNode).getComment ()).find ()) {
                            continue;
                        }
                        targetPutMethod.invoke (targetNode, new Object [] {value});
                        targetCompilationChanged = true;
                        if (targetPutMethod.getName ().equals ("setBody") && sourceNode instanceof JMethod) {
                            JMethod sourceMethod = (JMethod) sourceNode;
                            JMethod targetMethod = (JMethod) targetNode;
                            String [] sourceParameterTypes = sourceMethod.getParameterTypes ();
                            String [] targetParameterTypes = targetMethod.getParameterTypes ();
                            if (Arrays.equals (sourceParameterTypes, targetParameterTypes)) {
                                targetMethod.setParameterNames (sourceMethod.getParameterNames ());
                            }
                            else {
                                targetMethod.setParameters (sourceMethod.getParameters ());
                            }
                        }
                    }
                }
                else {
                    ArrayList < String > additionalStrings = new ArrayList < String > ();
                    String [] sourceStrings = (String []) value;
                    if (sourceStrings != null) {
                        additionalStrings.addAll (Arrays.asList (sourceStrings));
                    }
                    if (targetPutMethod.getName ().equals ("addSuperInterface")) {
                        Pattern sourceTransfer = pullRule.getSourceTransfer ();
                        String comment = ((JMember) targetNode).getComment ();
                        if (sourceTransfer != null && comment != null) {
                            Matcher matcher = sourceTransfer.matcher (comment);
                            while (matcher.find () && matcher.groupCount () >= 1) {
                                String clientStrings = comment.substring (matcher.start (matcher.groupCount ()), matcher.end (matcher.groupCount ()));
                                for (StringTokenizer stringTokenizer = new StringTokenizer (clientStrings, ", \t\n\r\f"); stringTokenizer.hasMoreTokens ();) {
                                    String token = stringTokenizer.nextToken ();
                                    if (! additionalStrings.contains (token)) {
                                        additionalStrings.add (token);
                                    }
                                }
                            }
                        }
                        String [] oldSuperInterfaces = (String []) sourceGetMethod.invoke (targetNode);
                        String [] superInterfaces = additionalStrings.toArray (new String [additionalStrings.size ()]);
                        if (oldSuperInterfaces == null ? superInterfaces.length != 0 : ! Arrays.equals (oldSuperInterfaces, superInterfaces)) {
                            Method putMethod = targetNode.getClass ().getMethod ("setSuperInterfaces", String [].class);
                            putMethod.invoke (targetNode, new Object [] {superInterfaces});
                            targetCompilationChanged = true;
                        }
                    }
                    else {
                        String [] oldStringValues = (String []) sourceGetMethod.invoke (targetNode, NO_ARGUMENTS);
                        List < String > old = oldStringValues == null ? Collections.< String > emptyList () : Arrays.< String > asList (oldStringValues);
                        for (String string : additionalStrings) {
                            if (! old.contains (string)) {
                                targetPutMethod.invoke (targetNode, new Object [] {string});
                                targetCompilationChanged = true;
                            }
                        }
                    }
                }
            }
        }
    } catch (InvocationTargetException exception) {
        if (DEBUG) {
            exception.printStackTrace ();
        }
    } catch (IllegalAccessException exception) {
        if (DEBUG) {
            exception.printStackTrace ();
        }
    } catch (SecurityException e) {
        if (DEBUG) {
            e.printStackTrace ();
        }
    } catch (NoSuchMethodException e) {
        if (DEBUG) {
            e.printStackTrace ();
        }
    }
}


-----Function Pair=56=-----==

protected void sweepTargetCompilationUnit () {
    Set < JNode > sweptNodes = new HashSet < JNode > (targetToSourceMap.size ());
    for (Map.Entry < JNode, JNode > entry : targetToSourceMap.entrySet ()) {
        if (entry.getValue () == null) {
            JNode node = entry.getKey ();
            JNode parent = node.getParent ();
            if (parent != null && sweptNodes.contains (parent)) {
                sweptNodes.add (node);
                continue;
            }
            if (applySweepRules (node)) {
                targetCompilationChanged = true;
                sweptNodes.add (node);
            }
        }
    }
}


protected Parameter getParameter (Element parameterElem) {
    if (parameterElem != null) {
        String Name = parameterElem.getAttributeValue ("Name");
        String Value = parameterElem.getAttributeValue ("Value");
        String Comment = parameterElem.getAttributeValue ("Comment");
        Parameter parameter = new Parameter (Name, Value, Comment);
        return parameter;
    }
    else {
        System.err.println ("Invalid element input in getParameter()");
        if (this.console != null) {
            console.setText ("Invalid element input in getParameter()");
        }
        return null;
    }
}


-----Function Pair=57=-----==

public void mousePressed (MouseEvent e) {
    lastPressedButtonWas = e.getButton ();
    if (e.getButton () == MouseEvent.BUTTON1) {
        int w = getWidth () - rightMargin;
        double diff_x_dat = zoomMaxComp1 - zoomMinComp1;
        double diff_x_scr = w;
        double xpos = (zoomMinComp1 + diff_x_dat * e.getX () / diff_x_scr);
        int h = getHeight ();
        double diff_y_dat = zoomMaxComp2 - zoomMinComp2;
        double diff_y_scr = h;
        double ypos = (zoomMinComp2 + diff_y_dat * (double) (h - e.getY ()) / diff_y_scr);
        selectionFirstClickComp1 = xpos;
        selectionFirstClickComp2 = ypos;
        mouseAreaStartComp1 = xpos;
        mouseAreaEndComp1 = xpos;
        mouseAreaStartComp2 = ypos;
        mouseAreaEndComp2 = ypos;
        cursorPositionComp1 = xpos;
        cursorPositionComp2 = ypos;
        zoomToSelectionMenuItem.setEnabled (false);
        repaint ();
    }
    statBar.setStatusText ("");
}


public void mousePressed (MouseEvent e) {
    lastPressedButtonWas = e.getButton ();
    if (e.getButton () == MouseEvent.BUTTON1) {
        int w = getWidth () - rightMargin;
        double diff_x_dat = zoomMaxComp1 - zoomMinComp1;
        double diff_x_scr = w;
        double xpos = (zoomMinComp1 + diff_x_dat * e.getX () / diff_x_scr);
        int h = getHeight ();
        double diff_y_dat = zoomMaxComp2 - zoomMinComp2;
        double diff_y_scr = h;
        double ypos = (zoomMinComp2 + diff_y_dat * (double) (h - e.getY ()) / diff_y_scr);
        selectionFirstClickComp1 = xpos;
        selectionFirstClickComp2 = ypos;
        mouseAreaStartComp1 = xpos;
        mouseAreaEndComp1 = xpos;
        mouseAreaStartComp2 = ypos;
        mouseAreaEndComp2 = ypos;
        cursorPositionComp1 = xpos;
        cursorPositionComp2 = ypos;
        zoomToSelectionMenuItem.setEnabled (false);
        repaint ();
    }
    statBar.setStatusText ("");
}


-----Function Pair=58=-----==

public DoubleSquareMatrix subtract (final DoubleSquareMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawSubtract (m);
        default :
            if (numRows == m.rows ()) {
                final double array [] [] = new double [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    array [i] [0] = matrix [i] [0] - m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) array [i] [j] = matrix [i] [j] - m.getElement (i, j);
                }
                return new DoubleSquareMatrix (array);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


public IntegerSquareMatrix subtract (final IntegerSquareMatrix m) {
    switch (m.storageFormat) {
        case ARRAY_2D :
            return rawSubtract (m);
        default :
            if (numRows == m.rows ()) {
                final int array [] [] = new int [numRows] [numCols];
                for (int j, i = 0; i < numRows; i ++) {
                    array [i] [0] = matrix [i] [0] - m.getElement (i, 0);
                    for (j = 1; j < numCols; j ++) array [i] [j] = matrix [i] [j] - m.getElement (i, j);
                }
                return new IntegerSquareMatrix (array);
            }
            else throw new MatrixDimensionException ("Matrices are different sizes.");
    }
}


-----Function Pair=59=-----==

public static void dcopy_f77 (int n, double dx [], int incx, double dy [], int incy) {
    double dtemp;
    int i, ix, iy, m;
    if (n <= 0) return;
    if ((incx == 1) && (incy == 1)) {
        m = n % 7;
        for (i = 1; i <= m; i ++) {
            dy [i] = dx [i];
        }
        for (i = m + 1; i <= n; i += 7) {
            dy [i] = dx [i];
            dy [i + 1] = dx [i + 1];
            dy [i + 2] = dx [i + 2];
            dy [i + 3] = dx [i + 3];
            dy [i + 4] = dx [i + 4];
            dy [i + 5] = dx [i + 5];
            dy [i + 6] = dx [i + 6];
        }
        return;
    }
    else {
        ix = 1;
        iy = 1;
        if (incx < 0) ix = (- n + 1) * incx + 1;
        if (incy < 0) iy = (- n + 1) * incy + 1;
        for (i = 1; i <= n; i ++) {
            dy [iy] = dx [ix];
            ix += incx;
            iy += incy;
        }
        return;
    }
}


public static double ddot_f77 (int n, double dx [], int incx, double dy [], int incy) {
    double ddot;
    int i, ix, iy, m;
    ddot = 0.0;
    if (n <= 0) return ddot;
    if ((incx == 1) && (incy == 1)) {
        m = n % 5;
        for (i = 1; i <= m; i ++) {
            ddot += dx [i] * dy [i];
        }
        for (i = m + 1; i <= n; i += 5) {
            ddot += dx [i] * dy [i] + dx [i + 1] * dy [i + 1] + dx [i + 2] * dy [i + 2] + dx [i + 3] * dy [i + 3] + dx [i + 4] * dy [i + 4];
        }
        return ddot;
    }
    else {
        ix = 1;
        iy = 1;
        if (incx < 0) ix = (- n + 1) * incx + 1;
        if (incy < 0) iy = (- n + 1) * incy + 1;
        for (i = 1; i <= n; i ++) {
            ddot += dx [ix] * dy [iy];
            ix += incx;
            iy += incy;
        }
        return ddot;
    }
}


-----Function Pair=60=-----==

public int [] [] calculateMatrix (int [] sequence) {
    int [] [] matrix = new int [n2] [n2];
    int i, j, k, ii, jj;
    int m1 = m - 1;
    for (i = 0; i < m1; i ++) {
        ii = actualSequence [i];
        jj = actualSequence [i + 1];
        for (j = 0; j < contents [ii].length; j ++) {
            for (k = 0; k < contents [jj].length; k ++) {
                matrix [contents [ii] [j]] [contents [jj] [k]] ++;
            }
        }
    }
    return matrix;
}


private static double [] generateSeq (int length, double [] arCoef, double [] maCoef) {
    double [] seq = new double [length];
    double [] r = new double [length];
    Random rd = new Random ();
    for (int i = 0; i < seq.length; i ++) {
        r [i] = rd.nextGaussian ();
        seq [i] = arCoef [0];
        for (int j = 1; j < arCoef.length; j ++) {
            if (i - j >= 0) {
                seq [i] += arCoef [j] * seq [i - j];
            }
        }
        for (int j = 0; j < maCoef.length; j ++) {
            if (i - j >= 0) {
                seq [i] += maCoef [j] * r [i - j];
            }
        }
    }
    return seq;
}


-----Function Pair=61=-----==

public Matrix times (Matrix B) throws Exception {
    if (B.m != n) {
        throw new Exception ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


public Matrix times (Matrix B) {
    if (B.m != n) {
        throw new IllegalArgumentException ("Matrix inner dimensions must agree.");
    }
    Matrix X = new Matrix (m, B.n);
    double [] [] C = X.getArray ();
    double [] Bcolj = new double [n];
    for (int j = 0; j < B.n; j ++) {
        for (int k = 0; k < n; k ++) {
            Bcolj [k] = B.A [k] [j];
        }
        for (int i = 0; i < m; i ++) {
            double [] Arowi = A [i];
            double s = 0;
            for (int k = 0; k < n; k ++) {
                s += Arowi [k] * Bcolj [k];
            }
            C [i] [j] = s;
        }
    }
    return X;
}


-----Function Pair=62=-----==

public void paint (Graphics g) {
    super.paint (g);
    int w = getWidth ();
    double h = getHeight ();
    if (w <= 0) {
        return;
    }
    if (h <= 0) {
        return;
    }
    double dataRange = maxX - minX;
    if (dataRange == 0) {
        return;
    }
    double pixelsPerUnit = (double) (w - leftMargin - rightMargin) / dataRange;
    if (pixelsPerUnit <= 0) {
        return;
    }
    double unitsPerTic = 0;
    while ((unitsPerTic * pixelsPerUnit) < 60) {
        unitsPerTic ++;
    }
    double pixelsPerTic = (double) unitsPerTic * pixelsPerUnit;
    int numoftics = (int) java.lang.Math.floor ((double) dataRange / (double) unitsPerTic);
    this.setForeground (Color.black);
    g.drawLine ((int) leftMargin, 0, (int) (w - rightMargin), 0);
    String tmps;
    double xpos = leftMargin;
    double xval = minX;
    for (int t = 0; t < numoftics; t ++) {
        tmps = numberFormatter.format (xval);
        g.drawLine ((int) java.lang.Math.round (xpos), 0, (int) java.lang.Math.round (xpos), (int) (h / 4));
        g.drawBytes (tmps.getBytes (), 0, tmps.length (), (int) java.lang.Math.round (xpos), (int) (3 * h / 4));
        xval += unitsPerTic;
        xpos += pixelsPerTic;
    }
}


public void paint (Graphics g) {
    super.paint (g);
    double w = getWidth ();
    double h = getHeight ();
    if (w <= 0) {
        return;
    }
    if (h <= 0) {
        return;
    }
    double dataRange = maxY - minY;
    if (dataRange == 0) {
        return;
    }
    double pixelsPerUnit = (double) (h - topMargin - bottomMargin) / dataRange;
    if (pixelsPerUnit <= 0) {
        return;
    }
    double unitsPerTic = 0;
    while ((unitsPerTic * pixelsPerUnit) < 60) {
        unitsPerTic ++;
    }
    double pixelsPerTic = (double) unitsPerTic * pixelsPerUnit;
    int numoftics = (int) java.lang.Math.floor ((double) dataRange / (double) unitsPerTic);
    this.setForeground (Color.black);
    g.drawLine ((int) w - 1, 0, (int) w - 1, (int) h);
    String tmps;
    double ypos = bottomMargin;
    double yval = minY;
    for (int t = 1; t <= numoftics; t ++) {
        tmps = numberFormatter.format (yval);
        g.drawLine ((int) (3 * w / 4), (int) (h - ypos), (int) (w), (int) (h - ypos));
        g.drawBytes (tmps.getBytes (), 0, tmps.length (), (int) (w / 4) - 4, (int) (h - ypos));
        yval += unitsPerTic;
        ypos += pixelsPerTic;
    }
}


-----Function Pair=63=-----==

private double getMaxCovarOrDotProd () {
    double xMax = Double.NEGATIVE_INFINITY;
    double xCurrent = Double.NEGATIVE_INFINITY;
    for (int i = 0; i < number_of_genes; i ++) {
        for (int j = 0; j < number_of_genes; j ++) {
            if (j != i) {
                if (function == Algorithm.DOTPRODUCT) {
                    xCurrent = ExperimentUtil.geneDotProduct (expMatrix, null, i, j, factor);
                    if (useAbsolute) {
                        xCurrent = Math.abs (xCurrent);
                    }
                }
                else if (function == Algorithm.COVARIANCE) {
                    xCurrent = ExperimentUtil.geneCovariance (expMatrix, null, i, j, factor);
                    if (useAbsolute) {
                        xCurrent = Math.abs (xCurrent);
                    }
                }
                if (xMax < xCurrent) xMax = xCurrent;
            }
        }
    }
    return xMax;
}


private double getMinCovOrDotProd () {
    double xMin = Double.POSITIVE_INFINITY;
    double xCurrent = Double.POSITIVE_INFINITY;
    for (int i = 0; i < number_of_genes; i ++) {
        for (int j = 0; j < number_of_genes; j ++) {
            if (j != i) {
                if (function == Algorithm.DOTPRODUCT) {
                    xCurrent = ExperimentUtil.geneDotProduct (expMatrix, null, i, j, factor);
                    if (useAbsolute) {
                        xCurrent = Math.abs (xCurrent);
                    }
                }
                else if (function == Algorithm.COVARIANCE) {
                    xCurrent = ExperimentUtil.geneCovariance (expMatrix, null, i, j, factor);
                    if (useAbsolute) {
                        xCurrent = Math.abs (xCurrent);
                    }
                }
                if (xMin > xCurrent) xMin = xCurrent;
            }
        }
    }
    return xMin;
}


-----Function Pair=64=-----==

byte addAnswer (Message response, Name name, short type, short dclass, int iterations, int flags) {
    SetResponse sr;
    byte rcode = Rcode.NOERROR;
    if (iterations > 6) return Rcode.NOERROR;
    if (type == Type.SIG) {
        type = Type.ANY;
        flags |= FLAG_SIGONLY;
    }
    Zone zone = findBestZone (name);
    if (zone != null) sr = zone.findRecords (name, type);
    else {
        Cache cache = getCache (dclass);
        sr = cache.lookupRecords (name, type, Credibility.NORMAL);
    }
    if (sr.isUnknown ()) {
        addCacheNS (response, getCache (dclass), name);
    }
    if (sr.isNXDOMAIN ()) {
        response.getHeader ().setRcode (Rcode.NXDOMAIN);
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        rcode = Rcode.NXDOMAIN;
    }
    else if (sr.isNXRRSET ()) {
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
    }
    else if (sr.isDelegation ()) {
        RRset nsRecords = sr.getNS ();
        addRRset (nsRecords.getName (), response, nsRecords, Section.AUTHORITY, flags);
    }
    else if (sr.isCNAME ()) {
        RRset rrset = new RRset ();
        CNAMERecord cname = sr.getCNAME ();
        rrset.addRR (cname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, cname.getTarget (), type, dclass, iterations + 1, flags);
    }
    else if (sr.isDNAME ()) {
        RRset rrset = new RRset ();
        DNAMERecord dname = sr.getDNAME ();
        rrset.addRR (dname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        Name newname;
        try {
            newname = name.fromDNAME (dname);
        } catch (NameTooLongException e) {
            return Rcode.YXDOMAIN;
        }
        try {
            rrset = new RRset ();
            rrset.addRR (new CNAMERecord (name, dclass, 0, newname));
            addRRset (name, response, rrset, Section.ANSWER, flags);
        } catch (IOException e) {
        }
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, newname, type, dclass, iterations + 1, flags);
    }
    else if (sr.isSuccessful ()) {
        RRset [] rrsets = sr.answers ();
        for (int i = 0; i < rrsets.length; i ++) addRRset (name, response, rrsets [i], Section.ANSWER, flags);
        if (zone != null) {
            addNS (response, zone, flags);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        else addCacheNS (response, getCache (dclass), name);
    }
    return rcode;
}


byte addAnswer (Message response, Name name, short type, short dclass, int iterations, int flags) {
    SetResponse sr;
    byte rcode = Rcode.NOERROR;
    if (iterations > 6) return Rcode.NOERROR;
    if (type == Type.SIG) {
        type = Type.ANY;
        flags |= FLAG_SIGONLY;
    }
    Zone zone = findBestZone (name);
    if (zone != null) sr = zone.findRecords (name, type);
    else {
        Cache cache = getCache (dclass);
        sr = cache.lookupRecords (name, type, Credibility.NONAUTH_ANSWER);
    }
    if (sr.isUnknown ()) {
        addCacheNS (response, getCache (dclass), name);
    }
    if (sr.isNXDOMAIN ()) {
        response.getHeader ().setRcode (Rcode.NXDOMAIN);
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        rcode = Rcode.NXDOMAIN;
    }
    else if (sr.isNXRRSET ()) {
        if (zone != null) {
            addSOA (response, zone);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
    }
    else if (sr.isDelegation ()) {
        RRset nsRecords = sr.getNS ();
        addRRset (nsRecords.getName (), response, nsRecords, Section.AUTHORITY, flags);
    }
    else if (sr.isCNAME ()) {
        RRset rrset = new RRset ();
        CNAMERecord cname = sr.getCNAME ();
        rrset.addRR (cname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, cname.getTarget (), type, dclass, iterations + 1, flags);
    }
    else if (sr.isDNAME ()) {
        RRset rrset = new RRset ();
        DNAMERecord dname = sr.getDNAME ();
        rrset.addRR (dname);
        addRRset (name, response, rrset, Section.ANSWER, flags);
        Name newname = name.fromDNAME (dname);
        if (newname == null) return Rcode.SERVFAIL;
        try {
            rrset = new RRset ();
            rrset.addRR (new CNAMERecord (name, dclass, 0, newname));
            addRRset (name, response, rrset, Section.ANSWER, flags);
        } catch (IOException e) {
        }
        if (zone != null && iterations == 0) response.getHeader ().setFlag (Flags.AA);
        rcode = addAnswer (response, newname, type, dclass, iterations + 1, flags);
    }
    else if (sr.isSuccessful ()) {
        RRset [] rrsets = sr.answers ();
        for (int i = 0; i < rrsets.length; i ++) addRRset (name, response, rrsets [i], Section.ANSWER, flags);
        if (zone != null) {
            addNS (response, zone, flags);
            if (iterations == 0) response.getHeader ().setFlag (Flags.AA);
        }
        else addCacheNS (response, getCache (dclass), name);
    }
    return rcode;
}


-----Function Pair=65=-----==

public void serveUDP (InetAddress addr, short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port, addr);
        final short udpLength = 512;
        byte [] in = new byte [udpLength];
        DatagramPacket indp = new DatagramPacket (in, in.length);
        DatagramPacket outdp = null;
        while (true) {
            indp.setLength (in.length);
            try {
                sock.receive (indp);
            } catch (InterruptedIOException e) {
                continue;
            }
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, null);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            if (outdp == null) outdp = new DatagramPacket (out, out.length, indp.getAddress (), indp.getPort ());
            else {
                outdp.setData (out);
                outdp.setLength (out.length);
                outdp.setAddress (indp.getAddress ());
                outdp.setPort (indp.getPort ());
            }
            sock.send (outdp);
        }
    } catch (IOException e) {
        String addrString;
        if (addr == null) addrString = "0.0.0.0";
        else addrString = addr.getHostAddress ();
        System.out.println ("serveUDP(" + addrString + "#" + port + "): " + e);
    }
}


public void serveTCP (short port) {
    try {
        ServerSocket sock = new ServerSocket (port);
        while (true) {
            Socket s = sock.accept ();
            int inLength;
            DataInputStream dataIn;
            DataOutputStream dataOut;
            byte [] in;
            try {
                InputStream is = s.getInputStream ();
                dataIn = new DataInputStream (is);
                inLength = dataIn.readUnsignedShort ();
                in = new byte [inLength];
                dataIn.readFully (in);
            } catch (InterruptedIOException e) {
                s.close ();
                continue;
            }
            Message query, response;
            try {
                query = new Message (in);
                response = generateReply (query, in, s);
                if (response == null) continue;
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dataOut = new DataOutputStream (s.getOutputStream ());
            dataOut.writeShort (out.length);
            dataOut.write (out);
            s.close ();
        }
    } catch (IOException e) {
        System.out.println ("serveTCP: " + e);
    }
}


-----Function Pair=66=-----=1=

public jnamed (String conffile) throws IOException, ZoneTransferException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    try {
        caches = new HashMap ();
        znames = new HashMap ();
        TSIGs = new HashMap ();
        InputStreamReader isr = new InputStreamReader (fs);
        BufferedReader br = new BufferedReader (isr);
        String line = null;
        while ((line = br.readLine ()) != null) {
            StringTokenizer st = new StringTokenizer (line);
            if (! st.hasMoreTokens ()) continue;
            String keyword = st.nextToken ();
            if (! st.hasMoreTokens ()) {
                System.out.println ("Invalid line: " + line);
                continue;
            }
            if (keyword.charAt (0) == '#') continue;
            if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("cache")) {
                Cache cache = new Cache (st.nextToken ());
                caches.put (new Integer (DClass.IN), cache);
            }
            else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("port")) ports.add (Integer.valueOf (st.nextToken ()));
            else if (keyword.equals ("address")) {
                String addr = st.nextToken ();
                addresses.add (InetAddress.getByName (addr));
            }
            else {
                System.out.println ("unknown keyword: " + keyword);
            }
        }
        if (ports.size () == 0) ports.add (new Integer (53));
        if (addresses.size () == 0) addresses.add (null);
        Iterator iaddr = addresses.iterator ();
        while (iaddr.hasNext ()) {
            InetAddress addr = (InetAddress) iaddr.next ();
            Iterator iport = ports.iterator ();
            while (iport.hasNext ()) {
                int port = ((Integer) iport.next ()).intValue ();
                String addrString;
                addUDP (addr, port);
                addTCP (addr, port);
                if (addr == null) addrString = "0.0.0.0";
                else addrString = addr.getHostAddress ();
                System.out.println ("jnamed: listening on " + addrString + "#" + port);
            }
        }
        System.out.println ("jnamed: running");
    } finally {
        fs.close ();
    }
}


public jnamed (String conffile) throws IOException, ZoneTransferException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    try {
        caches = new HashMap ();
        znames = new HashMap ();
        TSIGs = new HashMap ();
        InputStreamReader isr = new InputStreamReader (fs);
        BufferedReader br = new BufferedReader (isr);
        String line = null;
        while ((line = br.readLine ()) != null) {
            StringTokenizer st = new StringTokenizer (line);
            if (! st.hasMoreTokens ()) continue;
            String keyword = st.nextToken ();
            if (! st.hasMoreTokens ()) {
                System.out.println ("Invalid line: " + line);
                continue;
            }
            if (keyword.charAt (0) == '#') continue;
            if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
            else if (keyword.equals ("cache")) {
                Cache cache = new Cache (st.nextToken ());
                caches.put (new Integer (DClass.IN), cache);
            }
            else if (keyword.equals ("key")) {
                String s1 = st.nextToken ();
                String s2 = st.nextToken ();
                if (st.hasMoreTokens ()) addTSIG (s1, s2, st.nextToken ());
                else addTSIG ("hmac-md5", s1, s2);
            }
            else if (keyword.equals ("port")) {
                ports.add (Integer.valueOf (st.nextToken ()));
            }
            else if (keyword.equals ("address")) {
                String addr = st.nextToken ();
                addresses.add (Address.getByAddress (addr));
            }
            else {
                System.out.println ("unknown keyword: " + keyword);
            }
        }
        if (ports.size () == 0) ports.add (new Integer (53));
        if (addresses.size () == 0) addresses.add (Address.getByAddress ("0.0.0.0"));
        Iterator iaddr = addresses.iterator ();
        while (iaddr.hasNext ()) {
            InetAddress addr = (InetAddress) iaddr.next ();
            Iterator iport = ports.iterator ();
            while (iport.hasNext ()) {
                int port = ((Integer) iport.next ()).intValue ();
                addUDP (addr, port);
                addTCP (addr, port);
                System.out.println ("jnamed: listening on " + addrport (addr, port));
            }
        }
        System.out.println ("jnamed: running");
    } finally {
        fs.close ();
    }
}


-----Function Pair=67=-----==

public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


-----Function Pair=68=-----=1=

public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    boolean started = false;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new Hashtable ();
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) {
            short port = Short.parseShort (st.nextToken ());
            addUDP (port);
            addTCP (port);
            started = true;
        }
    }
    if (! started) {
        addUDP ((short) 53);
        addTCP ((short) 53);
    }
    System.out.println ("running");
}


public jnamed (String conffile) throws IOException {
    FileInputStream fs;
    boolean started = false;
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new Hashtable ();
    znames = new Hashtable ();
    TSIGs = new Hashtable ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Short (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) {
            short port = Short.parseShort (st.nextToken ());
            addUDP (port);
            addTCP (port);
            started = true;
        }
    }
    if (! started) {
        addUDP ((short) 53);
        addTCP ((short) 53);
    }
    System.out.println ("running");
}


-----Function Pair=69=-----==

void addRRset (Name name, Message response, RRset rrset, int section, int flags) {
    for (int s = 1; s <= section; s ++) if (response.findRRset (name, rrset.getType (), s)) return;
    if ((flags & FLAG_SIGONLY) == 0) {
        Iterator it = rrset.rrs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
    if ((flags & (FLAG_SIGONLY | FLAG_DNSSECOK)) != 0) {
        Iterator it = rrset.sigs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
}


void addRRset (Name name, Message response, RRset rrset, byte section, int flags) {
    for (byte s = 1; s <= section; s ++) if (response.findRRset (name, rrset.getType (), s)) return;
    if ((flags & FLAG_SIGONLY) == 0) {
        Iterator it = rrset.rrs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
    if ((flags & (FLAG_SIGONLY | FLAG_DNSSECOK)) != 0) {
        Iterator it = rrset.sigs ();
        while (it.hasNext ()) {
            Record r = (Record) it.next ();
            if (r.getName ().isWild () && ! name.isWild ()) r = r.withName (name);
            response.addRecord (r, section);
        }
    }
}


-----Function Pair=70=-----==

static void SolvePuzzle (PrintWriter os, SoDoKuPuzzle puzzle, ConstraintSet cs, boolean doArcConsist, Search.SearchAlg cspAlg, String strFEN) {
    if (! puzzle.setPuzzle (strFEN)) {
        System.out.print ("Error setting puzzle '");
        System.out.print (strFEN);
        System.out.println ("'");
    }
    else {
        int assignment [] = new int [ConstraintSet.MAX_NUM_VARIABLES];
        for (int i = 0; i < assignment.length; ++ i) {
            assignment [i] = 0;
        }
        Domain [] domain = new Domain [ConstraintSet.MAX_NUM_VARIABLES];
        GenerateDomains (puzzle, domain);
        if (doArcConsist) {
            AC3 (cs, domain);
        }
        Search search = new Search ();
        SearchStatistic stat = new SearchStatistic ();
        stat.solved = false;
        stat.nodes = 0;
        stat.checks = 0;
        stat.sec = 0;
        PrintWriter cout = new PrintWriter (System.out);
        cout.write ("======================================================================================\n");
        puzzle.display (cout);
        os.write ("======================================================================================\n");
        puzzle.display (os);
        search.setSearchMethod (cspAlg);
        search.solve (cs, domain, assignment, stat);
        if (stat.solved) {
            for (int i = 0; i < cs.getNumberOfVariables (); i ++) {
                puzzle.set (i, assignment [i]);
            }
        }
        cout.print ("Alg: ");
        cout.print (cspAlg.toString ());
        cout.print (" Solved: ");
        cout.print (stat.solved);
        cout.print ("  Expanded: ");
        cout.print (stat.nodes);
        cout.print ("  Checks: ");
        cout.print (stat.checks);
        cout.print ("  Sec: ");
        cout.println (stat.sec);
        cout.print ("Sol: ");
        for (int i = 0; i < cs.getNumberOfVariables () && stat.solved; i ++) {
            cout.print (assignment [i]);
        }
        cout.print ("\n");
        if (stat.solved) {
            puzzle.display (cout);
        }
        cout.flush ();
        os.print ("Alg: ");
        os.print (cspAlg.toString ());
        os.print (" Solved: ");
        os.print (stat.solved);
        os.print ("  Expanded: ");
        os.print (stat.nodes);
        os.print ("  Checks: ");
        os.print (stat.checks);
        os.print ("  Sec: ");
        os.println (stat.sec);
        os.print ("Sol: ");
        for (int i = 0; i < cs.getNumberOfVariables () && stat.solved; i ++) {
            os.print (assignment [i]);
        }
        os.print ("\n");
        if (stat.solved) {
            puzzle.display (os);
        }
        os.flush ();
    }
}


public jnamed (String conffile) throws IOException, ZoneTransferException {
    FileInputStream fs;
    List ports = new ArrayList ();
    List addresses = new ArrayList ();
    try {
        fs = new FileInputStream (conffile);
    } catch (Exception e) {
        System.out.println ("Cannot open " + conffile);
        return;
    }
    caches = new HashMap ();
    znames = new HashMap ();
    TSIGs = new HashMap ();
    BufferedReader br = new BufferedReader (new InputStreamReader (fs));
    String line = null;
    while ((line = br.readLine ()) != null) {
        StringTokenizer st = new StringTokenizer (line);
        if (! st.hasMoreTokens ()) continue;
        String keyword = st.nextToken ();
        if (! st.hasMoreTokens ()) {
            System.out.println ("Invalid line: " + line);
            continue;
        }
        if (keyword.charAt (0) == '#') continue;
        if (keyword.equals ("primary")) addPrimaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("secondary")) addSecondaryZone (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("cache")) {
            Cache cache = new Cache (st.nextToken ());
            caches.put (new Integer (DClass.IN), cache);
        }
        else if (keyword.equals ("key")) addTSIG (st.nextToken (), st.nextToken ());
        else if (keyword.equals ("port")) ports.add (Integer.valueOf (st.nextToken ()));
        else if (keyword.equals ("address")) {
            String addr = st.nextToken ();
            addresses.add (InetAddress.getByName (addr));
        }
        else {
            System.out.println ("ignoring invalid keyword: " + keyword);
        }
    }
    if (ports.size () == 0) ports.add (new Integer (53));
    if (addresses.size () == 0) addresses.add (null);
    Iterator iaddr = addresses.iterator ();
    while (iaddr.hasNext ()) {
        InetAddress addr = (InetAddress) iaddr.next ();
        Iterator iport = ports.iterator ();
        while (iport.hasNext ()) {
            int port = ((Integer) iport.next ()).intValue ();
            String addrString;
            addUDP (addr, port);
            addTCP (addr, port);
            if (addr == null) addrString = "0.0.0.0";
            else addrString = addr.getHostAddress ();
            System.out.println ("jnamed: listening on " + addrString + "#" + port);
        }
    }
    System.out.println ("jnamed: running");
}


-----Function Pair=71=-----==

public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


public void truncate (Message in, int length, int maxLength) {
    TSIGRecord tsig = in.getTSIG ();
    if (tsig != null) maxLength -= tsig.getWireLength ();
    length -= truncateSection (in, maxLength, length, Section.ADDITIONAL);
    if (length < maxLength) return;
    in.getHeader ().setFlag (Flags.TC);
    if (tsig != null) {
        in.removeAllRecords (Section.ANSWER);
        in.removeAllRecords (Section.AUTHORITY);
        return;
    }
    length -= truncateSection (in, maxLength, length, Section.AUTHORITY);
    if (length < maxLength) return;
    length -= truncateSection (in, maxLength, length, Section.ANSWER);
}


-----Function Pair=72=-----==

public void zip (String zipFile) {
    try {
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
        out.putNextEntry (new ZipEntry ((new File (currentFile)).getName ()));
        String newline = System.getProperty ("line.separator");
        Element map = getDocument ().getDefaultRootElement ();
        for (int i = 0; i < map.getElementCount (); i ++) {
            Element line = map.getElement (i);
            int start = line.getStartOffset ();
            byte [] buf = (getText (start, line.getEndOffset () - start - 1) + newline).getBytes ();
            out.write (buf, 0, buf.length);
        }
        out.closeEntry ();
        out.close ();
    } catch (IOException ioe) {
        showError ("Error has occured while ziping");
    } catch (BadLocationException ble) {
        showError ("Error has occured while ziping");
    }
}


private void getClassLibs () {
    String re = "lib.*?path=['\"](.*?jar)['\"]";
    Pattern p = Pattern.compile (re);
    Matcher matcher = p.matcher (classFileContents);
    int i = 0;
    while (matcher.find ()) {
        i ++;
    }
    String [] jars = new String [i];
    matcher.reset ();
    i = 0;
    while (matcher.find ()) {
        String match = matcher.group (1);
        System.out.println ("Class libs: " + i + ". " + match);
        jars [i] = match;
        i ++;
    }
    boolean addGwtServlet = true;
    jars = deleteGwtUserJar (jars, addGwtServlet);
    classLibs = jars;
}


-----Function Pair=73=-----=1=

public static File createZip (File tmpDir, String [] filenames, String zipName, String text) throws IOException {
    File zip = new File (tmpDir, zipName);
    byte [] buf = new byte [1024];
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zip));
    for (int i = 0; i < filenames.length; i ++) {
        out.putNextEntry (new ZipEntry (filenames [i]));
        if (filenames [i].endsWith ("/")) continue;
        if (text == null) {
            text = "this is file " + filenames [i];
        }
        InputStream in = new ByteArrayInputStream (text.getBytes ());
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
    out.close ();
    return zip;
}


public static void zip (String baseDir, String zipFilename, String [] filenames, String [] archFilenames) throws IOException {
    ZipOutputStream zout = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (zipFilename)));
    byte [] data = new byte [512];
    int bc;
    for (int i = 0; i < filenames.length; i ++) {
        try {
            InputStream fin = new BufferedInputStream (new FileInputStream (filenames [i]));
            ZipEntry entry = new ZipEntry (archFilenames [i].substring (baseDir.length () + 1));
            zout.putNextEntry (entry);
            while ((bc = fin.read (data, 0, 512)) != - 1) {
                zout.write (data, 0, bc);
            }
            zout.flush ();
        } catch (Exception ex) {
            ex.printStackTrace ();
        }
    }
    zout.close ();
}


-----Function Pair=74=-----==

protected void list (PrintWriter writer) {
    if (debug >= 1) log ("list: Listing contexts for virtual host '" + host.getName () + "'");
    writer.println (sm.getString ("managerServlet.listed", host.getName ()));
    Container [] contexts = host.findChildren ();
    for (int i = 0; i < contexts.length; i ++) {
        Context context = (Context) contexts [i];
        String displayPath = context.getPath ();
        if (displayPath.equals ("")) displayPath = "/";
        if (context != null) {
            if (context.getAvailable ()) {
                writer.println (sm.getString ("managerServlet.listitem", displayPath, "running", "" + context.getManager ().findSessions ().length, context.getDocBase ()));
            }
            else {
                writer.println (sm.getString ("managerServlet.listitem", displayPath, "stopped", "0", context.getDocBase ()));
            }
        }
    }
}


boolean createSessionArchive (String archiveFilename) {
    byte [] buffer = new byte [1024];
    try {
        ZipOutputStream archive = new ZipOutputStream (new FileOutputStream (archiveFilename));
        for (mAnnotationsCursor.moveToFirst (); ! mAnnotationsCursor.isAfterLast (); mAnnotationsCursor.moveToNext ()) {
            FileInputStream in = new FileInputStream (mAnnotationsCursor.getString (ANNOTATIONS_FILE_NAME));
            archive.putNextEntry (new ZipEntry ("audio" + (mAnnotationsCursor.getPosition () + 1) + ".3gpp"));
            int length;
            while ((length = in.read (buffer)) > 0) archive.write (buffer, 0, length);
            archive.closeEntry ();
            in.close ();
        }
        archive.close ();
    } catch (IOException e) {
        Toast.makeText (mActivity, mActivity.getString (R.string.error_zip) + " " + e.getMessage (), Toast.LENGTH_SHORT).show ();
        return false;
    }
    return true;
}


-----Function Pair=75=-----==

private X509Certificate [] getX509CertificateChain (CertificateGroupDetail certGroup) {
    List < X509Certificate > certificates = new ArrayList < X509Certificate > ();
    X509Certificate certificate = getTolvenConfigWrapper ().getX509Certificate (certGroup);
    certificates.add (certificate);
    if (! certificate.getIssuerDN ().equals (certificate.getSubjectDN ())) {
        X509Certificate issuingCertificate = null;
        do {
            CertificateGroupDetail issuingCertGroup = getTolvenConfigWrapper ().getCredentialGroup (certGroup.getCertificate ().getCaRefId ());
            issuingCertificate = getTolvenConfigWrapper ().getX509Certificate (issuingCertGroup);
            if (! certificates.contains (issuingCertificate)) certificates.add (issuingCertificate);
        }
        while ((! issuingCertificate.getIssuerDN ().equals (issuingCertificate.getSubjectDN ())));
    }
    X509Certificate [] certArr = new X509Certificate [certificates.size ()];
    for (int i = 0; i < certificates.size (); i ++) certArr [i] = certificates.get (i);
    return certArr;
}


public void doGetInstanceCommand (String command, String [] args) {
    if (args [0].startsWith ("(")) {
        int rparen = args [0].indexOf (')');
        if (rparen == - 1) {
            jdp_console.writeOutput ("missing parenthesis for class name: " + args [0]);
            return;
        }
        try {
            JDP_Class jdpClass = new JDP_Class ();
            jdpClass.address = parseHex32 (args [1]);
            jdpClass.name = args [0].substring (1, rparen);
            jdpClass.instance = true;
            try {
                user.bmap.classToJDPClass (jdpClass.name, jdpClass.address, false, jdpClass);
                jdpClass.fields.trimToSize ();
                jdp_console.writeOutput (jdpClass);
            } catch (memoryException e) {
                jdp_console.writeOutput ("(" + e.getMessage () + ")");
            } catch (NoSuchClassException e2) {
                jdp_console.writeOutput (jdpClass.name + " is an invalid class name");
            }
        } catch (NumberFormatException e) {
            jdp_console.writeOutput ("bad address for casting: " + args [1]);
        }
    }
    else {
        jdp_console.writeOutput ("invalid args for getinstance");
    }
    return;
}


-----Function Pair=76=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=77=-----==

public WAVFile (String filename) throws Exception {
    file = filename;
    byte [] buffer = new byte [1024];
    FileInputStream fin = new FileInputStream (filename);
    int amount = fin.read (buffer);
    System.out.println ("First chunk: " + amount + " bytes");
    riff = getIntASCII (buffer, 0);
    totallength = getInt (buffer, 4);
    wave = getIntASCII (buffer, 8);
    fmt = getIntASCII (buffer, FORMAT_START);
    fmt_length = getInt (buffer, FORMAT_START + 4);
    always_01 = getShort (buffer, FORMAT_START + 8);
    channels = getShort (buffer, FORMAT_START + 10);
    rate = getInt (buffer, FORMAT_START + 12);
    bytes_per_second = getInt (buffer, FORMAT_START + 16);
    bytes_per_sample = getShort (buffer, FORMAT_START + 20);
    bits_per_sample = getShort (buffer, FORMAT_START + 22);
    int DATA_START = FORMAT_START + 8 + fmt_length;
    data = getIntASCII (buffer, DATA_START);
    datalength = getInt (buffer, DATA_START + 4);
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    baos.write (buffer, DATA_START + 8, buffer.length - (DATA_START + 8));
    amount = fin.read (buffer);
    while (amount != - 1) {
        baos.write (buffer, 0, amount);
        amount = fin.read (buffer);
    }
    buffer = baos.toByteArray ();
    processAudioData (buffer, 0, bytes_per_sample);
    int mult = rate / 11025;
    if ((mult * 11025) != rate) throw new RuntimeException ("Rate must be multiple of 11025");
}


public boolean chequearMarca (int a, int m, int d) {
    boolean existe = false;
    try {
        cantidadArchivos = obtenerCantidad () + 1;
        String filenametxt = "";
        String filenamezip = "";
        int dia = 0;
        int mes = 0;
        int ano = 0;
        for (int i = 1; i < cantidadArchivos; i ++) {
            filenamezip = "recordatorio" + i + ".zip";
            filenametxt = "recordatorio" + i + ".txt";
            BufferedOutputStream dest = null;
            BufferedInputStream is = null;
            ZipEntry entry;
            ZipFile zipfile = new ZipFile (filenamezip);
            Enumeration e = zipfile.entries ();
            while (e.hasMoreElements ()) {
                entry = (ZipEntry) e.nextElement ();
                is = new BufferedInputStream (zipfile.getInputStream (entry));
                int count;
                byte data [] = new byte [buffer];
                FileOutputStream fos = new FileOutputStream (entry.getName ());
                dest = new BufferedOutputStream (fos, buffer);
                while ((count = is.read (data, 0, buffer)) != - 1) dest.write (data, 0, count);
                dest.flush ();
                dest.close ();
                is.close ();
            }
            DataInputStream input = new DataInputStream (new FileInputStream (filenametxt));
            dia = Integer.parseInt (input.readLine ());
            mes = Integer.parseInt (input.readLine ());
            ano = Integer.parseInt (input.readLine ());
            if (ano == a && mes == m && dia == d) existe = true;
            input.close ();
        }
    } catch (Exception e) {
        JOptionPane.showMessageDialog (null, "Error en: " + e.toString (), "Error", JOptionPane.ERROR_MESSAGE);
    }
    return (existe);
}


-----Function Pair=78=-----==

private void compareFile (File fileA, File fileB, boolean skipIdentical, String basePath) {
    String filename = null;
    if (fileB != null) filename = fileB.getPath ();
    else if (fileA != null) filename = fileA.getPath ();
    if (filename != null && basePath != null && filename.startsWith (basePath)) {
        filename = filename.substring (basePath.length ());
        if (filename.startsWith (File.separator)) filename = filename.substring (1);
    }
    updateProgress (filename);
    if (! isFile (fileA)) fileA = null;
    if (! isFile (fileB)) fileB = null;
    examineFiles (fileA, fileB);
    if (skipIdentical && filesAreIdentical) return;
    StringBuffer fileTable;
    String label, htmlName;
    if (fileA == null) {
        fileTable = addedTable;
        label = "Added";
    }
    else if (fileB == null) {
        fileTable = deletedTable;
        label = "Deleted";
    }
    else {
        fileTable = modifiedTable;
        label = "Modified";
    }
    htmlName = HTMLUtils.escapeEntities (filename);
    if (filesAreBinary) {
        fileTable.append ("<tr><td nowrap>").append (htmlName);
        if (fileTable == modifiedTable) fileTable.append ("</td><td></td><td></td><td></td><td>");
        fileTable.append ("</td><td></td><td>Binary</td></tr>\n");
        return;
    }
    String contentsA = getContents (fileA);
    String contentsB = getContents (fileB);
    PSPDiff diff = new PSPDiff (webServer, contentsA, contentsB, filename, null);
    if (skipIdentical && (diff.getDeleted () + diff.getAdded () + diff.getModified () == 0)) return;
    base += diff.getBase ();
    deleted += diff.getDeleted ();
    added += diff.getAdded ();
    modified += diff.getModified ();
    total += diff.getTotal ();
    fileTable.append ("<tr><td nowrap><a href='#file").append (counter).append ("'>").append (htmlName).append ("</a>");
    if (fileTable == deletedTable) fileTable.append ("</td><td>").append (diff.getBase ());
    else if (fileTable == modifiedTable) fileTable.append ("</td><td>").append (diff.getBase ()).append ("</td><td>").append (diff.getDeleted ()).append ("</td><td>").append (diff.getModified ()).append ("</td><td>").append (diff.getAdded ());
    fileTable.append ("</td><td>").append (diff.getTotal ()).append ("</td><td>").append (AbstractLanguageFilter.getFilterName (diff.getFilter ())).append ("</td></tr>\n");
    redlinesOut.print ("<hr><DIV onMouseOver=\"window.defaultStatus='");
    redlinesOut.print (EscapeString.escape (htmlName, '\\', "\""));
    redlinesOut.print ("'\"><h1>");
    redlinesOut.print (label);
    redlinesOut.print (": <a name='file");
    redlinesOut.print (counter ++);
    redlinesOut.print ("'>");
    redlinesOut.print (htmlName);
    redlinesOut.print ("</a></h1>");
    diff.displayHTMLRedlines (redlinesOut);
    redlinesOut.print ("</DIV>\n\n\n");
    diff.dispose ();
}


public static void listUnUsedTemplates () {
    DirectoryFileFilter filter = new DirectoryFileFilter ();
    int count = 0;
    for (File seasonFolder : new File (Program.Settings ().getDataFolder ()).listFiles (filter)) {
        count += seasonFolder.listFiles (filter).length;
    }
    LoadingBar Loadbar = new LoadingBar (count);
    Loadbar.setVisible (true);
    Loadbar.setTitle ("Checking templates");
    String strUsedTemps = "";
    String strUnusedTemps = "";
    String strDataFolder = Program.Settings ().getDataFolder ();
    for (final File seasonFolder : new File (strDataFolder).listFiles (filter)) {
        String strSeasonFolder = seasonFolder.getName ();
        Debug.print ("CurrentSeason: " + strSeasonFolder);
        for (final String siteFolder : seasonFolder.list (filter)) {
            Debug.print ("  CurrentSite: " + siteFolder);
            Loadbar.setTitle (String.format ("Checking templates for: %s/%s", strSeasonFolder, siteFolder));
            Site s = new Site (siteFolder, strSeasonFolder);
            try {
                s.load (false);
            } catch (Exception e) {
                Debug.print (e);
                continue;
            }
            for (Template t : s.getTemplates ().values ()) {
                Debug.print ("    CurrentTemplate: " + t.toString ());
                boolean templateFound = false;
                if (t != null) {
                    for (penguin.dataset.Day d : s.getDays ()) {
                        Debug.print ("      CurrentDay: " + d.getDate ());
                        if (d != null) {
                            for (penguin.dataset.NestImage n : d.getNestImages ()) {
                                Debug.print ("        CurrentTime: " + n.getTimeDateTaken ());
                                if (n != null && n.getTemplate () != null && n.getTemplate ().equals (t)) {
                                    Debug.print ("        CurrentTimeTemplate: " + n.getTemplate ());
                                    templateFound = true;
                                }
                            }
                        }
                    }
                }
                String strTemp = String.format ("%s/%s/templates/%s", seasonFolder.getName (), siteFolder, t.toString ());
                if (templateFound) strUsedTemps += "\n" + strTemp;
                else strUnusedTemps += "\n" + strTemp;
            }
            Loadbar.increment ();
        }
    }
    if (strUnusedTemps.equals ("")) strUnusedTemps = "No Unused templates found.";
    strUsedTemps = "=Used Templates=\n" + strUsedTemps;
    strUnusedTemps = "=Unused Templates=\n" + strUnusedTemps;
    boolean showall = false;
    if (showall) LogWindow.showDialog (String.format ("==Template Summary==\n\n%s\n\n%s", strUsedTemps, strUnusedTemps));
    else LogWindow.showDialog (String.format ("==Template Summary==\n\n%s", strUnusedTemps));
}


-----Function Pair=79=-----==

public void configureDeleteOption (ActionFormEvent event) throws PortletException {
    configureSave (event);
    String selectedLanguage = event.getActionRequest ().getParameter ("language");
    Compiler c = compilers.get (selectedLanguage);
    if (c != null) {
        String [] targets = event.getActionRequest ().getParameterValues ("selectedOptions");
        if (targets != null) {
            for (int i = targets.length - 1; i >= 0; i --) {
                try {
                    c.getOptions ().remove (Integer.parseInt (targets [i]));
                } catch (NumberFormatException e) {
                    log.error ("Hack warning:", e);
                }
            }
        }
        compilerService.saveCompiler (c);
    }
}


public static final String passwdCrypt (String pwd) {
    if (useFastMd5) {
        return MD5.passwdCrypt (pwd);
    }
    MessageDigest digest = null;
    try {
        digest = MessageDigest.getInstance (DigestAlgo.MD5.name);
    } catch (NoSuchAlgorithmException e) {
        return MD5.passwdCrypt (pwd);
    }
    byte [] bpwd = pwd.getBytes ();
    for (int i = 0; i < 16; i ++) {
        digest.update (bpwd, 0, bpwd.length);
        digest.update (salt, 0, salt.length);
    }
    byte [] buf = digest.digest ();
    digest = null;
    return getHex (buf);
}


-----Function Pair=80=-----==

private String divRubrics (String xmlString) {
    try {
        xmlString = xmlString.replaceAll ("[\\s][\\s+]", " ");
        xmlString = xmlString.replaceAll ("\\>[\\s+]\\<", "\\>\\<");
        ByteArrayInputStream fileStream = new ByteArrayInputStream (xmlString.getBytes ());
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance ();
        factory.setNamespaceAware (true);
        DocumentBuilder builder = factory.newDocumentBuilder ();
        Document doc = builder.parse (fileStream);
        XPathFactory xpfactory = XPathFactory.newInstance ();
        XPath xpath = xpfactory.newXPath ();
        NamespaceContext nc = new NamespaceContext () {
            @Override
            public String getNamespaceURI (String prefix) {
                return ("http://www.imsglobal.org/xsd/imsqti_v2p1");
            }@Override
            public String getPrefix (String namespaceURI) {
                return "qti";
            }@Override
            public Iterator getPrefixes (String namespaceURI) {
                return null;
            }
        }
        ;
        xpath.setNamespaceContext (nc);
        XPathExpression expr = xpath.compile ("//qti:rubricBlock");
        Object result = expr.evaluate (doc, XPathConstants.NODESET);
        NodeList nodes = (NodeList) result;
        for (int i = 0; i < nodes.getLength (); i ++) {
            Node bigNode = nodes.item (i);
            NodeList drilling = bigNode.getChildNodes ();
            for (int x = 0; x < drilling.getLength (); x ++) {
                if (drilling.item (x).getNodeType () == Node.TEXT_NODE) {
                    Node toKill = drilling.item (x);
                    Node parent = toKill.getParentNode ();
                    Node newNode = doc.createElement ("div");
                    newNode.setTextContent (toKill.getTextContent ());
                    parent.removeChild (toKill);
                    parent.appendChild (newNode);
                }
            }
        }
        return nodeToString (doc);
    } catch (Exception e) {
        e.printStackTrace ();
        return null;
    }
}


private File makeJar (String filename, File archive, File license, File readme, byte [] archiveInfos) throws IOException {
    File jar = new File (filename);
    JarOutputStream out = new JarOutputStream (new FileOutputStream (jar));
    copyInternalToJar (out, JAR_FILES_COMMON);
    copyInternalToJar (out, JAR_FILES_JNIREGISTRY);
    copyInternalToJar (out, JAR_FILES_JNISHORTCUT);
    copyInternalToJar (out, JAR_FILES_TEXT_UI);
    copyInternalToJar (out, JAR_FILES_ANSI_UI);
    if (uiMode_.equals ("graphic") == true) {
        copyInternalToJar (out, JAR_FILES_GRAPHIC_UI);
    }
    if (uiMode_.equals ("xtra") == true) {
        copyInternalToJar (out, JAR_FILES_XTRA_UI);
    }
    addToJar (out, new ByteArrayInputStream (archiveInfos), "com/memoire/vainstall/archive_infos", archiveInfos.length);
    addToJar (out, new FileInputStream (archive), "com/memoire/vainstall/archive.zip", archive.length ());
    InputStream licenseStream = new FileInputStream (license);
    String licenseEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.license.encoding");
    if (licenseEncoding == null || licenseEncoding.equals ("") == true) {
        licenseEncoding = new InputStreamReader (licenseStream).getEncoding ();
    }
    InputStreamReader isrLicense = new InputStreamReader (licenseStream, licenseEncoding);
    addToJarEncoded (out, isrLicense, "com/memoire/vainstall/license.txt", license.length ());
    InputStream readmeStream = new FileInputStream (readme);
    String readmeEncoding = VAProperties.PROPERTIES.getProperty ("vainstall.archive.readme.encoding");
    if (readmeEncoding == null || readmeEncoding.equals ("") == true) {
        readmeEncoding = new InputStreamReader (readmeStream).getEncoding ();
    }
    InputStreamReader isrReadme = new InputStreamReader (readmeStream, readmeEncoding);
    addToJarEncoded (out, isrReadme, "com/memoire/vainstall/readme.txt", readme.length ());
    InputStream invaiimage = null;
    try {
        invaiimage = new FileInputStream (new File (image_));
    } catch (Exception exc) {
        image_ = "/" + image_;
        invaiimage = getClass ().getResourceAsStream (image_);
    }
    if (invaiimage == null) {
        invaiimage = getClass ().getResourceAsStream (IMAGE_KEY);
        image_ = "com/memoire/vainstall/resources/banner.gif";
    }
    if (invaiimage != null) {
        addToJar (out, invaiimage, IMAGE_KEY, invaiimage.available ());
    }
    InputStream invailogo = getClass ().getResourceAsStream ("/" + VAILOGO);
    addToJar (out, invailogo, VAILOGO, invailogo.available ());
    invailogo.close ();
    ByteArrayOutputStream poutstream = new ByteArrayOutputStream ();
    installProperties.store (poutstream, VAGlobals.NAME + " " + VAGlobals.VERSION);
    ByteArrayInputStream pinstream = new ByteArrayInputStream (poutstream.toByteArray ());
    addToJar (out, pinstream, "com/memoire/vainstall/resources/vainstall.properties", poutstream.toByteArray ().length);
    out.close ();
    return jar;
}


-----Function Pair=81=-----==

public static String zipDirectory (final String directoryPath) {
    log.debug ("~zipDirectory(String) : About to zip a directory [" + directoryPath + "] (and subdirectories)");
    final File jobDirectoryFile = new File (directoryPath);
    if (! jobDirectoryFile.isDirectory ()) {
        log.warn ("~zipDirectory(String) : Path [" + directoryPath + "] was not a directory - ignored!");
        return null;
    }
    final String zipFilePath = directoryPath.concat (ZIP_SUFFIX);
    try {
        final ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (zipFilePath));
        doZip (directoryPath, directoryPath, zipOutputStream);
        zipOutputStream.close ();
    } catch (IOException ioe) {
        log.error ("~zipDirectory(String) : IO Exception [" + ioe.getMessage () + "] caught zipping directory [" + directoryPath + "]");
        ioe.printStackTrace ();
        throw new VRESystemException (MessageKeys.CREATION_FAIL_GENERIC, new Object [] {zipFilePath, ioe.getMessage ()});
    }
    return zipFilePath;
}


public static MethodInfo getMethodInfo (final Member member, final int modifiers) {
    final Signature sig = getSignature (member);
    return new MethodInfo () {
        private ClassInfo ci;
        public ClassInfo getClassInfo () {
            if (ci == null) ci = ReflectUtils.getClassInfo (member.getDeclaringClass ());
            return ci;
        } public int getModifiers () {
            return modifiers;
        } public Signature getSignature () {
            return sig;
        } public Type [] getExceptionTypes () {
            return ReflectUtils.getExceptionTypes (member);
        } public Attribute getAttribute () {
            return null;
        }
    }
    ;
}


-----Function Pair=82=-----==

private static byte [] blowfishCrypt (final byte [] input, final byte [] key, final int mode) throws Exception {
    final SecretKeySpec skeySpec = new SecretKeySpec (key, "Blowfish");
    final Cipher cipher = Cipher.getInstance ("Blowfish/ECB/PKCS5Padding");
    cipher.init (mode, skeySpec);
    final ByteArrayOutputStream bos = new ByteArrayOutputStream ();
    final ByteArrayInputStream bis = new ByteArrayInputStream (input);
    final CipherOutputStream cos = new CipherOutputStream (bos, cipher);
    int length = 0;
    final byte [] buffer = new byte [1024];
    while ((length = bis.read (buffer)) != - 1) {
        cos.write (buffer, 0, length);
    }
    bis.close ();
    cos.close ();
    return bos.toByteArray ();
}


void testCommand (String [] args, int expect_rc) throws Exception {
    System.err.println ("Test command: " + Arrays.asList (args));
    File javaHome = new File (System.getProperty ("java.home"));
    if (javaHome.getName ().equals ("jre")) javaHome = javaHome.getParentFile ();
    List < String > command = new ArrayList < String > ();
    command.add (new File (new File (javaHome, "bin"), "javah").getPath ());
    command.add ("-J-Xbootclasspath:" + System.getProperty ("sun.boot.class.path"));
    command.addAll (Arrays.asList (args));
    ProcessBuilder pb = new ProcessBuilder (command);
    pb.redirectErrorStream (true);
    Process p = pb.start ();
    p.getOutputStream ().close ();
    StringWriter sw = new StringWriter ();
    String line;
    BufferedReader in = new BufferedReader (new InputStreamReader (p.getInputStream ()));
    while ((line = in.readLine ()) != null) sw.write (line + NEWLINE);
    int rc = p.waitFor ();
    expect ("testCommand", sw.toString (), rc, expect_rc);
}


-----Function Pair=83=-----==

private void backupFiles (File destFile, boolean ignoreLastBackup) throws IOException {
    List dataFiles = getFilenamesToBackup ();
    if (dataFiles == null || dataFiles.size () == 0) return;
    Collections.sort (dataFiles);
    ProfTimer pt = new ProfTimer (IncrementalDirectoryBackup.class, "IncrementalDirectoryBackup.backupFiles");
    File dataDir = srcDirectory;
    File backupDir = destDirectory;
    File [] backupFiles = getBackupFiles (backupDir);
    File mostRecentBackupFile = (ignoreLastBackup ? null : findMostRecentBackupFile (backupFiles));
    File oldBackupTempFile = new File (backupDir, OLD_BACKUP_TEMP_FILENAME);
    File newBackupTempFile = new File (backupDir, NEW_BACKUP_TEMP_FILENAME);
    ZipOutputStream newBackupOut = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (newBackupTempFile)));
    newBackupOut.setLevel (9);
    boolean wroteHistLog = false;
    if (mostRecentBackupFile != null) {
        ZipInputStream oldBackupIn = new ZipInputStream (new TimedInputStream (new BufferedInputStream (new FileInputStream (mostRecentBackupFile)), 60000));
        ZipOutputStream oldBackupOut = new ZipOutputStream (new BufferedOutputStream (new FileOutputStream (oldBackupTempFile)));
        oldBackupOut.setLevel (9);
        oldBackupIsEmpty = true;
        atomicFilesInOldBackup = new ArrayList ();
        ZipEntry oldEntry;
        while ((oldEntry = oldBackupIn.getNextEntry ()) != null) {
            String filename = oldEntry.getName ();
            ThreadThrottler.tick ();
            if (HIST_LOG_FILE_NAME.equals (filename)) {
                long histLogModTime = oldEntry.getTime ();
                if (histLogModTime < 1) histLogModTime = mostRecentBackupFile.lastModified ();
                File logFile = new File (dataDir, LOG_FILE_NAME);
                long currentLogModTime = logFile.lastModified ();
                if (currentLogModTime <= histLogModTime) copyZipEntry (oldBackupIn, newBackupOut, oldEntry, null);
                else writeHistLogFile (oldBackupIn, newBackupOut, dataDir);
                wroteHistLog = true;
                continue;
            }
            if (! fileFilter.accept (srcDirectory, filename)) continue;
            File file = new File (dataDir, filename);
            if (dataFiles.remove (filename)) {
                backupFile (oldEntry, oldBackupIn, oldBackupOut, newBackupOut, file, filename);
            }
            else {
                copyZipEntry (oldBackupIn, oldBackupOut, oldEntry, null);
                wroteEntryToOldBackup (filename);
            }
        }
        addAtomicFilesToBackup (oldBackupOut);
        oldBackupIn.close ();
        mostRecentBackupFile.delete ();
        if (oldBackupIsEmpty) {
            oldBackupOut.putNextEntry (new ZipEntry ("foo"));
            oldBackupOut.close ();
            oldBackupTempFile.delete ();
        }
        else {
            oldBackupOut.close ();
            FileUtils.renameFile (oldBackupTempFile, mostRecentBackupFile);
        }
    }
    for (Iterator iter = dataFiles.iterator (); iter.hasNext ();) {
        ThreadThrottler.tick ();
        String filename = (String) iter.next ();
        File file = new File (dataDir, filename);
        backupFile (null, null, null, newBackupOut, file, filename);
    }
    if (wroteHistLog == false) writeHistLogFile (null, newBackupOut, dataDir);
    pt.click ("Backed up data files");
    if (extraContentSupplier != null) extraContentSupplier.addExtraContentToBackup (newBackupOut);
    pt.click ("Backed up extra content");
    newBackupOut.close ();
    FileUtils.renameFile (newBackupTempFile, destFile);
}


private String getCalendarTable (int month, int year, String id, int index, HTTPurl urlData) throws Exception {
    StringBuffer content = new StringBuffer ();
    Calendar cal = Calendar.getInstance ();
    ScheduleItem item = null;
    String idString = "";
    if (id != null && id.length () > 0) {
        item = store.getScheduleItem (id);
        idString = "&id=" + URLEncoder.encode (id, "UTF-8");
    }
    if (index > - 1) {
        idString += "&index=" + index;
    }
    int thisDay = 0;
    cal.get (Calendar.DATE);
    int thisMonth = 0;
    cal.get (Calendar.MONTH);
    int thisYear = 0;
    cal.get (Calendar.YEAR);
    if (item != null) {
        Calendar currentDate = Calendar.getInstance ();
        currentDate.setTime (item.getStart ());
        thisDay = currentDate.get (Calendar.DATE);
        thisMonth = currentDate.get (Calendar.MONTH);
        thisYear = currentDate.get (Calendar.YEAR);
    }
    else {
        thisDay = cal.get (Calendar.DATE);
        thisMonth = cal.get (Calendar.MONTH);
        thisYear = cal.get (Calendar.YEAR);
    }
    cal.set (Calendar.DATE, 1);
    if (month != - 1 && year != - 1) {
        cal.set (Calendar.MONTH, month);
        cal.set (Calendar.YEAR, year);
    }
    else {
        year = cal.get (Calendar.YEAR);
        month = cal.get (Calendar.MONTH);
    }
    cal.add (Calendar.MONTH, 1);
    int nextMonth = cal.get (Calendar.MONTH);
    int nextYear = cal.get (Calendar.YEAR);
    cal.add (Calendar.MONTH, - 2);
    int prevMonth = cal.get (Calendar.MONTH);
    int prevYear = cal.get (Calendar.YEAR);
    cal.add (Calendar.MONTH, 1);
    content.append ("<tr><td class='calendarTitle' colspan='7'>");
    content.append ("<a class='infoNav' href='/servlet/" + urlData.getServletClass () + "?action=01&month=" + prevMonth + "&year=" + prevYear + idString + "'><<</a> ");
    content.append (store.monthNameFull.get (new Integer (month)) + " " + year);
    content.append (" <a class='infoNav' href='/servlet/" + urlData.getServletClass () + "?action=01&month=" + nextMonth + "&year=" + nextYear + idString + "'>>></a> ");
    content.append ("</td></tr>");
    content.append ("<tr><td class='calendarweek'>SUN</td><td class='calendarweek'>MON</td><td class='calendarweek'>TUES</td><td class='calendarweek'>WED</td><td class='calendarweek'>THUR</td><td class='calendarweek'>FRI</td><td class='calendarweek'>SAT</td></tr>");
    int dayOfWeek = cal.get (Calendar.DAY_OF_WEEK);
    int dayOfMonth = 0;
    int numberOfWeeks = (cal.getActualMaximum (Calendar.DATE) + dayOfWeek + 5) / 7;
    for (int week = 0; week < numberOfWeeks; week ++) {
        content.append ("<tr>");
        for (int day = 1; day < 8; day ++) {
            if ((day < dayOfWeek) && week == 0) {
                content.append ("<td class='calendarday'>&nbsp;</td>");
            }
            else if (cal.get (Calendar.MONTH) != month) {
                content.append ("<td class='calendarday'>&nbsp;</td>");
            }
            else {
                dayOfMonth = cal.get (Calendar.DATE);
                String dayURL = "/servlet/" + urlData.getServletClass () + "?action=02&day=" + dayOfMonth + "&month=" + month + "&year=" + year + idString;
                if (dayOfMonth == thisDay && month == thisMonth && year == thisYear) {
                    content.append ("<td onClick=\"document.location.href='" + dayURL + "'\" class='calendarToday'>");
                }
                else {
                    content.append ("<td onClick=\"document.location.href='" + dayURL + "'\" class='calendarday'>");
                }
                content.append ("<a class='noUnder' href='" + dayURL + "'>");
                content.append (dayOfMonth + "</a></td>");
                cal.add (Calendar.DATE, 1);
            }
        }
        content.append ("</tr>");
    }
    return content.toString ();
}


-----Function Pair=84=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=85=-----==

private void readDirectoryViaMap () throws IOException {
    if (debug) {
        Log.log.println (LogType.EXHAUSTIVE, "Reading directory");
    }
    int num = 0;
    index.clear ();
    long loc = dirlistLoc;
    while (loc != 0) {
        bb.position ((int) loc);
        Block b = new Block ();
        b.length = bb.getLong ();
        b.loc = loc;
        free.add (b);
        num ++;
        byte marker = bb.get ();
        while (marker == 1) {
            DirEntry d = new DirEntry ();
            d.readViaMap ();
            marker = bb.get ();
            index.put (d.name, d);
        }
        loc = bb.getLong ();
    }
    if (debug) {
        Log.log.println (LogType.EXHAUSTIVE, "  Found " + index.size () + " items in " + num + " block");
    }
}


private byte [] moveAutoAddItem (HTTPurl urlData, HashMap headers) throws Exception {
    int id = - 1;
    try {
        id = Integer.parseInt (urlData.getParameter ("id"));
    } catch (Exception e) {
    }
    int dir = 1;
    try {
        dir = Integer.parseInt (urlData.getParameter ("dir"));
    } catch (Exception e) {
    }
    boolean direction = false;
    if (dir == 1) direction = true;
    if (id != - 1) store.moveEpgItem (id, direction);
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/KBAutoAddRes\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=86=-----==

public void doGetArrayCommand (String command, String [] args) {
    try {
        JDP_Class jdpClass = user.bmap.arrayTypeToJDPClass (args [0], args [1], parseHex32 (args [2]), false);
        jdpClass.fields.trimToSize ();
        jdp_console.writeOutput (jdpClass);
    } catch (memoryException e) {
        jdp_console.writeOutput ("(" + e.getMessage () + ")");
    } catch (NoSuchClassException e2) {
        jdp_console.writeOutput (args [0] + " is an invalid class name");
    } catch (NumberFormatException e3) {
        jdp_console.writeOutput ("bad address for casting: " + args [1]);
        e3.printStackTrace ();
    } catch (BmapNotFoundException e4) {
        jdp_console.writeOutput (args [0] + " is an invalid class name");
    }
    return;
}


public static File createFile (String filename) throws IOException {
    File file = new File (filename);
    try {
        if (file.isDirectory ()) throw new IOException ("The path '" + file.getPath () + "' does not specify a file.");
        if (! file.isFile ()) {
            file = file.getAbsoluteFile ();
            File parentDir = new File (file.getParent ());
            if (! parentDir.exists ()) parentDir.mkdirs ();
        }
    } catch (Exception e) {
        log.error (e.getMessage ());
        throw new IOException (e.getMessage ());
    }
    return file;
}


-----Function Pair=87=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=88=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=89=-----==

public String formatString (String text) {
    char [] car = new char [text.length ()];
    text.getChars (0, text.length (), car, 0);
    char c;
    int num = 0;
    String s = null;
    char shortcut = 0;
    int state = 0;
    boolean close = false;
    OOTag tag = null;
    LBuffer tagBuf = new LBuffer (8);
    LBuffer outBuf = new LBuffer (text.length () * 2);
    for (int i = 0; i < car.length; i ++) {
        c = car [i];
        if (c == '<') {
            if (state == 1) {
                outBuf.append ("&lt;");
                tagBuf.reset ();
                state = 0;
            }
            else if (state > 1) {
                state = - 1;
            }
            else {
                tagBuf.append (c);
                state = 1;
            }
        }
        else if ((state == 1) && (c == '/')) {
            close = true;
        }
        else if ((state == 1) && (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')))) {
            state ++;
            shortcut = c;
            if (shortcut < 'a') shortcut += ('a' - 'A');
            tagBuf.append (c);
        }
        else if (((state == 2) || (state == 3)) && ((c >= '0') && (c <= '9'))) {
            state ++;
            num = num * 10 + (c - '0');
            tagBuf.append (c);
        }
        else if (((state == 3) || (state == 4)) && (c == '>')) {
            tag = null;
            if ((num >= 0) && (num < m_tagList.size ())) {
                tag = (OOTag) m_tagList.get (num);
                if (tag.shortcut () != shortcut) tag = null;
            }
            if (tag == null) {
                state = - 1;
            }
            else if (close == false) {
                outBuf.append ('<');
                outBuf.append (tag.verbatum ());
                outBuf.append ('>');
            }
            else {
                outBuf.append ("</");
                outBuf.append (tag.name ());
                outBuf.append ('>');
            }
            state = 0;
            num = 0;
            tagBuf.reset ();
            close = false;
        }
        else if (state >= 0) {
            state = - 1;
        }
        else {
            s = OOParser.convert (c);
            if (s == null) outBuf.append (c);
            else {
                outBuf.append ('&');
                outBuf.append (s);
                outBuf.append (';');
            }
        }
        if (state < 0) {
            tagBuf.append (c);
            outBuf.append (OOParser.convertAll (tagBuf));
            tagBuf.reset ();
            state = 0;
        }
    }
    return outBuf.string ();
}


private void dropTargetHandleDrop (DropTargetEvent event, File targetFile) {
    if (! dropTargetValidate (event, targetFile)) return;
    final String [] sourceNames = (String []) event.data;
    if (sourceNames == null) event.detail = DND.DROP_NONE;
    if (event.detail == DND.DROP_NONE) return;
    progressDialog = new ProgressDialog (shell, (event.detail == DND.DROP_MOVE) ? ProgressDialog.MOVE : ProgressDialog.COPY);
    progressDialog.setTotalWorkUnits (sourceNames.length);
    progressDialog.open ();
    Vector processedFiles = new Vector ();
    for (int i = 0; (i < sourceNames.length) && (! progressDialog.isCancelled ()); i ++) {
        final File source = new File (sourceNames [i]);
        final File dest = new File (targetFile, source.getName ());
        if (source.equals (dest)) continue;
        progressDialog.setDetailFile (source, ProgressDialog.COPY);
        while (! progressDialog.isCancelled ()) {
            if (copyFileStructure (source, dest)) {
                processedFiles.add (source);
                break;
            }
            else if (! progressDialog.isCancelled ()) {
                if (event.detail == DND.DROP_MOVE && (! isDragging)) {
                    MessageBox box = new MessageBox (shell, SWT.ICON_ERROR | SWT.RETRY | SWT.CANCEL);
                    box.setText (getResourceString ("dialog.FailedCopy.title"));
                    box.setMessage (getResourceString ("dialog.FailedCopy.description", new Object [] {source, dest}));
                    int button = box.open ();
                    if (button == SWT.CANCEL) {
                        i = sourceNames.length;
                        event.detail = DND.DROP_NONE;
                        break;
                    }
                }
                else {
                    MessageBox box = new MessageBox (shell, SWT.ICON_ERROR | SWT.ABORT | SWT.RETRY | SWT.IGNORE);
                    box.setText (getResourceString ("dialog.FailedCopy.title"));
                    box.setMessage (getResourceString ("dialog.FailedCopy.description", new Object [] {source, dest}));
                    int button = box.open ();
                    if (button == SWT.ABORT) i = sourceNames.length;
                    if (button != SWT.RETRY) break;
                }
            }
            progressDialog.addProgress (1);
        }
    }
    if (isDragging) {
        processedDropFiles = ((File []) processedFiles.toArray (new File [processedFiles.size ()]));
    }
    else {
        progressDialog.close ();
        progressDialog = null;
    }
    notifyRefreshFiles (new File [] {targetFile});
}


-----Function Pair=90=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=91=-----==

private void displayPart (MailUserData mud, int msgNum, Part part, int partNum, HttpServletRequest req, ServletOutputStream out) throws IOException {
    if (partNum != 0) out.println ("<p><hr>");
    try {
        String sct = part.getContentType ();
        if (sct == null) {
            out.println ("invalid part");
            return;
        }
        ContentType ct = new ContentType (sct);
        if (partNum != 0) out.println ("<b>Attachment Type:</b> " + ct.getBaseType () + "<br>");
        if (ct.match ("text/plain")) {
            out.println ("<pre>");
            out.println ((String) part.getContent ());
            out.println ("</pre>");
        }
        else {
            String s;
            if ((s = part.getFileName ()) != null) out.println ("<b>Filename:</b> " + s + "<br>");
            s = null;
            if ((s = part.getDescription ()) != null) out.println ("<b>Description:</b> " + s + "<br>");
            out.println ("<a href=\"" + HttpUtils.getRequestURL (req) + "?message=" + msgNum + "&part=" + partNum + "\">Display Attachment</a>");
        }
    } catch (MessagingException mex) {
        out.println (mex.toString ());
    }
}


public void sendStringToZipStream (String userbaseDir, String fileStr, String fileValueString, ZipOutputStream zipout) throws Exception {
    if (! userbaseDir.endsWith (sep)) {
        userbaseDir += sep;
    }
    BufferedInputStream in = null;
    byte dataBuff [] = new byte [bufferSize];
    String entryPath = fileStr;
    in = new BufferedInputStream (new ByteArrayInputStream (fileValueString.getBytes ()), bufferSize);
    ZipEntry zipEntry = new ZipEntry (entryPath);
    zipout.putNextEntry (zipEntry);
    int writeLen;
    while ((writeLen = in.read (dataBuff)) > 0) {
        zipout.write (dataBuff, 0, writeLen);
    }
    zipout.flush ();
    zipout.closeEntry ();
    in.close ();
}


-----Function Pair=92=-----==

public void newButtonActionPerformed (Map foreingKeyMap) {
    try {
        KMetaUtilsClass.cursorWait (parentWindow);
        JDialog Dialog = getPDCEditorWidow ();
        ((KDialogInterface) Dialog).initializeDialog (KDialogInterface.CREATE_NEW_MODE, - 1L, foreingKeyMap);
        KMetaUtilsClass.cursorNormal (parentWindow);
        Dialog.setVisible (true);
    } catch (KExceptionClass error) {
        log.log (this, error.longMessage);
        KMetaUtilsClass.showErrorMessageFromException (parentWindow, error);
    } catch (Exception error) {
        log.log (this, KMetaUtilsClass.getStackTrace (error));
        KMetaUtilsClass.showErrorMessageFromException (parentWindow, error);
    } finally {
        KMetaUtilsClass.cursorNormal (parentWindow);
    }
}


public void run () {
    Enumeration keys;
    while (! this.main.finishedAll) {
        keys = this.main.mappings.keys ();
        while (keys.hasMoreElements ()) {
            String jobId = "" + keys.nextElement ();
            TraceFile tf = this.main.tfm.getTraceFile (jobId, this.main.mainMonitorURL);
            if (tf != null) {
                if (tf.getLinesNumber () == (this.main.maxMessageForAJob + 2)) this.main.finished (jobId);
            }
        }
        try {
            Thread.sleep (1000);
        } catch (InterruptedException ex) {
        }
    }
}


-----Function Pair=93=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=94=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=95=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


-----Function Pair=96=-----==

static void filledCheck () throws java.lang.Exception {
    int loop = 0;
    String n = null;
    SMPPPacket [] obj = new SMPPPacket [cs.length];
    System.out.println ("\n\n========= Filled in field check ==========");
    try {
        BindReceiver br = new BindReceiver (6);
        n = br.getClass ().getName ();
        obj [loop ++] = br;
        br.setSystemId ("sysId");
        br.setSystemType ("sysType");
        br.setPassword ("passwd");
        br.setInterfaceVersion (0x33);
        br.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534[1-3]"));
        BindReceiverResp brr = new BindReceiverResp (6);
        n = brr.getClass ().getName ();
        obj [loop ++] = brr;
        brr.setSystemId ("smscId");
        BindTransmitter bt = new BindTransmitter (6);
        n = bt.getClass ().getName ();
        bt.setSystemId ("sysId");
        bt.setSystemType ("sysType");
        bt.setPassword ("passwd");
        bt.setInterfaceVersion (0x33);
        bt.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534[1-3]"));
        obj [loop ++] = bt;
        BindTransmitterResp btr = new BindTransmitterResp (6);
        n = btr.getClass ().getName ();
        obj [loop ++] = btr;
        btr.setSystemId ("smscId");
        CancelSM cm = new CancelSM (6);
        n = cm.getClass ().getName ();
        obj [loop ++] = cm;
        cm.setServiceType ("svcTp");
        cm.setMessageId ("deadbeef");
        cm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        cm.setDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        CancelSMResp cmr = new CancelSMResp (6);
        n = cmr.getClass ().getName ();
        obj [loop ++] = cmr;
        DeliverSM dm = new DeliverSM (6);
        n = dm.getClass ().getName ();
        obj [loop ++] = dm;
        dm.setServiceType ("svcTp");
        dm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        dm.setDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293213"));
        dm.setPriority (true);
        dm.setDeliveryTime (new SMPPDate ());
        dm.setExpiryTime (new SMPPDate ());
        dm.setRegistered (true);
        dm.setReplaceIfPresent (true);
        dm.setMessageText ("This is a short message");
        DeliverSMResp dmr = new DeliverSMResp (6);
        n = dmr.getClass ().getName ();
        obj [loop ++] = dmr;
        EnquireLink el = new EnquireLink (6);
        n = el.getClass ().getName ();
        obj [loop ++] = el;
        EnquireLinkResp elr = new EnquireLinkResp (6);
        n = elr.getClass ().getName ();
        obj [loop ++] = elr;
        GenericNack gn = new GenericNack (6);
        n = gn.getClass ().getName ();
        obj [loop ++] = gn;
        ParamRetrieve pr = new ParamRetrieve (6);
        n = pr.getClass ().getName ();
        obj [loop ++] = pr;
        pr.setParamName ("getParam");
        ParamRetrieveResp prr = new ParamRetrieveResp (6);
        n = prr.getClass ().getName ();
        obj [loop ++] = prr;
        prr.setParamValue ("paramValueCanBeQuiteLong");
        QueryLastMsgs qlm = new QueryLastMsgs (6);
        n = qlm.getClass ().getName ();
        obj [loop ++] = qlm;
        qlm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        qlm.setMsgCount (45);
        QueryLastMsgsResp qlmr = new QueryLastMsgsResp (6);
        n = qlmr.getClass ().getName ();
        obj [loop ++] = qlmr;
        qlmr.addMessageId ("23423423");
        qlmr.addMessageId ("23423425");
        qlmr.addMessageId ("23423424");
        qlmr.addMessageId ("23323422");
        qlmr.addMessageId ("33324522");
        qlmr.addMessageId ("33323464");
        qlmr.addMessageId ("33323232");
        qlmr.addMessageId ("33323452");
        QueryMsgDetails qmd = new QueryMsgDetails (6);
        n = qmd.getClass ().getName ();
        obj [loop ++] = qmd;
        qmd.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        qmd.setMessageId ("aaeeffe");
        qmd.setSmLength (155);
        QueryMsgDetailsResp qmdr = new QueryMsgDetailsResp (6);
        n = qmdr.getClass ().getName ();
        obj [loop ++] = qmdr;
        qmdr.setServiceType ("svcTp");
        qmdr.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        qmdr.addDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293213"));
        qmdr.setPriority (true);
        qmdr.setDeliveryTime (new SMPPDate ());
        qmdr.setExpiryTime (new SMPPDate ());
        qmdr.setRegistered (true);
        qmdr.setMessageText ("This is a short message");
        qmdr.setMessageId ("deadbeef");
        qmdr.setFinalDate (new SMPPDate ());
        qmdr.setMessageStatus (9);
        qmdr.setErrorCode (2);
        QuerySM qm = new QuerySM (6);
        n = qm.getClass ().getName ();
        obj [loop ++] = qm;
        qm.setMessageId ("aaaaaaab");
        qm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        QuerySMResp qmr = new QuerySMResp (6);
        n = qmr.getClass ().getName ();
        obj [loop ++] = qmr;
        qmr.setMessageId ("aaaaabba");
        qmr.setFinalDate (new SMPPDate ());
        qmr.setMessageStatus (1);
        qmr.setErrorCode (4);
        ReplaceSM rm = new ReplaceSM (6);
        n = rm.getClass ().getName ();
        obj [loop ++] = rm;
        rm.setMessageId ("cafecafe");
        rm.setServiceType ("svcTp");
        rm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        rm.setDeliveryTime (new SMPPDate ());
        rm.setExpiryTime (new SMPPDate ());
        rm.setRegistered (true);
        rm.setMessageText ("This is a short message");
        ReplaceSMResp rmr = new ReplaceSMResp (6);
        n = rmr.getClass ().getName ();
        obj [loop ++] = rmr;
        SubmitMulti sml = new SubmitMulti (6);
        n = sml.getClass ().getName ();
        obj [loop ++] = sml;
        sml.setServiceType ("svcTp");
        sml.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        sml.addDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293211"));
        sml.addDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293212"));
        sml.addDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293213"));
        sml.setPriority (true);
        sml.setDeliveryTime (new SMPPDate ());
        sml.setExpiryTime (new SMPPDate ());
        sml.setRegistered (true);
        sml.setReplaceIfPresent (false);
        sml.setMessageText ("This is a short message, multi destinations");
        SubmitMultiResp smlr = new SubmitMultiResp (6);
        n = smlr.getClass ().getName ();
        obj [loop ++] = smlr;
        smlr.setMessageId ("213ffeaa");
        smlr.addSmeToTable (new SmeAddress_e (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111", 0));
        smlr.addSmeToTable (new SmeAddress_e (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293211", 3));
        smlr.addSmeToTable (new SmeAddress_e (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293212", 0));
        smlr.addSmeToTable (new SmeAddress_e (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293213", 5));
        SubmitSM sm = new SubmitSM (6);
        n = sm.getClass ().getName ();
        obj [loop ++] = sm;
        sm.setServiceType ("svcTp");
        sm.setSource (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "65534111"));
        sm.setDestination (new SmeAddress (GSMConstants.GSM_TON_UNKNOWN, GSMConstants.GSM_NPI_UNKNOWN, "991293213"));
        sm.setPriority (true);
        sm.setDeliveryTime (new SMPPDate ());
        sm.setExpiryTime (new SMPPDate ());
        sm.setRegistered (true);
        sm.setReplaceIfPresent (true);
        sm.setMessageText ("This is a short message");
        SubmitSMResp smr = new SubmitSMResp (6);
        n = smr.getClass ().getName ();
        obj [loop ++] = smr;
        smr.setMessageId ("12e53af");
        Unbind ub = new Unbind (6);
        n = ub.getClass ().getName ();
        obj [loop ++] = ub;
        UnbindResp ubr = new UnbindResp (6);
        n = ubr.getClass ().getName ();
        obj [loop ++] = ubr;
    } catch (Exception x) {
        System.out.print (n + ":\n    ");
        x.printStackTrace ();
    }
    runTestOnArray (obj);
    System.out.println ("\n\n============================================");
}


private String addSchedule (HTTPurl urlData, ScheduleItem item) throws Exception {
    int startBuff = 0;
    int endBuff = 0;
    try {
        startBuff = Integer.parseInt (store.getProperty ("schedule.buffer.start"));
        endBuff = Integer.parseInt (store.getProperty ("schedule.buffer.end"));
    } catch (Exception e) {
    }
    String addBuff = urlData.getParameter ("buffer");
    String y = urlData.getParameter ("year");
    String m = urlData.getParameter ("month");
    String d = urlData.getParameter ("day");
    String h = urlData.getParameter ("hour");
    String mi = urlData.getParameter ("min");
    String dur = urlData.getParameter ("duration");
    String channel = urlData.getParameter ("channel");
    String name = urlData.getParameter ("name");
    String autoDel = urlData.getParameter ("autoDel");
    String namePattern = urlData.getParameter ("namePattern");
    String keepFor = urlData.getParameter ("keepfor");
    String task = urlData.getParameter ("task");
    HashMap < String, Channel > channels = store.getChannels ();
    if (! channels.containsKey (channel)) {
        throw new Exception ("Channel Not Found!");
    }
    String [] namePatterns = store.getNamePatterns ();
    if (namePattern == null || namePattern.length () == 0) namePattern = namePatterns [0];
    GuideStore guide = GuideStore.getInstance ();
    boolean found = false;
    for (int x = 0; x < namePatterns.length; x ++) {
        if (namePatterns [x].equals (namePattern)) {
            found = true;
            break;
        }
    }
    if (! found) {
        throw new Exception ("Name Pattern Not Found!");
    }
    if (item != null) {
        store.removeScheduleItem (item.toString ());
    }
    int duration = Integer.parseInt (dur);
    int type = 0;
    try {
        type = Integer.parseInt (urlData.getParameter ("type"));
    } catch (Exception e01) {
    }
    int captype = 2;
    try {
        captype = Integer.parseInt (store.getProperty ("capture.deftype"));
    } catch (Exception e01) {
    }
    try {
        captype = Integer.parseInt (urlData.getParameter ("captype"));
    } catch (Exception e01) {
    }
    Calendar newDate = Calendar.getInstance ();
    newDate.set (Calendar.MILLISECOND, 0);
    newDate.set (Integer.parseInt (y), Integer.parseInt (m), Integer.parseInt (d), Integer.parseInt (h), Integer.parseInt (mi), 0);
    if ("yes".equals (addBuff)) {
        newDate.add (Calendar.MINUTE, (startBuff * - 1));
        duration = duration + startBuff + endBuff;
    }
    if (item == null) item = new ScheduleItem (store.rand.nextLong ());
    item.setCreatedFrom (null);
    item.setCapType (captype);
    item.setType (type);
    item.setName (name);
    item.setState (ScheduleItem.WAITING);
    item.setStatus ("Waiting");
    item.resetAbort ();
    item.setStart (newDate);
    item.setDuration (duration);
    int pathIndex = - 1;
    try {
        pathIndex = Integer.parseInt (urlData.getParameter ("path"));
    } catch (Exception e01) {
    }
    item.setCapturePathIndex (pathIndex);
    item.setChannel (channel);
    if ("true".equalsIgnoreCase (autoDel)) item.setAutoDeletable (true);
    else item.setAutoDeletable (false);
    item.setFilePattern (namePattern);
    if (keepFor != null) {
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    else {
        keepFor = store.getProperty ("autoDel.keepfor");
        int keepInt = 30;
        try {
            keepInt = Integer.parseInt (keepFor);
        } catch (Exception e) {
        }
        item.setKeepFor (keepInt);
    }
    if (task != null && ! task.equalsIgnoreCase ("none") && task.length () > 0) {
        HashMap < String, TaskCommand > tasks = store.getTaskList ();
        if (tasks.containsKey (task)) item.setPostTask (task);
    }
    else if (task != null && task.equalsIgnoreCase ("none")) {
        item.setPostTask ("");
    }
    item.log ("New Schedule added/edited");
    boolean isAlreadyInLIst = guide.isAlreadyInList (item, 1);
    if (isAlreadyInLIst) {
        return "Already In List";
    }
    else {
        store.addScheduleItem (item);
    }
    return null;
}


-----Function Pair=97=-----==

public static void test () throws Exception {
    int keySize = 512;
    int blockSize = keySize / 8;
    CertAndKeyGen certAndKeyGen = new CertAndKeyGen ("RSA", "MD5WithRSA");
    certAndKeyGen.generate (keySize);
    PublicKey publicKey = certAndKeyGen.getPublicKey ();
    PrivateKey privateKey = certAndKeyGen.getPrivateKey ();
    String input = "Aabcdefgh12345678 " + "Babcdefgh12345678 " + "Cabcdefgh12345678 " + "Dabcdefgh12345678 " + "Eabcdefgh12345678 " + "Fabcdefgh12345678 " + "Gabcdefgh12345678 " + "Habcdefgh12345678 " + "Iabcdefgh12345678 " + "Jabcdefgh12345678 " + "Kabcdefgh12345678 " + "Labcdefgh12345678 " + "Mabcdefgh12345678";
    input = "This is to be encoded. Part1, Part2,Part3";
    byte [] binput = input.getBytes ();
    System.out.println ("blockSize = " + blockSize);
    System.out.println ("len = " + binput.length);
    Cipher cipher1 = Cipher.getInstance ("RSA/ECB/PKCS1Padding");
    cipher1.init (Cipher.ENCRYPT_MODE, publicKey);
    System.out.println ("binput.length = " + binput.length);
    byte [] boutput1B = cipher1.doFinal (binput, 0, binput.length);
    System.out.println ("boutput1B.length = " + boutput1B.length);
    Cipher cipher2 = Cipher.getInstance ("RSA/ECB/PKCS1Padding");
    cipher2.init (Cipher.DECRYPT_MODE, privateKey);
    byte [] decoded1B = cipher2.doFinal (boutput1B);
    System.out.println ("decoded1B.length = " + decoded1B.length);
    System.out.println (new String (decoded1B));
}


public static File backupFile (File theSource, File theBackupDir, String thePrefix, int theMaxNumber) {
    int maxNumber = Math.max (theMaxNumber, 1);
    String prefix = (thePrefix == null) ? DEFAULT_BACKUP_PREFIX : thePrefix;
    prefix = (prefix.indexOf (BACKUP_INDEX_CHAR) < 0) ? DEFAULT_BACKUP_PREFIX : prefix;
    File backup = null;
    if (theSource.exists () && theSource.canRead ()) {
        File backupDir = (theBackupDir != null) ? theBackupDir : theSource.getParentFile ();
        if (! backupDir.exists ()) {
            backupDir.mkdirs ();
        }
        String baseName = theSource.getName ();
        for (int index = 0; index < maxNumber; index ++) {
            File file = IO.getFile (backupDir, prefix.replace (BACKUP_INDEX_CHAR, String.valueOf (index)) + baseName);
            if (! file.exists ()) {
                backup = file;
                break;
            }
            else if (backup == null) {
                backup = file;
            }
            else if (file.lastModified () < backup.lastModified ()) {
                backup = file;
            }
        }
        IO.copyFile (theSource, backup);
        backup.setLastModified (theSource.lastModified ());
    }
    return backup;
}


-----Function Pair=98=-----==

public String exec (String path, boolean wait) {
    String out = "";
    try {
        String line;
        Process p = Runtime.getRuntime ().exec (path);
        if (wait) {
            BufferedReader input = new BufferedReader (new InputStreamReader (p.getInputStream ()));
            BufferedReader err = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
            while ((line = input.readLine ()) != null) {
                if (out != "") out += "\r\n";
                out += line;
                System.out.println (line);
                line = err.readLine ();
                if (line != null) System.err.println (line);
            }
            input.close ();
        }
    } catch (Exception err) {
        System.err.println ("ERROR");
        err.printStackTrace ();
    }
    return out;
}


public void createNewFile (InputStream is, String filepath) {
    File file = new File (filepath);
    if (! file.exists ()) {
        try {
            String parent = file.getParent ();
            if (parent != null) {
                File dir = new File (parent);
                if (! dir.exists ()) {
                    dir.mkdirs ();
                }
            }
            file.createNewFile ();
        } catch (Exception e) {
            logger.error ("Can't create file...:" + file);
        }
    }
    FileOutputStream os = null;
    try {
        os = new FileOutputStream (filepath);
        int c;
        while ((c = is.read ()) != - 1) {
            os.write (c);
        }
    } catch (IOException e) {
        logger.error (e, e);
    } finally {
        if (os != null) {
            try {
                os.flush ();
                os.close ();
            } catch (Throwable e) {
            }
        }
    }
}


-----Function Pair=99=-----==

public int login () throws IOException {
    if (SSL > 0) {
        if (SSL == 3) {
            if (doCmd ("AUTH TLS") > 3) SSL = 0;
        }
        else if (SSL == 1) {
            if (doCmd ("AUTH SSL") > 3) SSL = 0;
        }
        gThread.wait = true;
        SSL = sc.tryTLS (SSL);
        gThread.wait = false;
    }
    String msg = "USER " + user;
    int ret;
    if ((ret = doCmd (msg)) > 3) {
        return ret;
    }
    if (ret == 2) {
        return 2;
    }
    String [] challenge = new String [2];
    int type;
    if ((type = testOTP (getReplyMultiLine, challenge)) > 0) {
        Utilities.print ("Challenge is: " + challenge [0] + " " + challenge [1] + "\n");
        msg = "PASS " + jotp.computeOTP (challenge [0], challenge [1], pass, type);
    }
    else msg = "PASS " + pass;
    return doCmd (msg);
}


private void copyRecursive (File source, File destination, FileFilter filter) {
    if (source.isDirectory ()) {
        boolean okay = destination.mkdir ();
        if (! okay) {
            throw new FileCreationFailedException (destination.getAbsolutePath (), true);
        }
        File [] children;
        if (filter == null) {
            children = source.listFiles ();
        }
        else {
            children = source.listFiles (filter);
        }
        for (File file : children) {
            copyRecursive (file, new File (destination, file.getName ()), filter);
        }
    }
    else {
        copyFile (source, destination);
    }
}


-----Function Pair=100=-----==

public boolean checkAntFile (String filename) {
    File buildFile = new File (filename);
    Project p = new Project ();
    p.setUserProperty ("ant.file", buildFile.getAbsolutePath ());
    boolean ant_file = true;
    try {
        p.init ();
        ProjectHelper helper = ProjectHelper.getProjectHelper ();
        p.addReference ("ant.projectHelper", helper);
        helper.parse (p, buildFile);
    } catch (BuildException e) {
        ant_file = false;
    }
    return ant_file;
}


public void unCompress (String fileName, String dir) {
    Enumeration entries;
    ZipFile zipFile;
    if (! dir.equals ("")) dir = dir + "/";
    try {
        zipFile = new ZipFile (fileName);
        entries = zipFile.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            if (entry.isDirectory ()) {
                (new File (dir + entry.getName ())).mkdir ();
                continue;
            }
            copyInputStream (zipFile.getInputStream (entry), new BufferedOutputStream (new FileOutputStream (dir + entry.getName ())));
        }
        zipFile.close ();
    } catch (IOException ioe) {
        System.err.println ("Unhandled exception:");
        ioe.printStackTrace ();
        return;
    }
}


-----Function Pair=101=-----==

private synchronized void writeToFile (String line) {
    try {
        PrintWriter out = new PrintWriter (new FileOutputStream (this.tf, true));
        out.println (line);
        out.close ();
    } catch (IOException ex) {
        System.out.println ("\tTestClient.writeToFile(" + line + ") ~ FAILED, IOException: " + ex.getMessage ());
        ex.printStackTrace (System.out);
        return;
    }
    System.out.print (".");
    if (this.currentMessageNumber ++ == this.maxMessageNumber + 1) {
        this.cbInterface.finished (this.jobId);
    }
}


private synchronized void writeToFile (String line) {
    try {
        PrintWriter out = new PrintWriter (new FileOutputStream (this.tf, true));
        out.println (line);
        out.close ();
    } catch (IOException ex) {
        System.out.println ("\tTestClient.writeToFile(" + line + ") ~ FAILED, IOException: " + ex.getMessage ());
        ex.printStackTrace (System.out);
        return;
    }
    System.out.print (".");
    if (this.currentMessageNumber ++ == this.maxMessageNumber + 1) {
        this.cbInterface.finished (this.jobId);
    }
}


-----Function Pair=102=-----==

public void upZipFile (String zipFile, boolean decrypt, String specifiedDir) throws Exception {
    ZipFile zfile = new ZipFile (zipFile);
    Enumeration zList = zfile.entries ();
    ZipEntry ze = null;
    byte [] buf = new byte [BUFFER];
    byte [] encrypByte = new byte [encrypLength];
    int readLen = 0;
    logger.error ("解压文件：" + zipFile);
    long [] sDCardRealease = LoadResources.readSDCard ();
    long [] extSDCardRealease = LoadResources.readExtSDCard ();
    while (zList.hasMoreElements ()) {
        ze = (ZipEntry) zList.nextElement ();
        if (stopZipFile) {
            break;
        }
        if (specifiedDir != null && ! "..".equals (specifiedDir) && ze.getName ().indexOf (specifiedDir) < 0) continue;
        if (ze.isDirectory ()) {
            File f = new File (sdPath + ze.getName ());
            f.mkdir ();
            continue;
        }
        File tempFile = null;
        RandomAccessFile os = null;
        try {
            if (sDCardRealease [1] >= ze.getSize ()) {
                tempFile = getRealFileName (sdPath, ze.getName (), specifiedDir);
                os = new RandomAccessFile (tempFile.getAbsoluteFile (), "rw");
                sDCardRealease [1] = sDCardRealease [1] - ze.getSize ();
            }
            else if (extSDCardRealease [1] >= ze.getSize ()) {
                tempFile = getRealFileName (extSdPath, ze.getName (), specifiedDir);
                os = new RandomAccessFile (tempFile.getAbsoluteFile (), "rw");
                extSDCardRealease [1] = extSDCardRealease [1] - ze.getSize ();
            }
            else {
                throw new IOException ("空间不足");
            }
            logger.error ("解压文件：" + ze.getName ());
            InputStream is = new BufferedInputStream (zfile.getInputStream (ze));
            readLen = is.read (buf, 0, BUFFER);
            if (decrypt) {
                System.arraycopy (buf, 0, encrypByte, 0, encrypLength);
                byte [] temp = CryptionControl.getInstance ().decryptECB (encrypByte, rootKey);
                System.arraycopy (temp, 0, buf, 0, encrypLength);
            }
            while (readLen != - 1) {
                os.write (buf, 0, readLen);
                readLen = is.read (buf, 0, BUFFER);
            }
            is.close ();
            os.close ();
        } catch (IOException e) {
            throw new IOException ("解压失败");
        }
    }
    zfile.close ();
}


private void compareFile (File fileA, File fileB, boolean skipIdentical, String basePath) {
    String filename = null;
    if (fileB != null) filename = fileB.getPath ();
    else if (fileA != null) filename = fileA.getPath ();
    if (filename != null && basePath != null && filename.startsWith (basePath)) {
        filename = filename.substring (basePath.length ());
        if (filename.startsWith (File.separator)) filename = filename.substring (1);
    }
    updateProgress (filename);
    if (! isFile (fileA)) fileA = null;
    if (! isFile (fileB)) fileB = null;
    examineFiles (fileA, fileB);
    if (skipIdentical && filesAreIdentical) return;
    StringBuffer fileTable;
    String label, htmlName;
    if (fileA == null) {
        fileTable = addedTable;
        label = "Added";
    }
    else if (fileB == null) {
        fileTable = deletedTable;
        label = "Deleted";
    }
    else {
        fileTable = modifiedTable;
        label = "Modified";
    }
    htmlName = HTMLUtils.escapeEntities (filename);
    if (filesAreBinary) {
        fileTable.append ("<tr><td nowrap>").append (htmlName);
        if (fileTable == modifiedTable) fileTable.append ("</td><td></td><td></td><td></td><td>");
        fileTable.append ("</td><td></td><td>Binary</td></tr>\n");
        return;
    }
    String contentsA = getContents (fileA);
    String contentsB = getContents (fileB);
    PSPDiff diff = new PSPDiff (webServer, contentsA, contentsB, filename, null);
    if (skipIdentical && (diff.getDeleted () + diff.getAdded () + diff.getModified () == 0)) return;
    base += diff.getBase ();
    deleted += diff.getDeleted ();
    added += diff.getAdded ();
    modified += diff.getModified ();
    total += diff.getTotal ();
    fileTable.append ("<tr><td nowrap><a href='#file").append (counter).append ("'>").append (htmlName).append ("</a>");
    if (fileTable == deletedTable) fileTable.append ("</td><td>").append (diff.getBase ());
    else if (fileTable == modifiedTable) fileTable.append ("</td><td>").append (diff.getBase ()).append ("</td><td>").append (diff.getDeleted ()).append ("</td><td>").append (diff.getModified ()).append ("</td><td>").append (diff.getAdded ());
    fileTable.append ("</td><td>").append (diff.getTotal ()).append ("</td><td>").append (AbstractLanguageFilter.getFilterName (diff.getFilter ())).append ("</td></tr>\n");
    redlinesOut.print ("<hr><DIV onMouseOver=\"window.defaultStatus='");
    redlinesOut.print (EscapeString.escape (htmlName, '\\', "\""));
    redlinesOut.print ("'\"><h1>");
    redlinesOut.print (label);
    redlinesOut.print (": <a name='file");
    redlinesOut.print (counter ++);
    redlinesOut.print ("'>");
    redlinesOut.print (htmlName);
    redlinesOut.print ("</a></h1>");
    diff.displayHTMLRedlines (redlinesOut);
    redlinesOut.print ("</DIV>\n\n\n");
    diff.dispose ();
}


-----Function Pair=103=-----==

private byte [] updateDeleteAfter (HTTPurl urlData) throws Exception {
    int deleteAfter = 0;
    try {
        deleteAfter = Integer.parseInt (urlData.getParameter ("deleteafter"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.time", new Integer (deleteAfter).toString ());
    int deleteAction = 0;
    try {
        deleteAction = Integer.parseInt (urlData.getParameter ("deleteaction"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.action", new Integer (deleteAction).toString ());
    System.out.println ("Action After : " + deleteAfter);
    System.out.println ("Action : " + deleteAction);
    String redirect = "HTTP/1.0 302 Moved Temporarily\n";
    redirect += "Location: /servlet/ScheduleDataRes\n\n";
    return redirect.getBytes ();
}


public void run () {
    byte [] b = new byte [1024];
    try {
        while (true) {
            int count = is.read (b);
            if (count < 0) return;
            out.write (b, 0, count);
            try {
                if (count == 0) Thread.sleep (10);
            } catch (InterruptedException e) {
            }
        }
    } catch (IOException e) {
    } finally {
        done = true;
    }
}


-----Function Pair=104=-----==

public static void compressFile (final File source, final File destination) {
    byte [] ioBuffer = new byte [8192];
    FileInputStream in = null;
    FileLock fosLock;
    FileLock fisLock = null;
    try {
        FileOutputStream fos = new FileOutputStream (destination);
        fosLock = fos.getChannel ().tryLock ();
        in = new FileInputStream (source);
        fisLock = in.getChannel ().tryLock (0, Long.MAX_VALUE, true);
        if (fosLock != null && fisLock != null) {
            ZipOutputStream zipOut = new ZipOutputStream (fos);
            zipOut.setLevel (Deflater.BEST_COMPRESSION);
            zipOut.putNextEntry (new ZipEntry (source.getName ()));
            int length;
            while ((length = in.read (ioBuffer)) > 0) {
                zipOut.write (ioBuffer, 0, length);
            }
            zipOut.closeEntry ();
            fosLock.release ();
            zipOut.close ();
        }
    } catch (IOException ex) {
        Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, ex);
    } finally {
        if (in != null) {
            try {
                if (fisLock != null) {
                    fisLock.release ();
                }
                in.close ();
            } catch (IOException e) {
                Logger.getLogger (FileUtils.class.getName ()).log (Level.SEVERE, null, e);
            }
        }
    }
}


static byte [] hexStream2Bytes (BufferedReader in) throws IOException {
    int n;
    int lastEvaluated = 0;
    char cbuf [] = new char [4096];
    n = in.read (cbuf);
    List < Byte > lb = new ArrayList < Byte > ();
    while (n > 1) {
        for (int i = 0; i < n - 1; i ++) {
            String test = "";
            test += cbuf [i];
            test += cbuf [i + 1];
            byte b = 0;
            try {
                b = AStringUtilities.hexToByte (test);
                lb.add (b);
                i ++;
            } catch (Exception ex) {
            }
            lastEvaluated = i;
        }
        if (lastEvaluated == (n - 2)) {
            cbuf [0] = cbuf [n - 1];
            n = in.read (cbuf, 1, 1) + 1;
        }
        else n = in.read (cbuf);
    }
    byte out [] = new byte [lb.size ()];
    for (int i = 0; i < lb.size (); i ++) {
        out [i] = lb.get (i);
    }
    return out;
}


-----Function Pair=105=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=106=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=107=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=108=-----==

public static byte [] getBytesFromFile (File file) throws IOException {
    InputStream is = null;
    byte [] bytes = null;
    try {
        is = new FileInputStream (file);
        long length = file.length ();
        if (length > Integer.MAX_VALUE) {
            throw new IOException ("File is too large");
        }
        bytes = new byte [(int) length];
        int offset = 0;
        int numRead = 0;
        while (offset < bytes.length && (numRead = is.read (bytes, offset, bytes.length - offset)) >= 0) {
            offset += numRead;
        }
        if (offset < bytes.length) {
            throw new IOException ("Could not completely read file " + file.getName ());
        }
    } catch (Exception ex) {
        throw new IOException (ex);
    } finally {
        if (is != null) {
            is.close ();
        }
    }
    return bytes;
}


public static final byte [] readBytes (File file) throws IOException {
    FileInputStream fileinputstream = new FileInputStream (file);
    long l = file.length ();
    if (l > Integer.MAX_VALUE) {
        throw new IOException ("File too big for loading into a byte array!");
    }
    byte byteArray [] = new byte [(int) l];
    int i = 0;
    for (int j = 0; (i < byteArray.length) && (j = fileinputstream.read (byteArray, i, byteArray.length - i)) >= 0; i += j);
    if (i < byteArray.length) {
        throw new IOException ("Could not completely read the file " + file.getName ());
    }
    fileinputstream.close ();
    return byteArray;
}


-----Function Pair=109=-----==

public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
    }
}


public void doSetBreakpoint (String command, String [] args) {
    breakpoint bp = null;
    if (args.length != 0) {
        try {
            int addr = parseHex32 (args [0]);
            jdp_console.writeOutput ("Caution: setting breakpoint at raw address. \n  If the code is moved by GC, the breakpoint will be lost \n  and the trap instruction will be left in the code.");
            bp = new breakpoint (addr);
        } catch (NumberFormatException e) {
            String sig = null;
            if (args.length >= 2) {
                sig = args [1];
            }
            try {
                bp = user.bmap.findBreakpoint (args [0], sig, user.reg.hardwareIP ());
            } catch (BmapMultipleException e1) {
                jdp_console.writeOutput (e1.getMessage ());
            } catch (BmapNotFoundException e2) {
                jdp_console.writeOutput (e2.getMessage ());
            }
        }
        if (bp != null) {
            user.bpset.setBreakpoint (bp);
            jdp_console.writeOutput ("breakpoint at: " + bp.toString (user.bmap));
        }
    }
    else {
        jdp_console.writeOutput (user.bpset.list ());
        Platform.printbp ();
    }
}


-----Function Pair=110=-----==

private static void compressZip (String source, String dest) throws Exception {
    File baseFolder = new File (source);
    if (baseFolder.exists ()) {
        if (baseFolder.isDirectory ()) {
            List < File > fileList = getSubFiles (new File (source));
            ZipOutputStream zos = new ZipOutputStream (new FileOutputStream (dest));
            zos.setEncoding ("GBK");
            ZipEntry entry = null;
            byte [] buf = new byte [2048];
            int readLen = 0;
            for (int i = 0; i < fileList.size (); i ++) {
                File file = fileList.get (i);
                if (file.isDirectory ()) {
                    entry = new ZipEntry (getAbsFileName (source, file) + "/");
                }
                else {
                    entry = new ZipEntry (getAbsFileName (source, file));
                }
                entry.setSize (file.length ());
                entry.setTime (file.lastModified ());
                zos.putNextEntry (entry);
                if (file.isFile ()) {
                    InputStream in = new BufferedInputStream (new FileInputStream (file));
                    while ((readLen = in.read (buf, 0, 1024)) != - 1) {
                        zos.write (buf, 0, readLen);
                    }
                    in.close ();
                }
            }
            zos.close ();
        }
        else {
            throw new Exception ("Can not do this operation!.");
        }
    }
    else {
        baseFolder.mkdirs ();
        compressZip (source, dest);
    }
}


private final void listRecursiveFileDirMark (String sleg, ArkFsLegacy legacy, NbFilesAndOutputFiles nfof, File dirsource, long refTime) throws IOException {
    if (dirsource == null) {
        logger.warn ("directory null");
        return;
    }
    if (! dirsource.exists ()) {
        logger.debug ("directory not exist");
        return;
    }
    String shash = null;
    if (dirsource.isDirectory ()) {
        File [] list = dirsource.listFiles ();
        if ((list == null) || (list.length == 0)) {
            list = null;
            return;
        }
        int len = list.length;
        for (int i = 0; i < len; i ++) {
            if (list [i].isDirectory ()) {
                listRecursiveFileDirMark (sleg, legacy, nfof, list [i], refTime);
            }
            else {
                if (list [i].getName ().endsWith (ArkDirConstants.METAEXT)) {
                    continue;
                }
                if (refTime == 0 || list [i].lastModified () > refTime) {
                    long [] sublist;
                    try {
                        sublist = pathToIdUnique (list [i].getAbsolutePath ());
                    } catch (ArUnvalidIndexException e) {
                        continue;
                    }
                    if ((sublist != null) && (sublist.length >= 2)) {
                        nfof.checkOutputAddFile ();
                        shash = computeStringMark (legacy, list [i]);
                        if (shash == null) {
                            logger.debug ("noMark for " + sublist [sublist.length - 1] + ' ' + sublist [sublist.length - 2]);
                            continue;
                        }
                        int length = sublist.length;
                        nfof.writeCheckFilesMark (sleg, Long.toString (sublist [length - 2]), Long.toString (sublist [length - 1]), shash, null);
                    }
                    sublist = null;
                }
            }
        }
        list = null;
    }
    else if (refTime == 0 || dirsource.lastModified () > refTime) {
        if (dirsource.getName ().endsWith (ArkDirConstants.METAEXT)) {
            return;
        }
        long [] sublist;
        try {
            sublist = pathToIdUnique (dirsource.getAbsolutePath ());
        } catch (ArUnvalidIndexException e) {
            sublist = null;
        }
        if ((sublist != null) && (sublist.length >= 2)) {
            nfof.checkOutputAddFile ();
            shash = computeStringMark (legacy, dirsource);
            if (shash == null) {
                logger.debug ("noMark for " + sublist [sublist.length - 1] + ' ' + sublist [sublist.length - 2]);
            }
            else {
                int length = sublist.length;
                nfof.writeCheckFilesMark (sleg, Long.toString (sublist [length - 2]), Long.toString (sublist [length - 1]), shash, null);
            }
        }
        sublist = null;
    }
}


-----Function Pair=111=-----==

protected Object createInstance (String locator) throws AxisException {
    Service locatorInstance;
    Iterator < ? > itr;
    Class < ? > clazz;
    Object instance;
    QName serviceName;
    int n;
    serviceName = null;
    instance = null;
    try {
        if ((n = locator.indexOf ('.')) > 0) {
            SicariSecurityManager.addTrusted (new WildcardedCharSequence (locator.substring (0, n) + ".*"));
        }
        else {
            log2_.warning ("Failed registering default package/class '" + locator + "' with " + SicariSecurityManager.class.getName ());
        }
        clazz = Class.forName (locator, true, new URLClassLoader (new URL [] {tmpdir_.toURL ()}));
        log2_.debug ("Successfully created service locator class '" + locator + "'");
        locatorInstance = (Service) clazz.newInstance ();
        log2_.debug ("Successfully created service locator instance '" + locator + "'");
        itr = locatorInstance.getPorts ();
        if (itr.hasNext ()) {
            serviceName = (QName) itr.next ();
            log2_.debug ("Retrieved port '" + serviceName.getLocalPart () + "' from service locator");
            instance = locatorInstance.getPort (serviceName, null);
            log2_.debug ("Successfully created '" + serviceName.getLocalPart () + "' client stub instance " + instance);
        }
    } catch (Exception e) {
        String msg = "Failed creating '" + serviceName + "' client stub instance from '" + locator + "'";
        log2_.caught (LogLevel.ERROR, msg, e);
        throw new AxisException (msg, e);
    }
    return instance;
}


public ArrayList < Mod > afterSort (ArrayList < Mod > list) {
    Enumeration e = Collections.enumeration (list);
    while (e.hasMoreElements ()) {
        Mod m = (Mod) e.nextElement ();
        if (after.containsKey (m)) {
            Iterator it = after.get (m).entrySet ().iterator ();
            while (it.hasNext ()) {
                Map.Entry entry = (Map.Entry) it.next ();
                Mod mod = ManagerOptions.getInstance ().getMod ((String) entry.getKey (), (String) entry.getValue ());
                if (mod != null && mod.isEnabled ()) {
                    if (list.indexOf (mod) >= list.indexOf (m)) {
                        int j = list.indexOf (mod);
                        int x = list.indexOf (m);
                        list.set (j, m);
                        list.set (x, mod);
                    }
                }
            }
        }
    }
    return list;
}


-----Function Pair=112=-----==

private byte [] updateDeleteAfter (HTTPurl urlData) throws Exception {
    int deleteAfter = 0;
    try {
        deleteAfter = Integer.parseInt (urlData.getParameter ("deleteafter"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.time", new Integer (deleteAfter).toString ());
    int deleteAction = 0;
    try {
        deleteAction = Integer.parseInt (urlData.getParameter ("deleteaction"));
    } catch (Exception e) {
    }
    store.setServerProperty ("sch.autodel.action", new Integer (deleteAction).toString ());
    System.out.println ("Action After : " + deleteAfter);
    System.out.println ("Action : " + deleteAction);
    String redirect = "HTTP/1.0 302 Moved Temporarily\n";
    redirect += "Location: /servlet/ScheduleDataRes\n\n";
    return redirect.getBytes ();
}


private static boolean copyStream (final InputStream is, final OutputStream os) {
    try {
        final byte [] buf = new byte [1024];
        int len = 0;
        while ((len = is.read (buf)) > 0) {
            os.write (buf, 0, len);
        }
        is.close ();
        os.close ();
        return true;
    } catch (final IOException e) {
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=113=-----==

public static boolean isBinary (File theSource) {
    boolean binary = false;
    if (theSource.exists () && theSource.canRead ()) {
        int size = (int) Math.min (BIG_BUFFER_SIZE, theSource.length ());
        byte [] bytes = new byte [size];
        try {
            FileInputStream in = new FileInputStream (theSource);
            while (in.read (bytes, 0, size) > 0) {
                for (byte data : bytes) {
                    if ((data <= 0) || (data > 127)) {
                        binary = true;
                        break;
                    }
                }
            }
            in.close ();
        } catch (Exception e) {
            Log.main.println ("IO.isBinary()", e);
        }
    }
    return binary;
}


ClientGroup removeSessionsFromGroup (int port) {
    Iterator < String > iter = clients.keySet ().iterator ();
    Map < String, DummyClient > removedClients = new HashMap < String, DummyClient > ();
    while (iter.hasNext ()) {
        String user = iter.next ();
        DummyClient client = clients.get (user);
        int redirectPort = client.getRedirectPort ();
        if ((redirectPort != 0 && port == redirectPort) || (redirectPort == 0 && port == client.getConnectPort ())) {
            iter.remove ();
            removedClients.put (user, client);
            client.disconnect ();
        }
    }
    return new ClientGroup (removedClients);
}


-----Function Pair=114=-----==

public static File getUniqueFile (File file) {
    String parent = file.getParent ();
    String name = file.getName ();
    String baseName = FilenameUtils.getBaseName (name);
    String extension = FilenameUtils.getExtension (name);
    File uniqueFile = file;
    int i = 1;
    while (uniqueFile.exists ()) {
        StringBuilder sb = new StringBuilder ();
        if (parent != null) {
            sb.append (parent).append (File.separator);
        }
        sb.append (baseName).append ('(').append (i ++).append (')');
        if (! StringUtils.isEmpty (extension)) {
            sb.append ('.').append (extension);
        }
        uniqueFile = new File (sb.toString ());
    }
    return uniqueFile;
}


public void paintLoopPointer (Graphics2D g2d, Rectangle rect, Color color) {
    int y0 = (int) rect.getX ();
    int y1 = (int) (rect.getX () + rect.getHeight ());
    int h = 5;
    g2d.setClip (rect);
    g2d.setStroke (new BasicStroke ());
    g2d.setComposite (AlphaComposite.getInstance (AlphaComposite.SRC_OVER, 1f));
    g2d.setColor (color);
    xLoopStartPointer = audio.getClip ().getSelectedLayer ().getChannel (0).getPlotter ().sampleToGraphX (audio.getLoopStartPointer ());
    g2d.drawLine (xLoopStartPointer, y0, xLoopStartPointer, y1);
    xLoopEndPointer = audio.getClip ().getSelectedLayer ().getChannel (0).getPlotter ().sampleToGraphX (audio.getLoopEndPointer ());
    g2d.drawLine (xLoopEndPointer, y0, xLoopEndPointer, y1);
    g2d.setComposite (AlphaComposite.getInstance (AlphaComposite.SRC_OVER, 0.5f));
    g2d.fillRect (xLoopStartPointer, y1 - h, xLoopEndPointer - xLoopStartPointer, h);
}


-----Function Pair=115=-----==

public static BackgroundEngine getInstance (File store) {
    try {
        if (instance == null) {
            instance = new BackgroundEngine (store);
            instance.setPriority (1);
            instance.start ();
            return instance;
        }
        else {
            return instance;
        }
    } catch (Exception ex) {
        _logger.error ("", ex);
        return null;
    }
}


protected void getAdditionalFileData () {
    if (this.getToolTipText ().equals ("")) {
        if (this.isFloppyDrive) {
            this.fileSize = 0;
            this.lastModification = 0;
        }
        else {
            this.fileSize = this.file.length ();
            this.lastModification = this.file.lastModified ();
        }
        if (new File (this.file.getAbsolutePath ()).exists ()) {
            this.setToolTipText ("<html><body>" + "<strong>" + this.fileName + "</strong><br>" + "Last modified : " + java.text.DateFormat.getDateInstance ().format (new java.util.Date (this.lastModification)) + "<br>" + (this.isDirectory ? "" : "File size : " + convertToCorrectFormat (this.fileSize) + "<br>") + "File Description : " + this.fileType + "<br>" + this.file.getPath () + "</body></html>");
        }
        else {
            this.setToolTipText ("<html><body>" + "<strong>" + this.fileName + "</strong>" + "</body></html>");
        }
    }
}


-----Function Pair=116=-----==

protected Dialog onCreateDialog (int id) {
    switch (id) {
        case DIALOG_NO_SDCARD :
            return new AlertDialog.Builder (this).setTitle (R.string.sdcard_is_not_present_dialog_title).setMessage (R.string.sdcard_is_not_present_dialog_body).setPositiveButton (R.string.sdcard_is_not_present_dialog_ok_button, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    dialog.dismiss ();
                }
            }
            ).create ();
        case DIALOG_OVERWRITE_UPDATE :
            return new AlertDialog.Builder (this).setTitle (R.string.overwrite_update_title).setMessage (R.string.overwrite_update_summary).setNegativeButton (R.string.overwrite_update_negative, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    dialog.dismiss ();
                }
            }
            ).setPositiveButton (R.string.overwrite_update_positive, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    foo.delete ();
                    if (showDebugOutput) Log.d (TAG, "Start downlading update: " + updateForDownload.getFileName ());
                    downloadRequestedUpdate (updateForDownload);
                }
            }
            ).create ();
        case DIALOG_DELETE_EXISTING :
            return new AlertDialog.Builder (this).setTitle (R.string.delete_updates_text).setMessage (R.string.confirm_delete_update_folder_dialog_message).setNeutralButton (R.string.confirm_delete_update_folder_dialog_neutral, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    String f = (String) mExistingUpdatesSpinner.getSelectedItem ();
                    if (showDebugOutput) Log.d (TAG, "Delete single Update selected: " + f);
                    deleteUpdate (f);
                    updateLayout ();
                }
            }
            ).setPositiveButton (R.string.confirm_delete_update_folder_dialog_yes, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    if (showDebugOutput) Log.d (TAG, "Delete all Updates selected");
                    deleteOldUpdates ();
                    updateLayout ();
                }
            }
            ).setNegativeButton (R.string.confirm_delete_update_folder_dialog_no, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    if (showDebugOutput) Log.d (TAG, "Delete no updates selected");
                    dialog.dismiss ();
                }
            }
            ).create ();
        case DIALOG_RUNNING_OLD_VERSION :
            return new AlertDialog.Builder (MainActivity.this).setTitle (R.string.alert_old_version_title).setMessage (R.string.alert_old_version_summary).setPositiveButton (R.string.alert_old_version_ok, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    dialog.dismiss ();
                }
            }
            ).setNegativeButton (R.string.alert_old_version_browser, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    Intent i = new Intent (Intent.ACTION_VIEW);
                    i.setData (Uri.parse (Customization.UPDATE_INSTRUCTIONS_URL));
                    startActivity (i);
                    dialog.dismiss ();
                }
            }
            ).create ();
        case DIALOG_NO_MD5 :
            return new AlertDialog.Builder (MainActivity.this).setTitle (R.string.no_md5_found_title).setMessage (R.string.no_md5_found_summary).setPositiveButton (R.string.no_md5_found_positive, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    new MD5CheckerTask (getApplicationContext (), null, existingUpdateFilename, showDebugOutput).onPostExecute (true);
                    dialog.dismiss ();
                }
            }
            ).setNegativeButton (R.string.no_md5_found_negative, new DialogInterface.OnClickListener () {
                public void onClick (DialogInterface dialog, int which) {
                    dialog.dismiss ();
                }
            }
            ).create ();
        case DIALOG_ABOUT :
            Dialog dialog = new Dialog (this);
            dialog.setTitle (R.string.about_dialog_title);
            dialog.setContentView (R.layout.about);
            TextView mVersionName = (TextView) dialog.findViewById (R.id.version_name_about_text_view);
            try {
                PackageInfo pi = getPackageManager ().getPackageInfo (getPackageName (), 0);
                mVersionName.setText ("v " + pi.versionName);
            } catch (NameNotFoundException e) {
                Log.e (TAG, "Can't find version name", e);
                mVersionName.setText ("v unknown");
            }
            return dialog;
        default :
            return null;
    }
}


public void find (File src, Integer deep) throws IOException {
    if (src.isDirectory ()) {
        File [] files = src.listFiles ();
        for (File file : files) {
            if (deep == 1) {
                subSrc = file.getAbsolutePath ();
            }
            if (file.isDirectory ()) {
                find (file, ++ deep);
                if (file.delete ()) {
                    System.out.println ("刪除成功！");
                }
                deep --;
            }
            else {
                if (deep == 2) {
                    file.renameTo (new File (file.getParent () + "\\" + generateName (++ index)));
                }
                if (deep > 2) {
                    String dest = subSrc + "\\" + generateName (++ index);
                    this.copy (file.getAbsolutePath (), dest);
                    if (file.delete ()) {
                        System.out.println ("刪除成功！");
                    }
                }
            }
        }
    }
    else {
        System.err.println ("根文件路徑有誤！");
    }
}


-----Function Pair=117=-----==

public ArrayList zoekWoordfrequentiestring (String woordfrequentiestring, ArrayList verdachtebronnen) {
    ArrayList result = new ArrayList ();
    ArrayList bronnen = new ArrayList ();
    ArrayList percentages = new ArrayList ();
    float totalematching = 0;
    try {
        IndexSearcher indexSearcher = new IndexSearcher (Settings.getIndexdir ());
        Analyzer analyzer = new StandardAnalyzer ();
        if (verdachtebronnen == null || verdachtebronnen.size () == 0) {
            QueryParser qparser = new QueryParser ("validforsimilaritymeasurecomparison", analyzer);
            String inhoudQuery = "validforsimilaritymeasurecomparison:\"" + "yes" + "\"";
            Query query = qparser.parse (inhoudQuery);
            Hits hits = indexSearcher.search (query);
            String [] bronnen_woordfrequentiestring = new String [hits.length ()];
            String [] bronnen_paden = new String [hits.length ()];
            AbstractStringMetric metric = new Levenshtein ();
            float [] matchingwaarden;
            for (int i = 0; i < hits.length (); i ++) {
                bronnen_woordfrequentiestring [i] = hits.doc (i).get ("woordfrequentiestring");
                bronnen_paden [i] = hits.doc (i).get ("path");
            }
            matchingwaarden = metric.batchCompareSet (bronnen_woordfrequentiestring, woordfrequentiestring);
            float matchingpercentage_i;
            for (int i = 0; i < matchingwaarden.length; i ++) {
                matchingpercentage_i = matchingwaarden [i] * 100;
                if (matchingpercentage_i > Settings.getMINIMUM_MATCHING_PERCENTAGE_TO_SHOW_UP_IN_RESULTS ()) {
                    percentages.add (matchingpercentage_i);
                    bronnen.add (bronnen_paden [i]);
                }
            }
            totalematching = maximumVanRij (matchingwaarden) * 100;
        }
        else {
        }
        indexSearcher.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    }
    result = getGesorteerdeVersieVanBronnenEnPercentages (bronnen, percentages);
    result.add (totalematching);
    return result;
}


private byte [] updateTask (HTTPurl urlData, HashMap headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("task_name");
    TaskCommand task = (TaskCommand) tasks.get (name);
    if (task != null) {
        String command = urlData.getParameter ("command");
        String autoRem = urlData.getParameter ("autoRemove");
        String delay = urlData.getParameter ("delay");
        String concurrentTasks = urlData.getParameter ("concurrentTasks");
        String timeToNextSchedule = urlData.getParameter ("timeToNextSchedule");
        String whenNotCapturing = urlData.getParameter ("whenNotCapturing");
        Boolean notCap = new Boolean (false);
        if ("true".equalsIgnoreCase (whenNotCapturing)) {
            notCap = new Boolean (true);
        }
        task.setWhenNotCapturing (notCap.booleanValue ());
        int timeToNext = 0;
        try {
            timeToNext = Integer.parseInt (timeToNextSchedule);
        } catch (Exception e) {
        }
        task.setTimeToNextSchedule (timeToNext);
        int conTasks = 0;
        try {
            conTasks = Integer.parseInt (concurrentTasks);
        } catch (Exception e) {
        }
        task.setConcurrent (conTasks);
        Boolean autoRemove = new Boolean (false);
        if ("true".equalsIgnoreCase (autoRem)) {
            autoRemove = new Boolean (true);
        }
        task.setAutoRemove (autoRemove.booleanValue ());
        int delayValue = 0;
        try {
            delayValue = Integer.parseInt (delay);
        } catch (Exception e) {
        }
        task.setDelay (delayValue);
        task.setCommand (command.trim ());
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


-----Function Pair=118=-----==

private static void convertSVG (File inputFile, File outputFile) {
    InputStream input;
    OutputStream output;
    String svg = "svg";
    try {
        input = new GZIPInputStream (new BufferedInputStream (new FileInputStream (inputFile)));
        output = new GZIPOutputStream (new BufferedOutputStream (new FileOutputStream (outputFile)));
    } catch (IOException e) {
        e.printStackTrace ();
        return;
    }
    try {
        XMLInputFactory factory = XMLInputFactory.newInstance ();
        XMLEventReader parser = factory.createXMLEventReader (input);
        XMLOutputFactory outputFactory = XMLOutputFactory.newInstance ();
        XMLEventWriter outputWriter = outputFactory.createXMLEventWriter (output);
        while (parser.hasNext ()) {
            XMLEvent event = (XMLEvent) parser.next ();
            if (event.isStartElement ()) {
                StartElement start = event.asStartElement ();
                if (start.getName ().getLocalPart ().equalsIgnoreCase (svg)) {
                    Iterator < Attribute > attributes = start.getAttributes ();
                    ArrayList < Attribute > newAttributes = new ArrayList < Attribute > ();
                    boolean viewBoxSet = false;
                    while (attributes.hasNext ()) {
                        Attribute attribute = attributes.next ();
                        String name = attribute.getName ().getLocalPart ();
                        if (name.equalsIgnoreCase ("width")) {
                            String width = attribute.getValue ();
                            newAttributes.add (m_eventFactory.createAttribute (attribute.getName (), "100%"));
                        }
                        else if (name.equalsIgnoreCase ("height")) {
                            String height = attribute.getValue ();
                            newAttributes.add (m_eventFactory.createAttribute (attribute.getName (), " 100%"));
                        }
                        else if (name.equalsIgnoreCase ("viewBox")) {
                            viewBoxSet = true;
                            newAttributes.add (attribute);
                        }
                        else newAttributes.add (attribute);
                    }
                    if (! viewBoxSet) {
                        newAttributes.add (m_eventFactory.createAttribute ("viewBox", "0 0 100 100"));
                    }
                    StartElement newStart = m_eventFactory.createStartElement (start.getName (), newAttributes.iterator (), start.getNamespaces ());
                    outputWriter.add (newStart);
                }
                else {
                    outputWriter.add (event);
                }
            }
            else {
                outputWriter.add (event);
            }
        }
        outputWriter.flush ();
        output.flush ();
        output.close ();
        outputWriter.close ();
        parser.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    System.out.println ("Done");
}


private void createFile (String filename, int position, String content, Hashtable properties) {
    String vfsFileName = (String) m_fileIndex.get (filename.replace ('\\', '/'));
    if (vfsFileName != null) {
        try {
            m_report.print (Messages.get ().container (Messages.RPT_CREATE_FILE_0), I_CmsReport.FORMAT_NOTE);
            m_report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_ARGUMENT_1, vfsFileName));
            m_report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
            if ((properties.get (CmsPropertyDefinition.PROPERTY_NAVPOS) == null) && (properties.get (CmsPropertyDefinition.PROPERTY_NAVTEXT) != null)) {
                properties.put (CmsPropertyDefinition.PROPERTY_NAVPOS, (position + 1) + "");
            }
            Locale locale = new Locale (m_locale);
            CmsXmlPage page = new CmsXmlPage (locale, OpenCms.getSystemInfo ().getDefaultEncoding ());
            page.addValue (m_element, locale);
            page.setStringValue (m_cmsObject, m_element, locale, content);
            CmsLinkTable linkTable = page.getLinkTable (m_element, locale);
            Iterator i = linkTable.iterator ();
            while (i.hasNext ()) {
                CmsLink link = (CmsLink) i.next ();
                String target = link.getTarget ();
                if (link.isInternal ()) {
                    target = m_cmsObject.getRequestContext ().getFileTranslator ().translateResource (target);
                    link.updateLink (target, link.getAnchor (), link.getQuery ());
                    link.checkConsistency (m_cmsObject);
                }
            }
            byte [] contentByteArray = page.marshal ();
            List oldProperties = new ArrayList ();
            if (! m_overwrite) {
                m_cmsObject.createResource (vfsFileName, CmsResourceTypeXmlPage.getStaticTypeId (), contentByteArray, new ArrayList ());
            }
            else {
                try {
                    oldProperties = m_cmsObject.readPropertyObjects (vfsFileName, false);
                    CmsLock lock = m_cmsObject.getLock (vfsFileName);
                    if (lock.getType () != CmsLockType.EXCLUSIVE) {
                        m_cmsObject.lockResource (vfsFileName);
                    }
                    m_cmsObject.deleteResource (vfsFileName, CmsResource.DELETE_PRESERVE_SIBLINGS);
                } catch (CmsException e) {
                } finally {
                    m_report.print (Messages.get ().container (Messages.RPT_OVERWRITE_0), I_CmsReport.FORMAT_NOTE);
                    m_report.print (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_DOTS_0));
                    m_cmsObject.createResource (vfsFileName, CmsResourceTypeXmlPage.getStaticTypeId (), contentByteArray, new ArrayList ());
                }
            }
            Iterator it = properties.entrySet ().iterator ();
            List propertyList = new ArrayList ();
            while (it.hasNext ()) {
                Map.Entry entry = (Map.Entry) it.next ();
                String propertyKey = (String) entry.getKey ();
                String propertyVal = (String) entry.getValue ();
                CmsProperty property = new CmsProperty (propertyKey, propertyVal, propertyVal);
                property.setAutoCreatePropertyDefinition (true);
                propertyList.add (property);
            }
            try {
                m_cmsObject.writePropertyObjects (vfsFileName, propertyList);
                m_cmsObject.writePropertyObjects (vfsFileName, oldProperties);
            } catch (CmsException e1) {
                e1.printStackTrace ();
            }
            m_report.println (org.opencms.report.Messages.get ().container (org.opencms.report.Messages.RPT_OK_0), I_CmsReport.FORMAT_OK);
        } catch (CmsException e) {
            m_report.println (e);
            LOG.error (e.getLocalizedMessage (), e);
        }
    }
}


-----Function Pair=119=-----==

public static Properties readProperties (File propsFile, Properties props) {
    Properties p = props == null ? new Properties () : props;
    if (propsFile != null && propsFile.canRead ()) {
        FileInputStream fileStream = null;
        try {
            fileStream = new FileInputStream (propsFile);
            p.load (fileStream);
        } catch (IOException e) {
            e.printStackTrace ();
        } finally {
            FileUtil.safeClose (fileStream);
        }
    }
    return p;
}


public Message [] getMessages (int [] msgs) throws MessagingException {
    if (! isOpen ()) {
        throw new IllegalStateException ("folder closed");
    }
    if (! exists ()) {
        throw new FolderNotFoundException (this);
    }
    if (isdefault) {
        throw new MessagingException ("no messages under root folder allowed");
    }
    final ArrayList outmsgs = new ArrayList (msgs.length);
    for (int i = 0; i < msgs.length; i ++) {
        if (messages.size () < msgs [i] || (msgs [i] <= 0)) {
            throw new IndexOutOfBoundsException ("message " + msgs [i] + " not available");
        }
        final MaildirMessage mdm = (MaildirMessage) messages.get (msgs [i] - 1);
        outmsgs.add (mdm);
    }
    return (Message []) outmsgs.toArray (emptyMessageArray);
}


-----Function Pair=120=-----==

void writeIndex (Collection < Example > examples) throws IOException {
    Map < String, Set < Example > > index = new TreeMap < String, Set < Example > > ();
    Set < String > initials = new HashSet < String > ();
    for (Example e : examples) {
        for (String k : e.getDeclaredKeys ()) {
            Set < Example > s = index.get (k);
            if (s == null) index.put (k, s = new TreeSet < Example > ());
            s.add (e);
        }
        initials.add (e.getName ().substring (0, 1).toUpperCase ());
    }
    if (INDEX_HEADER != null) {
        html.startTag (INDEX_HEADER);
        html.write ("Index");
        html.endTag (INDEX_HEADER);
    }
    html.startTag (HTMLWriter.P);
    html.writeLine ("Examples: ");
    for (char initial = 'A'; initial <= 'Z'; initial ++) {
        String s = String.valueOf (initial);
        if (initials.contains (s)) {
            html.writeLink ("#" + s, s);
        }
        else {
            html.write (s);
        }
        html.newLine ();
    }
    html.endTag (HTMLWriter.P);
    html.startTag (HTMLWriter.TABLE);
    html.writeAttr (HTMLWriter.CLASS, "index");
    html.newLine ();
    int row = 0;
    for (Map.Entry < String, Set < Example > > entry : index.entrySet ()) {
        html.startTag (HTMLWriter.TR);
        html.writeAttr (HTMLWriter.CLASS, (row ++ % 2 == 0 ? "even" : "odd"));
        html.startTag (HTMLWriter.TD);
        html.writeAttr ("valign", "top");
        html.write (entry.getKey ());
        html.endTag (HTMLWriter.TD);
        html.newLine ();
        html.startTag (HTMLWriter.TD);
        html.writeAttr (HTMLWriter.ALIGN, "top");
        String sep = "";
        for (Example e : entry.getValue ()) {
            html.write (sep);
            html.writeLink ('#' + e.getName (), e.getName ());
            sep = ", ";
        }
        html.endTag (HTMLWriter.TD);
        html.endTag (HTMLWriter.TR);
        html.newLine ();
    }
    html.endTag (HTMLWriter.TABLE);
}


private boolean doTemplateFiles (File webappPath) {
    try {
        InputStreamReader isr = new InputStreamReader (getClass ().getResourceAsStream ("templatefiles" + ".txt"));
        LineNumberReader lnttfs = new LineNumberReader (isr);
        String templateFileName;
        while ((templateFileName = lnttfs.readLine ()) != null) {
            if (templateFileName.trim ().length () > 0) {
                File templateFile = new File (webappPath, templateFileName.trim () + ".template");
                if (templateFile.exists ()) {
                    File outFile = new File (webappPath, templateFileName.trim ());
                    if (DEBUG) {
                        System.out.println ("template filename = \"" + outFile.getCanonicalPath () + "\"");
                    }
                    LineNumberReader lnr = new LineNumberReader (new FileReader (templateFile));
                    PrintWriter pw = new PrintWriter (new FileWriter (outFile));
                    String outLine;
                    String inLine;
                    while ((inLine = lnr.readLine ()) != null) {
                        outLine = replaceTemplateVariables (inLine);
                        if (DEBUG) System.out.println ("\ninLine: " + inLine + "\noutLine: " + outLine);
                        pw.println (outLine);
                    }
                    pw.close ();
                    lnr.close ();
                }
                else {
                    System.err.println ("Expected template file, " + templateFileName.trim () + ".template, does not exist.");
                    lnttfs.close ();
                    return false;
                }
            }
        }
    } catch (IOException ioe) {
        if (DEBUG) {
            System.err.println ("I/O Error doing template files.\n" + ioe);
            ioe.printStackTrace ();
        }
        return false;
    }
    return true;
}


-----Function Pair=121=-----==

public void testMarshal2 () throws JiBXException, SAXException, IOException {
    Slot o = SlotFactory.create2 ();
    IBindingFactory bfact = BindingDirectory.getFactory (Slot.class);
    IMarshallingContext marshallingContext = bfact.createMarshallingContext ();
    Writer outConsole = new BufferedWriter (new OutputStreamWriter (System.out));
    marshallingContext.setOutput (outConsole);
    marshallingContext.setIndent (3);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
    Writer out = new BufferedWriter (new OutputStreamWriter (outputStream));
    marshallingContext.setIndent (3);
    marshallingContext.setOutput (out);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    InputSource marshallingResult = new InputSource (new ByteArrayInputStream (outputStream.toByteArray ()));
    FileInputStream fis = new FileInputStream (new File ("src/test/resources/SlotTestData2.xml"));
    InputSource expectedResult = new InputSource (fis);
    DifferenceListener differenceListener = new IgnoreTextAndAttributeValuesDifferenceListener ();
    Diff diff = new Diff (expectedResult, marshallingResult);
    diff.overrideDifferenceListener (differenceListener);
    assertTrue ("Marshalled Slot matches expected XML " + diff, diff.similar ());
}


public void testMarshal () throws JiBXException, SAXException, IOException {
    GetDomainResponse o = GetDomainResponseFactory.create ();
    IBindingFactory bfact = BindingDirectory.getFactory (GetDomainResponse.class);
    IMarshallingContext marshallingContext = bfact.createMarshallingContext ();
    Writer outConsole = new BufferedWriter (new OutputStreamWriter (System.out));
    marshallingContext.setOutput (outConsole);
    marshallingContext.setIndent (3);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
    Writer out = new BufferedWriter (new OutputStreamWriter (outputStream));
    marshallingContext.setIndent (3);
    marshallingContext.setOutput (out);
    marshallingContext.marshalDocument (o, "UTF-8", null);
    InputSource marshallingResult = new InputSource (new ByteArrayInputStream (outputStream.toByteArray ()));
    FileInputStream fis = new FileInputStream (new File ("src/test/resources/csw202-discovery/GetDomainResponseTestData.xml"));
    InputSource expectedResult = new InputSource (fis);
    DifferenceListener differenceListener = new IgnoreTextAndAttributeValuesDifferenceListener ();
    Diff diff = new Diff (expectedResult, marshallingResult);
    diff.overrideDifferenceListener (differenceListener);
    assertTrue ("Marshalled GetDomainResponse matches expected XML " + diff, diff.similar ());
}


-----Function Pair=122=-----==

public void compareTopicXmlContent (FileWriter fw) throws IOException {
    Iterator iter = this.resultPair.entrySet ().iterator ();
    while (iter.hasNext ()) {
        int count = 0;
        Map.Entry entry = (Map.Entry) iter.next ();
        String topicId = (String) entry.getKey ();
        String shot_id = (String) entry.getValue ();
        fw.append (topicId + ' ');
        HashSet < String > words = this.queryWords.get (topicId);
        String xmlcontent = this.xmlContent.get (shot_id);
        if (xmlcontent == null) {
            fw.append ("null file" + '\n');
            continue;
        }
        xmlcontent = xmlcontent.toLowerCase ();
        Iterator it = words.iterator ();
        int termcount = 0;
        while (it.hasNext ()) {
            String queryTerm = (String) it.next ();
            queryTerm = queryTerm.toLowerCase ();
            Pattern pattern = Pattern.compile (' ' + queryTerm + ' ');
            if (queryTerm.length () == 0) {
                System.out.println ("query term is null" + queryTerm);
                continue;
            }
            System.out.println (xmlcontent);
            Matcher matcher = pattern.matcher (xmlcontent);
            while (matcher.find ()) termcount ++;
            fw.append (queryTerm + " ");
            fw.append (termcount + " ");
            count += termcount;
            termcount = 0;
        }
        fw.append (count + " ");
        fw.append ('\n');
        fw.flush ();
    }
}


public Vector getDataFromURL (String loadURL) throws Exception {
    Vector < byte [] > resultData = new Vector < byte [] > ();
    System.out.println ("Loading XMLTV data from URL : " + loadURL);
    Vector < byte [] > data = new Vector < byte [] > ();
    getContentUsingThread (new URL (loadURL), data);
    String pageData = "";
    if (data.size () == 1) {
        pageData = new String ((byte []) data.get (0));
    }
    if (pageData.length () > 0 && pageData.indexOf ("<XMLTV_FILE_LIST>") > - 1) {
        System.out.println ("Loading XMLTV data from file list");
        String [] fileList = extractNames (pageData);
        int lastIndex = loadURL.lastIndexOf ("/");
        if (lastIndex > - 1) {
            String baseUrl = loadURL.substring (0, lastIndex + 1);
            for (int x = 0; x < fileList.length; x ++) {
                String dataURL = baseUrl + fileList [x];
                System.out.println ("Loading XMLTV data from URL : " + dataURL);
                Vector < byte [] > pages = new Vector < byte [] > ();
                int result = getContentUsingThread (new URL (dataURL), pages);
                if (result == 200) {
                    for (int y = 0; y < pages.size (); y ++) {
                        byte [] pd = (byte []) pages.get (y);
                        if (pd.length > 0) resultData.add (pd);
                    }
                }
            }
        }
    }
    else if (data.size () > 0) {
        for (int y = 0; y < data.size (); y ++) {
            byte [] pd = (byte []) data.get (y);
            if (pd.length > 0) resultData.add (pd);
        }
    }
    return resultData;
}


-----Function Pair=123=-----==

public static BoundPropertyRenderer createRendererFor (BoundProperty prop) {
    if (prop == null) {
        log.error ("Property shouldn't be null!");
        return null;
    }
    if (prop.getParamType () == null) {
        log.error ("Param type for property " + prop.getName () + " shouldn't be null!");
        return null;
    }
    Class < ? > prClass = null;
    if (Collection.class.isAssignableFrom (prop.getParamType ())) {
        Type collType = prop.getGetter ().getGenericReturnType ();
        Type [] elemTypes = ((ParameterizedType) collType).getActualTypeArguments ();
        if (elemTypes.length == 1) {
            prClass = getRenderer (elemTypes [0], true);
        }
        else {
            log.warn ("Collection property: " + prop.getParamType ().getName () + " should have exactly one type parameter. Creating default renderer.");
        }
    }
    else {
        prClass = getRenderer (prop.getParamType ());
    }
    if (prClass == null) {
        log.warn ("Renderer for property: " + prop.getParamType ().getName () + " does not exist. Creating default renderer.");
        return new DefaultRenderer (prop);
    }
    return createRenderer (prop, prClass);
}


private void addContextSpecifiedConfig (List < FacesConfig > appConfigResources) throws IOException, SAXException {
    for (String systemId : getConfigFilesList ()) {
        if (MyfacesConfig.getCurrentInstance (_externalContext).isValidateXML ()) {
            URL url = _externalContext.getResource (systemId);
            if (url != null) {
                validateFacesConfig (url);
            }
        }
        InputStream stream = _externalContext.getResourceAsStream (systemId);
        if (stream == null) {
            log.severe ("Faces config resource " + systemId + " not found");
            continue;
        }
        if (log.isLoggable (Level.INFO)) {
            log.info ("Reading config " + systemId);
        }
        appConfigResources.add (getUnmarshaller ().getFacesConfig (stream, systemId));
        stream.close ();
    }
}


-----Function Pair=124=-----==

public FtpReply canLogin (BaseFtpConnection baseconn, User user) {
    int count = getConfig ().getMaxUsersTotal ();
    if (user.isExempt ()) count = Math.max (count, count + getConfig ().getMaxUsersExempt ());
    int userCount = 0;
    int ipCount = 0;
    if (_conns.size () > count) return new FtpReply (550, "The site is full, try again later.");
    synchronized (_conns) {
        for (Iterator iter = _conns.iterator (); iter.hasNext ();) {
            BaseFtpConnection tempConnection = (BaseFtpConnection) iter.next ();
            try {
                User tempUser = tempConnection.getUser ();
                if (tempUser.getUsername ().equals (user.getUsername ())) {
                    userCount ++;
                    if (tempConnection.getClientAddress ().equals (baseconn.getClientAddress ())) {
                        ipCount ++;
                    }
                }
            } catch (NoSuchUserException ex) {
            }
        }
    }
    if (user.getMaxLoginsPerIP () > 0 && ipCount > user.getMaxLoginsPerIP ()) return new FtpReply (530, "Sorry, your maximum number of connections from this IP (" + user.getMaxLoginsPerIP () + ") has been reached.");
    if (user.getMaxLogins () > 0 && userCount > user.getMaxLogins ()) return new FtpReply (530, "Sorry, your account is restricted to " + user.getMaxLogins () + " simultaneous logins.");
    if (! baseconn.isSecure () && getConfig ().checkUserRejectInsecure (user)) {
        return new FtpReply (530, "USE SECURE CONNECTION");
    }
    else if (baseconn.isSecure () && getConfig ().checkUserRejectSecure (user)) {
        return new FtpReply (530, "USE INSECURE CONNECTION");
    }
    return null;
}


private void removeSingleLocation (Collection < ? extends FreelordsEntity > entities) {
    List < FreelordsEntity > removed = new ArrayList < FreelordsEntity > ();
    Point sharedLocation = getSharedLocation (entities);
    for (FreelordsEntity id : entities) {
        removed.add (entityMap.remove (id.getId ()));
        entityLocated.remove (id);
    }
    TileSelectionDefault ts = getTileSelection (sharedLocation, false);
    ts.remove (entities);
    if (ts.isEmpty ()) {
        tileSelections.remove (ts);
        pointToSelection.remove (ts.getPoint ());
        for (StackListener sl : stackListeners) {
            sl.stackRemoved (ts);
        }
    }
    for (FreelordsEntity rem : removed) {
        for (EntityListener ecl : entityListeners) {
            ecl.entityRemoved (this, rem);
        }
    }
}


-----Function Pair=125=-----==

public static PZKSRenderer createRenderer (PZKSGraph graph) {
    PZKSRenderer renderer = null;
    String className = System.getProperty ("renderer");
    Class < ? > clazz = null;
    try {
        clazz = Class.forName (className);
        Constructor < ? > constructor = clazz.getConstructor (PZKSGraph.class);
        renderer = (PZKSRenderer) constructor.newInstance (graph);
    } catch (Exception e) {
        System.out.println ("Error during creating renderer " + className + ". Default renderer will be used");
        System.out.println (e.getMessage ());
        renderer = new PZKSLamaoRenderer (graph);
    }
    return renderer;
}


public List < Field > allDeclaredFieldsByReflection (final Class classForField) {
    Field [] fields;
    Class currentClass = classForField;
    final List < Field > list = new LinkedList < Field > ();
    while (currentClass != null && ! Enum.class.equals (currentClass)) {
        fields = currentClass.getDeclaredFields ();
        for (Field field : fields) {
            if (toPersist (field)) {
                list.add (field);
            }
            else if (_log.isDebugEnabled ()) {
                _log.debug ("not persisted => not writed " + field.getName ());
            }
        }
        currentClass = currentClass.getSuperclass ();
    }
    return list;
}


-----Function Pair=126=-----==

private void showHelp (String help) {
    java.net.URL helpFile = ClassLoader.getSystemResource ("html/" + help + ".htm");
    if (helpFile == null) {
        JOptionPane.showMessageDialog (null, "Help file for " + help + " could not be found", "Error", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    try {
        setCursor (java.awt.Cursor.getPredefinedCursor (java.awt.Cursor.WAIT_CURSOR));
        JEditorPane helpPanel = new JEditorPane (helpFile);
        helpPanel.setEditable (false);
        JScrollPane sp = new JScrollPane (helpPanel);
        JFrame helpFrame = new JFrame ("Help on " + help);
        helpFrame.getContentPane ().add (sp);
        helpFrame.pack ();
        helpFrame.setVisible (true);
    } catch (IOException e) {
    }
}


public < T extends Element > Set < T > getElementSet (ElementKey < ?, T > key) {
    ImmutableSet.Builder < T > builder = ImmutableSet.builder ();
    Object obj = getElementObject (key);
    if (obj != null) {
        try {
            if (obj instanceof Element) {
                T adapted = adapt (key, (Element) obj);
                builder.add (adapted);
            }
            else {
                for (Object o : (Collection < ? >) obj) {
                    Element e = (Element) o;
                    builder.add (adapt (key, (Element) o));
                }
            }
        } catch (ContentCreationException e) {
            throw new IllegalArgumentException ("Unable to adapt to " + key.getElementType (), e);
        }
    }
    return builder.build ();
}


-----Function Pair=127=-----==

public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


public static void main (String [] argv) {
    try {
        int num = 1;
        if (argv.length > 0) {
            num = Integer.parseInt (argv [0]);
        }
        Thread [] threadList = new Thread [num];
        for (int i = 0; i < num; ++ i) {
            threadList [i] = new TestRuntimeExec (i);
            threadList [i].start ();
        }
        for (int i = 0; i < num; ++ i) threadList [i].join ();
        System.out.println ("All test threads finished");
    } catch (Exception e) {
        System.out.println ("TestRuntimeExec: FAILED");
        System.exit (1);
    }
}


-----Function Pair=128=-----==

public static void main (String args []) {
    if (! (args.length == 4 || args.length == 5 || args.length == 6)) {
        System.out.println ("\n Description: Starts the given application {jobNumber} times at different hosts in the cluster and tries to collect \n" + "              its application.message metric via Mercury's Java interface. \n" + "              - The test application is started by ssh-ing into the given host of the cluster. \n" + "              - The hosts are selected from the output of the 'linuxall' command \n");
        System.out.println (" Usage: java SubscribeTest {test-app_abs-path} {job-number} {max-message-for-a-job} {main-monitor-url} [delay] [-p]");
        System.out.println ("      (The [delay] parameter is optional; it means seconds. If not given, it defaults to 0.)");
        System.out.println ("      (The [-p] flag is optional; emulates monitoring in the portal, i.e. using the same package. Using this flag, ensure that tracefile.jar is in the classpath.)");
        System.out.println ("\n Examples:");
        System.out.println ("    1) Without delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234");
        System.out.println ("    2)    With delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234 1");
        System.out.println ("    3) Emulating portal usage: Add '-p' as the last argument. \n");
        return;
    }
    if (args.length == 4 || args.length == 5 || args.length == 6) {
        File testApp = new File (args [0]);
        if (! testApp.isFile ()) {
            System.out.println ("\nTest application: " + testApp.getAbsolutePath () + " does not exists!\n");
            return;
        }
        int jobNumber;
        try {
            jobNumber = Integer.parseInt (args [1]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'job-number' has to be number!! ( '" + args [1] + "' is not a number ) \n");
            return;
        }
        int maxMessageForAJob;
        try {
            maxMessageForAJob = Integer.parseInt (args [2]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'max-message-for-a-job' has to be number!! ( '" + args [2] + "' is not a number ) \n");
            return;
        }
        try {
        } catch (Exception ex) {
            System.out.println ("\nChecking monitor at: " + args [3] + " -- FAILED.");
            ex.printStackTrace ();
            return;
        }
        int delay = 0;
        boolean portalEmul = false;
        if (args.length == 5 || args.length == 6) {
            if (! args [4].startsWith ("-")) {
                try {
                    delay = Integer.parseInt (args [4]);
                } catch (NumberFormatException nfex) {
                    System.out.println ("\n'delay' has to be number!! ( '" + args [4] + "' is not a number ) \n");
                    return;
                }
            }
            else {
                if (args [4].equals ("-p")) portalEmul = true;
            }
        }
        if (args.length == 6) {
            if (args [5].equals ("-p")) portalEmul = true;
        }
        SubscribeTest st = new SubscribeTest (args [0], jobNumber, maxMessageForAJob, args [3], delay, portalEmul);
    }
}


public static void main (String args []) {
    if (! (args.length == 4 || args.length == 5 || args.length == 6)) {
        System.out.println ("\n Description: Starts the given application {jobNumber} times at different hosts in the cluster and tries to collect \n" + "              its application.message metric via Mercury's Java interface. \n" + "              - The test application is started by ssh-ing into the given host of the cluster. \n" + "              - The hosts are selected from the output of the 'linuxall' command \n");
        System.out.println (" Usage: java SubscribeTest {test-app_abs-path} {job-number} {max-message-for-a-job} {main-monitor-url} [delay] [-p]");
        System.out.println ("      (The [delay] parameter is optional; it means seconds. If not given, it defaults to 0.)");
        System.out.println ("      (The [-p] flag is optional; emulates monitoring in the portal, i.e. using the same package. Using this flag, ensure that tracefile.jar is in the classpath.)");
        System.out.println ("\n Examples:");
        System.out.println ("    1) Without delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234");
        System.out.println ("    2)    With delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234 1");
        System.out.println ("    3) Emulating portal usage: Add '-p' as the last argument. \n");
        return;
    }
    if (args.length == 4 || args.length == 5 || args.length == 6) {
        File testApp = new File (args [0]);
        if (! testApp.isFile ()) {
            System.out.println ("\nTest application: " + testApp.getAbsolutePath () + " does not exists!\n");
            return;
        }
        int jobNumber;
        try {
            jobNumber = Integer.parseInt (args [1]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'job-number' has to be number!! ( '" + args [1] + "' is not a number ) \n");
            return;
        }
        int maxMessageForAJob;
        try {
            maxMessageForAJob = Integer.parseInt (args [2]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'max-message-for-a-job' has to be number!! ( '" + args [2] + "' is not a number ) \n");
            return;
        }
        try {
        } catch (Exception ex) {
            System.out.println ("\nChecking monitor at: " + args [3] + " -- FAILED.");
            ex.printStackTrace ();
            return;
        }
        int delay = 0;
        boolean portalEmul = false;
        if (args.length == 5 || args.length == 6) {
            if (! args [4].startsWith ("-")) {
                try {
                    delay = Integer.parseInt (args [4]);
                } catch (NumberFormatException nfex) {
                    System.out.println ("\n'delay' has to be number!! ( '" + args [4] + "' is not a number ) \n");
                    return;
                }
            }
            else {
                if (args [4].equals ("-p")) portalEmul = true;
            }
        }
        if (args.length == 6) {
            if (args [5].equals ("-p")) portalEmul = true;
        }
        SubscribeTest st = new SubscribeTest (args [0], jobNumber, maxMessageForAJob, args [3], delay, portalEmul);
    }
}


-----Function Pair=129=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=130=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=131=-----=1=

public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (1);
    }
}


public void run () {
    try {
        charsExpected = 10000 * (testData [0].length () + testData [1].length ());
        String fileName = "/tmp/out" + myNumber;
        final Process tac = Runtime.getRuntime ().exec (new String [] {PROGRAM, fileName}, null, new File ("/tmp"));
        Thread writer = new Thread () {
            public void run () {
                DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            charsWritten += testData [i].length ();
                            stdin.writeUTF (testData [i]);
                        }
                    }
                    stdin.flush ();
                    stdin.close ();
                } catch (IOException e) {
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        Thread reader = new Thread () {
            public void run () {
                DataInputStream stdout = new DataInputStream (tac.getInputStream ());
                try {
                    for (int x = 0; x < 10000; x ++) {
                        for (int i = 0; i < testData.length; i ++) {
                            String in = stdout.readUTF ();
                            charsRead += in.length ();
                            if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
                        }
                    }
                    int exitCode = tac.waitFor ();
                    if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
                    else System.err.println ("TestRuntimeExec FAILED");
                } catch (Throwable e) {
                    e.printStackTrace ();
                    throw new Error ("TestRuntimeExec FAILED");
                }
            }
        }
        ;
        writer.start ();
        reader.start ();
        final Thread waiter = new Thread () {
            public void run () {
                try {
                    int exitCode = tac.waitFor ();
                    System.out.println ("waitFor(): Process exited with code " + exitCode);
                } catch (InterruptedException e) {
                    if (! interruptWait) {
                        System.out.println ("Waiting thread uninterrupted unexpectedly!!!");
                        System.out.println ("TestRuntimeExec FAILED");
                        System.exit (1);
                    }
                    System.out.println ("Waiting thread interrupted! (THIS IS GOOD)");
                    e.printStackTrace ();
                }
            }
        }
        ;
        waiter.start ();
        if (interruptWait) {
            new Thread () {
                public void run () {
                    try {
                        Thread.sleep (2000);
                    } catch (Exception e) {
                    }
                    waiter.interrupt ();
                }
            }
            .start ();
        }
        Thread poller = new Thread () {
            public void run () {
                int exitCode = - 99;
                boolean exited = false;
                do {
                    try {
                        exitCode = tac.exitValue ();
                        exited = true;
                    } catch (IllegalThreadStateException e) {
                        System.out.println ("still alive!");
                        try {
                            Thread.sleep (1000);
                        } catch (Exception ee) {
                        }
                    }
                }
                while (! exited);
                System.out.println ("exitValue(): Process exited with code " + exitCode);
            }
        }
        ;
        poller.start ();
        try {
            reader.join ();
            writer.join ();
            waiter.join ();
            poller.join ();
        } catch (InterruptedException eee) {
            eee.printStackTrace ();
        }
    } catch (Throwable e) {
        System.err.println ("TestRuntimeExec FAILED with");
        e.printStackTrace ();
        System.exit (- 1);
    }
}


-----Function Pair=132=-----==

public static void main (String args []) {
    if (! (args.length == 4 || args.length == 5 || args.length == 6)) {
        System.out.println ("\n Description: Starts the given application {jobNumber} times at different hosts in the cluster and tries to collect \n" + "              its application.message metric via Mercury's Java interface. \n" + "              - The test application is started by ssh-ing into the given host of the cluster. \n" + "              - The hosts are selected from the output of the 'linuxall' command \n");
        System.out.println (" Usage: java SubscribeTest {test-app_abs-path} {job-number} {max-message-for-a-job} {main-monitor-url} [delay] [-p]");
        System.out.println ("      (The [delay] parameter is optional; it means seconds. If not given, it defaults to 0.)");
        System.out.println ("      (The [-p] flag is optional; emulates monitoring in the portal, i.e. using the same package. Using this flag, ensure that tracefile.jar is in the classpath.)");
        System.out.println ("\n Examples:");
        System.out.println ("    1) Without delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234");
        System.out.println ("    2)    With delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234 1");
        System.out.println ("    3) Emulating portal usage: Add '-p' as the last argument. \n");
        return;
    }
    if (args.length == 4 || args.length == 5 || args.length == 6) {
        File testApp = new File (args [0]);
        if (! testApp.isFile ()) {
            System.out.println ("\nTest application: " + testApp.getAbsolutePath () + " does not exists!\n");
            return;
        }
        int jobNumber;
        try {
            jobNumber = Integer.parseInt (args [1]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'job-number' has to be number!! ( '" + args [1] + "' is not a number ) \n");
            return;
        }
        int maxMessageForAJob;
        try {
            maxMessageForAJob = Integer.parseInt (args [2]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'max-message-for-a-job' has to be number!! ( '" + args [2] + "' is not a number ) \n");
            return;
        }
        try {
        } catch (Exception ex) {
            System.out.println ("\nChecking monitor at: " + args [3] + " -- FAILED.");
            ex.printStackTrace ();
            return;
        }
        int delay = 0;
        boolean portalEmul = false;
        if (args.length == 5 || args.length == 6) {
            if (! args [4].startsWith ("-")) {
                try {
                    delay = Integer.parseInt (args [4]);
                } catch (NumberFormatException nfex) {
                    System.out.println ("\n'delay' has to be number!! ( '" + args [4] + "' is not a number ) \n");
                    return;
                }
            }
            else {
                if (args [4].equals ("-p")) portalEmul = true;
            }
        }
        if (args.length == 6) {
            if (args [5].equals ("-p")) portalEmul = true;
        }
        SubscribeTest st = new SubscribeTest (args [0], jobNumber, maxMessageForAJob, args [3], delay, portalEmul);
    }
}


public static void main (String args []) {
    if (! (args.length == 4 || args.length == 5 || args.length == 6)) {
        System.out.println ("\n Description: Starts the given application {jobNumber} times at different hosts in the cluster and tries to collect \n" + "              its application.message metric via Mercury's Java interface. \n" + "              - The test application is started by ssh-ing into the given host of the cluster. \n" + "              - The hosts are selected from the output of the 'linuxall' command \n");
        System.out.println (" Usage: java SubscribeTest {test-app_abs-path} {job-number} {max-message-for-a-job} {main-monitor-url} [delay] [-p]");
        System.out.println ("      (The [delay] parameter is optional; it means seconds. If not given, it defaults to 0.)");
        System.out.println ("      (The [-p] flag is optional; emulates monitoring in the portal, i.e. using the same package. Using this flag, ensure that tracefile.jar is in the classpath.)");
        System.out.println ("\n Examples:");
        System.out.println ("    1) Without delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234");
        System.out.println ("    2)    With delay: > java SubscribeTest ~/test_app 10 200 monp://localhost:1234 1");
        System.out.println ("    3) Emulating portal usage: Add '-p' as the last argument. \n");
        return;
    }
    if (args.length == 4 || args.length == 5 || args.length == 6) {
        File testApp = new File (args [0]);
        if (! testApp.isFile ()) {
            System.out.println ("\nTest application: " + testApp.getAbsolutePath () + " does not exists!\n");
            return;
        }
        int jobNumber;
        try {
            jobNumber = Integer.parseInt (args [1]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'job-number' has to be number!! ( '" + args [1] + "' is not a number ) \n");
            return;
        }
        int maxMessageForAJob;
        try {
            maxMessageForAJob = Integer.parseInt (args [2]);
        } catch (NumberFormatException ex) {
            System.out.println ("\n'max-message-for-a-job' has to be number!! ( '" + args [2] + "' is not a number ) \n");
            return;
        }
        try {
        } catch (Exception ex) {
            System.out.println ("\nChecking monitor at: " + args [3] + " -- FAILED.");
            ex.printStackTrace ();
            return;
        }
        int delay = 0;
        boolean portalEmul = false;
        if (args.length == 5 || args.length == 6) {
            if (! args [4].startsWith ("-")) {
                try {
                    delay = Integer.parseInt (args [4]);
                } catch (NumberFormatException nfex) {
                    System.out.println ("\n'delay' has to be number!! ( '" + args [4] + "' is not a number ) \n");
                    return;
                }
            }
            else {
                if (args [4].equals ("-p")) portalEmul = true;
            }
        }
        if (args.length == 6) {
            if (args [5].equals ("-p")) portalEmul = true;
        }
        SubscribeTest st = new SubscribeTest (args [0], jobNumber, maxMessageForAJob, args [3], delay, portalEmul);
    }
}


-----Function Pair=133=-----==

public static StringBuffer exec (String [] cmd, int type, boolean outputSkip) throws Exception {
    Runtime rt = Runtime.getRuntime ();
    Process proc = rt.exec (cmd);
    if (outputSkip == false) {
        return null;
    }
    StringBuffer result = new StringBuffer ();
    BufferedReader out;
    if (type == STANDARD) {
        out = new BufferedReader (new InputStreamReader (proc.getInputStream ()));
    }
    else {
        out = new BufferedReader (new InputStreamReader (proc.getErrorStream ()));
    }
    String line = null;
    while ((line = out.readLine ()) != null) {
        result.append (line);
    }
    return result;
}


private byte [] runTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String taskName = urlData.getParameter ("name");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    TaskCommand taskCommand = tasks.get (taskName);
    if (taskCommand != null) {
        System.out.println ("Runnig Task : " + taskName);
        TaskItemThread taskItem = new TaskItemThread (taskCommand, new CommandWaitThread (taskCommand.getCommand ()), null);
        Thread taskThread = new Thread (Thread.currentThread ().getThreadGroup (), taskItem, taskItem.getClass ().getName ());
        taskThread.start ();
    }
    StringBuffer buff = new StringBuffer ();
    buff.append ("HTTP/1.0 302 Moved Temporarily\n");
    buff.append ("Location: /servlet/TaskManagementDataRes\n\n");
    return buff.toString ().getBytes ();
}


-----Function Pair=134=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=135=-----==

public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataOutputStream stdin = new DataOutputStream (tac.getOutputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                charsWritten += testData [i].length ();
                stdin.writeUTF (testData [i]);
            }
        }
        stdin.flush ();
        stdin.close ();
    } catch (IOException e) {
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=136=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=137=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=138=-----==

public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


public void run () {
    DataInputStream stdout = new DataInputStream (tac.getInputStream ());
    try {
        for (int x = 0; x < 10000; x ++) {
            for (int i = 0; i < testData.length; i ++) {
                String in = stdout.readUTF ();
                charsRead += in.length ();
                if (! in.equals (testData [i])) throw new Error ("TestRuntimeExec FAILED: bad input " + in);
            }
        }
        int exitCode = tac.waitFor ();
        if (exitCode == 0 && charsRead == charsExpected && charsWritten == charsExpected) System.err.println ("TestRuntimeExec SUCCESS");
        else System.err.println ("TestRuntimeExec FAILED");
    } catch (Throwable e) {
        e.printStackTrace ();
        throw new Error ("TestRuntimeExec FAILED");
    }
}


-----Function Pair=139=-----==

public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


public void run () {
    int exitCode = - 99;
    boolean exited = false;
    do {
        try {
            exitCode = tac.exitValue ();
            exited = true;
        } catch (IllegalThreadStateException e) {
            System.out.println ("still alive!");
            try {
                Thread.sleep (1000);
            } catch (Exception ee) {
            }
        }
    }
    while (! exited);
    System.out.println ("exitValue(): Process exited with code " + exitCode);
}


-----Function Pair=140=-----==

public static Document parse (File xmlFile) throws ParserConfigurationException, SAXException, IOException {
    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance ();
    docFactory.setValidating (false);
    docFactory.setNamespaceAware (true);
    docFactory.setExpandEntityReferences (false);
    DocumentBuilder parser = docFactory.newDocumentBuilder ();
    Document document = parser.parse (xmlFile);
    return document;
}


private void convertMedia (String [] command) throws FFMpegException {
    LOGGER.info ("Conversion command = " + Arrays.asList (command));
    ProcessBuilder builder = new ProcessBuilder (command);
    Process ffmpeg = null;
    try {
        ffmpeg = builder.start ();
        Thread.sleep (100);
    } catch (IOException e) {
        throw new FFMpegException ("Can't start FFMpeg", e);
    } catch (InterruptedException e) {
        throw new FFMpegException ("Can't start FFMpeg", e);
    }
    try {
        ffmpeg.getOutputStream ().close ();
        ffmpeg.getInputStream ().close ();
        ffmpeg.getErrorStream ().close ();
    } catch (IOException e) {
        throw new FFMpegException ("Can't start FFMpeg without output or error stream", e);
    }
    int exitStatus = - 1;
    try {
        exitStatus = ffmpeg.waitFor ();
    } catch (InterruptedException e) {
        throw new FFMpegException ("FFMpeg conversion interrupted", e);
    }
    if (exitStatus != 0) {
        throw new FFMpegException (new StringBuilder ("FFMpeg conversion failed with status = [").append (exitStatus).append ("] using command = ").append (Arrays.asList (command)).toString ());
    }
}


-----Function Pair=141=-----==

public boolean validateMethodGetUserArg () throws Exception {
    String testRoot = TEST_MethodGetUserArg;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("ua1", "ua1");
    sReferencePS.set ("ua2", "ua2");
    sReferencePS.set ("ua3", "ua3");
    sReferencePS.set ("ua4", "ua4");
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.equals (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


public boolean validateDirectiveSection () throws Exception {
    String testRoot = TEST_DirectiveSection;
    boolean test = true;
    sReferencePS.clear ();
    sReferencePS.set ("list0", EMPTY);
    sReferencePS.set ("list1", "[0]");
    sReferencePS.set ("list2", "[0][1]");
    sReferencePS.set (FOO, BAR);
    sTestPS.load (new File (getTestFolder (), PREFIX_RESULT + testRoot + DOT + TXT));
    test = sTestPS.contains (sReferencePS) && test;
    if (! test) {
        displayPropertySets (sTestPS, sReferencePS);
    }
    return test;
}


-----Function Pair=142=-----==

private byte [] updateTask (HTTPurl urlData, HashMap < String, String > headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    String secLevel = store.getProperty ("security.highsecurity");
    boolean allowed = false;
    if ("0".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"));
    }
    else if ("1".equals (secLevel)) {
        allowed = "true".equalsIgnoreCase ((String) headers.get ("LoopbackAddress")) || headers.containsKey ("authenticated");
    }
    else if ("2".equals (secLevel)) {
        allowed = true;
    }
    if (allowed == false) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    String sessionID = urlData.getParameter ("sessionID");
    if (! store.checkSessionID (sessionID)) {
        out = "Security Warning: The Security Session ID you entered is not correct.";
        return out.getBytes ();
    }
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String name = urlData.getParameter ("task_name");
    TaskCommand task = (TaskCommand) tasks.get (name);
    if (task != null) {
        String command = urlData.getParameter ("command");
        String autoRem = urlData.getParameter ("autoRemove");
        String delay = urlData.getParameter ("delay");
        String concurrentTasks = urlData.getParameter ("concurrentTasks");
        String timeToNextSchedule = urlData.getParameter ("timeToNextSchedule");
        String whenNotCapturing = urlData.getParameter ("whenNotCapturing");
        Boolean notCap = new Boolean (false);
        if ("true".equalsIgnoreCase (whenNotCapturing)) {
            notCap = new Boolean (true);
        }
        task.setWhenNotCapturing (notCap.booleanValue ());
        int timeToNext = 0;
        try {
            timeToNext = Integer.parseInt (timeToNextSchedule);
        } catch (Exception e) {
        }
        task.setTimeToNextSchedule (timeToNext);
        int conTasks = 0;
        try {
            conTasks = Integer.parseInt (concurrentTasks);
        } catch (Exception e) {
        }
        task.setConcurrent (conTasks);
        Boolean autoRemove = new Boolean (false);
        if ("true".equalsIgnoreCase (autoRem)) {
            autoRemove = new Boolean (true);
        }
        task.setAutoRemove (autoRemove.booleanValue ());
        int delayValue = 0;
        try {
            delayValue = Integer.parseInt (delay);
        } catch (Exception e) {
        }
        task.setDelay (delayValue);
        task.setCommand (command.trim ());
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


public JMenuBar createMenuBar () {
    JMenuBar mnuBar = new JMenuBar ();
    setJMenuBar (mnuBar);
    JMenu mnuFile = new JMenu ("File", true);
    mnuFile.setMnemonic (KeyEvent.VK_F);
    mnuBar.add (mnuFile);
    mnuFile.setToolTipText ("Perform operations on documents");
    JMenuItem mnuAddSample = new JMenuItem ("Add Sample Document");
    mnuAddSample.setMnemonic (KeyEvent.VK_S);
    mnuFile.add (mnuAddSample);
    mnuAddSample.setActionCommand ("AddSample");
    mnuAddSample.addActionListener (this);
    JMenuItem mnuAddTesting = new JMenuItem ("Add Testing Document");
    mnuAddTesting.setMnemonic (KeyEvent.VK_T);
    mnuFile.add (mnuAddTesting);
    mnuAddTesting.setActionCommand ("AddTesting");
    mnuAddTesting.addActionListener (this);
    JMenuItem mnuProcess = new JMenuItem ("Process Documents");
    mnuProcess.setMnemonic (KeyEvent.VK_P);
    mnuFile.add (mnuProcess);
    mnuProcess.setActionCommand ("Process");
    mnuProcess.addActionListener (this);
    JMenuItem mnuClear = new JMenuItem ("Clear Documents");
    mnuClear.setMnemonic (KeyEvent.VK_C);
    mnuFile.add (mnuClear);
    mnuClear.setActionCommand ("Clear");
    mnuClear.addActionListener (this);
    JMenuItem mnuExit = new JMenuItem ("Exit");
    mnuExit.setMnemonic (KeyEvent.VK_E);
    mnuFile.add (mnuExit);
    mnuExit.setActionCommand ("Exit");
    mnuExit.addActionListener (this);
    JMenu mnuAlgo = new JMenu ("Algorithm", true);
    mnuAlgo.setMnemonic (KeyEvent.VK_A);
    mnuBar.add (mnuAlgo);
    mnuAlgo.setToolTipText ("Change processing algorithm");
    ButtonGroup grpAlgo = new ButtonGroup ();
    JRadioButtonMenuItem algoItem = new JRadioButtonMenuItem ("Cross - Entropy");
    algoItem.setSelected (true);
    algoItem.setMnemonic (KeyEvent.VK_C);
    grpAlgo.add (algoItem);
    mnuAlgo.add (algoItem);
    algoItem.setActionCommand ("Cross");
    algoItem.addActionListener (this);
    algoItem = new JRadioButtonMenuItem ("LZW (*NIX Only)");
    algoItem.setMnemonic (KeyEvent.VK_L);
    grpAlgo.add (algoItem);
    mnuAlgo.add (algoItem);
    algoItem.setActionCommand ("LZW");
    algoItem.addActionListener (this);
    JMenu mnuEvent = new JMenu ("Event Type", true);
    mnuEvent.setMnemonic (KeyEvent.VK_E);
    mnuBar.add (mnuEvent);
    mnuEvent.setToolTipText ("Change definition of events");
    ButtonGroup grpEvent = new ButtonGroup ();
    JRadioButtonMenuItem eventItem = new JRadioButtonMenuItem ("Word");
    eventItem.setSelected (true);
    eventItem.setMnemonic (KeyEvent.VK_W);
    grpEvent.add (eventItem);
    mnuEvent.add (eventItem);
    eventItem.setActionCommand ("Word");
    eventItem.addActionListener (this);
    eventItem = new JRadioButtonMenuItem ("Letter");
    eventItem.setSelected (false);
    eventItem.setMnemonic (KeyEvent.VK_L);
    grpEvent.add (eventItem);
    mnuEvent.add (eventItem);
    eventItem.setActionCommand ("Letter");
    eventItem.addActionListener (this);
    JMenu mnuPre = new JMenu ("Preprocessing", true);
    mnuPre.setMnemonic (KeyEvent.VK_P);
    mnuBar.add (mnuPre);
    mnuPre.setToolTipText ("Turn preprocessing on/off");
    ButtonGroup grpPre = new ButtonGroup ();
    JRadioButtonMenuItem preItem = new JRadioButtonMenuItem ("Yes");
    preItem.setSelected (true);
    preItem.setMnemonic (KeyEvent.VK_Y);
    grpPre.add (preItem);
    mnuPre.add (preItem);
    preItem.setActionCommand ("Yes");
    preItem.addActionListener (this);
    preItem = new JRadioButtonMenuItem ("No");
    preItem.setSelected (false);
    preItem.setMnemonic (KeyEvent.VK_N);
    grpPre.add (preItem);
    mnuPre.add (preItem);
    preItem.setActionCommand ("No");
    preItem.addActionListener (this);
    JMenu mnuHelp = new JMenu ("Help", true);
    mnuHelp.setMnemonic (KeyEvent.VK_H);
    mnuBar.add (mnuHelp);
    mnuHelp.setToolTipText ("Instructions and program information");
    JMenuItem mnuInst = new JMenuItem ("Instructions");
    mnuInst.setMnemonic (KeyEvent.VK_I);
    mnuHelp.add (mnuInst);
    mnuInst.setActionCommand ("Instructions");
    mnuInst.addActionListener (this);
    JMenuItem mnuAbout = new JMenuItem ("About");
    mnuAbout.setMnemonic (KeyEvent.VK_A);
    mnuHelp.add (mnuAbout);
    mnuAbout.setActionCommand ("About");
    mnuAbout.addActionListener (this);
    return mnuBar;
}


-----Function Pair=143=-----==

public int [] getMessages () {
    int [] allMessages = {0};
    try {
        Connection conn = getDBConnection ();
        Statement stmt = conn.createStatement ();
        String dbQuery = "SELECT COUNT(M_ID) FROM Messages WHERE FromAddress='" + getEmail () + "'";
        ResultSet results = stmt.executeQuery (dbQuery);
        allMessages = new int [results.getInt ("COUNT(M_ID)")];
        dbQuery = "SELECT M_ID FROM Messages WHERE FromAddress='" + getEmail () + "' ORDER BY Received";
        results = stmt.executeQuery (dbQuery);
        for (int i = 0; results.next (); i ++) {
            allMessages [i] = results.getInt ("M_ID");
        }
    } catch (SQLException e) {
        System.out.println (e);
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    } catch (InstantiationException e) {
        System.out.println (e);
    } catch (IllegalAccessException e) {
        System.out.println (e);
    }
    return allMessages;
}


public int [] getMyLists () {
    int [] myLists = {1};
    try {
        Connection conn = Ozymandias.getDBConnection ();
        Statement stmt = conn.createStatement ();
        String dbQuery = "SELECT COUNT(L_ID) FROM UserLists WHERE U_ID='" + userUID + "'";
        ResultSet results = stmt.executeQuery (dbQuery);
        myLists = new int [results.getInt ("COUNT(L_ID)")];
        dbQuery = "SELECT L_ID FROM UserLists WHERE U_ID='" + getUID () + "'";
        results = stmt.executeQuery (dbQuery);
        for (int i = 0; results.next (); i ++) {
            myLists [i] = results.getInt ("L_ID");
        }
    } catch (SQLException e) {
        System.out.println (e);
    } catch (ClassNotFoundException e) {
        System.out.println (e);
    } catch (InstantiationException e) {
        System.out.println (e);
    } catch (IllegalAccessException e) {
        System.out.println (e);
    }
    return myLists;
}


-----Function Pair=144=-----=1=

public static void main (String [] args) {
    if (args.length != 4) {
        System.out.println ("usage: java msgmultisend <to> <from> <smtp> true|false");
        return;
    }
    String to = args [0];
    String from = args [1];
    String host = args [2];
    boolean debug = Boolean.valueOf (args [3]).booleanValue ();
    Properties props = new Properties ();
    props.put ("mail.smtp.host", host);
    Session session = Session.getInstance (props, null);
    session.setDebug (debug);
    try {
        MimeMessage msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (from));
        InternetAddress [] address = {new InternetAddress (to)};
        msg.setRecipients (Message.RecipientType.TO, address);
        msg.setSubject ("JavaMail APIs Multipart Test");
        msg.setSentDate (new Date ());
        MimeBodyPart mbp1 = new MimeBodyPart ();
        mbp1.setText (msgText1);
        MimeBodyPart mbp2 = new MimeBodyPart ();
        mbp2.setText (msgText2, "us-ascii");
        Multipart mp = new MimeMultipart ();
        mp.addBodyPart (mbp1);
        mp.addBodyPart (mbp2);
        msg.setContent (mp);
        Transport.send (msg);
    } catch (MessagingException mex) {
        mex.printStackTrace ();
        Exception ex = null;
        if ((ex = mex.getNextException ()) != null) {
            ex.printStackTrace ();
        }
    }
}


public static void main (String [] args) {
    if (args.length != 4) {
        System.out.println ("usage: java msgmultisend <to> <from> <smtp> true|false");
        return;
    }
    String to = args [0];
    String from = args [1];
    String host = args [2];
    boolean debug = Boolean.valueOf (args [3]).booleanValue ();
    Properties props = new Properties ();
    props.put ("mail.smtp.host", host);
    Session session = Session.getInstance (props, null);
    session.setDebug (debug);
    try {
        MimeMessage msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (from));
        InternetAddress [] address = {new InternetAddress (to)};
        msg.setRecipients (Message.RecipientType.TO, address);
        msg.setSubject ("JavaMail APIs Multipart Test");
        msg.setSentDate (new Date ());
        MimeBodyPart mbp1 = new MimeBodyPart ();
        mbp1.setText (msgText1);
        MimeBodyPart mbp2 = new MimeBodyPart ();
        mbp2.setText (msgText2, "us-ascii");
        Multipart mp = new MimeMultipart ();
        mp.addBodyPart (mbp1);
        mp.addBodyPart (mbp2);
        msg.setContent (mp);
        Transport.send (msg);
    } catch (MessagingException mex) {
        mex.printStackTrace ();
        Exception ex = null;
        if ((ex = mex.getNextException ()) != null) {
            ex.printStackTrace ();
        }
    }
}


-----Function Pair=145=-----==

private void displayMessageHeaders (MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
    try {
        out.println ("<b>Date:</b> " + msg.getSentDate () + "<br>");
        Address [] fr = msg.getFrom ();
        if (fr != null) {
            boolean tf = true;
            out.print ("<b>From:</b> ");
            for (int i = 0; i < fr.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (fr [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] to = msg.getRecipients (Message.RecipientType.TO);
        if (to != null) {
            boolean tf = true;
            out.print ("<b>To:</b> ");
            for (int i = 0; i < to.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (to [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] cc = msg.getRecipients (Message.RecipientType.CC);
        if (cc != null) {
            boolean cf = true;
            out.print ("<b>CC:</b> ");
            for (int i = 0; i < cc.length; i ++) {
                out.print (((cf) ? " " : ", ") + getDisplayAddress (cc [i]));
                cf = false;
            }
            out.println ("<br>");
        }
        out.print ("<b>Subject:</b> " + ((msg.getSubject () != null) ? msg.getSubject () : "") + "<br>");
    } catch (MessagingException mex) {
        out.println (msg.toString ());
    }
}


private void displayMessageHeaders (MailUserData mud, Message msg, ServletOutputStream out) throws IOException {
    try {
        out.println ("<b>Date:</b> " + msg.getSentDate () + "<br>");
        Address [] fr = msg.getFrom ();
        if (fr != null) {
            boolean tf = true;
            out.print ("<b>From:</b> ");
            for (int i = 0; i < fr.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (fr [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] to = msg.getRecipients (Message.RecipientType.TO);
        if (to != null) {
            boolean tf = true;
            out.print ("<b>To:</b> ");
            for (int i = 0; i < to.length; i ++) {
                out.print (((tf) ? " " : ", ") + getDisplayAddress (to [i]));
                tf = false;
            }
            out.println ("<br>");
        }
        Address [] cc = msg.getRecipients (Message.RecipientType.CC);
        if (cc != null) {
            boolean cf = true;
            out.print ("<b>CC:</b> ");
            for (int i = 0; i < cc.length; i ++) {
                out.print (((cf) ? " " : ", ") + getDisplayAddress (cc [i]));
                cf = false;
            }
            out.println ("<br>");
        }
        out.print ("<b>Subject:</b> " + ((msg.getSubject () != null) ? msg.getSubject () : "") + "<br>");
    } catch (MessagingException mex) {
        out.println (msg.toString ());
    }
}


-----Function Pair=146=-----=1=

public static void main (String [] args) {
    if (args.length != 4) {
        usage ();
        System.exit (1);
    }
    System.out.println ();
    String to = args [0];
    String from = args [1];
    String host = args [2];
    boolean debug = Boolean.valueOf (args [3]).booleanValue ();
    Properties props = new Properties ();
    props.put ("mail.smtp.host", host);
    if (debug) props.put ("mail.debug", args [3]);
    Session session = Session.getInstance (props, null);
    session.setDebug (debug);
    try {
        Message msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (from));
        InternetAddress [] address = {new InternetAddress (args [0])};
        msg.setRecipients (Message.RecipientType.TO, address);
        msg.setSubject ("JavaMail APIs Test");
        msg.setSentDate (new Date ());
        msg.setText (msgText);
        Transport.send (msg);
    } catch (MessagingException mex) {
        System.out.println ("\n--Exception handling in msgsendsample.java");
        mex.printStackTrace ();
        System.out.println ();
        Exception ex = mex;
        do {
            if (ex instanceof SendFailedException) {
                SendFailedException sfex = (SendFailedException) ex;
                Address [] invalid = sfex.getInvalidAddresses ();
                if (invalid != null) {
                    System.out.println ("    ** Invalid Addresses");
                    if (invalid != null) {
                        for (int i = 0; i < invalid.length; i ++) System.out.println ("         " + invalid [i]);
                    }
                }
                Address [] validUnsent = sfex.getValidUnsentAddresses ();
                if (validUnsent != null) {
                    System.out.println ("    ** ValidUnsent Addresses");
                    if (validUnsent != null) {
                        for (int i = 0; i < validUnsent.length; i ++) System.out.println ("         " + validUnsent [i]);
                    }
                }
                Address [] validSent = sfex.getValidSentAddresses ();
                if (validSent != null) {
                    System.out.println ("    ** ValidSent Addresses");
                    if (validSent != null) {
                        for (int i = 0; i < validSent.length; i ++) System.out.println ("         " + validSent [i]);
                    }
                }
            }
            System.out.println ();
            if (ex instanceof MessagingException) ex = ((MessagingException) ex).getNextException ();
            else ex = null;
        }
        while (ex != null);
    }
}


public static void main (String [] args) {
    if (args.length != 4) {
        usage ();
        System.exit (1);
    }
    System.out.println ();
    String to = args [0];
    String from = args [1];
    String host = args [2];
    boolean debug = Boolean.valueOf (args [3]).booleanValue ();
    Properties props = new Properties ();
    props.put ("mail.smtp.host", host);
    if (debug) props.put ("mail.debug", args [3]);
    Session session = Session.getInstance (props, null);
    session.setDebug (debug);
    try {
        Message msg = new MimeMessage (session);
        msg.setFrom (new InternetAddress (from));
        InternetAddress [] address = {new InternetAddress (args [0])};
        msg.setRecipients (Message.RecipientType.TO, address);
        msg.setSubject ("JavaMail APIs Test");
        msg.setSentDate (new Date ());
        msg.setText (msgText);
        Transport.send (msg);
    } catch (MessagingException mex) {
        System.out.println ("\n--Exception handling in msgsendsample.java");
        mex.printStackTrace ();
        System.out.println ();
        Exception ex = mex;
        do {
            if (ex instanceof SendFailedException) {
                SendFailedException sfex = (SendFailedException) ex;
                Address [] invalid = sfex.getInvalidAddresses ();
                if (invalid != null) {
                    System.out.println ("    ** Invalid Addresses");
                    if (invalid != null) {
                        for (int i = 0; i < invalid.length; i ++) System.out.println ("         " + invalid [i]);
                    }
                }
                Address [] validUnsent = sfex.getValidUnsentAddresses ();
                if (validUnsent != null) {
                    System.out.println ("    ** ValidUnsent Addresses");
                    if (validUnsent != null) {
                        for (int i = 0; i < validUnsent.length; i ++) System.out.println ("         " + validUnsent [i]);
                    }
                }
                Address [] validSent = sfex.getValidSentAddresses ();
                if (validSent != null) {
                    System.out.println ("    ** ValidSent Addresses");
                    if (validSent != null) {
                        for (int i = 0; i < validSent.length; i ++) System.out.println ("         " + validSent [i]);
                    }
                }
            }
            System.out.println ();
            if (ex instanceof MessagingException) ex = ((MessagingException) ex).getNextException ();
            else ex = null;
        }
        while (ex != null);
    }
}


-----Function Pair=147=-----==

private void omegaConfActionPerformed (java.awt.event.ActionEvent evt) {
    if (evt.getSource () == omegaConf) {
        if (readyForCI) {
            (new Thread () {
                public void run () {
                    FredOutVal result = runOmegaConfidenceInterval ();
                    if (result != null) {
                        if (userApproval (result)) {
                            try {
                                readyForCI = false;
                                hClimbResult = hillClimbing (result);
                                readyForCI = true;
                            } catch (IOException e) {
                                e.printStackTrace ();
                            }
                        }
                    }
                }
            }
            ).start ();
        }
        else log.append ("You must run binning and hillclimbing from a " + "fasta file before you can run a confidence interval.\n");
    }
}


public boolean checkDirty () {
    if (root.isTreeDirty ()) {
        int option = JOptionPane.showConfirmDialog (this, "The project has changed.  Save?", "Save?", JOptionPane.YES_NO_CANCEL_OPTION);
        switch (option) {
            case JOptionPane.YES_OPTION :
                save (prop.getProperty ("last", ""));
            case JOptionPane.NO_OPTION :
                return true;
            default :
            case JOptionPane.CANCEL_OPTION :
                return false;
        }
    }
    return true;
}


-----Function Pair=148=-----==

public ProjectGUI () {
    setSize (500, 450);
    setTitle ("Pascal Interpreter");
    cp = getContentPane ();
    area = new JTextArea ();
    scroll = new JScrollPane (area);
    cp.add (scroll, BorderLayout.CENTER);
    variables = new HashMap < String, Variable > ();
    JMenu file = new JMenu ("Plik");
    JMenuItem open = file.add (new OpenFileAction ("Otworz"));
    JMenuItem save = file.add (new SaveFileAction ("Zapisz"));
    file.addSeparator ();
    JMenuItem exit = file.add (new ExitAction ("Zakoncz"));
    JMenuBar menu = new JMenuBar ();
    setJMenuBar (menu);
    menu.add (file);
    JMenu action = new JMenu ("Uruchom");
    JMenuItem scanner = action.add (new RunScannerAction ("Uruchom.."));
    JMenuItem parser = action.add (new RunApp ("Info"));
    menu.add (action);
    wybor = new JFileChooser ();
    wybor.setCurrentDirectory (new File ("."));
    final FiltrRozszerzenia filtr = new FiltrRozszerzenia ();
    filtr.ustawRozszerzenie ("pas");
    wybor.setFileFilter (filtr);
    setVisible (true);
    setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
}


void showPrefs () {
    String oldDirectory = libDirectory;
    DialogOptions options = new DialogOptions (this, CC.getMapCoordinates ().getXMagnitude (), CC.profileTime, CC.antiAlias, CC.getMapCoordinates ().getXGridStep (), libDirectory, textToolbar, smallIconsToolbar, CC.getPCB_thickness (), CC.getPCB_pad_sizex (), CC.getPCB_pad_sizey (), CC.getPCB_pad_drill (), extFCJ_s, extFCJ_c, Globals.quaquaActive, CC.getStrict (), CC.P.getTextFont (), splitNonStandardMacro_s, splitNonStandardMacro_c, Globals.lineWidth, Globals.lineWidthCircles, Globals.diameterConnection, CC.P.getTextFontSize ());
    options.setVisible (true);
    CC.profileTime = options.profileTime;
    CC.antiAlias = options.antiAlias;
    textToolbar = options.textToolbar;
    smallIconsToolbar = options.smallIconsToolbar;
    CC.getMapCoordinates ().setMagnitudes (options.zoomValue, options.zoomValue);
    CC.getMapCoordinates ().setXGridStep (options.gridSize);
    CC.getMapCoordinates ().setYGridStep (options.gridSize);
    CC.setPCB_thickness (options.pcblinewidth_i);
    CC.setPCB_pad_sizex (options.pcbpadwidth_i);
    CC.setPCB_pad_sizey (options.pcbpadheight_i);
    CC.setPCB_pad_drill (options.pcbpadintw_i);
    CC.P.setTextFont (options.macroFont, options.macroSize_i);
    extFCJ_s = options.extFCJ_s;
    extFCJ_c = options.extFCJ_c;
    splitNonStandardMacro_s = options.split_n_s;
    splitNonStandardMacro_c = options.split_n_c;
    CC.setStrict (options.extStrict);
    Globals.quaquaActive = options.quaquaActive;
    libDirectory = options.libDirectory;
    Globals.lineWidth = options.stroke_size_straight_i;
    Globals.lineWidthCircles = options.stroke_size_oval_i;
    Globals.diameterConnection = options.connectionSize_i;
    if (runsAsApplication) {
        prefs.put ("DIR_LIBS", libDirectory);
        prefs.put ("MACRO_FONT", CC.P.getTextFont ());
        prefs.put ("MACRO_SIZE", "" + CC.P.getTextFontSize ());
        prefs.put ("STROKE_SIZE_STRAIGHT", "" + Globals.lineWidth);
        prefs.put ("STROKE_SIZE_OVAL", "" + Globals.lineWidthCircles);
        prefs.put ("CONNECTION_SIZE", "" + Globals.diameterConnection);
        prefs.put ("SMALL_ICON_TOOLBAR", (smallIconsToolbar ? "true" : "false"));
        prefs.put ("TEXT_TOOLBAR", (textToolbar ? "true" : "false"));
        prefs.put ("QUAQUA", (Globals.quaquaActive ? "true" : "false"));
        prefs.put ("FCJ_EXT_STRICT", (CC.getStrict () ? "true" : "false"));
        prefs.put ("SPLIT_N_MACRO_SAVE", (splitNonStandardMacro_s ? "true" : "false"));
        prefs.put ("SPLIT_N_MACRO_COPY", (splitNonStandardMacro_c ? "true" : "false"));
    }
    if (! libDirectory.equals (oldDirectory)) {
        loadLibraries ();
        show ();
    }
    repaint ();
}


-----Function Pair=149=-----==

private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void open (File f) {
    try {
        ImageInputStream iis = ImageIO.createImageInputStream (f);
        Iterator iter = ImageIO.getImageReadersByFormatName ("DICOM");
        ImageReader reader = (ImageReader) iter.next ();
        reader.setInput (iis, false);
        JPanel p = new ImageBox (reader);
        JFrame jf = new JFrame ("ImageDisplay - Display Panel");
        jf.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
        jf.getContentPane ().add (p);
        jf.pack ();
        jf.setSize (Math.min (jf.getWidth (), 800), Math.min (jf.getHeight (), 600));
        jf.setVisible (true);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


-----Function Pair=150=-----==

public void actionPerformed (ActionEvent ev) {
    Object s = ev.getSource ();
    if (s == optBox) {
        if (optBox.isSelected ()) {
            filepath.setEditable (true);
            butFile.setEnabled (true);
        }
        else {
            filepath.setEditable (false);
            butFile.setEnabled (false);
        }
    }
    else if (s == butFile) {
        JFileChooser file = new JFileChooser ();
        int r;
        if (isOpenFileDialog) r = file.showOpenDialog (this);
        else r = file.showSaveDialog (this);
        if (r == JFileChooser.APPROVE_OPTION) filepath.setText (file.getSelectedFile ().getPath ());
    }
}


private int chooseTree () {
    Object [] options = {"NJPlot", "Newick"};
    int useNewick = JOptionPane.showOptionDialog (ParameterSolutions.this, "Generate tree from Fasta file using NJPlot " + "or provide own Newick tree?", "Tree Generation", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE, null, options, options [0]);
    if (useNewick == 1) {
        int returnVal2 = fc.showDialog (ParameterSolutions.this, "Open Newick Tree");
        if (returnVal2 == JFileChooser.APPROVE_OPTION) {
            tree = fc.getSelectedFile ();
            log.append ("Opening: " + tree.getName () + "\n");
        }
        else {
            useNewick = - 1;
        }
    }
    else {
        tree = null;
    }
    return useNewick;
}


-----Function Pair=151=-----==

private Menu createAdminMenu () {
    logger.debug ("creating admin menu");
    ResourceBundle res = ResourceBundle.getBundle ("org.openi.labels", user.getLocale ());
    Menu adminMenu = new Menu (res.getString ("java_ProjectContext.adminmenu.Administration"));
    Map config = this.getProject ().getMenuConfig (user.getLocale ());
    if (Util.isItemInList (this.getUser ().getId (), Application.getInstance ().getApplicationAdmins ())) {
        this.addItemList (adminMenu, (List) config.get ("appAdminList"));
        this.addItemList (adminMenu, (List) config.get ("projectAdminList"));
        this.addItemList (adminMenu, (List) config.get ("projectUserList"));
    }
    if (Util.isItemInList (this.getUser ().getId (), this.getProject ().getProjectAdmins ())) {
        this.addItemList (adminMenu, (List) config.get ("projectAdminList"));
        this.addItemList (adminMenu, (List) config.get ("projectUserList"));
    }
    if (Util.isItemInList (this.getUser ().getId (), this.getProject ().getProjectUsers ())) {
        this.addItemList (adminMenu, (List) config.get ("projectUserList"));
    }
    return adminMenu;
}


public static boolean isLZMA (InputStream is) throws IOException {
    byte [] buf = new byte [lzma_identifier.length ()];
    is.mark (lzma_identifier.length () + 8);
    if (is.read (buf, 0, lzma_identifier.length ()) != lzma_identifier.length ()) {
        is.reset ();
        return false;
    }
    for (int i = 0; i < lzma_identifier.length (); i ++) {
        if (buf [i] != lzma_identifier.charAt (i)) {
            is.reset ();
            return false;
        }
    }
    return true;
}


-----Function Pair=152=-----==

public static Map < String, String > jobDirectoryCompressor (final String simulationDirectoryPath, Set < String > directoriesToIgnore) {
    log.debug ("~jobDirectoryCompressor(String) : About to compress simulation job directories for [" + simulationDirectoryPath + "]");
    if (directoriesToIgnore == null) directoriesToIgnore = new HashSet < String > (0);
    final Map < String, String > zipFiles = new HashMap < String, String > ();
    final String [] jobDirectories = new File (simulationDirectoryPath).list ();
    Arrays.sort (jobDirectories);
    for (int idx = 0; idx < jobDirectories.length; idx ++) {
        final String jobDirectoryName = jobDirectories [idx];
        if (directoriesToIgnore.contains (jobDirectoryName)) continue;
        final String jobDirectoryPath = simulationDirectoryPath.concat (jobDirectoryName);
        final String zipFilePath = zipDirectory (jobDirectoryPath);
        if (zipFilePath != null) zipFiles.put (jobDirectoryName.concat (ZIP_SUFFIX), zipFilePath);
    }
    return zipFiles;
}


public static File [] extractFiles (File dirOrFile, String extension) {
    if (dirOrFile == null) return null;
    File [] files = null;
    Pattern p = Pattern.compile (".*" + extension + "$", Pattern.CASE_INSENSITIVE);
    Matcher m;
    if (dirOrFile.isDirectory ()) {
        files = dirOrFile.listFiles ();
        int num = files.length;
        ArrayList < File > chromFiles = new ArrayList < File > ();
        for (int i = 0; i < num; i ++) {
            m = p.matcher (files [i].getName ());
            if (m.matches ()) chromFiles.add (files [i]);
        }
        files = new File [chromFiles.size ()];
        chromFiles.toArray (files);
    }
    else {
        m = p.matcher (dirOrFile.getName ());
        if (m.matches ()) {
            files = new File [1];
            files [0] = dirOrFile;
        }
    }
    if (files != null) Arrays.sort (files);
    return files;
}


-----Function Pair=153=-----==

public void close () {
    if (log == null) {
        if (VAGlobals.DEBUG) System.out.println ("log file null");
    }
    else {
        log.flush ();
        log.close ();
    }
    try {
        if (filewriter != null) filewriter.close ();
    } catch (IOException e) {
        VAGlobals.printDebug ("LogInfo.close IOException: " + e.getMessage ());
    }
    if (oldlog != null) oldlog.clear ();
    oldlog = null;
}


public final void finaliseFile () {
    super.finaliseFile ();
    if (currentZipStream != null) {
        try {
            zips.remove (currentZipStream);
        } catch (final Exception e) {
            Generic.debug ("zip stream removal", e);
        }
        try {
            currentZipStream.closeEntry ();
            currentZipStream.close ();
        } catch (final Exception e) {
            Generic.debug ("finaliseFile", e);
        }
        currentZipStream = null;
    }
}


-----Function Pair=154=-----==

private Vector loadLogFile (File _logfile) throws IOException {
    Vector res = new Vector ();
    if (_logfile == null) return res;
    File logfile = _logfile;
    if (logfile != null && logfile.exists ()) {
        LineNumberReader log = new LineNumberReader (new FileReader (logfile));
        String line = log.readLine ();
        while (line != null) {
            res.add (line);
            line = log.readLine ();
        }
        log.close ();
    }
    else {
        VAGlobals.printDebug ("log not found" + _logfile.getAbsoluteFile ());
    }
    return res;
}


private void SaveSiteVar (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from site_vars where siteid=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
        if (vars != null && ! vars.isEmpty ()) {
            sql = "insert into site_vars(siteid,varname,value) values(?,?,?)";
            pstmt = conn.prepareStatement (sql);
            Enumeration vars_elements = vars.elements ();
            while (vars_elements.hasMoreElements ()) {
                Site.Var var = (Site.Var) vars_elements.nextElement ();
                pstmt.setString (1, id);
                pstmt.setString (2, var.name);
                pstmt.setString (3, var.value);
                pstmt.executeUpdate ();
            }
        }
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=155=-----==

public void sendDirNameToZipStream (String userbaseDir, String DirStr, ZipOutputStream zipout) throws Exception {
    if (! userbaseDir.endsWith (sep)) {
        userbaseDir += sep;
    }
    if (! DirStr.endsWith (sep)) {
        DirStr += sep;
    }
    String entryPath = userbaseDir + DirStr;
    File dir = new File (entryPath);
    dir.mkdirs ();
    if ((dir.exists ()) && (dir.isDirectory ())) {
        ZipEntry zipEntry = new ZipEntry (DirStr);
        zipEntry.setMethod (ZipEntry.STORED);
        zipEntry.setSize (0);
        zipEntry.setCrc (0);
        zipout.putNextEntry (zipEntry);
        zipout.flush ();
        zipout.closeEntry ();
    }
    else {
    }
}


private Map getEVSchedules (Collection taskListNames) {
    Map schedules = new TreeMap ();
    for (Iterator iter = taskListNames.iterator (); iter.hasNext ();) {
        boolean merged = false;
        String taskScheduleName = (String) iter.next ();
        if (taskScheduleName.startsWith (MERGED_PREFIX)) {
            merged = true;
            taskScheduleName = taskScheduleName.substring (MERGED_PREFIX.length ());
        }
        EVTaskList tl = EVTaskList.openExisting (taskScheduleName, ctx.getData (), ctx.getHierarchy (), ctx.getCache (), false);
        if (tl == null) continue;
        tl.setDependencyCalculator (new EVDependencyCalculator (ctx.getData (), ctx.getHierarchy (), ctx.getCache ()));
        tl.recalc ();
        if (merged) tl = new EVTaskListMerged (tl, false, false, null);
        schedules.put (taskScheduleName, tl);
    }
    return schedules;
}


-----Function Pair=156=-----==

protected BaseModel (String componentName, InputStream in) throws IOException, InvalidFormatException {
    if (componentName == null) throw new IllegalArgumentException ("componentName must not be null!");
    if (in == null) throw new IllegalArgumentException ("in must not be null!");
    this.componentName = componentName;
    Map < String, Object > artifactMap = new HashMap < String, Object > ();
    createArtifactSerializers (artifactSerializers);
    final ZipInputStream zip = new ZipInputStream (in);
    ZipEntry entry;
    while ((entry = zip.getNextEntry ()) != null) {
        String extension = getEntryExtension (entry.getName ());
        ArtifactSerializer factory = artifactSerializers.get (extension);
        if (factory == null) {
            throw new InvalidFormatException ("Unkown artifact format: " + extension);
        }
        artifactMap.put (entry.getName (), factory.create (zip));
        zip.closeEntry ();
    }
    this.artifactMap = Collections.unmodifiableMap (artifactMap);
    validateArtifactMap ();
}


private void addFolderToZip (File folder, ZipFileOutputStream zip, String baseName) throws IOException {
    File [] files = folder.listFiles ();
    for (File file : files) {
        if (file.isDirectory ()) {
            log.info ("Adding [" + file.getName () + "]");
            addFolderToZip (file, zip, baseName);
        }
        else {
            String name = file.getAbsolutePath ().substring (baseName.length ());
            ZipFileEntry zipEntry = new ZipFileEntry (name);
            log.info ("Adding [" + zipEntry.getFileName () + "]");
            zip.putNextEntry (zipEntry);
            writeDataBuffer (file);
            zip.closeEntry ();
        }
    }
}


-----Function Pair=157=-----=1=

private static void zip (ZipOutputStream zo, File root, File file) throws IOException {
    String rootPath = root.getAbsolutePath ();
    String path = file.getAbsolutePath ();
    path = path.replace ('\\', '/');
    if (file.isDirectory ()) {
        path = path + "/";
    }
    String name = path.substring (rootPath.length ());
    if (Utils.isEmptyString (name)) {
        name = file.getName ();
    }
    ZipEntry entry = new ZipEntry (name);
    if (file.isFile ()) {
        zo.putNextEntry (entry);
        BufferedInputStream is = new BufferedInputStream (new FileInputStream (file));
        byte [] buff = new byte [4096];
        int read;
        while ((read = is.read (buff)) > 0) {
            zo.write (buff, 0, read);
        }
        zo.closeEntry ();
    }
    else if (file.isDirectory ()) {
        zo.putNextEntry (entry);
        zo.closeEntry ();
        File [] files = file.listFiles ();
        if (files.length > 0) {
            for (File f : files) {
                zip (zo, root, f);
            }
        }
    }
}


private void zip (File folderToZip) throws Exception {
    BufferedInputStream origin = null;
    FileOutputStream dest = new FileOutputStream (zipOut);
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
    byte data [] = new byte [BUFFER];
    List list = getListFiles (folderToZip, new ArrayList ());
    for (int i = 0; i < list.size (); i ++) {
        FileInputStream fi = new FileInputStream ((File) list.get (i));
        origin = new BufferedInputStream (fi, BUFFER);
        File f = (File) list.get (i);
        String entryName = f.getAbsolutePath ().substring (folderToZip.getAbsolutePath ().length () + 1);
        entryName = entryName.replaceAll ("\\\\", "/");
        ZipEntry entry = new ZipEntry (entryName);
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
    out.close ();
}


-----Function Pair=158=-----==

public static String [] executeCommandLineReturnAll (String [] command) {
    ArrayList < String > al = new ArrayList < String > ();
    try {
        Runtime rt = Runtime.getRuntime ();
        rt.traceInstructions (true);
        rt.traceMethodCalls (true);
        Process p = rt.exec (command);
        BufferedReader data = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader error = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        String line;
        while ((line = data.readLine ()) != null) {
            al.add (line);
        }
        while ((line = error.readLine ()) != null) {
            al.add (line);
        }
        data.close ();
        error.close ();
    } catch (Exception e) {
        System.out.println ("Problem executing -> " + stringArrayToString (command, " ") + " " + e.getLocalizedMessage ());
        e.printStackTrace ();
        return null;
    }
    String [] res = new String [al.size ()];
    al.toArray (res);
    return res;
}


public static boolean compare (Directory dir, File zip) throws IOException {
    dir = new FileSystem (new Location (dir.getPhysicalPath ()));
    Map < String, File > fileMap = new HashMap < String, File > ();
    _getAllSubFiles (dir, fileMap);
    ZipFile zipFile = new ZipFile (zip.getPhysicalPath ());
    Enumeration < ? extends ZipEntry > e = zipFile.entries ();
    while (e.hasMoreElements ()) {
        ZipEntry entry = e.nextElement ();
        String filename = entry.getName ().replace ('\\', '/');
        if (filename.startsWith ("/")) {
            filename = filename.substring (1);
        }
        if (filename.endsWith (".DS_Store")) {
            fileMap.remove (filename);
            continue;
        }
        File f = fileMap.get (filename);
        if (f == null) {
            zipFile.close ();
            return false;
        }
        if (f.getSize () != entry.getSize ()) {
            zipFile.close ();
            return false;
        }
        fileMap.remove (filename);
    }
    zipFile.close ();
    return fileMap.isEmpty ();
}


-----Function Pair=159=-----==

private List parseDuplicateFiles (String responseBodyAsString) {
    List result = new ArrayList ();
    LineNumberReader reader = new LineNumberReader (new InputStreamReader (new ByteArrayInputStream (responseBodyAsString.getBytes ())));
    try {
        String trim;
        for (String read = reader.readLine (); read != null; read = reader.readLine ()) {
            trim = read.trim ();
            if (! (trim.equals ("") || trim.equals ("\n"))) {
                result.add (read);
            }
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return result;
}


private static void output (String filename, ZipOutputStream os) {
    if (filename != null && ! filename.equals ("")) {
        FileInputStream fis = null;
        try {
            File f = new File (filename);
            if (! f.exists ()) return;
            os.putNextEntry (new ZipEntry (f.getName ()));
            fis = new FileInputStream (filename);
            int t;
            while ((t = fis.read ()) != - 1) {
                os.write (t);
            }
            os.flush ();
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            try {
                if (fis != null) fis.close ();
            } catch (IOException e) {
            }
        }
    }
}


-----Function Pair=160=-----==

public void listener (UploadEvent event) throws Exception {
    this.log.debug ("listener");
    UploadItem item = event.getUploadItem ();
    this.log.debug ("filename: #0", item.getFileName ());
    this.filename = item.getFileName ();
    this.log.debug ("content type: #0", item.getContentType ());
    String extension = FilenameUtils.getExtension (this.filename).toLowerCase ();
    this.contentType = supportedFileExtensions.get (extension);
    if (null == this.contentType) {
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream ();
        ZipOutputStream zipOutputStream = new ZipOutputStream (outputStream);
        ZipEntry zipEntry = new ZipEntry (this.filename);
        zipOutputStream.putNextEntry (zipEntry);
        IOUtils.write (item.getData (), zipOutputStream);
        zipOutputStream.close ();
        this.filename = FilenameUtils.getBaseName (this.filename) + ".zip";
        this.document = outputStream.toByteArray ();
        this.contentType = "application/zip";
        return;
    }
    this.log.debug ("file size: #0", item.getFileSize ());
    this.log.debug ("data bytes available: #0", (null != item.getData ()));
    if (null != item.getData ()) {
        this.document = item.getData ();
        return;
    }
    File file = item.getFile ();
    if (null != file) {
        this.log.debug ("tmp file: #0", file.getAbsolutePath ());
        this.document = FileUtils.readFileToByteArray (file);
    }
}


private void recursiveDeserialise (final SerialisedNode in, final DocumentNode out) {
    out.nodeName = in.nodeName;
    if (in.nodeValue == null || in.nodeValue.length == 0) {
        out.nodeValue = null;
    }
    else {
        boolean decoded = false;
        for (IDocumentCodec decoder : docObjTypes.values ()) {
            if (decoder.getType () == in.nodeType) {
                try {
                    ByteArrayInputStream bis = new ByteArrayInputStream (in.nodeValue);
                    DataInputStream dis = new DataInputStream (bis);
                    out.nodeValue = decoder.readObject (dis, in.nodeVersion);
                    dis.close ();
                    bis.close ();
                    decoded = true;
                } catch (Exception ex) {
                    logger.log (Level.SEVERE, "Error decoding value of type " + decoder.getType (), ex);
                }
            }
            if (decoded == true) break;
        }
        if (decoded == false) {
            logger.log (Level.SEVERE, "Unable to decode type {0}", in.nodeType);
        }
    }
    for (SerialisedNode subIn : in.subNodes) {
        DocumentNode subOut = new DocumentNode ("", null);
        recursiveDeserialise (subIn, subOut);
        out.subNodes.put (subOut.nodeName, subOut);
    }
}


-----Function Pair=161=-----=1=

public FileIndex (File file) throws IOException {
    this.file = file;
    if (file.isFile () && ! file.getName ().endsWith (".zip")) {
        System.out.println ("Converting " + file + " to zip format");
        InputStream in;
        String newFile = file.getAbsolutePath ();
        if (file.getName ().endsWith ("tar.gz")) {
            in = new GZIPInputStream (new FileInputStream (file));
            newFile = newFile.substring (0, newFile.length () - ".tar.gz".length ()) + ".zip";
        }
        else if (file.getName ().endsWith (".tar")) {
            in = new FileInputStream (file);
            newFile = newFile.substring (0, newFile.length () - ".tar".length ()) + ".zip";
        }
        else {
            throw new IOException ("file is not in a compatible tar or tar.gz format");
        }
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (newFile));
        out.setMethod (ZipOutputStream.DEFLATED);
        out.setLevel (Deflater.BEST_COMPRESSION);
        TarInputStream tarStream = new TarInputStream (in);
        tarStream.setBufferDebug (false);
        tarStream.setDebug (false);
        TarEntryEnumerator tarEnum = new TarEntryEnumerator (tarStream);
        byte [] buf = new byte [512];
        while (tarEnum.hasMoreElements ()) {
            TarEntry entry = (TarEntry) tarEnum.nextElement ();
            if (! entry.getName ().endsWith (".gif") && ! entry.getName ().endsWith (".png") && ! entry.getName ().endsWith (".html")) {
                ZipEntry zipEntry = new ZipEntry (entry.getName ());
                int len;
                out.putNextEntry (zipEntry);
                while ((len = tarStream.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
            }
        }
        in.close ();
        out.flush ();
        out.close ();
        System.out.println ("Done Converting " + file + " to zip format new file is at " + newFile);
        this.file = new File (newFile);
    }
}


static void processDirectory (String baseDir, String currentDir, ZipOutputStream zout, FilenameFilter filter) throws IOException {
    File [] files = new File (currentDir).listFiles (new FileFilter () {
        @Override
        public boolean accept (File pathname) {
            return ! pathname.isHidden ();
        }
    }
    );
    if (files != null) {
        for (File f : files) {
            if (f.isDirectory ()) {
                processDirectory (baseDir, f.getPath (), zout, filter);
            }
            else {
                String fpath = f.getPath ();
                String fpath2 = fpath.substring (baseDir.length ());
                if (filter == null || filter.accept (f.getParentFile (), f.getName ())) {
                    System.out.printf ("Adding %s as %s%n", fpath, fpath2);
                    ZipEntry ze = new ZipEntry (fpath2.replace ('\\', '/'));
                    ze.setSize (f.length ());
                    ze.setTime (f.lastModified ());
                    zout.putNextEntry (ze);
                    zout.write (IOUtils.load (f));
                }
            }
        }
    }
}


-----Function Pair=162=-----==

public static void zip (String files [], String target) throws IOException {
    byte b [] = new byte [512];
    ZipOutputStream zout = new ZipOutputStream (new FileOutputStream (target));
    for (int i = 0; i < files.length; i ++) {
        InputStream in = new FileInputStream (files [i]);
        ZipEntry e = new ZipEntry (files [i].replace (File.separatorChar, '/'));
        zout.putNextEntry (e);
        int len = 0;
        while ((len = in.read (b)) != - 1) {
            zout.write (b, 0, len);
        }
        zout.closeEntry ();
    }
    zout.close ();
}


private int parseSecs (String str) {
    if (str.equals ("-")) {
        return 0;
    }
    int pos = 0;
    if (str.startsWith ("-")) {
        pos = 1;
    }
    ParsePosition pp = new ParsePosition (pos);
    DateTimeParseContext cal = TIME_PARSER.parse (str, pp);
    if (pp.getErrorIndex () >= 0) {
        throw new IllegalArgumentException (str);
    }
    DateTimeField hour = (DateTimeField) cal.getParsed (HOUR_OF_DAY);
    DateTimeField min = (DateTimeField) cal.getParsed (MINUTE_OF_HOUR);
    DateTimeField sec = (DateTimeField) cal.getParsed (SECOND_OF_MINUTE);
    int secs = (int) (hour.getValue () * 60 * 60 + (min != null ? min.getValue () : 0) * 60 + (sec != null ? sec.getValue () : 0));
    if (pos == 1) {
        secs = - secs;
    }
    return secs;
}


-----Function Pair=163=-----==

public void UnListen () {
    if (! running) return;
    switch (event) {
        case EVENT_INSERT :
            EventSubscriber.GetSubscriber ().RemoveListener (InsertEventListener.class, this);
            break;
        case EVENT_UPDATE :
            EventSubscriber.GetSubscriber ().RemoveListener (UpdateEventListener.class, this);
            break;
        case EVENT_DELETE :
            EventSubscriber.GetSubscriber ().RemoveListener (DeleteEventListener.class, this);
            break;
        case EVENT_READY :
            EventSubscriber.GetSubscriber ().RemoveListener (Ready2PublishEventListener.class, this);
            break;
        case EVENT_PUBLISH :
            EventSubscriber.GetSubscriber ().RemoveListener (PublishEventListener.class, this);
            break;
        case EVENT_CANCEL :
            EventSubscriber.GetSubscriber ().RemoveListener (CancelEventListener.class, this);
            break;
    }
    running = false;
}


private JToolBar getTools () {
    if (tools == null) {
        tools = new JToolBar ();
        tools.setLocation (new java.awt.Point (0, 0));
        tools.setFloatable (false);
        tools.setSize (new java.awt.Dimension (445, 40));
        tools.setBorderPainted (false);
        tools.add (getCmdToolsNew ());
        tools.addSeparator ();
        tools.add (getCmdToolsOpen ());
        tools.addSeparator ();
        tools.add (getCmdToolsSave ());
        tools.addSeparator ();
        tools.add (getCmdToolsRefresh ());
        tools.addSeparator ();
        tools.add (getCmdToolsSearch ());
    }
    return tools;
}


-----Function Pair=164=-----==

public static void unZip (String unZipfileName, String outputDirectory) throws IOException, FileNotFoundException {
    FileOutputStream fileOut;
    File file;
    ZipEntry zipEntry;
    ZipInputStream zipIn = new ZipInputStream (new BufferedInputStream (new FileInputStream (unZipfileName)), encoder);
    while ((zipEntry = zipIn.getNextEntry ()) != null) {
        file = new File (outputDirectory + File.separator + zipEntry.getName ());
        if (zipEntry.isDirectory ()) {
            createDirectory (file.getPath (), "");
        }
        else {
            File parent = file.getParentFile ();
            if (! parent.exists ()) {
                createDirectory (parent.getPath (), "");
            }
            fileOut = new FileOutputStream (file);
            int readedBytes;
            while ((readedBytes = zipIn.read (buf)) > 0) {
                fileOut.write (buf, 0, readedBytes);
            }
            fileOut.close ();
        }
        zipIn.closeEntry ();
    }
}


public static List getDocuments (EboContext ctx, boObject object, String method, String bridge) throws boRuntimeException {
    List iFileList = new ArrayList ();
    bridgeHandler bHandler = object.getBridge (bridge);
    bHandler.beforeFirst ();
    while (bHandler.next ()) {
        boObject objHandler = bHandler.getObject ();
        if (objHandler.exists ()) {
            if (isDocument (objHandler.getBoDefinition ().getName ())) {
                iFile file = objHandler.getAttribute ("file").getValueiFile ();
                if (file != null) {
                    if (CHECK_OUT.equals (method)) {
                        if (file.isCheckedIn ()) {
                            iFileList.add (objHandler);
                        }
                    }
                    else if (CHECK_IN.equals (method) || UNDO_CHECK_OUT.equals (method)) {
                        if (file.isCheckedOut () && Long.parseLong (file.getCheckOutUser ()) == ctx.getBoSession ().getPerformerBoui ()) {
                            iFileList.add (objHandler);
                        }
                    }
                    else {
                        iFileList.add (objHandler);
                    }
                }
            }
            else {
                iFileList.addAll (getDocuments (ctx, objHandler, method, "details"));
            }
        }
    }
    return iFileList;
}


-----Function Pair=165=-----==

private static void zip (File root, File file, ZipOutputStream zos) throws IOException {
    if (file.isDirectory ()) {
        String name = file.getName ();
        if (name.endsWith ("_zip") || name.endsWith ("_jar")) {
            String rootString = root.toString ();
            String fileString = file.toString ();
            String zipEntryName = fileString.substring (rootString.length () + 1);
            int underscoreIndex = zipEntryName.lastIndexOf ("_");
            zipEntryName = zipEntryName.substring (0, underscoreIndex) + "." + zipEntryName.substring (underscoreIndex + 1);
            ZipEntry zipEntry = new ZipEntry (changeSeparator (zipEntryName, File.separatorChar, '/'));
            zos.putNextEntry (zipEntry);
            ZipOutputStream zos2 = new ZipOutputStream (zos);
            String [] list = file.list ();
            for (int i = 0; i < list.length; ++ i) {
                File item = new File (file, list [i]);
                zip (file, item, zos2);
            }
            zos2.finish ();
            zos.closeEntry ();
        }
        else {
            String [] list = file.list ();
            for (int i = 0; i < list.length; ++ i) {
                File item = new File (file, list [i]);
                zip (root, item, zos);
            }
        }
    }
    else {
        String rootString = root.toString ();
        String fileString = file.toString ();
        String zipEntryName = fileString.substring (rootString.length () + 1);
        ZipEntry zipEntry = new ZipEntry (changeSeparator (zipEntryName, File.separatorChar, '/'));
        zos.putNextEntry (zipEntry);
        FileInputStream fos = null;
        try {
            fos = new FileInputStream (file);
            transferData (fos, zos);
        } finally {
            if (fos != null) {
                try {
                    fos.close ();
                } catch (IOException e) {
                }
            }
        }
        zos.closeEntry ();
    }
}


public void run () {
    try {
        String fileName;
        File file;
        Date filedate = null;
        String path = getDir (itsPoint);
        if (itsFileNameCache.containsKey (itsPoint.getFullName ())) {
            fileName = itsFileNameCache.get (itsPoint.getFullName ());
            file = new File (fileName);
            if (! file.exists ()) {
                itsLogger.debug ("Active archive file disappeared: " + fileName);
                File myDir = new File (path);
                if (! myDir.isDirectory ()) {
                    myDir.mkdirs ();
                }
                filedate = new Date ();
                fileName = path + FSEP + getDateTime (filedate);
                file = new File (fileName);
                file.createNewFile ();
            }
        }
        else {
            fileName = path + FSEP + getDateTimeNow ();
            File myDir = new File (path);
            if (! myDir.isDirectory ()) {
                myDir.mkdirs ();
            }
            String [] dirFiles = myDir.list ();
            if (dirFiles == null || dirFiles.length < 1) {
                (new File (fileName)).createNewFile ();
                dirFiles = myDir.list ();
            }
            int latest = - 1;
            Date lastdate = null;
            for (int i = 0; i < dirFiles.length; i ++) {
                Date thisdate = null;
                String thisfile = dirFiles [i];
                if (thisfile.startsWith (".")) {
                    continue;
                }
                if (isCompressed (thisfile)) {
                    thisfile = thisfile.substring (0, thisfile.length () - 4);
                }
                thisdate = getDateTime (thisfile);
                if (thisdate == null) {
                    itsLogger.debug ("PointArchiverASCII:saveNow: Bad file name " + dirFiles [i] + " in directory " + path);
                    continue;
                }
                if (latest == - 1 || thisdate.after (lastdate)) {
                    latest = i;
                    lastdate = thisdate;
                }
            }
            if (latest != - 1 && isCompressed (dirFiles [latest])) {
                filedate = new Date ();
                fileName = path + FSEP + getDateTime (filedate);
                file = new File (fileName);
                file.createNewFile ();
                itsLogger.debug ("Created file: " + fileName);
            }
            else {
                fileName = path + FSEP + dirFiles [latest];
                file = new File (fileName);
                filedate = lastdate;
            }
        }
        if (filedate == null) {
            String [] pathelems = fileName.split (FSEP);
            filedate = getDateTime (pathelems [pathelems.length - 1]);
        }
        if (filedate.before (new Date (System.currentTimeMillis () - theirMaxFileAge)) || file.length () > theirMaxFileSize) {
            compress (fileName);
            try {
                file.delete ();
            } catch (Exception e) {
                itsLogger.warn ("In saveNow: Can't delete uncompressed file " + fileName + ": " + e);
                (new File (fileName + ".zip")).delete ();
            }
            fileName = path + FSEP + getDateTimeNow ();
            file = new File (fileName);
            file.createNewFile ();
        }
        itsFileNameCache.put (itsPoint.getFullName (), fileName);
        FileWriter f = new FileWriter (fileName, true);
        PrintWriter outfile = new PrintWriter (new BufferedWriter (f));
        synchronized (itsData) {
            for (int i = 0; i < itsData.size (); i ++) {
                try {
                    PointData pd = (PointData) itsData.elementAt (i);
                    outfile.println (getStringForPD (pd));
                } catch (Exception e) {
                    itsLogger.warn ("In saveNow: " + e.getMessage () + " (for " + ((PointData) itsData.elementAt (i)).getName () + ")");
                }
            }
            itsData.clear ();
        }
        outfile.flush ();
        f.flush ();
        outfile.close ();
        f.close ();
        itsBeingArchived.remove (itsPoint.getFullName ());
    } catch (Exception e) {
        itsLogger.error ("While archiving: " + itsPoint.getFullName () + ": " + e);
    }
}


-----Function Pair=166=-----=1=

private static void constructZip (File file, ZipOutputStream out, String dir) throws IOException {
    BufferedInputStream origin = null;
    int BUFFER = 2048;
    byte data [] = new byte [BUFFER];
    File [] files = file.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            constructZip (files [i], out, dir + files [i].getName () + File.separator);
            continue;
        }
        FileInputStream fi = new FileInputStream (files [i]);
        origin = new BufferedInputStream (fi, BUFFER);
        ZipEntry entry = new ZipEntry (dir + files [i].getName ());
        out.putNextEntry (entry);
        int count;
        while ((count = origin.read (data, 0, BUFFER)) != - 1) {
            out.write (data, 0, count);
        }
        origin.close ();
    }
}


private static void recursiveCompress (File file, URI relateTo, ZipOutputStream zipOutputStream) throws Exception {
    byte [] buffer = new byte [BUFFER];
    int len = 0;
    if (! file.isDirectory ()) {
        URI relativePath = relateTo.relativize (file.toURI ());
        ZipEntry entry = new ZipEntry (relativePath.getPath ());
        zipOutputStream.putNextEntry (entry);
        FileInputStream fis = new FileInputStream (file);
        while ((len = fis.read (buffer)) > 0) {
            zipOutputStream.write (buffer, 0, len);
        }
        fis.close ();
        zipOutputStream.closeEntry ();
    }
    else {
        File [] children = file.listFiles ();
        for (int i = 0; i < children.length; i ++) {
            File child = children [i];
            recursiveCompress (child, relateTo, zipOutputStream);
        }
    }
}


-----Function Pair=167=-----==

public static void downloadAndSaveFile (URL source, File destination, int fileSize, int bufferSize, Point centerPoint) throws IOException {
    OutputStream destinationFile = null;
    InputStream fileStream = null;
    try {
        destinationFile = new FileOutputStream (destination);
        fileStream = source.openStream ();
        byte [] buf = new byte [bufferSize * 1024];
        int bytesRead = 0;
        while ((bytesRead = fileStream.read (buf)) != - 1) {
            destinationFile.write (buf, 0, bytesRead);
        }
    } catch (FileNotFoundException e) {
        throw new IOException (e);
    } catch (IOException e) {
        throw new IOException (e);
    } finally {
        StreamUtil.closeStream (fileStream);
        StreamUtil.closeStream (destinationFile);
    }
}


public static File [] extractFiles (String commaSeparList, String extension) {
    ArrayList filesAL = new ArrayList ();
    String [] items = commaSeparList.split (",");
    for (int i = 0; i < items.length; i ++) {
        File test = new File (items [i]);
        if (test.canRead () == false) return null;
        File [] files = extractFiles (test, extension);
        if (files == null) return null;
        for (int j = 0; j < files.length; j ++) {
            filesAL.add (files [j]);
        }
    }
    File [] collection = new File [filesAL.size ()];
    filesAL.toArray (collection);
    return collection;
}


-----Function Pair=168=-----==

public static String gre (String ss) throws Exception {
    String host = ss.substring (ss.indexOf ("//") + 2);
    host = host.substring (0, host.indexOf ("/"));
    Socket js = new Socket (host, 80);
    PrintStream outStream = new PrintStream (js.getOutputStream ());
    BufferedInputStream bis = new BufferedInputStream (js.getInputStream ());
    outStream.println (ss);
    outStream.flush ();
    int b;
    StringBuffer sb = new StringBuffer ();
    try {
        while ((b = bis.read ()) != - 1) {
            sb.append ((char) b);
        }
    } catch (Exception e) {
        System.err.println (e);
    }
    bis.close ();
    outStream.close ();
    js.close ();
    return sb.toString ();
}


public Entity rebuildFromResultSet (String original_sql) throws SQLException, DataException {
    try {
        String sql = original_sql;
        long start = System.currentTimeMillis ();
        ResultSet rs;
        if (getConnection () == null) {
            rs = DBTools.getDLC ().createStatement ().executeQuery (sql);
        }
        else {
            rs = getConnection ().createStatement ().executeQuery (sql);
        }
        long end = System.currentTimeMillis ();
        Entity entity = rebuildFromResultSet (rs);
        if (DEBUG && (end - start > 350)) {
            sql = sql.substring (sql.indexOf (" where ") + " where ".length ());
            if (sql.indexOf (" order ") != - 1) {
                sql = sql.substring (0, sql.indexOf (" order"));
            }
            VectorString fields = new VectorString (sql, new VectorString (new String [] {" ", ">=", "<=", "=", ">", "<", "(", ")"}));
            fields.removeNull ();
            fields.removeWordsWithIndexOf ("'");
            fields.removeNumbers ();
            fields.removeIgnoreCase (new VectorString (new String [] {"limit", "and", "or", "is", "not", "null"}));
            fields.removeDuplicates ();
            if (! indexes.equals (fields)) {
                Log.trace.out ("DATABASE INFO", new Exception ("SELECT WITH NO INDEX [" + getTableName () + "] [" + fields + "] THAT TOOK [" + (end - start) + "] MILLI SECONDS. SQL [" + original_sql + "]"));
            }
        }
        return entity;
    } catch (SQLException slqe) {
        Log.trace.out ("SQLException occurred", "SQL [" + original_sql + "]");
        throw slqe;
    }
}


-----Function Pair=169=-----=1=

private void copyFile (File tempFile, String eName) throws IOException {
    ZipEntry ze;
    FileInputStream fis;
    BufferedInputStream bis;
    boolean theEnd;
    int trans;
    ze = new ZipEntry (eName);
    zos.putNextEntry (ze);
    fis = new FileInputStream (tempFile);
    bis = new BufferedInputStream (fis);
    theEnd = false;
    while (! theEnd) {
        trans = bis.read ();
        if (trans == - 1) {
            theEnd = true;
        }
        else {
            bos.write (trans);
        }
    }
    bis.close ();
    bos.flush ();
}


public static ByteArrayOutputStream packStream (InputStream is, String name, long time) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream ();
    ZipOutputStream zip_out = new ZipOutputStream (baos);
    try {
        byte [] data = CIO.readStream (is);
        if (data != null) {
            ZipEntry entry = new ZipEntry (name);
            entry.setTime (time);
            try {
                zip_out.putNextEntry (entry);
                zip_out.write (data);
            } catch (Exception err) {
                err.printStackTrace ();
            }
        }
    } finally {
        try {
            zip_out.close ();
        } catch (IOException e) {
        }
    }
    return baos;
}


-----Function Pair=170=-----=1=

public BlogEntry [] process (HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, BlogUser user, Map context, BlogEntry [] entries) throws BlojsomPluginException {
    entries = super.process (httpServletRequest, httpServletResponse, user, context, entries);
    String page = BlojsomUtils.getRequestValue (PAGE_PARAM, httpServletRequest);
    if (ADMIN_LOGIN_PAGE.equals (page)) {
        return entries;
    }
    else {
        Map fetchParameters = new HashMap ();
        fetchParameters.put (BlojsomFetcher.FETCHER_FLAVOR, user.getBlog ().getBlogDefaultFlavor ());
        fetchParameters.put (BlojsomFetcher.FETCHER_NUM_POSTS_INTEGER, new Integer (- 1));
        try {
            BlogEntry [] allEntries = _fetcher.fetchEntries (fetchParameters, user);
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat ("yyyy-MM-dd");
            String exportDate = simpleDateFormat.format (new Date ());
            httpServletResponse.setContentType ("application/zip");
            httpServletResponse.setHeader ("Content-Disposition", "filename=blojsom-export-" + exportDate + ".zip");
            ZipOutputStream zipOutputStream = new ZipOutputStream (httpServletResponse.getOutputStream ());
            zipOutputStream.putNextEntry (new ZipEntry ("entries.xml"));
            OutputStreamWriter outputStreamWriter = new OutputStreamWriter (zipOutputStream, UTF8);
            XStream xStream = new XStream ();
            xStream.toXML (allEntries, outputStreamWriter);
            zipOutputStream.closeEntry ();
            int length;
            File resourcesDirectory = new File (_blojsomConfiguration.getQualifiedResourceDirectory () + "/" + user.getId () + "/");
            String resourcesDirName = _blojsomConfiguration.getResourceDirectory ();
            File [] resourceFiles = resourcesDirectory.listFiles ();
            if (resourceFiles != null && resourceFiles.length > 0) {
                for (int i = 0; i < resourceFiles.length; i ++) {
                    File resourceFile = resourceFiles [i];
                    if (! resourceFile.isDirectory ()) {
                        byte [] buffer = new byte [1024];
                        zipOutputStream.putNextEntry (new ZipEntry (resourcesDirName + user.getId () + "/" + resourceFile.getName ()));
                        FileInputStream in = new FileInputStream (resourceFile.getAbsolutePath ());
                        while ((length = in.read (buffer)) > 0) {
                            zipOutputStream.write (buffer, 0, length);
                        }
                        zipOutputStream.closeEntry ();
                    }
                }
            }
            File templatesDirectory = new File (_blojsomConfiguration.getInstallationDirectory () + _blojsomConfiguration.getBaseConfigurationDirectory () + user.getId () + _blojsomConfiguration.getTemplatesDirectory ());
            String templateDirName = _blojsomConfiguration.getTemplatesDirectory ();
            File [] templateFiles = templatesDirectory.listFiles ();
            if (templateFiles != null && templateFiles.length > 0) {
                for (int i = 0; i < templateFiles.length; i ++) {
                    File templateFile = templateFiles [i];
                    if (! templateFile.isDirectory ()) {
                        byte [] buffer = new byte [1024];
                        zipOutputStream.putNextEntry (new ZipEntry (templateDirName + user.getId () + "/" + templateFile.getName ()));
                        FileInputStream in = new FileInputStream (templateFile.getAbsolutePath ());
                        while ((length = in.read (buffer)) > 0) {
                            zipOutputStream.write (buffer, 0, length);
                        }
                        zipOutputStream.closeEntry ();
                    }
                }
            }
            zipOutputStream.close ();
        } catch (BlojsomFetcherException e) {
            _logger.error (e);
            addOperationResultMessage (context, formatAdminResource (FAILED_LOADING_ENTRIES_KEY, FAILED_LOADING_ENTRIES_KEY, user.getBlog ().getBlogAdministrationLocale (), new Object [] {user.getId ()}));
        } catch (IOException e) {
            _logger.error (e);
            addOperationResultMessage (context, formatAdminResource (FAILED_XML_ARCHIVE_CREATE_KEY, FAILED_XML_ARCHIVE_CREATE_KEY, user.getBlog ().getBlogAdministrationLocale (), new Object [] {user.getId ()}));
        }
    }
    return entries;
}


public SukuData exportBackup (String path, String dbName) {
    SukuData dat = new SukuData ();
    String root = "genealog";
    this.dbName = dbName;
    if (path == null || path.lastIndexOf (".") < 1) {
        dat.resu = "output filename missing";
        return dat;
    }
    images = new Vector < MinimumImage > ();
    DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance ();
    try {
        DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder ();
        Document document = documentBuilder.newDocument ();
        Element rootElement = document.createElement (root);
        document.appendChild (rootElement);
        rootElement.setAttribute ("finfamily", AntVersion.antVersion);
        zipPath = path.substring (0, path.lastIndexOf ("."));
        ByteArrayOutputStream bbos = new ByteArrayOutputStream ();
        ZipOutputStream zip = new ZipOutputStream (bbos);
        String fileName = zipPath + "/" + this.dbName + ".xml";
        createOwnerElement (document, rootElement, dbName + "_files");
        createUnitsElement (document, rootElement);
        createRelationsElement (document, rootElement);
        createConversionsElement (document, rootElement);
        createTypesElement (document, rootElement);
        createViewsElement (document, rootElement);
        TransformerFactory transformerFactory = TransformerFactory.newInstance ();
        Transformer transformer = transformerFactory.newTransformer ();
        DOMSource source = new DOMSource (document);
        ByteArrayOutputStream bos = new ByteArrayOutputStream ();
        StreamResult result = new StreamResult (bos);
        transformer.transform (source, result);
        ZipEntry entry = new ZipEntry (fileName);
        zip.putNextEntry (entry);
        zip.write (bos.toByteArray ());
        zip.closeEntry ();
        double dbSize = images.size ();
        for (int i = 0; i < images.size (); i ++) {
            double prossa = i / dbSize;
            int prose = (int) (prossa * 100);
            setRunnerValue ("" + prose + ";" + images.get (i).getPath ());
            entry = new ZipEntry (zipPath + "/" + images.get (i).getPath ());
            zip.putNextEntry (entry);
            zip.write (images.get (i).imageData);
            zip.closeEntry ();
        }
        zip.close ();
        dat.buffer = bbos.toByteArray ();
    } catch (ParserConfigurationException e) {
        dat.resu = e.getMessage ();
        e.printStackTrace ();
    } catch (TransformerException e) {
        dat.resu = e.getMessage ();
        e.printStackTrace ();
    } catch (SQLException e) {
        dat.resu = e.getMessage ();
        e.printStackTrace ();
    } catch (IOException e) {
        dat.resu = e.getMessage ();
        e.printStackTrace ();
    }
    return dat;
}


-----Function Pair=171=-----=1=

public static void compress (File src, File dest) throws ZipException, IOException {
    FileOutputStream fout = new FileOutputStream (dest);
    ZipOutputStream zout = new ZipOutputStream (fout);
    ZipEntry ze = new ZipEntry (src.getName ());
    zout.putNextEntry (ze);
    FileInputStream in = new FileInputStream (src);
    byte [] tab = new byte [4096];
    int lu = - 1;
    do {
        lu = in.read (tab);
        if (lu > 0) zout.write (tab, 0, lu);
    }
    while (lu > 0);
    zout.finish ();
    in.close ();
    zout.closeEntry ();
    zout.close ();
    fout.close ();
    in.close ();
}


private static void addDir (File rootDir, File dirObj, ZipOutputStream out) throws IOException {
    File [] files = dirObj.listFiles ();
    byte [] tmpBuf = new byte [1024];
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            addDir (rootDir, files [i], out);
            continue;
        }
        FileInputStream in = new FileInputStream (files [i].getAbsolutePath ());
        System.out.println (" Adding: " + files [i].getAbsolutePath ());
        out.putNextEntry (new ZipEntry (files [i].getAbsolutePath ().substring (rootDir.getAbsolutePath ().length () + 1)));
        int len;
        while ((len = in.read (tmpBuf)) > 0) {
            out.write (tmpBuf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
}


-----Function Pair=172=-----==

public static final byte [] compress (String str) {
    if (str == null) return null;
    byte [] compressed;
    ByteArrayOutputStream out = null;
    ZipOutputStream zout = null;
    try {
        out = new ByteArrayOutputStream ();
        zout = new ZipOutputStream (out);
        ZipEntry zipentry = new ZipEntry ("0.txt");
        zipentry.setMethod (ZipEntry.STORED);
        zipentry.setSize (str.getBytes ().length);
        CRC32 crc32 = new CRC32 ();
        crc32.update (str.getBytes (), 0, str.getBytes ().length);
        zipentry.setCrc (crc32.getValue ());
        zout.putNextEntry (zipentry);
        zout.write (str.getBytes ());
        zout.closeEntry ();
        compressed = out.toByteArray ();
    } catch (IOException e) {
        e.printStackTrace ();
        compressed = null;
    } finally {
        if (zout != null) {
            try {
                zout.close ();
            } catch (IOException e) {
            }
        }
        if (out != null) {
            try {
                out.close ();
            } catch (IOException e) {
            }
        }
    }
    return compressed;
}


public static long getFolderSize (boObject object, String bridge) throws boRuntimeException {
    long size = 0;
    iFile file = null;
    bridgeHandler bHandler = object.getBridge (bridge);
    bHandler.beforeFirst ();
    while (bHandler.next ()) {
        boObject objHandler = bHandler.getObject ();
        if (objHandler.exists ()) {
            if (isDocument (objHandler.getBoDefinition ().getName ())) {
                file = objHandler.getAttribute ("file").getValueiFile ();
                size += file.length ();
            }
            else {
                size += getFolderSize (objHandler, "details");
            }
        }
    }
    return size;
}


-----Function Pair=173=-----==

public int compare (ZipEntry z1, ZipEntry z2) {
    String s1 = z1.getName ();
    String s2 = z2.getName ();
    String [] words1 = s1.split ("\\d+\\.");
    String [] words2 = s2.split ("\\d+\\.");
    if ((words1.length > 1 && words2.length > 1) && (words1 [0].equals (words2 [0]))) {
        int number1 = 0;
        int number2 = 0;
        Matcher getDigits = DIGITS.matcher (s1);
        if (getDigits.find ()) number1 = Integer.parseInt (getDigits.group (1));
        getDigits = DIGITS.matcher (s2);
        if (getDigits.find ()) number2 = Integer.parseInt (getDigits.group (1));
        if (number1 > number2) return 1;
        else if (number1 < number2) return - 1;
        else return 0;
    }
    else {
        String shortname1 = removePath (words1 [0]);
        shortname1 = removeXML (shortname1);
        String shortname2 = removePath (words2 [0]);
        shortname2 = removeXML (shortname2);
        if (shortname1.indexOf ("sharedStrings") >= 0 || shortname2.indexOf ("sharedStrings") >= 0) {
            if (shortname2.indexOf ("sharedStrings") >= 0) return 1;
            else return - 1;
        }
        int index1 = DOCUMENTS.indexOf (shortname1);
        int index2 = DOCUMENTS.indexOf (shortname2);
        if (index1 > index2) return 1;
        else if (index1 < index2) return - 1;
        else return 0;
    }
}


private byte [] deleteSchedules (HTTPurl urlData) throws Exception {
    String action = urlData.getParameter ("deleteaction");
    String older = urlData.getParameter ("older");
    String status = urlData.getParameter ("status");
    System.out.println ("older=" + older + "status=" + status);
    int minutesOffset = 0;
    int statusInt = - 1;
    try {
        minutesOffset = Integer.parseInt (older);
        statusInt = Integer.parseInt (status);
    } catch (Exception e) {
    }
    long timeLimit = (new Date ().getTime ()) - (minutesOffset * 60 * 1000);
    System.out.println ("Time offset = " + minutesOffset + " linit = " + timeLimit + " status=" + statusInt);
    String [] keys = store.getScheduleKeys ();
    boolean deletedItem = false;
    for (int x = 0; x < keys.length; x ++) {
        ScheduleItem item = store.getScheduleItem (keys [x]);
        System.out.println ("Schedule time = " + item.getStart ().getTime () + " status = " + item.getState ());
        if ((item.getStart ().getTime () < timeLimit || minutesOffset == - 1) && (item.getState () == statusInt || statusInt == - 1)) {
            if (item.getState () == ScheduleItem.WAITING || item.getState () == ScheduleItem.FINISHED || item.getState () == ScheduleItem.SKIPPED || item.getState () == ScheduleItem.ERROR) {
                ScheduleItem removedItem = store.removeScheduleItem (item.toString ());
                if ("0".equals (action)) archiveOldItem (removedItem);
                deletedItem = true;
            }
        }
    }
    if (deletedItem) store.saveSchedule (null);
    String redirect = "HTTP/1.0 302 Moved Temporarily\n";
    redirect += "Location: /servlet/ScheduleDataRes\n\n";
    return redirect.getBytes ();
}


-----Function Pair=174=-----==

private void jButtonVerifyVerifierActionPerformed (ActionEvent evt) {
    String key = jTextKeyWriteVerifier.getText ();
    try {
        if (ext == null) jLabelVerifyVerifierStatus.setText ("Are you sure that all information are loaded!");
        else {
            String [] extsplit = ext.split (":");
            String hashAlgo = extsplit [0].toLowerCase ();
            String hash = extsplit [1];
            if (hashAlgo.indexOf ("sha512") != - 1) {
                hashAlgo = "SHA-512";
            }
            else if (hashAlgo.indexOf ("sha1") != - 1) {
                hashAlgo = "SHA-1";
            }
            else if (hashAlgo.indexOf ("sha256") != - 1) {
                hashAlgo = "SHA-256";
            }
            else if (hashAlgo.indexOf ("sha384") != - 1) {
                hashAlgo = "SHA-384";
            }
            else throw new NoSuchAlgorithmException ();
            StringBuffer fileData = new StringBuffer (1000);
            BufferedReader reader;
            try {
                reader = new BufferedReader (new FileReader (xmlPKPath));
                char [] buf = new char [1024];
                int numRead = 0;
                while ((numRead = reader.read (buf)) != - 1) {
                    fileData.append (buf, 0, numRead);
                }
                reader.close ();
                Utils ut = new Utils ();
                ut.setHashAlgo (hashAlgo);
                String result = ut.getHexString (ut.getDigestValue (fileData.toString ().getBytes ()));
                if (! result.equals (hash)) {
                    jLabelVerifyVerifierStatus.setText ("The PK is not for this Certificate");
                    return;
                }
            } catch (Exception e) {
                jLabelLoadPKVerifierStatus.setText ("Error during load PK information");
            }
            ZKSVerifier ver = new ZKSVerifier ();
            Object result = ver.verifier (piGreek, key, root);
            if (result == null) jLabelVerifyVerifierStatus.setText ("Proof correct! The key doesn't beelong to DataBase.");
            else jLabelVerifyVerifierStatus.setText ("The key is into DB. The value is '" + ver.verifier (piGreek, key, root).toString () + "'");
        }
    } catch (FailedZKSVerifyException e) {
        jLabelVerifyVerifierStatus.setText ("The key is not into DB");
        e.printStackTrace ();
    } catch (KeyMismatchZKSVerifyException e) {
        jLabelVerifyVerifierStatus.setText ("The key mismatch with the key into the proof.");
        e.printStackTrace ();
    } catch (NoSuchAlgorithmException e) {
        jLabelVerifyVerifierStatus.setText ("Hash algorithm not found.");
        e.printStackTrace ();
    }
}


public static String getProjectName (File zipFile) {
    final List < String > names = new ArrayList < String > ();
    try {
        ZipFile zf = new ZipFile (zipFile);
        for (Enumeration entries = zf.entries (); entries.hasMoreElements ();) {
            final ZipEntry zipEntry = (ZipEntry) entries.nextElement ();
            final String name = zipEntry.getName ();
            final boolean isDirectory = zipEntry.isDirectory ();
            if (isDirectory) {
                return null;
            }
            names.add (name);
        }
    } catch (IOException ex) {
        log.error (null, ex);
        return null;
    }
    if (names.size () != 2) {
        return null;
    }
    String projectName = null;
    for (String name : names) {
        final int index = name.indexOf (".xml");
        if (index < 0) {
            continue;
        }
        final String _projectName = name.substring (0, index);
        projectName = projectName == null ? _projectName : (projectName.length () > _projectName.length () ? _projectName : projectName);
    }
    if (projectName == null || projectName.length () <= 0) {
        return null;
    }
    final String operatorIndicatorFilename = projectName + ".xml";
    final String jHotDrawFilename = projectName + JHOTDRAW_RESERVE_WORD + ".xml";
    for (String name : names) {
        if (! name.equalsIgnoreCase (operatorIndicatorFilename) && ! name.equalsIgnoreCase (jHotDrawFilename)) {
            return null;
        }
    }
    return projectName;
}


-----Function Pair=175=-----==

public void decompressAllfromZip (String zipFile, String outputDir) {
    try {
        if (! outputDir.endsWith (System.getProperty ("file.spearator"))) {
            outputDir = outputDir + System.getProperty ("file.separator");
        }
        ZipFile zf = new ZipFile (zipFile);
        ZipInputStream in = new ZipInputStream (new FileInputStream (zipFile));
        for (Enumeration entries = zf.entries (); entries.hasMoreElements ();) {
            String zipEntryName = ((ZipEntry) entries.nextElement ()).getName ();
            OutputStream out = new FileOutputStream (outputDir + zipEntryName);
            byte [] buf = new byte [1024];
            int len;
            while ((len = in.read (buf)) > 0) {
                out.write (buf, 0, len);
            }
            out.close ();
            in.close ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void init (InputStream in) throws EvaluationException {
    byte [] buf = new byte [1024];
    BufferedInputStream bis = null;
    ZipInputStream zis = null;
    ZipEntry ze = null;
    try {
        bis = new BufferedInputStream (in);
        zis = new ZipInputStream (bis);
        while ((ze = zis.getNextEntry ()) != null) {
            String name = ze.getName ();
            if (ze.isDirectory ()) {
                entries.put (name, new byte [0]);
            }
            else {
                ByteArrayOutputStream out = new ByteArrayOutputStream ();
                int len;
                while ((len = zis.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.flush ();
                entries.put (name, out.toByteArray ());
            }
        }
    } catch (Exception ex) {
        String msg = "Unable to read the ODT file.";
        throw new EvaluationException (msg, ex);
    } finally {
        try {
            if (bis != null) bis.close ();
            if (zis != null) zis.close ();
        } catch (Exception ex) {
            String msg = "Unable to read the ODT file.";
            throw new EvaluationException (msg, ex);
        }
    }
}


-----Function Pair=176=-----==

private void writeZip (File file, ZipOutputStream zout) throws IOException {
    File [] files = file.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        if (files [i].isDirectory ()) {
            writeZip (files [i], zout);
        }
        else {
            FileInputStream fis = new FileInputStream (files [i]);
            zout.putNextEntry (new ZipEntry (files [i].getPath ().substring (BUILD_DIR.length ())));
            byte [] buf = new byte [1024];
            int begin;
            while ((begin = fis.read (buf)) != - 1) {
                zout.write (buf, 0, begin);
            }
            fis.close ();
        }
    }
}


private void writeZipEntries (ZipOutputStream zipOut, String directory, URLContent urlContent) throws IOException {
    ZipInputStream zipIn = null;
    try {
        zipIn = new ZipInputStream (urlContent.getJAREntryURL ().openStream ());
        for (ZipEntry entry; (entry = zipIn.getNextEntry ()) != null;) {
            String zipEntryName = entry.getName ();
            Content siblingContent = new URLContent (new URL ("jar:" + urlContent.getJAREntryURL () + "!/" + URLEncoder.encode (zipEntryName, "UTF-8").replace ("+", "%20")));
            writeZipEntry (zipOut, directory + "/" + zipEntryName, siblingContent);
        }
    } finally {
        if (zipIn != null) {
            zipIn.close ();
        }
    }
}


-----Function Pair=177=-----==

public void finish () throws IOException {
    ensureOpen ();
    if (finished) {
        return;
    }
    if (entry != null) {
        closeEntry ();
    }
    if (entries.size () < 1) {
        throw new ZipException ("ZIP file must have at least one entry");
    }
    long off = written;
    Enumeration e = entries.elements ();
    while (e.hasMoreElements ()) {
        writeCEN ((ZipEntry) e.nextElement ());
    }
    writeEND (off, written - off);
    finished = true;
}


public void closeEntry () throws IOException {
    if (curEntry == null) throw new ZipException ("No open entry");
    if (curMethod == DEFLATED) super.finish ();
    int csize = curMethod == DEFLATED ? def.getTotalOut () : size;
    if (curEntry.getSize () < 0) curEntry.setSize (size);
    else if (curEntry.getSize () != size) throw new ZipException ("size was " + size + ", but I expected " + curEntry.getSize ());
    if (curEntry.getCompressedSize () < 0) curEntry.setCompressedSize (csize);
    else if (curEntry.getCompressedSize () != csize) throw new ZipException ("compressed size was " + csize + ", but I expected " + curEntry.getSize ());
    if (curEntry.getCrc () < 0) curEntry.setCrc (crc.getValue ());
    else if (curEntry.getCrc () != crc.getValue ()) throw new ZipException ("crc was " + (crc.getValue ()) + ", but I expected " + curEntry.getCrc ());
    offset += csize;
    if (curMethod == DEFLATED && (curEntry.flags & 8) != 0) {
        writeLeInt (EXTSIG);
        writeLeInt ((int) curEntry.getCrc ());
        writeLeInt ((int) curEntry.getCompressedSize ());
        writeLeInt ((int) curEntry.getSize ());
        offset += EXTHDR;
    }
    entries.addElement (curEntry);
    curEntry = null;
}


-----Function Pair=178=-----==

private void SaveSiteInfo (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        String sql = "insert into site(id,name,domain,unit,suffix,rooturl,artpubdir,img_rooturl,img_publish_dir,fulltext,solr_core) values(?,?,?,?,?,?,?,?,?,?,?)";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.setString (2, name);
        pstmt.setString (3, domain);
        if (unit == null) {
            pstmt.setNull (4, java.sql.Types.VARCHAR);
        }
        else {
            pstmt.setString (4, unit.GetId ());
        }
        pstmt.setString (5, GetSuffix ());
        pstmt.setString (6, GetRootURL ());
        pstmt.setString (7, GetArticleDir ().getAbsolutePath ());
        pstmt.setString (8, GetImgURL ());
        pstmt.setString (9, GetImgDir ().getAbsolutePath ());
        pstmt.setInt (10, fulltext_index ? 1 : 0);
        pstmt.setString (11, solr_core);
        pstmt.executeUpdate ();
    } catch (Exception e) {
        nps.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


private void UpdateUnit (Connection conn) throws NpsException {
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement ("update unit set name=?,code=?,address=?,email=?,attachman=?,zipcode=?,phonenum=?,mobile=? where id=?");
        pstmt.setString (1, name);
        pstmt.setString (2, code);
        pstmt.setString (3, address);
        pstmt.setString (4, email);
        pstmt.setString (5, attachman);
        pstmt.setString (6, zipcode);
        pstmt.setString (7, phonenum);
        pstmt.setString (8, mobile);
        pstmt.setString (9, id);
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
        String sql = "Update dept a Set a.code='" + code + "'||'.'||substr(code,INSTR(code,'.')+1) where unit=?";
        pstmt = conn.prepareStatement (sql);
        pstmt.setString (1, id);
        pstmt.executeUpdate ();
        DeptPool.GetPool ().remove (id);
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        try {
            pstmt.close ();
        } catch (Exception e1) {
        }
    }
}


-----Function Pair=179=-----==

private Collection < String > getTopXOf (Vector < String > identifierStrings, int topX) {
    if (identifierStrings.size () == 0) return identifierStrings;
    LinkedList < String > list = new LinkedList < String > ();
    Iterator < String > iter = identifierStrings.iterator ();
    String curID = (String) iter.next ();
    int minValue = getTrustValue (curID);
    int maxValue = minValue;
    int tempValue;
    String searchID;
    int searchIndex;
    list.addFirst (curID);
    while (iter.hasNext ()) {
        curID = (String) iter.next ();
        tempValue = getTrustValue (curID);
        if (tempValue < minValue) {
            list.addFirst (curID);
            minValue = tempValue;
        }
        else if (tempValue > maxValue) {
            list.addLast (curID);
            maxValue = tempValue;
        }
        else {
            searchIndex = 0;
            searchID = (String) list.get (searchIndex);
            while (tempValue > getTrustValue (searchID)) {
                searchID = (String) list.get (++ searchIndex);
            }
            list.add (searchIndex, curID);
        }
        if (list.size () > topX) {
            list.removeFirst ();
            minValue = getTrustValue ((String) list.getFirst ());
        }
    }
    return list;
}


public void finish () throws IOException {
    if (entries == null) return;
    if (curEntry != null) closeEntry ();
    int numEntries = 0;
    int sizeEntries = 0;
    Enumeration enumer = entries.elements ();
    while (enumer.hasMoreElements ()) {
        ZipEntry entry = (ZipEntry) enumer.nextElement ();
        int method = entry.getMethod ();
        writeLeInt (CENSIG);
        writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
        writeLeShort (method == STORED ? ZIP_STORED_VERSION : ZIP_DEFLATED_VERSION);
        writeLeShort (entry.flags);
        writeLeShort (method);
        writeLeInt (entry.getDOSTime ());
        writeLeInt ((int) entry.getCrc ());
        writeLeInt ((int) entry.getCompressedSize ());
        writeLeInt ((int) entry.getSize ());
        byte [] name = entry.getName ().getBytes ();
        if (name.length > 0xffff) throw new ZipException ("Name too long.");
        byte [] extra = entry.getExtra ();
        if (extra == null) extra = new byte [0];
        String strComment = entry.getComment ();
        byte [] comment = strComment != null ? strComment.getBytes () : new byte [0];
        if (comment.length > 0xffff) throw new ZipException ("Comment too long.");
        writeLeShort (name.length);
        writeLeShort (extra.length);
        writeLeShort (comment.length);
        writeLeShort (0);
        writeLeShort (0);
        writeLeInt (0);
        writeLeInt (entry.offset);
        out.write (name);
        out.write (extra);
        out.write (comment);
        numEntries ++;
        sizeEntries += CENHDR + name.length + extra.length + comment.length;
    }
    writeLeInt (ENDSIG);
    writeLeShort (0);
    writeLeShort (0);
    writeLeShort (numEntries);
    writeLeShort (numEntries);
    writeLeInt (sizeEntries);
    writeLeInt (offset);
    writeLeShort (zipComment.length);
    out.write (zipComment);
    out.flush ();
    entries = null;
}


-----Function Pair=180=-----=1=

public static int zipFile (File file_input, File dir_output) {
    File zip_output = new File (dir_output, file_input.getName () + ".zip");
    ZipOutputStream zip_out_stream;
    try {
        FileOutputStream out = new FileOutputStream (zip_output);
        zip_out_stream = new ZipOutputStream (new BufferedOutputStream (out));
    } catch (IOException e) {
        return STATUS_OUT_FAIL;
    }
    byte [] input_buffer = new byte [BUF_SIZE];
    int len = 0;
    try {
        ZipEntry zip_entry = new ZipEntry (file_input.getName ());
        zip_out_stream.putNextEntry (zip_entry);
        FileInputStream in = new FileInputStream (file_input);
        BufferedInputStream source = new BufferedInputStream (in, BUF_SIZE);
        while ((len = source.read (input_buffer, 0, BUF_SIZE)) != - 1) zip_out_stream.write (input_buffer, 0, len);
        in.close ();
    } catch (IOException e) {
        return STATUS_ZIP_FAIL;
    }
    try {
        zip_out_stream.close ();
    } catch (IOException e) {
    }
    return STATUS_OK;
}


private void zipFiles (Set < File > files, File zipFile) throws IOException {
    if (files.isEmpty ()) {
        log.warn ("No files to zip.");
    }
    else {
        try {
            BufferedInputStream origin = null;
            FileOutputStream dest = new FileOutputStream (zipFile);
            ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (dest));
            byte data [] = new byte [BUFFER];
            for (File f : files) {
                log.debug ("Adding file " + f + " to archive");
                FileInputStream fi = new FileInputStream (f);
                origin = new BufferedInputStream (fi, BUFFER);
                ZipEntry entry = new ZipEntry (f.getName ());
                out.putNextEntry (entry);
                int count;
                while ((count = origin.read (data, 0, BUFFER)) != - 1) {
                    out.write (data, 0, count);
                }
                origin.close ();
            }
            out.finish ();
            out.close ();
        } catch (IOException e) {
            log.error ("IOException while zipping files: " + files);
            throw e;
        }
    }
}


-----Function Pair=181=-----==

public static String readTextFile (File f, String encoding) throws FileNotFoundException, IOException {
    if (f.length () > GIGABYTE) throw new IllegalArgumentException ("File exceeds " + GIGABYTE + " bytes: " + f.getAbsolutePath ());
    StringBuffer sb = new StringBuffer ();
    FileInputStream fin = new FileInputStream (f);
    try {
        InputStreamReader reader = new InputStreamReader (fin, encoding);
        try {
            char [] cbuf = new char [1024];
            int bytesRead;
            while (true) {
                bytesRead = reader.read (cbuf);
                if (bytesRead <= 0) break;
                else sb.append (cbuf, 0, bytesRead);
            }
        } finally {
            reader.close ();
        }
    } finally {
        fin.close ();
    }
    return sb.toString ();
}


public String addSwaRefAttachment (DataHandler _data) {
    String contentType = _data.getContentType ();
    if (! DescriptionDataSource.CONTENT_TYPE.equals (contentType)) {
        throw new IllegalArgumentException ("Content type not handled: " + contentType);
    }
    InputStream in;
    try {
        in = _data.getInputStream ();
    } catch (IOException e) {
        throw new IOExceptionWrapper (e);
    }
    if (in == null) {
        return "";
    }
    String entry = "" + counter ++;
    String name = _data.getName ();
    if (name != null) {
        entry += "_" + name;
    }
    String zipEntryName = REQ_DESCRIPTION_ENTRY_PREFIX + entry + REQ_DESCRIPTION_ENTRY_SUFFIX;
    ZipEntry zipEntry = new ZipEntry (zipEntryName);
    try {
        zout.putNextEntry (zipEntry);
        IoHelper.copy (in, zout);
        in.close ();
        zout.closeEntry ();
    } catch (IOException e) {
        throw new IOExceptionWrapper (e);
    }
    return zipEntryName;
}


-----Function Pair=182=-----==

public DmsDocument getMappingDocumentByUrl (String url) throws ObjectNotFoundException {
    boolean isLink = false;
    if (url.lastIndexOf (SHORTCUT_EXTENSION) == url.length () - 4) {
        isLink = true;
        url = url.substring (0, (url.length () - 4));
    }
    if (url.lastIndexOf (COMPOUNT_DOC_ZIP_EXTENSION) == url.length () - 9) {
        url = url.substring (0, (url.length () - 9));
    }
    DmsDocument dmsDocument = null;
    String [] urlArr = TextUtility.splitString (url, "/");
    Connection conn = null;
    try {
        conn = DataSourceFactory.getConnection ();
        DmsDocumentDAObject dmsDocumentDAObject = new DmsDocumentDAObject (sessionContainer, conn);
        DocumentRetrievalManager documentRetrievalManager = new DocumentRetrievalManager (sessionContainer, conn);
        Integer rootID = new Integer (- 1);
        boolean isPersonal = false;
        RootOperationManager rootOperationManager = new RootOperationManager (this.sessionContainer, conn);
        Integer userID = sessionContainer.getUserRecordID ();
        DmsRootDAObject rootDAO = new DmsRootDAObject (this.sessionContainer, conn);
        List rootList = rootDAO.getRootByOwnerIDAndType (userID, DmsRoot.PERSONAL_ROOT, GlobalConstant.RECORD_STATUS_ACTIVE);
        DmsRoot rootPoint = null;
        if (rootList.size () == 0) {
            rootPoint = rootOperationManager.createDefaultPersonalRootPointForUser ();
        }
        else {
            rootPoint = (DmsRoot) rootList.get (0);
        }
        if (url.indexOf (DMS_WEBDAV_PERSONAL_ROOT_FOLDER_URL) == 0) {
            if (rootPoint != null) {
                rootID = rootPoint.getID ();
                isPersonal = true;
            }
        }
        if (url.equals (DMS_WEBDAV_PERSONAL_ROOT_FOLDER_URL) || url.equals (DMS_WEBDAV_PUBLIC_ROOT_FOLDER_URL)) {
            return (DmsDocument) dmsDocumentDAObject.getObjectByID (rootPoint.getRootFolderID ());
        }
        if (urlArr.length > 0) {
            DmsDocument tmpDmsDocument = null;
            for (int i = 0; i < urlArr.length; i ++) {
                if (i == 2) {
                    if (isPersonal) {
                        if (rootPoint != null) {
                            tmpDmsDocument = (DmsDocument) dmsDocumentDAObject.getObjectByID (rootPoint.getRootFolderID ());
                        }
                    }
                }
                if (i == 3) {
                    if (isPersonal) {
                        if (tmpDmsDocument != null) {
                            if (urlArr.length - 1 != i) {
                                tmpDmsDocument = documentRetrievalManager.getDocumentByNameParentID (urlArr [i], tmpDmsDocument.getID ());
                            }
                            else {
                                if (isLink) {
                                    tmpDmsDocument = documentRetrievalManager.getDocumentByNameParentID (urlArr [i], tmpDmsDocument.getID (), "L");
                                }
                                else {
                                    tmpDmsDocument = documentRetrievalManager.getDocumentByNameParentID (urlArr [i], tmpDmsDocument.getID (), "*");
                                }
                            }
                        }
                    }
                    else {
                        rootPoint = (DmsRoot) rootDAO.getObjectByName (urlArr [i]);
                        if (rootPoint != null) {
                            tmpDmsDocument = (DmsDocument) dmsDocumentDAObject.getObjectByID (rootPoint.getRootFolderID ());
                        }
                    }
                }
                if (i > 3) {
                    if (tmpDmsDocument != null) {
                        if (isLink && urlArr.length - 1 == i) {
                            tmpDmsDocument = documentRetrievalManager.getDocumentByNameParentID (urlArr [i], tmpDmsDocument.getID (), "L");
                        }
                        else {
                            tmpDmsDocument = documentRetrievalManager.getDocumentByNameParentID (urlArr [i], tmpDmsDocument.getID (), "*");
                        }
                    }
                }
            }
            dmsDocument = tmpDmsDocument;
        }
        return dmsDocument;
    } catch (Exception e) {
        log.error (e, e);
        throw new ObjectNotFoundException (url);
    } finally {
        closeConnection (conn);
    }
}


protected void storeDocuments () throws DocumentStoreException {
    ReportFileHome reportFileHome = null;
    try {
        Context initialContext = new InitialContext ();
        reportFileHome = (ReportFileHome) PortableRemoteObject.narrow (initialContext.lookup (ReportFileHome.COMP_NAME), ReportFileHome.class);
    } catch (Exception e) {
        throw new DocumentStoreException ("ReportFileHome could not be loaded");
    }
    int count = 0;
    String filename;
    String title, ending;
    byte [] b;
    ReportFileObject reportFileObject;
    Enumeration enumTitles;
    try {
        enumTitles = reportDocHandler.getReportDocumentTitles ().elements ();
    } catch (RemoteException re) {
        enumTitles = new Vector ().elements ();
    }
    while (enumTitles.hasMoreElements ()) {
        try {
            filename = (String) enumTitles.nextElement ();
            ending = filename.substring (filename.lastIndexOf ('.') + 1);
            title = filename.substring (0, filename.lastIndexOf ('.'));
            b = reportDocHandler.getReportDocumentStream (filename);
            if (filename.endsWith ("HTML") | filename.endsWith ("html")) {
                zipStream = new ByteArrayOutputStream ();
                ZipOutputStream zip = new ZipOutputStream (zipStream);
                ZipEntry entry = new ZipEntry (filename);
                zip.putNextEntry (entry);
                zip.write (b);
                zip.closeEntry ();
                String key;
                Set imageSet = imageByteArrays.keySet ();
                Iterator iterCharts = imageSet.iterator ();
                while (iterCharts.hasNext ()) {
                    key = (String) iterCharts.next ();
                    b = (byte []) imageByteArrays.get (key);
                    entry = new ZipEntry ("images/" + key);
                    zip.putNextEntry (entry);
                    zip.write (b);
                    zip.closeEntry ();
                }
                zip.close ();
                UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
                reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, zipStream.toByteArray (), new Date (), reportID, "ZIP");
                reportfiles.addElement (reportFileObject);
                zipStream = null;
                count ++;
            }
            else {
                UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
                reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, b, new Date (), reportID, ending);
                reportfiles.addElement (reportFileObject);
                count ++;
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    try {
        reportDocHandler.deleteDocuments ();
    } catch (RemoteException re) {
    }
    try {
        enumTitles = dataDocHandler.getDataDocumentTitles ().elements ();
    } catch (RemoteException re) {
        enumTitles = new Vector ().elements ();
    }
    while (enumTitles.hasMoreElements ()) {
        try {
            filename = (String) enumTitles.nextElement ();
            ending = filename.substring (filename.lastIndexOf ('.') + 1);
            title = filename.substring (0, filename.lastIndexOf ('.'));
            b = dataDocHandler.getDataDocumentStream (filename);
            UniqueKeyGenerator primkeygen = new UniqueKeyGenerator ();
            reportFileObject = reportFileHome.create (primkeygen.getUniqueId (), title, b, new Date (), reportID, ending);
            reportfiles.addElement (reportFileObject);
            count ++;
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
    try {
        dataDocHandler.deleteDocuments ();
    } catch (RemoteException re) {
    }
    if (count == 0) throw new DocumentStoreException ("No document could be stored.");
}


-----Function Pair=183=-----=1=

public static boolean ZipFiles (String [] files, String zipname, boolean type) throws Exception {
    FileOutputStream os = new FileOutputStream (zipname);
    ZipOutputStream zip = new ZipOutputStream (os);
    for (int i = 0; i < files.length; i ++) {
        File file = new File (files [i]);
        if (file.exists ()) {
            byte [] buf = new byte [1024];
            int len;
            ZipEntry zipEntry = new ZipEntry (type ? file.getName () : file.getPath ());
            try {
                FileInputStream fin = new FileInputStream (file);
                BufferedInputStream in = new BufferedInputStream (fin);
                zip.putNextEntry (zipEntry);
                while ((len = in.read (buf)) >= 0) {
                    zip.write (buf, 0, len);
                }
                in.close ();
                zip.closeEntry ();
            } catch (FileNotFoundException e) {
            } catch (IOException e) {
            }
        }
    }
    zip.close ();
    os.close ();
    return true;
}


public static void zipDirectory (File directory, String nameZip, String pathExport, boolean pathWithFirstDirectory) throws IOException {
    FileOutputStream f = new FileOutputStream (pathExport + File.separator + nameZip);
    CheckedOutputStream csum = new CheckedOutputStream (f, new Adler32 ());
    ZipOutputStream out = new ZipOutputStream (new BufferedOutputStream (csum));
    Collection < File > listeFiles = getListeFile (directory, FILTER_ALLFILE, true, false);
    Iterator < File > itListeFiles = listeFiles.iterator ();
    while (itListeFiles.hasNext ()) {
        File fileToZip = (File) itListeFiles.next ();
        FileInputStream in = new FileInputStream (fileToZip);
        out.putNextEntry (new ZipEntry (getZipEntryName (directory, fileToZip, pathWithFirstDirectory)));
        int c;
        while ((c = in.read ()) != - 1) {
            out.write (c);
        }
        in.close ();
    }
    out.close ();
}


-----Function Pair=184=-----==

public EList < Diagnostic > getWarnings () {
    if (warnings == null) {
        warnings = new NotifyingListImpl < Diagnostic > () {
            private static final long serialVersionUID = 1L;
            @Override
            protected boolean isNotificationRequired () {
                return ResourceImpl.this.eNotificationRequired ();
            }@Override
            public Object getNotifier () {
                return ResourceImpl.this;
            }@Override
            public int getFeatureID () {
                return RESOURCE__WARNINGS;
            }
        }
        ;
    }
    return warnings;
}


public void actionPerformed (ActionEvent ae) {
    new Thread (getClass ().getName () + "/ActionPerformed/Package") {
        @Override
        public void run () {
            try {
                JFileChooser fc = Core.UI.getFileChooser ();
                fc.setMultiSelectionEnabled (true);
                int prev_option = fc.getFileSelectionMode ();
                fc.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
                if (fc.showOpenDialog (Core.UI) != JFileChooser.APPROVE_OPTION) {
                    fc.setMultiSelectionEnabled (false);
                    fc.setFileSelectionMode (prev_option);
                    return;
                }
                File file = fc.getSelectedFile ();
                Thread packager = new Packager (tokenBook, file);
                packager.start ();
                try {
                    while (packager.isAlive ()) sleep (10);
                } catch (Exception e) {
                }
                fc.setMultiSelectionEnabled (false);
                fc.setFileSelectionMode (prev_option);
            } catch (Exception e) {
                Core.Logger.log (e.getMessage (), Level.ERROR);
                e.printStackTrace ();
            }
        }
    }
    .start ();
}


-----Function Pair=185=-----==

public static CharSequence charSequenceFromFile (String filename) throws Exception {
    if (! new File (filename).exists ()) {
        throw new Exception ("File not found " + filename);
    }
    FileInputStream fis = new FileInputStream (filename);
    FileChannel fc = fis.getChannel ();
    ByteBuffer bbuf = fc.map (FileChannel.MapMode.READ_ONLY, 0, (int) fc.size ());
    CharBuffer cbuf = Charset.forName ("8859_1").newDecoder ().decode (bbuf);
    fc.close ();
    fis.close ();
    bbuf.clear ();
    bbuf = null;
    System.gc ();
    return cbuf;
}


private long getCompressedSize (File file) throws IOException {
    ZipEntry entry = new ZipEntry (file.getName ());
    entry.setMethod (ZipEntry.DEFLATED);
    ZipOutputStream out = new ZipOutputStream (new IdleOutputStream ());
    out.setLevel (COMPRESS_LEVEL);
    out.putNextEntry (entry);
    BufferedInputStream input = new BufferedInputStream (new FileInputStream (file));
    int b;
    while ((b = input.read ()) != - 1) {
        out.write (b);
    }
    input.close ();
    out.closeEntry ();
    out.close ();
    return entry.getCompressedSize ();
}


-----Function Pair=186=-----==

private void saveXMLFile (Document doc, String fileName) {
    FileOutputStream outputStream = null;
    try {
        OutputFormat outputFormat = new OutputFormat (doc);
        outputFormat.setIndenting (true);
        outputFormat.setLineWidth (0);
        outputFormat.setOmitComments (false);
        outputFormat.setOmitDocumentType (false);
        outputFormat.setOmitXMLDeclaration (false);
        outputFormat.setEncoding ("UTF-8");
        outputStream = new FileOutputStream ("xmlFiles\\" + fileName);
        XMLSerializer serializer = new XMLSerializer (outputStream, outputFormat);
        serializer.asDOMSerializer ();
        serializer.serialize (doc.getDocumentElement ());
        outputStream.flush ();
        outputStream.close ();
    } catch (IOException ex) {
        Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
    } finally {
        try {
            outputStream.close ();
        } catch (IOException ex) {
            Logger.getLogger (CCRepositoryProxyImpl.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
}


public static void saveToFile (Object obj, File xmlFile) {
    ISerializer xs = Lookup.get ().getImplObject (ISerializer.class);
    OutputStream os;
    try {
        os = new FileOutputStream (xmlFile);
        try {
            if (xmlFile.getName ().endsWith (".zip")) {
                ZipOutputStream zip = new ZipOutputStream (os);
                zip.putNextEntry (new ZipEntry (zipEntryName));
                os = zip;
            }
            else if (xmlFile.getName ().endsWith (".gz")) {
                GZIPOutputStream zip = new GZIPOutputStream (os);
                os = zip;
            }
            xs.toXML (obj, os);
        } finally {
            os.close ();
        }
    } catch (SerializeException e) {
        GLog.warn (L.tr ("XML_Write_Exception:"), e);
    } catch (MalformedURLException e) {
        GLog.warn (L.tr ("Malformed_URL:"), e);
    } catch (FileNotFoundException ex) {
        GLog.warn (L.tr ("Can't_find_file!"));
    } catch (IOException e) {
        GLog.warn (L.tr ("Can't_gzip_the_file:_IOException:"), e);
    }
    GLog.log (L.tr ("Saved_object_to:") + " " + xmlFile.getAbsolutePath ());
}


-----Function Pair=187=-----==

private void importerConfig () {
    JFileChooser jfc = new JFileChooser ();
    jfc.setCurrentDirectory (new File (ConfigNat.getUserConfigFolder ()));
    jfc.addChoosableFileFilter (new FiltreFichier (new String [] {"nca"}, "archive configuration nat (*.nca)"));
    jfc.setDialogTitle ("Exporter la configuration courante");
    if (jfc.showOpenDialog (this) == JFileChooser.APPROVE_OPTION) {
        try {
            File tmpConf = new File (ConfigNat.getConfTempFolder ());
            File [] files = tmpConf.listFiles ();
            for (File f : files) {
                if (f.isFile ()) {
                    f.delete ();
                }
            }
            String inFilename = jfc.getSelectedFile ().getCanonicalPath ();
            ZipInputStream in = new ZipInputStream (new FileInputStream (inFilename));
            ZipEntry entry;
            while ((entry = in.getNextEntry ()) != null) {
                String outFilename = ConfigNat.getConfTempFolder () + entry.getName ();
                OutputStream out = new FileOutputStream (outFilename);
                byte [] buf = new byte [1024];
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.close ();
            }
            in.close ();
            files = tmpConf.listFiles ();
            ArrayList < File > al_Files = new ArrayList < File > ();
            for (int i = 0; i < files.length; i ++) {
                al_Files.add (files [i]);
            }
            Collections.sort (al_Files);
            File fVersion = al_Files.get (0);
            File fConf = al_Files.get (1);
            File fAbr = new File ("");
            File fCoup = new File ("");
            for (int i = 3; i < al_Files.size (); i ++) {
                if (al_Files.get (i).getName ().startsWith ("4")) {
                    fAbr = al_Files.get (i);
                }
                else if (al_Files.get (i).getName ().startsWith ("5")) {
                    fCoup = al_Files.get (i);
                }
            }
            boolean restart = false;
            int version = Integer.parseInt (FileToolKit.loadFileToStr (fVersion.getCanonicalPath ()).split ("\n") [0]);
            if (version > ConfigNat.getSvnVersion ()) {
                System.out.println ("update needed");
            }
            else {
                if (version < ConfigNat.getSvnVersion ()) {
                    restart = true;
                }
                Properties conf = new Properties ();
                FileInputStream fis = new FileInputStream (fConf);
                conf.load (fis);
                fis.close ();
                String nomFichierReglesG2 = conf.getProperty (OptNames.fi_litt_fr_abbreg_rules_filename_perso);
                boolean abregerDefaut = nomFichierReglesG2 == null || nomFichierReglesG2.equals (ConfigNat.getCurrentConfig ().getRulesFrG2 ());
                if (! abregerDefaut) {
                    conf.setProperty (OptNames.fi_litt_fr_abbreg_rules_filename_perso, ConfigNat.getConfImportFolder () + fAbr.getName ());
                    FileToolKit.copyFile (fAbr.getCanonicalPath (), ConfigNat.getConfImportFolder () + fAbr.getName ());
                }
                String nomFichierCoup = conf.getProperty (OptNames.fi_hyphenation_rulefile_name);
                boolean coupDefaut = nomFichierCoup == null || nomFichierCoup.equals (ConfigNat.getDicoCoupDefaut ());
                if (! coupDefaut) {
                    conf.setProperty (OptNames.fi_hyphenation_rulefile_name, ConfigNat.getConfImportFolder () + fCoup.getName ());
                    FileToolKit.copyFile (fCoup.getCanonicalPath (), ConfigNat.getConfImportFolder () + fCoup.getName ());
                }
                FileToolKit.copyFile (fConf.getCanonicalPath (), ConfigNat.getUserConfigFilterFolder () + fConf.getName ());
                chargeConfigurations ();
                if (restart) {
                    JOptionPane.showMessageDialog (this, texts.getText ("confRestart"));
                }
                else {
                    JOptionPane.showMessageDialog (this, texts.getText ("confImportSuccessfull"));
                }
            }
        } catch (IOException e) {
            gestErreur.afficheMessage ("Erreur lors de l'importation", Nat.LOG_SILENCIEUX);
        }
    }
}


public static Class evalToClass (Compilation comp, URL url) throws SyntaxException {
    ModuleExp mexp = comp.getModule ();
    SourceMessages messages = comp.getMessages ();
    try {
        comp.minfo.loadByStages (Compilation.COMPILED);
        if (messages.seenErrors ()) return null;
        ArrayClassLoader loader = comp.loader;
        if (url == null) url = Path.currentPath ().toURL ();
        loader.setResourceContext (url);
        java.util.zip.ZipOutputStream zout = null;
        if (dumpZipPrefix != null) {
            StringBuffer zipname = new StringBuffer (dumpZipPrefix);
            lastZipCounter ++;
            if (interactiveCounter > lastZipCounter) lastZipCounter = interactiveCounter;
            zipname.append (lastZipCounter);
            zipname.append (".zip");
            java.io.FileOutputStream zfout = new java.io.FileOutputStream (zipname.toString ());
            zout = new java.util.zip.ZipOutputStream (zfout);
        }
        for (int iClass = 0; iClass < comp.numClasses; iClass ++) {
            ClassType clas = comp.classes [iClass];
            String className = clas.getName ();
            byte [] classBytes = clas.writeToArray ();
            loader.addClass (className, classBytes);
            if (zout != null) {
                String clname = className.replace ('.', '/') + ".class";
                java.util.zip.ZipEntry zent = new java.util.zip.ZipEntry (clname);
                zent.setSize (classBytes.length);
                java.util.zip.CRC32 crc = new java.util.zip.CRC32 ();
                crc.update (classBytes);
                zent.setCrc (crc.getValue ());
                zent.setMethod (java.util.zip.ZipEntry.STORED);
                zout.putNextEntry (zent);
                zout.write (classBytes);
            }
        }
        if (zout != null) {
            zout.close ();
        }
        Class clas = null;
        ArrayClassLoader context = loader;
        while (context.getParent () instanceof ArrayClassLoader) context = (ArrayClassLoader) context.getParent ();
        for (int iClass = 0; iClass < comp.numClasses; iClass ++) {
            ClassType ctype = comp.classes [iClass];
            Class cclass = loader.loadClass (ctype.getName ());
            ctype.setReflectClass (cclass);
            ctype.setExisting (true);
            if (iClass == 0) clas = cclass;
            else if (context != loader) context.addClass (cclass);
        }
        ModuleInfo minfo = comp.minfo;
        minfo.setModuleClass (clas);
        comp.cleanupAfterCompilation ();
        int ndeps = minfo.numDependencies;
        for (int idep = 0; idep < ndeps; idep ++) {
            ModuleInfo dep = minfo.dependencies [idep];
            Class dclass = dep.getModuleClassRaw ();
            if (dclass == null) dclass = evalToClass (dep.comp, null);
            comp.loader.addClass (dclass);
        }
        return clas;
    } catch (java.io.IOException ex) {
        throw new WrappedException ("I/O error in lambda eval", ex);
    } catch (ClassNotFoundException ex) {
        throw new WrappedException ("class not found in lambda eval", ex);
    } catch (Throwable ex) {
        comp.getMessages ().error ('f', "internal compile error - caught " + ex, ex);
        throw new SyntaxException (messages);
    }
}


-----Function Pair=188=-----==

private static void save (Instance instance, InstanceClass instanceClass) {
    if (instance.isNew ()) {
        try {
            PreparedStatement ps;
            final String insertQuery = "INSERT INTO " + table + " (name, md5, instance) " + "VALUES (?, ?, ?)";
            ps = DatabaseConnector.getInstance ().getConn ().prepareStatement (insertQuery, PreparedStatement.RETURN_GENERATED_KEYS);
            File input = null;
            FileInputStream fInStream = null;
            if (instance.getFile () != null) {
                input = instance.getFile ();
                fInStream = new FileInputStream (input);
                java.sql.Blob b = DatabaseConnector.getInstance ().getConn ().createBlob ();
                TaskICodeProgress progress = new TaskICodeProgress (input.length (), "Compressing " + input.getName ());
                Util.sevenZipEncode (fInStream, b.setBinaryStream (1), input.length (), progress);
                progress.finished ();
                ps.setBlob (3, b);
            }
            else {
                ps.setNull (3, Types.BLOB);
            }
            ps.setString (1, instance.getName ());
            ps.setString (2, instance.getMd5 ());
            ps.executeUpdate ();
            ResultSet rs = ps.getGeneratedKeys ();
            if (rs.next ()) {
                instance.setId (rs.getInt (1));
            }
            cache.cache (instance);
            ps.close ();
            instance.setSaved ();
            InstanceHasInstanceClassDAO.createInstanceHasInstance (instance, instanceClass);
        } catch (Exception ex) {
            Logger.getLogger (InstanceDAO.class.getName ()).log (Level.SEVERE, null, ex);
        }
    }
}


protected void zipDir (ZipOutputStream zos, File baseDir, String relativeSubDir) throws IOException {
    File dir = new File (baseDir, relativeSubDir);
    File [] files = dir.listFiles ();
    for (int i = 0; i < files.length; i ++) {
        File file = files [i];
        if (file.isFile ()) {
            FileInputStream in = new FileInputStream (file);
            ZipEntry entry = new ZipEntry (addFinalSeparator (relativeSubDir) + file.getName ());
            entry.setTime (file.lastModified ());
            entry.setSize (file.length ());
            zos.putNextEntry (entry);
            copy (in, zos);
            zos.flush ();
            zos.closeEntry ();
            in.close ();
        }
        else if (file.isDirectory ()) {
            zipDir (zos, baseDir, addFinalSeparator (relativeSubDir) + file.getName ());
        }
    }
}


-----Function Pair=189=-----==

public void actionPerformed (ActionEvent e) {
    try {
        int pos = editor.getCaretPosition ();
        Element root = editor.getDocument ().getDefaultRootElement ();
        int line = root.getElementIndex (pos);
        int lineEnd = root.getElement (line).getEndOffset ();
        int len = editor.getDocument ().getLength ();
        int offset = lineEnd - pos;
        if (lineEnd - 1 == len) {
            Toolkit.getDefaultToolkit ().beep ();
        }
        else if (offset == 1) {
            editor.getDocument ().remove (pos, 1);
        }
        else if (lineEnd - 1 < len) {
            editor.getDocument ().remove (pos, offset - 1);
        }
    } catch (BadLocationException ex) {
        ex.printStackTrace ();
    }
}


public void setBinaryData (byte [] inflatedData) {
    if ((inflatedData == null) || (inflatedData.length == 0)) {
        throw new IllegalArgumentException ("InflatedData is NULL");
    }
    m_inflated = new Integer (inflatedData.length);
    ByteArrayOutputStream out = new ByteArrayOutputStream ();
    ZipOutputStream zip = new ZipOutputStream (out);
    zip.setMethod (ZipOutputStream.DEFLATED);
    zip.setLevel (Deflater.BEST_COMPRESSION);
    zip.setComment ("openxpertya");
    byte [] deflatedData = null;
    try {
        ZipEntry entry = new ZipEntry ("OpenxpertyaArchive");
        entry.setTime (System.currentTimeMillis ());
        entry.setMethod (ZipEntry.DEFLATED);
        zip.putNextEntry (entry);
        zip.write (inflatedData, 0, inflatedData.length);
        zip.closeEntry ();
        log.fine (entry.getCompressedSize () + " (" + entry.getSize () + ") " + (entry.getCompressedSize () * 100 / entry.getSize ()) + "%");
        zip.close ();
        deflatedData = out.toByteArray ();
        log.fine ("Length=" + inflatedData.length);
        m_deflated = new Integer (deflatedData.length);
    } catch (Exception e) {
        log.log (Level.SEVERE, "saveLOBData", e);
        deflatedData = null;
        m_deflated = null;
    }
    super.setBinaryData (deflatedData);
}


-----Function Pair=190=-----=1=

public boolean zipDir (String inputDirPath, String dir2zip, ZipOutputStream zos) {
    try {
        File zipDir = new File (inputDirPath);
        String dirList [] = zipDir.list ();
        byte readBuffer [] = new byte [2156];
        int bytesIn = 0;
        for (int i = 0; i < dirList.length; i ++) {
            File f = new File (zipDir, dirList [i]);
            if (f.isDirectory ()) {
                String fileDirPath = f.getPath ();
                zipDir (fileDirPath, fileDirPath, zos);
                continue;
            }
            FileInputStream fis = new FileInputStream (f);
            String filePath = f.getPath ();
            ZipEntry anEntry = new ZipEntry (filePath);
            zos.putNextEntry (anEntry);
            while ((bytesIn = fis.read (readBuffer)) != - 1) zos.write (readBuffer, 0, bytesIn);
            fis.close ();
        }
        return (true);
    } catch (Exception e) {
        errMsgLog += "Problem zipping to zip file '" + dir2zip + "' in zipDir() failed.";
        lastErrMsgLog = errMsgLog;
        return (false);
    }
}


public boolean execute (PlugInContext context) throws Exception {
    WorkbenchContext workbenchContext = context.getWorkbenchContext ();
    if (JFileChooser.APPROVE_OPTION == fileChooser.showSaveDialog (workbenchContext.getLayerViewPanel ())) {
        String zipFileName = fileChooser.getSelectedFile ().getPath ();
        Collection layerCollection = (Collection) workbenchContext.getLayerNamePanel ().getLayerManager ().getLayers ();
        List filesToZip = new ArrayList ();
        try {
            for (Iterator l = layerCollection.iterator (); l.hasNext ();) {
                Layer layer = (Layer) l.next ();
                if (layer.hasReadableDataSource ()) {
                    DataSourceQuery dsq = layer.getDataSourceQuery ();
                    String fname = "";
                    Object fnameObj = dsq.getDataSource ().getProperties ().get ("File");
                    if (fnameObj != null) {
                        fname = fnameObj.toString ();
                        if (new File (fname).exists ()) {
                            filesToZip.add (fname);
                        }
                    }
                }
                if (filesToZip.size () > 0) {
                    byte [] buffer = new byte [18024];
                    try {
                        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFileName));
                        out.setLevel (Deflater.DEFAULT_COMPRESSION);
                        for (int i = 0; i < filesToZip.size (); i ++) {
                            System.out.println (i);
                            FileInputStream in = new FileInputStream ((String) filesToZip.get (i));
                            out.putNextEntry (new ZipEntry ((String) filesToZip.get (i)));
                            int len;
                            while ((len = in.read (buffer)) > 0) {
                                out.write (buffer, 0, len);
                            }
                            out.closeEntry ();
                            in.close ();
                        }
                        out.close ();
                    } catch (IllegalArgumentException iae) {
                        iae.printStackTrace ();
                    } catch (FileNotFoundException fnfe) {
                        fnfe.printStackTrace ();
                    } catch (IOException ioe) {
                        ioe.printStackTrace ();
                    }
                }
            }
        } catch (Exception e) {
            context.getWorkbenchFrame ().getOutputFrame ().createNewDocument ();
            context.getWorkbenchFrame ().warnUser ("Error: see output window");
            context.getWorkbenchFrame ().getOutputFrame ().addText ("CreateBackupPlugIn Exception:" + e.toString ());
            return false;
        }
    }
    return true;
}


-----Function Pair=191=-----==

public static HashMap < Integer, Instance > importInstances (Tasks task, ZipFile file, List < Instance > instances) throws SQLException, InstanceClassMustBeSourceException, IOException, InstanceClassAlreadyInDBException, ClassNotFoundException {
    task.setOperationName ("Importing instances..");
    HashMap < Integer, Instance > res = new HashMap < Integer, Instance > ();
    InstanceClass clazz = null;
    List < Instance > dbInstances = getAll ();
    int current = 1;
    for (Instance fileInstance : instances) {
        task.setStatus ("Saving instance " + current + " / " + instances.size ());
        task.setTaskProgress (current / (float) instances.size ());
        boolean found = false;
        for (Instance i : dbInstances) {
            if (i.getMd5 ().equals (fileInstance.getMd5 ())) {
                found = true;
                res.put (fileInstance.getId (), i);
                break;
            }
        }
        if (! found) {
            if (clazz == null) {
                clazz = InstanceClassDAO.createInstanceClass ("imported instances", "Imported instances from other databases", null);
            }
            ObjectInputStream stream = new ObjectInputStream (file.getInputStream (file.getEntry ("instance_" + fileInstance.getId () + ".binary")));
            Instance newInstance = new Instance (fileInstance);
            InstanceDAO.save (newInstance, true, clazz, readInstanceBinaryFromStream (stream));
            res.put (fileInstance.getId (), newInstance);
        }
        current ++;
    }
    task.setTaskProgress (0.f);
    task.setStatus ("Done.");
    return res;
}


public File write (File saveDirectory, boolean attemptToSaveAsShort) {
    boolean useShortBeginning = false;
    boolean useShortLength = false;
    if (attemptToSaveAsShort) {
        int bp = sortedRegions [0].start;
        useShortBeginning = true;
        for (int i = 1; i < sortedRegions.length; i ++) {
            int currentStart = sortedRegions [i].start;
            int diff = currentStart - bp;
            if (diff > 65536) {
                useShortBeginning = false;
                break;
            }
            bp = currentStart;
        }
        useShortLength = true;
        for (int i = 0; i < sortedRegions.length; i ++) {
            int diff = sortedRegions [i].stop - sortedRegions [i].start;
            if (diff > 65536) {
                useShortLength = false;
                break;
            }
        }
    }
    String fileType;
    if (useShortBeginning) fileType = USeqUtilities.SHORT;
    else fileType = USeqUtilities.INT;
    if (useShortLength) fileType = fileType + USeqUtilities.SHORT;
    else fileType = fileType + USeqUtilities.INT;
    sliceInfo.setBinaryType (fileType);
    binaryFile = new File (saveDirectory, sliceInfo.getSliceName ());
    FileOutputStream workingFOS = null;
    DataOutputStream workingDOS = null;
    try {
        workingFOS = new FileOutputStream (binaryFile);
        workingDOS = new DataOutputStream (new BufferedOutputStream (workingFOS));
        workingDOS.writeUTF (header);
        workingDOS.writeInt (sortedRegions [0].start);
        int bp = sortedRegions [0].start;
        if (useShortBeginning) {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegions [0].stop - sortedRegions [0].start);
                for (int i = 1; i < sortedRegions.length; i ++) {
                    int currentStart = sortedRegions [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeInt (sortedRegions [i].stop - sortedRegions [i].start);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegions [0].stop - sortedRegions [0].start - 32768));
                for (int i = 1; i < sortedRegions.length; i ++) {
                    int currentStart = sortedRegions [i].start;
                    int diff = currentStart - bp - 32768;
                    workingDOS.writeShort ((short) (diff));
                    workingDOS.writeShort ((short) (sortedRegions [i].stop - sortedRegions [i].start - 32768));
                    bp = currentStart;
                }
            }
        }
        else {
            if (useShortLength == false) {
                workingDOS.writeInt (sortedRegions [0].stop - sortedRegions [0].start);
                for (int i = 1; i < sortedRegions.length; i ++) {
                    int currentStart = sortedRegions [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeInt (sortedRegions [i].stop - sortedRegions [i].start);
                    bp = currentStart;
                }
            }
            else {
                workingDOS.writeShort ((short) (sortedRegions [0].stop - sortedRegions [0].start - 32768));
                for (int i = 1; i < sortedRegions.length; i ++) {
                    int currentStart = sortedRegions [i].start;
                    int diff = currentStart - bp;
                    workingDOS.writeInt (diff);
                    workingDOS.writeShort ((short) (sortedRegions [i].stop - sortedRegions [i].start - 32768));
                    bp = currentStart;
                }
            }
        }
    } catch (Exception e) {
        e.printStackTrace ();
        binaryFile = null;
    } finally {
        USeqUtilities.safeClose (workingDOS);
        USeqUtilities.safeClose (workingFOS);
    }
    return binaryFile;
}


-----Function Pair=192=-----==

public void testJarFileModifiedClass () throws IOException {
    String modifiedJarName = "Modified_Class.jar";
    Support_Resources.copyFile (resources, null, modifiedJarName);
    JarFile jarFile = new JarFile (new File (resources, modifiedJarName), true);
    Enumeration < JarEntry > entries = jarFile.entries ();
    while (entries.hasMoreElements ()) {
        ZipEntry zipEntry = entries.nextElement ();
        jarFile.getInputStream (zipEntry);
    }
    ZipEntry zipEntry = jarFile.getEntry ("Test.class");
    InputStream in = jarFile.getInputStream (zipEntry);
    byte [] buffer = new byte [1024];
    try {
        while (in.available () > 0) {
            in.read (buffer);
        }
        fail ("SecurityException expected");
    } catch (SecurityException e) {
    }
}


public void write (OutputStream out) throws IOException {
    XmlSerializer ser = XMLUtils.getXmlSerializer (true);
    ser.setOutput (out, ENCODING);
    ser.startDocument (ENCODING, null);
    ser.startTag (null, DOC_ROOT_ELEM);
    for (MappingEntry e : mappingEntries) {
        String origURL = e.getOriginalURL ();
        String origPath = e.getOriginalPath ();
        String newPath = e.getNewPath ();
        ser.startTag (null, IMPORT_DIR_ELEM);
        if (StringUtils.hasValue (origURL)) ser.attribute (null, ORIGINAL_URL, origURL);
        if (StringUtils.hasValue (origPath)) ser.attribute (null, ORIGINAL_PATH, origPath);
        ser.attribute (null, NEW_PATH, newPath);
        ser.endTag (null, IMPORT_DIR_ELEM);
    }
    ser.endTag (null, DOC_ROOT_ELEM);
    ser.endDocument ();
}


-----Function Pair=193=-----==

public File pakEntrys (Map < String, byte [] > entrys, String out) {
    try {
        File output = new File (dir, out).getCanonicalFile ();
        ByteArrayOutputStream baos = new ByteArrayOutputStream ();
        ZipOutputStream zip_out = new ZipOutputStream (baos);
        try {
            for (Entry < String, byte [] > pak : entrys.entrySet ()) {
                ZipEntry entry = new ZipEntry (pak.getKey ());
                try {
                    entry.setTime (0);
                    zip_out.putNextEntry (entry);
                    zip_out.write (pak.getValue ());
                } catch (Exception err) {
                    err.printStackTrace ();
                }
            }
        } finally {
            try {
                zip_out.close ();
            } catch (IOException e) {
            }
            try {
                baos.close ();
            } catch (IOException e) {
            }
        }
        CFile.writeData (output, baos.toByteArray ());
        return output;
    } catch (Exception err) {
        err.printStackTrace ();
    }
    return null;
}


private void UpdateTopicPageTemplate (NpsContext inCtxt, Topic t) throws NpsException {
    if (t == null) return;
    PreparedStatement pstmt = null;
    try {
        String sql = "delete from topic_pts where topid=?";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        pstmt.setString (1, t.GetId ());
        pstmt.executeUpdate ();
        try {
            pstmt.close ();
        } catch (Exception e) {
        }
        java.util.List pts = t.GetPageTemplates ();
        if (pts == null || pts.isEmpty ()) return;
        sql = "insert into topic_pts(topid,templateid) values(?,?)";
        pstmt = inCtxt.GetConnection ().prepareStatement (sql);
        for (Object obj : pts) {
            PageTemplate pt = (PageTemplate) obj;
            pstmt.setString (1, t.GetId ());
            pstmt.setString (2, pt.GetId ());
            pstmt.executeUpdate ();
        }
    } catch (Exception e) {
        com.microfly.util.DefaultLog.error (e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (Exception e) {
        }
    }
}


-----Function Pair=194=-----==

public File getLayerFile (String id) throws IOException {
    File f = null;
    if (zipFile != null) {
        ZipOutputStream out = null;
        byte [] buf = new byte [1024];
        for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
            ZipEntry ze = (ZipEntry) e.nextElement ();
            String baseName = getBase (ze.getName ());
            if (baseName.equals (id)) {
                if (out == null) {
                    f = File.createTempFile ("layer_", ".zip");
                    out = new ZipOutputStream (new FileOutputStream (f));
                }
                InputStream in = zipFile.getInputStream (ze);
                out.putNextEntry (new ZipEntry (ze.getName ()));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
        }
        if (out != null) {
            out.close ();
        }
    }
    else {
        f = file;
    }
    return f;
}


public static OutputStream getOutputStream (String format, String location, String file, boolean append) throws FileNotFoundException, IOException, ZipException {
    OutputStream stream = null;
    if (format.equals (ZIP_FILE)) {
        try {
            System.out.println ("WARNING: ZIP not yet fully supported.!");
            File path = new File (location);
            File parent = new File (path.getParent ());
            if (! parent.exists ()) {
                parent.mkdirs ();
            }
            FileOutputStream fos = new FileOutputStream (new File (new URI (location)), append);
            stream = new ZipOutputStream (new BufferedOutputStream (fos));
            ZipEntry entry = new ZipEntry (file);
            ((ZipOutputStream) stream).putNextEntry (entry);
        } catch (URISyntaxException use) {
            use.printStackTrace ();
            throw new ZipException ("URISyntaxException: " + use.getMessage ());
        }
    }
    else if (format.equals (DIRECTORY)) {
        if (location != null) {
            File path = new File (location + File.separator + file);
            File parent = new File (path.getParent ());
            if (! parent.exists ()) {
                parent.mkdirs ();
            }
            stream = new FileOutputStream (location + File.separator + file);
        }
        else {
            File path = new File (file);
            File parent = new File (path.getParent ());
            if (! parent.exists ()) {
                parent.mkdirs ();
            }
            stream = new FileOutputStream (file);
        }
    }
    else {
        throw new IOException ("Format not supported for writing");
    }
    return stream;
}


-----Function Pair=195=-----==

private void implantSelf () throws IOException {
    InputStream manifest = getClass ().getClassLoader ().getResourceAsStream ("META-INF/manifest.mf");
    log ("my classloader is " + getClass ().getClassLoader ().getClass ().getName ());
    ClassLoader loader = getClass ().getClassLoader ();
    if (manifest == null || loader == null || (loader.getClass ().getName ().indexOf ("Applet") == - 1 && loader.getClass ().getName ().indexOf ("Plugin") == - 1)) return;
    BufferedReader br = new BufferedReader (new InputStreamReader (manifest));
    Vector entries = new Vector ();
    String s = null;
    while ((s = br.readLine ()) != null) if (s.startsWith ("Name: ")) entries.addElement (s.substring (6));
    String ext_dirs = System.getProperty ("java.ext.dirs");
    log ("java.ext.dirs = " + ext_dirs);
    ext_dirs = ext_dirs + File.pathSeparatorChar + System.getProperty ("user.home") + File.separatorChar + ".vexi";
    StringTokenizer st = new StringTokenizer (ext_dirs, File.pathSeparatorChar + "");
    while (st.hasMoreTokens ()) {
        String dir = st.nextToken ();
        new File (dir).mkdirs ();
        try {
            if (! st.hasMoreTokens ()) modifyPolicyFile ();
            implantInDirectory (dir, entries);
            return;
        } catch (IOException e) {
            log ("Failed to implant in " + dir + " due to " + e);
        }
    }
    log ("Failed to implant self!");
}


protected static void createXAPublish (final String directory, final Hashtable < String, String > xarfiles, final String xarName) throws Exception {
    try {
        final Element application = getApplicationElement (xarfiles);
        final Element root = new Element (PUBLISH_ROOT, ns);
        root.setAttribute (XAwareConstants.XAWARE_FILE_NAME, xarName, ns);
        root.setAttribute (XAWARE_ATTR_VESION, "1", ns);
        root.addContent (application);
        final Document doc = new Document (root);
        final XMLOutputter outputter = new XMLOutputter (Format.getPrettyFormat ());
        final File outFile = new File (directory + XAPUBLISH_XML_FILE);
        outputter.output (doc, new FileOutputStream (outFile));
        xarfiles.put (XAPUBLISH_XML_FILE, outFile.getAbsolutePath ());
    } catch (final FileNotFoundException e) {
        e.printStackTrace ();
        throw e;
    } catch (final IOException e) {
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=196=-----==

protected static void AddAndSaveHistory (String name) {
    try {
        for (int n = 0; n < projectNames.size (); n ++) {
            String aName = (String) projectNames.elementAt (n);
            if (aName.compareTo (name) == 0) return;
        }
        projectNames.insertElementAt (name, 0);
        if (projectNames.size () > maxHistory) {
            projectNames.removeElement (projectNames.lastElement ());
        }
        String filename = null;
        String installRoot = System.getProperty ("install.root");
        if (installRoot != null) {
            filename = installRoot + System.getProperty ("file.separator") + "scripts" + System.getProperty ("file.separator") + "sp.history";
        }
        if (filename != null) {
            Document doc = new DocumentImpl ();
            Element root = (Element) doc.createElement ("ROOT");
            doc.appendChild (root);
            Element rt = (Element) doc.createElement ("History");
            root.appendChild (rt);
            for (int n = 0; n < projectNames.size (); n ++) {
                String aName = (String) projectNames.elementAt (n);
                Element el2 = (Element) doc.createElement ("Projects");
                el2.appendChild (doc.createTextNode (aName));
                rt.appendChild (el2);
            }
            FileWriter fw = new FileWriter (filename);
            XMLSerializer xmlWriter = new XMLSerializer (new OutputFormat ());
            xmlWriter.setOutputCharStream (fw);
            xmlWriter.serialize (doc);
            fw.close ();
            for (Enumeration e = projects.elements (); e.hasMoreElements ();) {
                ((ProjectFrame) e.nextElement ()).buildProjectMenu ();
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}


public static void decompress (File infile, String destDir) throws Exception {
    ZipFile zip = new ZipFile (infile);
    if (zip != null) {
        Enumeration entries = zip.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            String fileName = entry.getName ();
            InputStream in = zip.getInputStream (entry);
            File dir = new File (destDir);
            if (! dir.exists ()) {
                dir.mkdirs ();
            }
            String fullPath = destDir + "/" + fileName;
            FileOutputStream out = new FileOutputStream (fullPath);
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                out.write (buffer, 0, nNumber);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=197=-----==

public void createZIPFileBackup (ArrayList < File > filesToZip) {
    try {
        byte [] buffer = new byte [1024];
        File zipFile = getNewFile (new File (Data.DATA_FOLDER_PATH + System.currentTimeMillis () + "added_files_backup.zip"));
        FileOutputStream fout = new FileOutputStream (zipFile);
        ZipOutputStream zout = new ZipOutputStream (fout);
        for (File a : filesToZip) {
            log.log (Level.INFO, this.getClass ().getName (), "Added file " + a.getAbsolutePath () + " to zip file " + zipFile.getAbsolutePath ());
            FileInputStream fin = new FileInputStream (a);
            zout.putNextEntry (new ZipEntry (a.getName ()));
            int length;
            while ((length = fin.read (buffer)) > 0) {
                zout.write (buffer, 0, length);
            }
            zout.closeEntry ();
            fin.close ();
        }
        zout.close ();
    } catch (IOException e) {
        log.log (Level.SEVERE, this.getClass ().getName (), e);
    }
}


protected void execute () {
    try {
        outer_loop : while (something_to_do) {
            fte.finishedAWrite (this);
            if (chunk != null) {
                if (chunk.hasFailed ()) {
                    logger.logComment ("Writing error marker to UPL output");
                    ZipEntry marker = new ZipEntry ("ERROR");
                    connection.getDataOutputStream ().putNextEntry (marker);
                    connection.getDataOutputStream ().closeEntry ();
                    connection.doneWithDataOutputStream ();
                    continue outer_loop;
                }
                if (chunk.getFileName ().equals ("NO_OVERWRITE")) {
                    logger.logComment ("Adding no overwrite marker to stream for <" + chunk.getPortfolio ().getUPLDirectoryName () + ">");
                    ZipEntry marker = new ZipEntry (chunk.getPortfolio ().getUPLDirectoryName () + "/");
                    marker.setExtra (new byte [1]);
                    connection.getDataOutputStream ().putNextEntry (marker);
                    connection.getDataOutputStream ().closeEntry ();
                    connection.doneWithDataOutputStream ();
                    continue outer_loop;
                }
                synchronized (open_writers) {
                    Iterator iterator = open_writers.iterator ();
                    while (iterator.hasNext ()) {
                        WriterChunk wc = (WriterChunk) iterator.next ();
                        if (wc.name.equals (chunk.getFileName ())) {
                            if (wc.end_of_known_writes == chunk.getStartByte ()) {
                                logger.logComment (Thread.currentThread ().getName () + " is handing off <" + chunk.getFileName () + "> <" + chunk.getStartByte () + ">");
                                wc.appendChunk (chunk);
                                chunk = null;
                                continue outer_loop;
                            }
                        }
                    }
                    if (chunk.getFileName ().equals (me_as_writer_chunk.name) && me_as_writer_chunk.end_of_known_writes == chunk.getStartByte ()) {
                        logger.logComment (Thread.currentThread ().getName () + " has contiguous chunk <" + chunk.getFileName () + "> <" + chunk.getStartByte () + ">");
                        me_as_writer_chunk.end_of_known_writes += chunk.getChunkLength ();
                    }
                    else {
                        if (me_as_writer_chunk.name != null) {
                            logger.logComment (Thread.currentThread ().getName () + " has new chunk <" + chunk.getFileName () + "> <" + chunk.getStartByte () + ">");
                            connection.getDataOutputStream ().flush ();
                            connection.getDataOutputStream ().closeEntry ();
                        }
                        me_as_writer_chunk.initChunk (chunk);
                        String file_name;
                        if (chunk.getPortfolio () != null) {
                            file_name = chunk.getPortfolio ().getUPLDirectoryName () + "/" + chunk.getFileName ();
                        }
                        else {
                            file_name = chunk.getFileName ();
                        }
                        if (chunk.getStartByte () != 0) {
                            file_name = "CHUNK_" + chunk.getStartByte () + "_" + file_name;
                        }
                        ZipEntry zip_entry = new ZipEntry (file_name);
                        zip_entry.setExtra (new byte [] {chunk.getMode ()});
                        connection.getDataOutputStream ().putNextEntry (zip_entry);
                    }
                    open_writers.add (me_as_writer_chunk);
                }
                Chunk to_write = chunk;
                while (to_write != null) {
                    logger.logComment (Thread.currentThread ().getName () + " is writing <" + to_write.getFileName () + "> <" + to_write.getStartByte () + "> <" + to_write.getChunkLength () + "> <" + (char) to_write.getBuffer () [0] + ">");
                    connection.getDataOutputStream ().write (to_write.getBuffer (), 0, (int) to_write.getChunkLength ());
                    fte.disposeWrittenChunk (to_write);
                    synchronized (open_writers) {
                        to_write = me_as_writer_chunk.getChunk ();
                        if (to_write == null) open_writers.remove (me_as_writer_chunk);
                    }
                }
                connection.getDataOutputStream ().flush ();
            }
        }
        connection.getDataOutputStream ().closeEntry ();
        connection.doneWithDataOutputStream ();
    } catch (IOException e) {
        terminate (true);
        fte.notifyError (chunk, e);
    } catch (Exception e) {
        terminate (true);
        fte.notifyError (chunk, e);
    } finally {
    }
}


-----Function Pair=198=-----==

private byte [] enableTask (HTTPurl urlData, HashMap headers) throws Exception {
    String out = "HTTP/1.0 302 Moved Temporarily\nLocation: " + "/servlet/" + urlData.getServletClass () + "?action=08\n\n";
    if ("false".equalsIgnoreCase ((String) headers.get ("LoopbackAddress"))) {
        out = "Security Warning:\n\n";
        out += "This action is not permitted from remote addresses, you can only perform\n";
        out += "this action from the machine that TV Scheduler Pro is running on.\n\n";
        out += "Tour current address is " + (String) headers.get ("RemoteAddress");
        return out.getBytes ();
    }
    HashMap tasks = store.getTaskList ();
    String enabled = urlData.getParameter ("enabled");
    String name = urlData.getParameter ("name");
    TaskCommand taskCommand = (TaskCommand) tasks.get (name);
    if (taskCommand != null) {
        if ("true".equals (enabled)) taskCommand.setEnabled (true);
        else taskCommand.setEnabled (false);
        store.saveTaskList (null);
    }
    return out.getBytes ();
}


private void processEntry (final ZipInputStream zis, final ZipEntry ze, final ContentHandlerFactory handlerFactory) {
    ContentHandler handler = handlerFactory.createContentHandler ();
    try {
        boolean singleInputDocument = inRepresentation == SINGLE_XML;
        if (inRepresentation == BYTECODE) {
            ClassReader cr = new ClassReader (readEntry (zis, ze));
            cr.accept (new SAXClassAdapter (handler, singleInputDocument), 0);
        }
        else {
            XMLReader reader = XMLReaderFactory.createXMLReader ();
            reader.setContentHandler (handler);
            reader.parse (new InputSource (singleInputDocument ? (InputStream) new ProtectedInputStream (zis) : new ByteArrayInputStream (readEntry (zis, ze))));
        }
    } catch (Exception ex) {
        update (ze.getName (), 0);
        update (ex, 0);
    }
}


-----Function Pair=199=-----==

public static File copyFileAs (String path, String newName) {
    File src = new File (path);
    File dest = new File (newName);
    try {
        if (! dest.exists ()) {
            dest.createNewFile ();
        }
        FileChannel source = new FileInputStream (src).getChannel ();
        FileChannel destination = new FileOutputStream (dest).getChannel ();
        destination.transferFrom (source, 0, source.size ());
        source.close ();
        destination.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return dest;
}


public static void main (String [] args) {
    final String username = "username@gmail.com";
    final String password = "password";
    Properties props = new Properties ();
    props.put ("mail.smtp.auth", "true");
    props.put ("mail.smtp.starttls.enable", "true");
    props.put ("mail.smtp.host", "smtp.gmail.com");
    props.put ("mail.smtp.port", "587");
    Session session = Session.getInstance (props, new javax.mail.Authenticator () {
        protected PasswordAuthentication getPasswordAuthentication () {
            return new PasswordAuthentication (username, password);
        }
    }
    );
    try {
        Message message = new MimeMessage (session);
        message.setFrom (new InternetAddress ("from-email@gmail.com"));
        message.setRecipients (Message.RecipientType.TO, InternetAddress.parse ("to-email@gmail.com"));
        message.setSubject ("Testing Subject");
        message.setText ("Dear Mail Crawler," + "\n\n No spam to my email, please!");
        Transport.send (message);
    } catch (MessagingException e) {
        throw new RuntimeException (e);
    }
}


-----Function Pair=200=-----==

public void doUnzipFolder () {
    try {
        if (this.unzipZipFolder == null) {
            throw new Exception ("Use 'setUnzipZipFolder(String)' to specify the zip-file to unzip");
        }
        if (this.unzipDestinationFolder == null) {
            throw new Exception ("Use 'setUnzipDestinationFolder(String)' to specify the destination for unzipping");
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (this.unzipZipFolder != null && this.unzipDestinationFolder != null) {
        this.kindOfExec = execUnZip;
        this.start ();
    }
}


public void UnListen () {
    if (! running) return;
    switch (event) {
        case EVENT_INSERT :
            EventSubscriber.GetSubscriber ().RemoveListener (InsertEventListener.class, this);
            break;
        case EVENT_UPDATE :
            EventSubscriber.GetSubscriber ().RemoveListener (UpdateEventListener.class, this);
            break;
        case EVENT_DELETE :
            EventSubscriber.GetSubscriber ().RemoveListener (DeleteEventListener.class, this);
            break;
        case EVENT_READY :
            EventSubscriber.GetSubscriber ().RemoveListener (Ready2PublishEventListener.class, this);
            break;
        case EVENT_PUBLISH :
            EventSubscriber.GetSubscriber ().RemoveListener (PublishEventListener.class, this);
            break;
        case EVENT_CANCEL :
            EventSubscriber.GetSubscriber ().RemoveListener (CancelEventListener.class, this);
            break;
    }
    running = false;
}


-----Function Pair=201=-----==

public boolean storeDataForTransactionIdentifier (String transactionIdentifier, InputStream inputStream, int inputLength) {
    try {
        if (true) {
            System.out.println ("This does not work because Java 1.5 does not support appending to zip files");
            return false;
        }
        ZipOutputStream zipOutputStream = new ZipOutputStream (new FileOutputStream (this.zipFilePath, true));
        ZipEntry entry = new ZipEntry (ArchiveFileSupport.fileNameForTransactionIdentifier (transactionIdentifier));
        zipOutputStream.putNextEntry (entry);
        byte [] buffer = new byte [4096];
        int length;
        while ((length = inputStream.read (buffer)) > 0) {
            zipOutputStream.write (buffer, 0, length);
        }
        zipOutputStream.closeEntry ();
        zipOutputStream.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
    return true;
}


public static File createFile (String filename, InputStream contentStream) throws IOException {
    if (StringUtil.isBlank (filename)) {
        throw new IOException ("invalid filename " + filename);
    }
    File file = new File (filename);
    if (contentStream != null) {
        FileWriter fileWriter = null;
        try {
            fileWriter = new FileWriter (file);
            FileOutputStream out = new FileOutputStream (file);
            byte [] buffer = new byte [STREAM_BUFFER_SIZE];
            int bytesRead;
            while ((bytesRead = contentStream.read (buffer)) != - 1) {
                out.write (buffer, 0, bytesRead);
            }
        } catch (IOException e) {
            throw e;
        } finally {
            if (fileWriter != null) {
                try {
                    fileWriter.close ();
                } catch (Exception e) {
                }
            }
        }
    }
    return file;
}


-----Function Pair=202=-----==

protected void process (ReportGenerationMeasure reportGenMeasure) throws RemoteException {
    TimePeriod timePeriod = reportGenMeasure.getReportMeasureTimePeriod ();
    String measureName = reportGenMeasure.getMeasureName ();
    System.out.println ("Processing " + measureName);
    monitorMessenger.sendMonitorInformation (reportName + ": Processing " + measureName);
    reportDocHandler.openChapter (measureName, chapterNumber);
    chapterNumber ++;
    Locale englishloc = new Locale ("en", "");
    SimpleDateFormat formatterMeasure = new SimpleDateFormat (" EEEE  dd  MMMM  yyyy HH:mm zzz", englishloc);
    Date begindate = timePeriod.getBeginDate ().getTime ();
    String beginDateString = formatterMeasure.format (begindate);
    Date enddate = timePeriod.getEndDate ().getTime ();
    enddate.setMinutes (enddate.getMinutes () - 1);
    String endDateString = formatterMeasure.format (enddate);
    String beginEndDateString = beginDateString + " - " + endDateString;
    reportDocHandler.addMeasureHeaderTime (beginEndDateString);
    try {
        reportDocHandler.addReportText ("Description: " + reportGenMeasure.getMeasureDescription ());
    } catch (Exception e) {
    }
    try {
        reportGenMeasure.loadData ();
    } catch (NoDataException nde) {
        try {
            reportDocHandler.addReportText (" ");
            reportDocHandler.addReportText ("No data was found at all" + " for this measure at the given time period!");
            reportDocHandler.closeChapter ();
        } catch (Exception e) {
        }
        return;
    }
    try {
        reportDocHandler.addReportText ("Annotations: " + reportGenMeasure.getAnnotations ());
    } catch (Exception e) {
    }
    Collection visualisations = reportGenMeasure.getVisualisations ();
    String visualisationName;
    Iterator iterator = visualisations.iterator ();
    while (iterator.hasNext ()) {
        visualisationName = ((Visualisation) iterator.next ()).getRw_name ();
        if (visualisationName.equalsIgnoreCase ("ReportTable")) {
            reportDocHandler.addReportMeasureTable (specificationsName, reportGenMeasure);
        }
        if (visualisationName.equalsIgnoreCase ("Text")) {
            reportDocHandler.addText (specificationsName, reportGenMeasure);
        }
        if (visualisationName.endsWith ("Chart") || visualisationName.endsWith ("CHART")) {
            try {
                addMeasureChart (visualisationName, reportGenMeasure);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
        if (visualisationName.equalsIgnoreCase ("DATA")) {
            try {
                dataDocHandler.writeData (reportGenMeasure);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
    try {
        reportDocHandler.closeChapter ();
    } catch (DocumentInsertException de) {
        de.printStackTrace ();
    }
}


private void collectFamilies () throws SQLException {
    StringBuilder sql = new StringBuilder ();
    PreparedStatement pst;
    sql.append ("select a.pid,a.tag,a.relationrow,b.pid,b.tag,b.relationrow,a.rid " + "from relation as a inner join relation as b on a.rid=b.rid ");
    if (viewId > 0) {
        sql.append ("and a.pid in (select pid from viewunits where vid=" + viewId + ") " + "and b.pid in (select pid from viewunits where vid=" + viewId + ") ");
    }
    if (surety != 100) {
        sql.append ("and a.surety >= " + surety + " ");
    }
    sql.append ("and a.tag='WIFE' and b.tag='HUSB' " + "order by a.pid,a.relationrow");
    pst = con.prepareStatement (sql.toString ());
    ResultSet rs = pst.executeQuery ();
    while (rs.next ()) {
        int dada = rs.getInt (1);
        int mama = rs.getInt (4);
        int rid = rs.getInt (7);
        ParentPair pp = new ParentPair (dada, mama);
        MinimumFamily mf = new MinimumFamily (dada, mama, rid);
        families.put (pp.toString (), mf);
        famById.put (mf.id, mf);
        MinimumIndividual mi = units.get (dada);
        mi.addFams (mf.id);
        mi = units.get (mama);
        mi.addFams (mf.id);
    }
    rs.close ();
    pst.close ();
    sql = new StringBuilder ();
    sql.append ("select a.pid,b.pid,b.tag,a.rid from ");
    sql.append ("relation as a inner join relation as b on a.rid=b.rid ");
    sql.append ("and a.tag='CHIL' and b.tag != 'CHIL' ");
    if (viewId > 0) {
        sql.append ("and a.pid in (select pid from viewunits where vid=" + viewId + ") " + "and b.pid in (select pid from viewunits where vid=" + viewId + ") ");
    }
    if (surety != 100) {
        sql.append ("and a.surety >= " + surety + " ");
    }
    sql.append ("order by b.pid,a.relationrow ");
    pst = con.prepareStatement (sql.toString ());
    Vector < MinimumIndividual > p = new Vector < MinimumIndividual > ();
    int previd = 0;
    int rid = 0;
    rs = pst.executeQuery ();
    while (rs.next ()) {
        int pare = rs.getInt (1);
        int chil = rs.getInt (2);
        rid = rs.getInt (4);
        if (chil != previd) {
            addChildToFamilies (p, previd, rid);
            p = new Vector < MinimumIndividual > ();
        }
        MinimumIndividual pi = units.get (pare);
        p.add (pi);
        previd = chil;
    }
    rs.close ();
    pst.close ();
    if (previd > 0) {
        addChildToFamilies (p, previd, rid);
    }
}


-----Function Pair=203=-----==

protected synchronized void flush () throws IOException {
    flushing = true;
    try {
        if (needsFlush) {
            needsFlush = false;
            ByteArrayOutputStream bos = new ByteArrayOutputStream ();
            ZipOutputStream zos = new ZipOutputStream (bos);
            if (zipFile != null) {
                for (Enumeration e = zipFile.entries (); e.hasMoreElements ();) {
                    ZipEntry zipEntry = (ZipEntry) (e.nextElement ());
                    JarFile jarFile = (JarFile) (jarFileTable.get (zipEntry.getName ()));
                    if (jarFile == null) writeZipEntry (zos, zipEntry, zipFile.getInputStream (zipEntry));
                }
            }
            for (Enumeration e = jarFileTable.keys (); e.hasMoreElements ();) {
                String name = (String) (e.nextElement ());
                JarFile jarFile = (JarFile) (jarFileTable.get (name));
                if (jarFile.exists () && ! jarFile.isDirectory ()) {
                    jarFile.flush ();
                    writeZipEntry (zos, jarFile.getZipEntry (), jarFile.getInputStream ());
                }
            }
            if (zipFile != null) zipFile.close ();
            zos.flush ();
            zos.close ();
            file.delete ();
            file.createNewFile ();
            FileOutputStream fos = new FileOutputStream (file);
            fos.write (bos.toByteArray ());
            fos.flush ();
            fos.close ();
            zipFile = new ZipFile (file, ZipFile.OPEN_READ);
        }
    } finally {
        flushing = false;
    }
}


public static BufferedImage convertRawImageToBufferedImage (RawImage rawImage) {
    assert rawImage.bpp == 16;
    BufferedImage im = new BufferedImage (rawImage.width, rawImage.height, BufferedImage.TYPE_USHORT_565_RGB);
    SampleModel sampleModel = new SinglePixelPackedSampleModel (DataBuffer.TYPE_USHORT, rawImage.width, rawImage.height, new int [] {0xf800, 0x07e0, 0x001f});
    short shortData [] = new short [rawImage.size / 2];
    for (int x = 0; x < shortData.length; x ++) {
        int rawImageOffset = x * 2;
        int a = 0xff & rawImage.data [rawImageOffset];
        int b = 0xff & rawImage.data [rawImageOffset + 1];
        shortData [x] = (short) ((b << 8) | a);
    }
    DataBuffer db = new DataBufferUShort (shortData, shortData.length);
    Raster raster = Raster.createRaster (sampleModel, db, null);
    im.setData (raster);
    return im;
}


-----Function Pair=204=-----==

private byte [] showTasks (HTTPurl urlData) throws Exception {
    StringBuffer out = new StringBuffer (2048);
    PageTemplate template = new PageTemplate (store.getProperty ("path.template") + File.separator + "TaskList.html");
    HashMap < String, TaskCommand > tasks = store.getTaskList ();
    String [] key = (String []) tasks.keySet ().toArray (new String [0]);
    Arrays.sort (key);
    for (int x = 0; x < key.length; x ++) {
        TaskCommand taskCommand = (TaskCommand) tasks.get (key [x]);
        out.append ("<tr>\n");
        if (taskCommand.getEnabled ()) {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=false'><img border='0' alt='Yes' src='/images/tick.png' width='24' height='24'></a></td>");
        }
        else {
            out.append ("<td align='center'><a href='/servlet/" + urlData.getServletClass () + "?action=17&name=" + URLEncoder.encode (key [x], "UTF-8") + "&enabled=true'><img border='0' alt='No' src='/images/stop.png' width='24' height='24'></a></td>");
        }
        out.append ("<td nowrap>" + key [x] + "</td>");
        out.append ("<td nowrap>" + new Boolean (taskCommand.getAutoRemove ()).toString () + "</td>");
        out.append ("<td nowrap>" + new Integer (taskCommand.getDelay ()).toString () + "</td>");
        out.append ("<td>" + taskCommand.getCommand () + "</td>");
        out.append ("<td align='center' nowrap>");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Run\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=44&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/RunTaskSmall.png' border='0' alt='Delete' title='Run' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' " + "href='/servlet/" + urlData.getServletClass () + "?action=22&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/edit.png' border='0' alt='Edit' title='Edit' width='24' height='24'></a> ");
        out.append ("<a class='noUnder' onClick='return confirmAction(\"Delete\");' " + "href='/servlet/" + urlData.getServletClass () + "?action=10&name=" + URLEncoder.encode (key [x], "UTF-8") + "'>");
        out.append ("<img src='/images/delete.png' border='0' alt='Delete' title='Delete' width='24' height='24'></a> ");
        out.append ("</td>");
        out.append ("</tr>\n");
    }
    template.replaceAll ("$taskList", out.toString ());
    template.replaceAll ("$defEpgTaskSelect", getTaskSelect ("tasks.deftask"));
    template.replaceAll ("$preTaskSelect", getTaskSelect ("tasks.pretask"));
    template.replaceAll ("$startErrorSelect", getTaskSelect ("tasks.starterrortask"));
    template.replaceAll ("$noDataErrorSelect", getTaskSelect ("tasks.nodataerrortask"));
    return template.getPageBytes ();
}


public static String convertHexadecimal2RGB (String hexColor, String divider) {
    String hex = hexColor.replaceFirst ("#", "");
    if (hex.length () != 6) return null;
    StringBuilder sb = new StringBuilder ();
    String toCon = hex.substring (0, 2);
    int color = Integer.parseInt (toCon, 16);
    sb.append (color);
    for (int i = 2; i < 6; i += 2) {
        toCon = hex.substring (i, i + 2);
        color = Integer.parseInt (toCon, 16);
        sb.append (divider);
        sb.append (color);
    }
    return sb.toString ();
}


-----Function Pair=205=-----==

private List < Foto > loadRss (String rssUrl, FotoFeed feed) throws URISyntaxException, IOException, JDOMException, ParseException {
    logger.info ("Fetching RSS : " + rssUrl);
    File tmpfile = File.createTempFile ("XXXX", "YYYY");
    Wget.get (rssUrl, tmpfile.toString ());
    InputStreamReader in = new InputStreamReader (new FileInputStream (tmpfile), Charset.forName ("ISO-8859-1"));
    ArrayList < Foto > fotos = new ArrayList < Foto > ();
    Namespace ns = Namespace.getNamespace ("media", "http://search.yahoo.com/mrss/");
    SAXBuilder builder = new SAXBuilder ();
    Document doc = builder.build (in);
    in.close ();
    tmpfile.delete ();
    Element root = doc.getRootElement ().getChild ("channel");
    List < Element > list = root.getChildren ("item");
    for (Element item : list) {
        Foto f = new Foto ();
        f.setTitle (item.getChildTextNormalize ("title"));
        f.setDate (item.getChildTextNormalize ("pubDate"));
        f.setImgUrl (item.getChild ("content", ns).getAttributeValue ("url"));
        f.setThumbUrl (item.getChild ("thumbnail", ns).getAttributeValue ("url"));
        f.setFeed (feed);
        fotos.add (f);
    }
    return fotos;
}


public static void decompress (File infile, String destDir) throws Exception {
    ZipFile zip = new ZipFile (infile);
    if (zip != null) {
        Enumeration entries = zip.entries ();
        while (entries.hasMoreElements ()) {
            ZipEntry entry = (ZipEntry) entries.nextElement ();
            String fileName = entry.getName ();
            InputStream in = zip.getInputStream (entry);
            File dir = new File (destDir);
            if (! dir.exists ()) {
                dir.mkdirs ();
            }
            String fullPath = destDir + "/" + fileName;
            FileOutputStream out = new FileOutputStream (fullPath);
            int nNumber;
            byte [] buffer = new byte [512];
            while ((nNumber = in.read (buffer)) != - 1) {
                out.write (buffer, 0, nNumber);
            }
            in.close ();
            out.close ();
        }
    }
}


-----Function Pair=206=-----==

public static void insertAdditionalParticipant (BPMNGraph graph, String id, String value, boolean toTop, Object parent) {
    mxGraphModel model = graph.getModel ();
    if (model.getCell (id) != null) {
        return;
    }
    double yOffset = 0;
    String style = "";
    mxCell subprocess = Utils.getChoreographyActivity (graph, parent);
    mxGeometry subgeo = model.getGeometry (subprocess);
    if (toTop) {
        yOffset = subgeo.getY () - 1;
        style = "participantAdditionalTop";
    }
    else {
        yOffset = subgeo.getY () + subgeo.getHeight () - 1;
        style = "participantAdditionalBottom";
    }
    mxCell participantCell = new mxCell (value, new mxGeometry (0, yOffset, Constants.ACTIVITY_WIDTH, Constants.PARTICIPANT_HEIGHT), style);
    participantCell.setId (id);
    participantCell.setVertex (true);
    graph.addCell (participantCell, (mxICell) parent);
    Utils.arrangeChoreography (graph, parent, false);
    graph.refresh ();
}


private static void zipDirectory (File directory, String name, ZipOutputStream zos) throws IOException {
    name += "/";
    zos.putNextEntry (new ZipEntry (name));
    zos.closeEntry ();
    String [] entryList = directory.list ();
    for (int i = 0; i < entryList.length; ++ i) {
        File f = new File (directory, entryList [i]);
        if (f.isDirectory ()) {
            zipDirectory (f, name + f.getName (), zos);
        }
        else {
            FileInputStream fis = new FileInputStream (f);
            ZipEntry entry = new ZipEntry (name + f.getName ());
            byte [] buffer = new byte [BUFFER_SIZE];
            int bytesIn = 0;
            zos.putNextEntry (entry);
            while ((bytesIn = fis.read (buffer)) != - 1) {
                zos.write (buffer, 0, bytesIn);
            }
            fis.close ();
            zos.closeEntry ();
        }
    }
}


-----Function Pair=207=-----==

public static void patch (String patch, String file) throws Exception {
    LinkedList < String > entries = new LinkedList < String > ();
    ZipFile patch_files = new ZipFile (patch);
    Enumeration patch_entries = patch_files.entries ();
    ZipFile original_files = new ZipFile (file);
    Enumeration original_entries = original_files.entries ();
    FileOutputStream t = new FileOutputStream (file + ".new");
    CheckedOutputStream csum = new CheckedOutputStream (t, new Adler32 ());
    BufferedOutputStream bos = new BufferedOutputStream (csum);
    ZipOutputStream zipper = new ZipOutputStream (bos);
    while (patch_entries.hasMoreElements ()) {
        ZipEntry ze = (ZipEntry) patch_entries.nextElement ();
        entries.add (ze.getName ());
        zipper.putNextEntry (ze);
        InputStream is = patch_files.getInputStream (ze);
        int i = 0;
        while (true) {
            i = is.read ();
            if (i == - 1) break;
            zipper.write (i);
        }
        zipper.closeEntry ();
    }
    try {
        while (original_entries.hasMoreElements ()) {
            ZipEntry ze = (ZipEntry) original_entries.nextElement ();
            if (! entries.contains (ze.getName ())) {
                zipper.putNextEntry (ze);
                InputStream is = original_files.getInputStream (ze);
                int i = 0;
                while (true) {
                    i = is.read ();
                    if (i == - 1) break;
                    zipper.write (i);
                }
                zipper.closeEntry ();
            }
        }
        zipper.close ();
        String temp = file + ".backup";
        File fpatch = new File (file + ".new");
        File ffile = new File (file);
        System.out.println (ffile.renameTo (new File (temp)));
        System.out.println (fpatch.renameTo (new File (file)));
    } catch (Exception e) {
        e.printStackTrace ();
    }
    zipper.close ();
}


public static WorkflowInstance create (WorkflowConf wfConf, List < DigitalObject > digos) throws Exception {
    String QName = wfConf.getTemplate ().getClazz ();
    File fTemplateJava = fetchDataToTempDir (QName);
    File fClazz = compileTemplateClassAtRuntime (fTemplateJava);
    File fJar = buildJarFile (fClazz, QName);
    addClassToClassPath (Thread.currentThread ().getContextClassLoader (), fJar);
    boolean bCheckOK = checkIsValidInstanceOfWFTemplate (QName);
    if (! bCheckOK) {
        String err = "The provided WFTemplate: " + QName + " is not a valid implementation";
        log.debug (err);
        throw new Exception (err);
    }
    WorkflowTemplate wft = (WorkflowTemplate) Class.forName (QName).newInstance ();
    log.debug ("WorkflowFactory: " + QName + " loaded, compiled and classloaded");
    workflowContext = null;
    List < Field > declaredServices = getDeclaredWFServices (wft);
    int iCount = 0;
    for (Field declaredService : declaredServices) {
        String declaredServiceID = declaredService.getName ();
        for (Service serviceConf : wfConf.getServices ().getService ()) {
            String serviceConfID = serviceConf.getId ();
            if (declaredServiceID.equals (serviceConfID)) {
                initWFService (wft, declaredService, serviceConf);
                iCount ++;
            }
        }
    }
    if (iCount != declaredServices.size ()) {
        String err = "The provided Workflow configuration is not suitable for the given workflow " + wft.getClass ().getCanonicalName () + "1..n service configurations missing";
        log.debug (err);
        throw new Exception (err);
    }
    wft.setData (digos);
    wft.setWorkflowContext (getOrInitWFContext ());
    WorkflowInstance wfi = new WorkflowInstanceImpl (wft);
    wft.setWorkflowInstanceID (wfi.getWorkflowID ());
    return wfi;
}


-----Function Pair=208=-----==

private void copyZip (ZipInputStream zin, org.apache.tools.zip.ZipOutputStream out, List < String > files) throws IOException {
    java.util.zip.ZipEntry zentry;
    if (! alreadyWrittenFiles.containsKey (out)) {
        alreadyWrittenFiles.put (out, new HashSet < String > ());
    }
    HashSet < String > currentSet = alreadyWrittenFiles.get (out);
    while ((zentry = zin.getNextEntry ()) != null) {
        String currentName = zentry.getName ();
        String testName = currentName.replace ('/', '.');
        testName = testName.replace ('\\', '.');
        if (files != null) {
            Iterator < String > i = files.iterator ();
            boolean founded = false;
            while (i.hasNext ()) {
                String doInclude = i.next ();
                if (testName.matches (doInclude)) {
                    founded = true;
                    break;
                }
            }
            if (! founded) {
                continue;
            }
        }
        if (currentSet.contains (currentName)) {
            continue;
        }
        try {
            org.apache.tools.zip.ZipEntry newEntry = new org.apache.tools.zip.ZipEntry (currentName);
            long fileTime = zentry.getTime ();
            if (fileTime != - 1) {
                newEntry.setTime (fileTime);
            }
            out.putNextEntry (newEntry);
            PackagerHelper.copyStream (zin, out);
            out.closeEntry ();
            zin.closeEntry ();
            currentSet.add (currentName);
        } catch (ZipException x) {
        }
    }
}


static void copyZipEntries (ZipOutputStream zout, File src, Filter filter) throws Throwable {
    ZipFile zipSrc = null;
    try {
        zipSrc = new ZipFile (src);
    } catch (Throwable t) {
        System.out.println ("Unexpected error:");
        t.printStackTrace ();
        System.out.println ();
        System.out.println ("Your JDK_DIR cannot handle long JAR entries");
        System.out.println ("Please upgrade to JDK 1.4.1 or later.");
        System.out.println ("JDK version '1.4.1' is known to work.");
        System.exit (- 1);
    }
    for (Enumeration e = zipSrc.entries (); e.hasMoreElements ();) {
        ZipEntry entry = (ZipEntry) e.nextElement ();
        String name = entry.getName ();
        if (name.startsWith ("META-INF")) {
            continue;
        }
        if (filter != null && ! filter.includeEntry (entry.getName ())) {
            continue;
        }
        int size = (int) entry.getSize ();
        byte data [] = new byte [size];
        InputStream in = zipSrc.getInputStream (entry);
        DataInputStream din = new DataInputStream (in);
        din.readFully (data);
        zout.putNextEntry (entry);
        zout.write (data, 0, data.length);
        zout.closeEntry ();
        din.close ();
    }
}


-----Function Pair=209=-----==

public static final boolean existsDocuments (boObject object) throws boRuntimeException {
    boolean result = false;
    String objClassName = null;
    boObject attObject = null;
    AttributeHandler attHandler = null;
    Enumeration oEnum = object.getAttributes ().elements ();
    while (oEnum.hasMoreElements () && ! result) {
        attHandler = (AttributeHandler) oEnum.nextElement ();
        if (attHandler.getDefAttribute ().getAtributeType () == attHandler.getDefAttribute ().TYPE_OBJECTATTRIBUTE) {
            if (attHandler.getDefAttribute ().getRelationType () == boDefAttribute.RELATION_1_TO_1) {
                attObject = attHandler.getObject ();
                if (attObject != null) {
                    objClassName = attObject.getName ();
                    if (isDocument (objClassName) && isIFile (attObject)) {
                        result = true;
                    }
                }
            }
            else if (attHandler.getDefAttribute ().getRelationType () == boDefAttribute.RELATION_MULTI_VALUES) {
                boObject [] attBoObjects = attHandler.getObjects ();
                if (attBoObjects != null) {
                    for (int i = 0; i < attBoObjects.length; i ++) {
                        attObject = attBoObjects [i];
                        objClassName = attObject.getName ();
                        if (isDocument (objClassName) && isIFile (attObject)) {
                            result = true;
                        }
                    }
                }
            }
            else {
                bridgeHandler bridge = object.getBridge (attHandler.getName ());
                bridge.beforeFirst ();
                while (bridge.next ()) {
                    attObject = bridge.getObject ();
                    objClassName = attObject.getName ();
                    if (isDocument (objClassName) && isIFile (attObject)) {
                        result = true;
                    }
                }
            }
        }
    }
    return result;
}


public static void createZipFile (File zipFile, Collection includeFiles, final boolean verbose) throws IOException {
    if (verbose) {
        System.out.println ("ZIP: " + zipFile.getAbsolutePath ());
    }
    byte [] buf = new byte [BUFFER_SIZE];
    ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
    for (Iterator iterator = includeFiles.iterator (); iterator.hasNext ();) {
        File entryFile = (File) iterator.next ();
        if (verbose) {
            System.out.println ("Adding: " + entryFile.getAbsolutePath ());
        }
        if (! entryFile.canRead ()) {
            System.err.println ("ZipBuilder: Could not read " + entryFile.getAbsolutePath ());
            continue;
        }
        FileInputStream in = new FileInputStream (entryFile);
        out.putNextEntry (new ZipEntry (entryFile.getName ()));
        int len;
        while ((len = in.read (buf)) > 0) {
            out.write (buf, 0, len);
        }
        out.closeEntry ();
        in.close ();
    }
    out.close ();
}


-----Function Pair=210=-----==

private void explodeGeometryCollection (FeatureSchema fs, ArrayList pointFeatures, ArrayList lineFeatures, ArrayList polyFeatures, GeometryCollection geometryCollection, Feature feature) {
    for (int i = 0; i < geometryCollection.getNumGeometries (); i ++) {
        Geometry geometry = geometryCollection.getGeometryN (i);
        if (geometry instanceof GeometryCollection) {
            explodeGeometryCollection (fs, pointFeatures, lineFeatures, polyFeatures, (GeometryCollection) geometry, feature);
        }
        else {
            Feature newFeature = feature.clone (true);
            newFeature.setGeometry (geometry);
            BitSet featureBit = new BitSet ();
            featureBit = GeoUtils.setBit (featureBit, geometry);
            if (featureBit.get (GeoUtils.pointBit)) pointFeatures.add (newFeature);
            if (featureBit.get (GeoUtils.lineBit)) lineFeatures.add (newFeature);
            if (featureBit.get (GeoUtils.polyBit)) polyFeatures.add (newFeature);
        }
    }
}


private void createPoseidonFile (String zipFilename) throws MiddlegenException {
    try {
        File dir = getDestinationDir ();
        String xmiFileName = getXmiFilename ();
        String projFileName = getProjFilename ();
        File zipFile = new File (dir, zipFilename);
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (zipFile));
        ZipEntry zipEntry = new ZipEntry (projFileName);
        out.putNextEntry (zipEntry);
        File projFile = new File (dir, projFileName);
        FileInputStream in = new FileInputStream (projFile);
        writeInToOut (in, out);
        in.close ();
        zipEntry = new ZipEntry (xmiFileName);
        out.putNextEntry (zipEntry);
        File xmiFile = new File (dir, xmiFileName);
        in = new FileInputStream (xmiFile);
        writeInToOut (in, out);
        in.close ();
        out.close ();
        projFile.delete ();
    } catch (Exception ex) {
        throw new MiddlegenException (ex.getMessage ());
    }
}


-----Function Pair=211=-----=1=

public void outputEntry (ZipOutputStream zos, File f, boolean isRecursive) throws Error, IOException {
    String adjustedPath = f.getPath ().replace (File.separatorChar, '/');
    if (f.isDirectory () && ! adjustedPath.endsWith ("/")) {
        adjustedPath += '/';
    }
    String fileName = f.getName ();
    ZipEntry entry = new ZipEntry (fileName);
    entry.setTime (f.lastModified ());
    zos.putNextEntry (entry);
    if (f.isDirectory ()) {
        if (isRecursive) {
            String [] files = f.list ();
            for (int i = 0; i < files.length; ++ i) {
                outputEntry (zos, new File (f, files [i]), isRecursive);
            }
        }
    }
    else {
        FileInputStream fis = new FileInputStream (f);
        byte buf [] = new byte [1024];
        for (int cnt; (cnt = fis.read (buf)) != - 1;) {
            zos.write (buf, 0, cnt);
        }
        fis.close ();
    }
}


public static void decompileClass (String className, ZipOutputStream destZip, String destDir, TabbedPrintWriter writer, ImportHandler imports) {
    try {
        ClassInfo clazz;
        try {
            clazz = ClassInfo.forName (className);
        } catch (IllegalArgumentException ex) {
            GlobalOptions.err.println ("`" + className + "' is not a class name");
            return;
        }
        if (skipClass (clazz)) return;
        String filename = className.replace ('.', File.separatorChar) + ".java";
        if (destZip != null) {
            writer.flush ();
            destZip.putNextEntry (new ZipEntry (filename));
        }
        else if (destDir != null) {
            File file = new File (destDir, filename);
            File directory = new File (file.getParent ());
            if (! directory.exists () && ! directory.mkdirs ()) {
                GlobalOptions.err.println ("Could not create directory " + directory.getPath () + ", check permissions.");
            }
            writer = new TabbedPrintWriter (new BufferedOutputStream (new FileOutputStream (file)), imports, false);
        }
        GlobalOptions.err.println (className);
        ClassAnalyzer clazzAna = new ClassAnalyzer (clazz, imports);
        clazzAna.dumpJavaFile (writer);
        if (destZip != null) {
            writer.flush ();
            destZip.closeEntry ();
        }
        else if (destDir != null) writer.close ();
        System.gc ();
        successCount ++;
    } catch (IOException ex) {
        failedClasses.addElement (className);
        GlobalOptions.err.println ("Can't write source of " + className + ".");
        GlobalOptions.err.println ("Check the permissions.");
        ex.printStackTrace (GlobalOptions.err);
    } catch (Throwable t) {
        failedClasses.addElement (className);
        GlobalOptions.err.println ("Failed to decompile " + className + ".");
        t.printStackTrace (GlobalOptions.err);
    }
}


-----Function Pair=212=-----=1=

public static void zipFiles (String zipFilePath, String [] filenames) {
    byte [] buf = new byte [1024];
    try {
        String outFilename = zipFilePath;
        ZipOutputStream out = new ZipOutputStream (new FileOutputStream (outFilename));
        for (int i = 0; i < filenames.length; i ++) {
            File file = new File (filenames [i]);
            if (file.exists ()) {
                FileInputStream in = new FileInputStream (filenames [i]);
                out.putNextEntry (new ZipEntry (filenames [i]));
                int len;
                while ((len = in.read (buf)) > 0) {
                    out.write (buf, 0, len);
                }
                out.closeEntry ();
                in.close ();
            }
        }
        out.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}


private void downloadZipDocument (HttpServletResponse response) throws Exception {
    ZipOutputStream out = new ZipOutputStream (response.getOutputStream ());
    out.setMethod (ZipOutputStream.DEFLATED);
    for (int i = 0; i < this.lstZipFileName.size (); i ++) {
        String documentName = (String) this.lstZipFileName.get (i);
        String documentPath = (String) this.lstZipFilePath.get (i);
        if ("NO_FILE".equals (documentPath)) {
            out.putNextEntry (new ZipEntry (documentName));
        }
        else {
            out.putNextEntry (new ZipEntry (documentName));
            File file = new File (documentPath);
            if (file.exists ()) {
                FileInputStream in = new FileInputStream (file);
                byte [] buffer = new byte [8192];
                int length = - 1;
                while ((length = in.read (buffer, 0, 8192)) != - 1) {
                    out.write (buffer, 0, length);
                }
                in.close ();
            }
        }
    }
    out.flush ();
    out.close ();
}


-----Function Pair=213=-----==

public static void saveInputStreamToFile (InputStream in, File file) throws Exception {
    if (file.getParentFile () != null) {
        file.getParentFile ().mkdirs ();
    }
    FileOutputStream fos = new FileOutputStream (file);
    try {
        byte [] buf = new byte [4000];
        int c;
        while (true) {
            c = in.read (buf);
            if (c == - 1) {
                break;
            }
            fos.write (buf, 0, c);
        }
    } finally {
        fos.close ();
    }
}


public long getChecksumValue (File fname) throws Exception {
    Checksum checksum = new CRC32 ();
    checksum.reset ();
    BufferedInputStream inputStream = null;
    try {
        inputStream = new BufferedInputStream (new FileInputStream (fname));
        byte [] bytes = new byte [1024];
        int len = 0;
        while ((len = inputStream.read (bytes)) >= 0) {
            checksum.update (bytes, 0, len);
        }
    } catch (Exception ex) {
        return - 1;
    } finally {
        try {
            inputStream.close ();
        } catch (Exception ex) {
        }
    }
    return checksum.getValue ();
}


-----Function Pair=214=-----==

public static void exampleContentHandlertoDOM (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException, ParserConfigurationException {
    TransformerFactory tfactory = TransformerFactory.newInstance ();
    if (tfactory.getFeature (SAXSource.FEATURE) && tfactory.getFeature (DOMSource.FEATURE)) {
        SAXTransformerFactory sfactory = (SAXTransformerFactory) tfactory;
        DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance ();
        DocumentBuilder docBuilder = dfactory.newDocumentBuilder ();
        org.w3c.dom.Document outNode = docBuilder.newDocument ();
        TransformerHandler handler = sfactory.newTransformerHandler (new StreamSource (xslID));
        handler.setResult (new DOMResult (outNode));
        XMLReader reader = makeXMLReader ();
        reader.setContentHandler (handler);
        reader.setProperty ("http://xml.org/sax/properties/lexical-handler", handler);
        reader.parse (sourceID);
        exampleSerializeNode (outNode);
    }
    else {
        System.out.println ("Can't do exampleContentHandlerToContentHandler because tfactory is not a SAXTransformerFactory");
    }
}


public static void exampleContentHandlerToContentHandler (String sourceID, String xslID) throws TransformerException, TransformerConfigurationException, SAXException, IOException {
    TransformerFactory tfactory = TransformerFactory.newInstance ();
    if (tfactory.getFeature (SAXSource.FEATURE)) {
        SAXTransformerFactory stfactory = ((SAXTransformerFactory) tfactory);
        TransformerHandler handler = stfactory.newTransformerHandler (new StreamSource (xslID));
        Result result = new SAXResult (new ExampleContentHandler ());
        handler.setResult (result);
        XMLReader reader = null;
        try {
            javax.xml.parsers.SAXParserFactory factory = javax.xml.parsers.SAXParserFactory.newInstance ();
            factory.setNamespaceAware (true);
            javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser ();
            reader = jaxpParser.getXMLReader ();
        } catch (javax.xml.parsers.ParserConfigurationException ex) {
            throw new org.xml.sax.SAXException (ex);
        } catch (javax.xml.parsers.FactoryConfigurationError ex1) {
            throw new org.xml.sax.SAXException (ex1.toString ());
        } catch (NoSuchMethodError ex2) {
        }
        if (reader == null) reader = XMLReaderFactory.createXMLReader ();
        reader.setContentHandler (handler);
        reader.setProperty ("http://xml.org/sax/properties/lexical-handler", handler);
        reader.parse (sourceID);
    }
    else {
        System.out.println ("Can't do exampleContentHandlerToContentHandler because tfactory is not a SAXTransformerFactory");
    }
}


-----Function Pair=215=-----=1=

public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


public static void BubbleSortLong2 (long [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                long temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=216=-----=1=

public static File chooseFileSave (JFrame frame) {
    File retval;
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.FILES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFile ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


public static File [] chooseFileDirectory (JFrame frame) {
    File retval [];
    JFileChooser fc = new JFileChooser ();
    fc.setDialogTitle ("Select input file.");
    fc.setFileSelectionMode (JFileChooser.DIRECTORIES_ONLY);
    fc.setMultiSelectionEnabled (false);
    int status = fc.showSaveDialog (frame);
    if (status == JFileChooser.APPROVE_OPTION) {
        retval = fc.getSelectedFiles ();
    }
    else if (status == JFileChooser.CANCEL_OPTION) {
        retval = null;
    }
    else {
        retval = null;
    }
    fc.setEnabled (false);
    fc.setVisible (false);
    return retval;
}


-----Function Pair=217=-----==

public static void main (String [] args) throws TransformerException, TransformerConfigurationException, FileNotFoundException, ParserConfigurationException, SAXException, IOException {
    TransformerFactory tFactory = TransformerFactory.newInstance ();
    if (tFactory.getFeature (DOMSource.FEATURE) && tFactory.getFeature (DOMResult.FEATURE)) {
        DocumentBuilderFactory dFactory = DocumentBuilderFactory.newInstance ();
        dFactory.setNamespaceAware (true);
        DocumentBuilder dBuilder = dFactory.newDocumentBuilder ();
        Document xslDoc = dBuilder.parse ("birds.xsl");
        DOMSource xslDomSource = new DOMSource (xslDoc);
        xslDomSource.setSystemId ("birds.xsl");
        Transformer transformer = tFactory.newTransformer (xslDomSource);
        Document xmlDoc = dBuilder.parse ("birds.xml");
        DOMSource xmlDomSource = new DOMSource (xmlDoc);
        xmlDomSource.setSystemId ("birds.xml");
        DOMResult domResult = new DOMResult ();
        transformer.transform (xmlDomSource, domResult);
        java.util.Properties xmlProps = OutputPropertiesFactory.getDefaultMethodProperties ("xml");
        xmlProps.setProperty ("indent", "yes");
        xmlProps.setProperty ("standalone", "no");
        Serializer serializer = SerializerFactory.getSerializer (xmlProps);
        serializer.setOutputStream (System.out);
        serializer.asDOMSerializer ().serialize (domResult.getNode ());
    }
    else {
        throw new org.xml.sax.SAXNotSupportedException ("DOM node processing not supported!");
    }
}


public static void exampleXMLFilterChain (String sourceID, String xslID_1, String xslID_2, String xslID_3) throws TransformerException, TransformerConfigurationException, SAXException, IOException, MalformedURLException {
    TransformerFactory tfactory = TransformerFactory.newInstance ();
    Templates stylesheet1 = tfactory.newTemplates (new StreamSource (new File (xslID_1)));
    Transformer transformer1 = stylesheet1.newTransformer ();
    if (tfactory.getFeature (SAXSource.FEATURE)) {
        SAXTransformerFactory stf = (SAXTransformerFactory) tfactory;
        XMLReader reader = makeXMLReader ();
        XMLFilter filter1 = stf.newXMLFilter (new StreamSource (new File (xslID_1)));
        XMLFilter filter2 = stf.newXMLFilter (new StreamSource (new File (xslID_2)));
        XMLFilter filter3 = stf.newXMLFilter (new StreamSource (new File (xslID_3)));
        if (null != filter1) {
            filter1.setParent (reader);
            filter2.setParent (filter1);
            filter3.setParent (filter2);
            filter3.setContentHandler (new ExampleContentHandler ());
            filter3.parse (new InputSource (new File (sourceID).toURL ().toString ()));
        }
        else {
            System.out.println ("Can't do exampleXMLFilter because " + "tfactory doesn't support newXMLFilter()");
        }
    }
    else {
        System.out.println ("Can't do exampleXMLFilter because " + "tfactory is not a SAXTransformerFactory");
    }
}


-----Function Pair=218=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=219=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=220=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=221=-----==

public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=222=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=223=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=224=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=225=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=226=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=227=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=228=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=229=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=230=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=231=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=232=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=233=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=234=-----==

public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=235=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=236=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=237=-----==

public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=238=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=239=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=240=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=241=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=242=-----==

public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


-----Function Pair=243=-----==

public void test40 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the delimiter is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, This field contains a comma\\, but it doesn't matter as the delimiter is escaped", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=244=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=245=-----==

public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                OPTRecord opt = query.getOPT ();
                if (opt != null) udpLength = opt.getPayloadSize ();
                response = generateReply (query, in, udpLength);
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


public void serveUDP (short port) {
    try {
        DatagramSocket sock = new DatagramSocket (port);
        while (true) {
            short udpLength = 512;
            DatagramPacket dp = new DatagramPacket (new byte [512], 512);
            try {
                sock.receive (dp);
            } catch (InterruptedIOException e) {
                continue;
            }
            byte [] in = new byte [dp.getLength ()];
            System.arraycopy (dp.getData (), 0, in, 0, in.length);
            Message query, response;
            try {
                query = new Message (in);
                OPTRecord opt = query.getOPT ();
                if (opt != null) udpLength = opt.getPayloadSize ();
                response = generateReply (query, in, udpLength);
            } catch (IOException e) {
                response = formerrMessage (in);
            }
            byte [] out = response.toWire ();
            dp = new DatagramPacket (out, out.length, dp.getAddress (), dp.getPort ());
            sock.send (dp);
        }
    } catch (IOException e) {
        System.out.println ("serveUDP: " + e);
    }
}


-----Function Pair=246=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=247=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=248=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=249=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=250=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=251=-----==

public void test72 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\0', writer.getRecordDelimiter ());
    writer.setRecordDelimiter (';');
    Assert.assertEquals (';', writer.getRecordDelimiter ());
    writer.write ("a;b");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"a;b\";", data);
}


public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


-----Function Pair=252=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


-----Function Pair=253=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=254=-----==

public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


public void test117 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('#', writer.getComment ());
    writer.setComment ('~');
    Assert.assertEquals ('~', writer.getComment ());
    writer.setRecordDelimiter (';');
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1;~blah;", data);
}


-----Function Pair=255=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=256=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=257=-----==

public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=258=-----==

public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test4 () throws Exception {
    String data = "1\r2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=259=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=260=-----==

public void test123 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("#123");
    writer.endRecord ();
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("#123");
    writer.endRecord ();
    writer.write ("#");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"#123\"\r\n\\#123\r\n\\#\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=261=-----==

public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test138 () throws Exception {
    CsvReader reader = CsvReader.parse ("1;; ;1");
    reader.setRecordDelimiter (';');
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=262=-----==

public void test1 () throws Exception {
    CsvReader reader = CsvReader.parse ("1,2");
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1,2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test135 () throws Exception {
    CsvReader reader = CsvReader.parse ("1\n\n1\r\r1\r\n\r\n1\n\r1");
    Assert.assertTrue (reader.getSkipEmptyRecords ());
    reader.setSkipEmptyRecords (false);
    Assert.assertFalse (reader.getSkipEmptyRecords ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (4L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (5L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (6L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (7L, reader.getCurrentRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (8L, reader.getCurrentRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=263=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=264=-----=1=

public static void main (String [] argv) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, (Object []) noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


public static void main (String [] argv) throws Exception {
    if (argv.length == 0) {
        printUsage ();
        return;
    }
    for (int iArg = 0; iArg < argv.length; iArg ++) {
        String arg = argv [iArg];
        if (arg.startsWith ("-h")) {
            printUsage ();
            return;
        }
        System.out.println ("**** START OF EXECUTION of " + arg + "." + methodToRun + " " + signatureToPrintOut + " ****.");
        Class klass = Class.forName (arg);
        Method method = klass.getDeclaredMethod (methodToRun, noparams);
        Object result = method.invoke (null, (Object []) noparams);
        System.out.println ("**** RESULT: " + result);
    }
}


-----Function Pair=265=-----==

public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test21 () throws Exception {
    String data = "'bob said, ''Hey!''',2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setTextQualifier ('\'');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, 'Hey!'", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("'bob said, ''Hey!''',2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=266=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=267=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=268=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=269=-----==

public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=270=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=271=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=272=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=273=-----==

public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=274=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=275=-----==

public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=276=-----==

public void test48 () throws Exception {
    byte [] buffer;
    String test = "M�nchen";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (new OutputStreamWriter (stream, Charset.forName ("UTF-8")));
    writer.write (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new InputStreamReader (new ByteArrayInputStream (buffer), Charset.forName ("UTF-8")));
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


public void test92 () throws Exception {
    byte [] buffer;
    String test = "test";
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    PrintWriter writer = new PrintWriter (stream);
    writer.println (test);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    CsvReader reader = new CsvReader (new ByteArrayInputStream (buffer), ',', Charset.forName ("ISO-8859-1"));
    reader.readRecord ();
    Assert.assertEquals (test, reader.get (0));
    reader.close ();
}


-----Function Pair=277=-----==

public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


-----Function Pair=278=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=279=-----==

private static Set getOpcodes (Method [] emitters) {
    Set s = new HashSet ();
    for (int i = 0; i < emitters.length; i ++) {
        String name = emitters [i].getName ();
        if (DEBUG) System.out.println (name);
        if (name.startsWith ("emit")) {
            int posOf_ = name.indexOf ('_');
            if (posOf_ != - 1) {
                String opcode = name.substring (4, posOf_);
                if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
            else {
                String opcode = name.substring (4);
                if (opcode.equals (opcode.toUpperCase (Locale.getDefault ()))) if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
        }
    }
    return s;
}


private static Set getOpcodes (Method [] emitters) {
    Set s = new HashSet ();
    for (int i = 0; i < emitters.length; i ++) {
        String name = emitters [i].getName ();
        if (DEBUG) System.out.println (name);
        if (name.startsWith ("emit")) {
            int posOf_ = name.indexOf ('_');
            if (posOf_ != - 1) {
                String opcode = name.substring (4, posOf_);
                if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
            else {
                String opcode = name.substring (4);
                if (opcode.equals (opcode.toUpperCase (Locale.getDefault ()))) if (! excludedOpcodes.contains (opcode)) s.add (opcode);
            }
        }
    }
    return s;
}


-----Function Pair=280=-----==

public void test119 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    Assert.assertEquals (',', writer.getDelimiter ());
    writer.setDelimiter ('\t');
    Assert.assertEquals ('\t', writer.getDelimiter ());
    writer.write ("1,2");
    writer.write ("3");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3\r\n1,2\t3\r\n", data);
}


public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


-----Function Pair=281=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=282=-----==

public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=283=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test27 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\n\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"1\",Bruce", reader.getRawRecord ());
    Assert.assertTrue (reader.skipRecord ());
    Assert.assertEquals ("\"2\n\",Toni", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get (0));
    Assert.assertEquals ("Brian", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("\"3\",Brian", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=284=-----==

public void test122 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write (null);
    writer.write ("3 ", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",,\"3 \"\r\n", data);
}


public void test131 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setUseTextQualifier (false);
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.write ("1,\\\r\n2");
    writer.endRecord ();
    writer.setRecordDelimiter (';');
    writer.write ("1,\\;2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,\\\\\\\r\\\n2\r\n1\\,\\\\\\;2;", data);
}


-----Function Pair=285=-----==

public void test34 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"\r\n" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=286=-----==

private void emitEmitCall (String opcode, int [] args, int count, int level, int size) {
    emitTab (level);
    emit ("emit" + opcode);
    for (int i = 0; i < count; i ++) emit ("_" + encoding [args [i]]);
    if (size != 0) emit ("_" + encoding [size]);
    if (count == 0) emit ("();\n");
    else {
        emit ("(");
        for (int i = 0; i < count; i ++) {
            emit ("\n");
            emitTab (level + 1);
            emitArgs (i, args [i]);
            if (i == count - 1) emit (");\n");
            else emit (",");
        }
    }
}


private void emitEmitCall (String opcode, int [] args, int count, int level, int size) {
    emitTab (level);
    emit ("emit" + opcode);
    for (int i = 0; i < count; i ++) emit ("_" + encoding [args [i]]);
    if (size != 0) emit ("_" + encoding [size]);
    if (count == 0) emit ("();\n");
    else {
        emit ("(");
        for (int i = 0; i < count; i ++) {
            emit ("\n");
            emitTab (level + 1);
            emitArgs (i, args [i]);
            if (i == count - 1) emit (");\n");
            else emit (",");
        }
    }
}


-----Function Pair=287=-----==

public void test14 () throws Exception {
    String data = "user_id,name\r\n1,Bruce";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readHeaders ());
    Assert.assertEquals ("user_id,name", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("Bruce", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (0, reader.getIndex ("user_id"));
    Assert.assertEquals (1, reader.getIndex ("name"));
    Assert.assertEquals ("user_id", reader.getHeader (0));
    Assert.assertEquals ("name", reader.getHeader (1));
    Assert.assertEquals ("1", reader.get ("user_id"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals ("1,Bruce", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=288=-----==

public void test16 () throws Exception {
    String data = "\r\r\n1\r";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals ("", reader.get (2));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\r\r", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test45 () throws Exception {
    String data = "\"Chicane\", \"Love on the Run\", \"Knight Rider\", \"This field contains a comma, but it doesn't matter as the field is quoted\"i" + "\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (false);
    Assert.assertFalse (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("", reader.getRawRecord ());
    Assert.assertFalse (reader.getCaptureRawRecord ());
    reader.setCaptureRawRecord (true);
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("\"Samuel Barber\", \"Adagio for Strings\", \"Classical\", \"This field contains a double quote character, \"\", but it doesn't matter as it is escaped\"", reader.getRawRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a double quote character, \", but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertTrue (reader.getCaptureRawRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=289=-----==

public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


-----Function Pair=290=-----==

static Object [] packageParameterFromVarArg (VM_Method targetMethod, int argAddress) {
    VM_Type [] argTypes = targetMethod.getParameterTypes ();
    int argCount = argTypes.length;
    Object [] argObjectArray = new Object [argCount];
    VM_JNIEnvironment env = VM_Thread.getCurrentThread ().getJNIEnv ();
    for (int i = 0, addr = argAddress; i < argCount; i ++) {
        int loword, hiword;
        loword = VM_Magic.getMemoryWord (addr);
        addr += 4;
        if (argTypes [i].isFloatType ()) {
            hiword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapFloat ((float) (Double.longBitsToDouble (doubleBits)));
        }
        else if (argTypes [i].isDoubleType ()) {
            hiword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapDouble (Double.longBitsToDouble (doubleBits));
        }
        else if (argTypes [i].isLongType ()) {
            hiword = VM_Magic.getMemoryWord (addr);
            addr += 4;
            long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapLong (longValue);
        }
        else if (argTypes [i].isBooleanType ()) {
            argObjectArray [i] = VM_Reflection.wrapBoolean (loword);
        }
        else if (argTypes [i].isByteType ()) {
            argObjectArray [i] = VM_Reflection.wrapByte ((byte) loword);
        }
        else if (argTypes [i].isCharType ()) {
            argObjectArray [i] = VM_Reflection.wrapChar ((char) loword);
        }
        else if (argTypes [i].isShortType ()) {
            argObjectArray [i] = VM_Reflection.wrapShort ((short) loword);
        }
        else if (argTypes [i].isReferenceType ()) {
            argObjectArray [i] = env.getJNIRef (loword);
        }
        else if (argTypes [i].isIntType ()) {
            argObjectArray [i] = VM_Reflection.wrapInt (loword);
        }
        else {
            return null;
        }
    }
    return argObjectArray;
}


static Object [] packageParameterFromJValue (VM_Method targetMethod, int argAddress) {
    VM_Type [] argTypes = targetMethod.getParameterTypes ();
    int argCount = argTypes.length;
    Object [] argObjectArray = new Object [argCount];
    VM_JNIEnvironment env = VM_Thread.getCurrentThread ().getJNIEnv ();
    for (int i = 0, addr = argAddress; i < argCount; i ++, addr += 8) {
        int loword, hiword;
        loword = VM_Magic.getMemoryWord (addr);
        if (argTypes [i].isFloatType ()) {
            argObjectArray [i] = VM_Reflection.wrapFloat (Float.intBitsToFloat (loword));
        }
        else if (argTypes [i].isDoubleType ()) {
            hiword = VM_Magic.getMemoryWord (addr + 4);
            long doubleBits = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapDouble (Double.longBitsToDouble (doubleBits));
        }
        else if (argTypes [i].isLongType ()) {
            hiword = VM_Magic.getMemoryWord (addr + 4);
            long longValue = (((long) hiword) << 32) | (loword & 0xFFFFFFFFL);
            argObjectArray [i] = VM_Reflection.wrapLong (longValue);
        }
        else if (argTypes [i].isBooleanType ()) {
            argObjectArray [i] = VM_Reflection.wrapBoolean (loword & 0x000000FF);
        }
        else if (argTypes [i].isByteType ()) {
            argObjectArray [i] = VM_Reflection.wrapByte ((byte) (loword & 0x000000FF));
        }
        else if (argTypes [i].isCharType ()) {
            argObjectArray [i] = VM_Reflection.wrapChar ((char) (loword & 0x0000FFFF));
        }
        else if (argTypes [i].isShortType ()) {
            argObjectArray [i] = VM_Reflection.wrapShort ((short) (loword & 0x0000FFFF));
        }
        else if (argTypes [i].isReferenceType ()) {
            argObjectArray [i] = env.getJNIRef (loword);
        }
        else if (argTypes [i].isIntType ()) {
            argObjectArray [i] = VM_Reflection.wrapInt (loword);
        }
        else {
            return null;
        }
    }
    return argObjectArray;
}


-----Function Pair=291=-----==

public void test37 () throws Exception {
    String data = "  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals (" Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("  \" Chicane\"  junk here  , Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=292=-----==

public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test24 () throws Exception {
    String data = "1\r\n\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=293=-----==

public void test120 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.endRecord ();
    buffer = stream.toByteArray ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("", data);
    writer.flush ();
    buffer = stream.toByteArray ();
    stream.close ();
    data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\"\r\n", data);
    writer.close ();
}


public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


-----Function Pair=294=-----==

public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=295=-----==

public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test2 () throws Exception {
    String data = "\"bob said, \"\"Hey!\"\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \"\"Hey!\"\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=296=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=297=-----==

public void test73 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_DOUBLED, writer.getEscapeMode ());
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvWriter.ESCAPE_MODE_BACKSLASH, writer.getEscapeMode ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.setForceQualifier (true);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"1,2\",3,\"blah \\\"some stuff in quotes\\\"\"\r\n\"1,2\",\"3\",\"blah \\\"some stuff in quotes\\\"\"", data);
}


public void test118 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    Assert.assertEquals ('\"', writer.getTextQualifier ());
    writer.setTextQualifier ('\'');
    Assert.assertEquals ('\'', writer.getTextQualifier ());
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.write ("blah \'some stuff in quotes\'");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\tblah \"some stuff in quotes\"\t\'blah \'\'some stuff in quotes\'\'\'\r\n", data);
}


-----Function Pair=298=-----==

public void test3 () throws Exception {
    String data = ",";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals ("", reader.get (1));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals (",", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test28 () throws Exception {
    String data = "\"bob said, \\\"Hey!\\\"\",2, 3 ";
    CsvReader reader = CsvReader.parse (data);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("bob said, \"Hey!\"", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals ("3", reader.get (2));
    Assert.assertEquals (',', reader.getDelimiter ());
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (3, reader.getColumnCount ());
    Assert.assertEquals ("\"bob said, \\\"Hey!\\\"\",2, 3 ", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=299=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


-----Function Pair=300=-----==

public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


public void test39 () throws Exception {
    CsvReader reader = CsvReader.parse ("user_id,name\r\n1,Bruce");
    Assert.assertTrue (reader.getSafetySwitch ());
    reader.setSafetySwitch (false);
    Assert.assertFalse (reader.getSafetySwitch ());
    Assert.assertEquals ('#', reader.getComment ());
    reader.setComment ('!');
    Assert.assertEquals ('!', reader.getComment ());
    Assert.assertEquals (CsvReader.ESCAPE_MODE_DOUBLED, reader.getEscapeMode ());
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    Assert.assertEquals (CsvReader.ESCAPE_MODE_BACKSLASH, reader.getEscapeMode ());
    Assert.assertEquals ('\0', reader.getRecordDelimiter ());
    reader.setRecordDelimiter (';');
    Assert.assertEquals (';', reader.getRecordDelimiter ());
    Assert.assertEquals ('\"', reader.getTextQualifier ());
    reader.setTextQualifier ('\'');
    Assert.assertEquals ('\'', reader.getTextQualifier ());
    Assert.assertTrue (reader.getTrimWhitespace ());
    reader.setTrimWhitespace (false);
    Assert.assertFalse (reader.getTrimWhitespace ());
    Assert.assertFalse (reader.getUseComments ());
    reader.setUseComments (true);
    Assert.assertTrue (reader.getUseComments ());
    Assert.assertTrue (reader.getUseTextQualifier ());
    reader.setUseTextQualifier (false);
    Assert.assertFalse (reader.getUseTextQualifier ());
    reader.close ();
}


-----Function Pair=301=-----==

public void test25 () throws Exception {
    String data = "1\r\n# bunch of crazy stuff here\r\n1";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setUseComments (true);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test10 () throws Exception {
    String data = "1\r2\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setDelimiter ('\r');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals ("2", reader.get (1));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertEquals ("1\r2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=302=-----==

public static void main (String [] args) throws Exception {
    Class testClass = AllTests.class;
    ArrayList < Method > setups = new ArrayList < Method > ();
    ArrayList < Method > tearDowns = new ArrayList < Method > ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            if (method.getAnnotation (Before.class) != null) {
                setups.add (method);
            }
            if (method.getAnnotation (After.class) != null) {
                setups.add (method);
            }
        }
    }
    System.out.println ("Starting all tests.");
    Object instance = testClass.newInstance ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            Test testAnnotation = method.getAnnotation (Test.class);
            if (testAnnotation != null) {
                for (Method setup : setups) {
                    setup.invoke (instance, (Object []) null);
                }
                Class expectedException = testAnnotation.expected ();
                if (expectedException.getName ().equals ("org.junit.Test$None")) {
                    expectedException = null;
                }
                try {
                    method.invoke (instance, (Object []) null);
                } catch (Exception e) {
                    if (expectedException == null) {
                        System.out.println (testClass.getName () + "." + method.getName () + ": " + e.getCause ().getMessage ());
                        new BufferedReader (new InputStreamReader (System.in)).readLine ();
                    }
                    else {
                        if (! e.getCause ().getClass ().equals (testAnnotation.expected ())) {
                            System.out.println (testClass.getName () + "." + method.getName () + ": " + "Exception expected: " + testAnnotation.expected ().getName () + ", Exception thrown: " + e.getCause ().getMessage ());
                            new BufferedReader (new InputStreamReader (System.in)).readLine ();
                        }
                        expectedException = null;
                    }
                }
                if (expectedException != null) {
                    System.out.println (testClass.getName () + "." + method.getName () + ": " + "Expected exception not thrown: " + testAnnotation.expected ().getName ());
                    new BufferedReader (new InputStreamReader (System.in)).readLine ();
                }
                for (Method tearDown : tearDowns) {
                    tearDown.invoke (instance, (Object []) null);
                }
            }
        }
    }
    System.out.println ("Done with all tests.");
}


public static void main (String [] args) throws Exception {
    Class testClass = AllTests.class;
    ArrayList < Method > setups = new ArrayList < Method > ();
    ArrayList < Method > tearDowns = new ArrayList < Method > ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            if (method.getAnnotation (Before.class) != null) {
                setups.add (method);
            }
            if (method.getAnnotation (After.class) != null) {
                setups.add (method);
            }
        }
    }
    System.out.println ("Starting all tests.");
    Object instance = testClass.newInstance ();
    for (Method method : testClass.getDeclaredMethods ()) {
        int modifiers = method.getModifiers ();
        if (Modifier.isPublic (modifiers) && ! Modifier.isStatic (modifiers) && method.getAnnotation (Ignore.class) == null) {
            Test testAnnotation = method.getAnnotation (Test.class);
            if (testAnnotation != null) {
                for (Method setup : setups) {
                    setup.invoke (instance, (Object []) null);
                }
                Class expectedException = testAnnotation.expected ();
                if (expectedException.getName ().equals ("org.junit.Test$None")) {
                    expectedException = null;
                }
                try {
                    method.invoke (instance, (Object []) null);
                } catch (Exception e) {
                    if (expectedException == null) {
                        System.out.println (testClass.getName () + "." + method.getName () + ": " + e.getCause ().getMessage ());
                        new BufferedReader (new InputStreamReader (System.in)).readLine ();
                    }
                    else {
                        if (! e.getCause ().getClass ().equals (testAnnotation.expected ())) {
                            System.out.println (testClass.getName () + "." + method.getName () + ": " + "Exception expected: " + testAnnotation.expected ().getName () + ", Exception thrown: " + e.getCause ().getMessage ());
                            new BufferedReader (new InputStreamReader (System.in)).readLine ();
                        }
                        expectedException = null;
                    }
                }
                if (expectedException != null) {
                    System.out.println (testClass.getName () + "." + method.getName () + ": " + "Expected exception not thrown: " + testAnnotation.expected ().getName ());
                    new BufferedReader (new InputStreamReader (System.in)).readLine ();
                }
                for (Method tearDown : tearDowns) {
                    tearDown.invoke (instance, (Object []) null);
                }
            }
        }
    }
    System.out.println ("Done with all tests.");
}


-----Function Pair=303=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test75 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.write ("1");
    writer.endRecord ();
    writer.writeComment ("blah");
    writer.write ("2");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\r\n#blah\r\n2\r\n", data);
}


-----Function Pair=304=-----==

public void test58 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("data\r\nmore data");
    writer.write (" 3\t", false);
    writer.write (" 3\t");
    writer.write (" 3\t", true);
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("\"data\r\nmore data\"\t3\t3\t\" 3\t\"\r\n", data);
}


public void test74 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.setEscapeMode (CsvWriter.ESCAPE_MODE_BACKSLASH);
    writer.setUseTextQualifier (false);
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1\\,2,3,blah \"some stuff in quotes\"\r\n", data);
}


-----Function Pair=305=-----==

public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test35 () throws Exception {
    String data = "Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains a comma, but it doesn't matter as the field is quoted", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertEquals ("Chicane, Love on the Run, Knight Rider, \"This field contains a comma, but it doesn't matter as the field is quoted\"", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=306=-----==

public void test6 () throws Exception {
    String data = "1\r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=307=-----==

public void test121 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, ',', Charset.forName ("ISO-8859-1"));
    writer.writeRecord (new String [] {" 1 ", "2"}, false);
    writer.writeRecord (new String [] {" 1 ", "2"});
    writer.writeRecord (new String [] {" 1 ", "2"}, true);
    writer.writeRecord (new String [0], true);
    writer.writeRecord (null, true);
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\r\n1,2\r\n\" 1 \",2\r\n", data);
}


public void test56 () throws Exception {
    byte [] buffer;
    ByteArrayOutputStream stream = new ByteArrayOutputStream ();
    CsvWriter writer = new CsvWriter (stream, '\t', Charset.forName ("ISO-8859-1"));
    writer.write ("1,2");
    writer.write ("3");
    writer.write ("blah \"some stuff in quotes\"");
    writer.endRecord ();
    writer.close ();
    buffer = stream.toByteArray ();
    stream.close ();
    String data = Charset.forName ("ISO-8859-1").decode (ByteBuffer.wrap (buffer)).toString ();
    Assert.assertEquals ("1,2\t3\t\"blah \"\"some stuff in quotes\"\"\"\r\n", data);
}


-----Function Pair=308=-----==

public void test46 () throws Exception {
    String data = "Ch\\icane, Love on the Run, Kn\\ight R\\ider, Th\\is f\\ield conta\\ins an \\i\\, but \\it doesn't matter as \\it \\is escapedi" + "Samuel Barber, Adag\\io for Str\\ings, Class\\ical, Th\\is f\\ield conta\\ins a comma \\, but \\it doesn't matter as \\it \\is escaped";
    CsvReader reader = CsvReader.parse (data);
    reader.setUseTextQualifier (false);
    reader.setEscapeMode (CsvReader.ESCAPE_MODE_BACKSLASH);
    reader.setRecordDelimiter ('i');
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Chicane", reader.get (0));
    Assert.assertEquals ("Love on the Run", reader.get (1));
    Assert.assertEquals ("Knight Rider", reader.get (2));
    Assert.assertEquals ("This field contains an i, but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("Samuel Barber", reader.get (0));
    Assert.assertEquals ("Adagio for Strings", reader.get (1));
    Assert.assertEquals ("Classical", reader.get (2));
    Assert.assertEquals ("This field contains a comma , but it doesn't matter as it is escaped", reader.get (3));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (4, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test5 () throws Exception {
    String data = "1\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    Assert.assertEquals ("", reader.getRawRecord ());
    reader.close ();
}


-----Function Pair=309=-----==

public void test70 () throws Exception {
    String data = "\"1\",Bruce\r\n\"2\",Toni\r\n\"3\",Brian\r\n";
    CsvReader reader = CsvReader.parse (data);
    reader.setHeaders (new String [] {"userid", "name"});
    Assert.assertEquals (2, reader.getHeaderCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get ("userid"));
    Assert.assertEquals ("Bruce", reader.get ("name"));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get ("userid"));
    Assert.assertEquals ("Toni", reader.get ("name"));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("3", reader.get ("userid"));
    Assert.assertEquals ("Brian", reader.get ("name"));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (2, reader.getColumnCount ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


public void test38 () throws Exception {
    String data = "1\r\n\r\n\"\"\r\n \r\n2";
    CsvReader reader = CsvReader.parse (data);
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("1", reader.get (0));
    Assert.assertEquals (0L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("1", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (1L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("\"\"", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("", reader.get (0));
    Assert.assertEquals (2L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals (" ", reader.getRawRecord ());
    Assert.assertTrue (reader.readRecord ());
    Assert.assertEquals ("2", reader.get (0));
    Assert.assertEquals (3L, reader.getCurrentRecord ());
    Assert.assertEquals (1, reader.getColumnCount ());
    Assert.assertEquals ("2", reader.getRawRecord ());
    Assert.assertFalse (reader.readRecord ());
    reader.close ();
}


-----Function Pair=310=-----=1=

public static void shuffle1 (int [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        int tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


public static < T > void shuffle3 (T [] a) {
    int length = a.length;
    Random random = new Random ();
    random.nextInt ();
    for (int i = 0; i < length; i ++) {
        int j = i + random.nextInt (length - i);
        T tmp = a [i];
        a [i] = a [j];
        a [j] = tmp;
    }
}


-----Function Pair=311=-----==

public static String getCurrentEnvironmentNetworkIp () {
    Enumeration < NetworkInterface > netInterfaces = null;
    try {
        netInterfaces = NetworkInterface.getNetworkInterfaces ();
    } catch (SocketException e) {
        log.error ("Failed to get interface IP address", e);
        netInterfaces = new Enumerator (Collections.emptyList ());
    }
    while (netInterfaces.hasMoreElements ()) {
        NetworkInterface ni = netInterfaces.nextElement ();
        Enumeration < InetAddress > address = ni.getInetAddresses ();
        while (address.hasMoreElements ()) {
            InetAddress addr = address.nextElement ();
            if (! addr.isLoopbackAddress () && ! addr.isSiteLocalAddress () && addr.getHostAddress ().indexOf (":") == - 1) {
                return addr.getHostAddress ();
            }
        }
    }
    try {
        return InetAddress.getLocalHost ().getHostAddress ();
    } catch (UnknownHostException e) {
        return "127.0.0.1";
    }
}


public void actionPerformed (ActionEvent e) {
    String cmd = e.getActionCommand ();
    if (cmdFileOpenFile.equals (cmd)) {
        openFile (null);
        return;
    }
    if (cmdFilterType.equals (cmd)) {
        typeFilter ();
        return;
    }
    if (cmdFilterName.equals (cmd)) {
        nameFilter ();
        return;
    }
    if (cmdFilterSimplify.equals (cmd)) {
        simplifyEdges ();
        return;
    }
    if (cmdFileSaveAs.equals (cmd)) {
        exportToGIS ();
        return;
    }
    if (cmdFileSaveConfiguration.equals (cmd)) {
        exportToXML ();
        return;
    }
    if (cmdHelpAbout.equals (cmd)) {
        new WindowAbout ("GISImporter", this);
        return;
    }
    if (cmdHelpContactTOPL.equals (cmd)) {
        Desktop desktop = null;
        String email = AuroraConstants.CONTACT_EMAIL;
        if (Desktop.isDesktopSupported ()) {
            desktop = Desktop.getDesktop ();
            if (desktop.isSupported (Desktop.Action.MAIL)) try {
                desktop.mail (new URI ("mailto", email, null));
                return;
            } catch (Exception exp) {
            }
        }
        JOptionPane.showMessageDialog (this, "Cannot launch email client...\n Please, email your questions to\n" + email, "", JOptionPane.INFORMATION_MESSAGE);
        return;
    }
    if (cmdFileExit.equals (cmd)) {
        statusBar.setText ("Exiting...");
        setVisible (false);
        dispose ();
        System.exit (0);
    }
}


-----Function Pair=312=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=313=-----==

public KeySpec findAppropriateKeySpec (String algName, String keyType, String [] combos, byte [] rawdata) {
    KeySpec _spec = null;
    byte [] _bytearray = {0};
    Class _constructorSig = _bytearray.getClass ();
    Class [] _constructorSpec = new Class [] {_constructorSig};
    Object [] _args = new Object [] {rawdata};
    for (int _i = 0; _i < combos.length; _i ++) {
        try {
            Class _c = Class.forName (combos [_i]);
            Constructor _con = _c.getConstructor (_constructorSig);
            _spec = (KeySpec) _con.newInstance (_args);
            break;
        } catch (Exception e) {
        }
    }
    if (null != _spec) {
        log.debug ("findAppropriateKeySpec(): found " + _spec.getClass ().getName ());
    }
    return _spec;
}


private void analyseDepartures (Person person) {
    Plan plan = person.getPlans ().get (0);
    Iterator actIter = plan.getIteratorAct ();
    while (actIter.hasNext ()) {
        Act act = (Act) actIter.next ();
        String actType = act.getType ().substring (0, 1);
        double depTime = act.getEndTime ();
        if (depTime != Time.UNDEFINED_TIME) {
            int actIndex = Activities.valueOf (actType).getPosition ();
            int timeIndex = ((int) depTime) / timeBinSize;
            int oldLength = numDeps [actIndex].length;
            if (timeIndex >= oldLength) {
                numDeps [actIndex] = (int []) PersonAnalyseTimesByActivityType.resizeArray (numDeps [actIndex], timeIndex + 1);
                for (int ii = oldLength; ii < numDeps [actIndex].length; ii ++) {
                    numDeps [actIndex] [ii] = 0;
                }
                System.out.println ("new length of " + actType + ": " + numDeps [actIndex].length);
            }
            numDeps [actIndex] [timeIndex] ++;
            if (numDeps [actIndex].length > numDeps [ALL_POS].length) {
                oldLength = numDeps [ALL_POS].length;
                numDeps [ALL_POS] = (int []) PersonAnalyseTimesByActivityType.resizeArray (numDeps [ALL_POS], timeIndex + 1);
                for (int ii = oldLength; ii < numDeps [ALL_POS].length; ii ++) {
                    numDeps [ALL_POS] [ii] = 0;
                }
                System.out.println ("new length of " + actType + ": " + numDeps [actIndex].length);
            }
            numDeps [ALL_POS] [timeIndex] ++;
        }
    }
}


-----Function Pair=314=-----==

public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=315=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=316=-----==

public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=317=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=318=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=319=-----==

public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=320=-----==

public static String nullSafeToString (float [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=321=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuilder sb = new StringBuilder ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            sb.append (ARRAY_START);
        }
        else {
            sb.append (ARRAY_ELEMENT_SEPARATOR);
        }
        sb.append (array [i]);
    }
    sb.append (ARRAY_END);
    return sb.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=322=-----==

public static String nullSafeToString (long [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=323=-----==

public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=324=-----==

public static String nullSafeToString (char [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append ("'").append (array [i]).append ("'");
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (int [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=325=-----==

public static int lastIndexOf (Object [] array, Object objectToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    }
    else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    if (objectToFind == null) {
        for (int i = startIndex; i >= 0; i --) {
            if (array [i] == null) {
                return i;
            }
        }
    }
    else {
        for (int i = startIndex; i >= 0; i --) {
            if (objectToFind.equals (array [i])) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}


public static int lastIndexOf (long [] array, long valueToFind, int startIndex) {
    if (array == null) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex < 0) {
        return INDEX_NOT_FOUND;
    }
    else if (startIndex >= array.length) {
        startIndex = array.length - 1;
    }
    for (int i = startIndex; i >= 0; i --) {
        if (valueToFind == array [i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}


-----Function Pair=326=-----==

public static String nullSafeToString (double [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (boolean [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=327=-----==

public static String nullSafeToString (Object [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (String.valueOf (array [i]));
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


public static String nullSafeToString (byte [] array) {
    if (array == null) {
        return NULL_STRING;
    }
    int length = array.length;
    if (length == 0) {
        return EMPTY_ARRAY;
    }
    StringBuffer buffer = new StringBuffer ();
    for (int i = 0; i < length; i ++) {
        if (i == 0) {
            buffer.append (ARRAY_START);
        }
        else {
            buffer.append (ARRAY_ELEMENT_SEPARATOR);
        }
        buffer.append (array [i]);
    }
    buffer.append (ARRAY_END);
    return buffer.toString ();
}


-----Function Pair=328=-----==

private AlgorithmParameters parseAlgParameters (DerInputStream in) throws IOException {
    AlgorithmParameters algParams = null;
    try {
        DerValue params;
        if (in.available () == 0) {
            params = null;
        }
        else {
            params = in.getDerValue ();
            if (params.tag == DerValue.tag_Null) {
                params = null;
            }
        }
        if (params != null) {
            algParams = AlgorithmParameters.getInstance ("PBE");
            algParams.init (params.toByteArray ());
        }
    } catch (Exception e) {
        IOException ioe = new IOException ("parseAlgParameters failed: " + e.getMessage ());
        ioe.initCause (e);
        throw ioe;
    }
    return algParams;
}


public List < String > getEntries (String path) {
    check ();
    ArrayList < String > entries = new ArrayList < String > ();
    try {
        lock.lock ();
        swrap.writeOpCode (OPCodes.LIST_DIRECTORIES);
        swrap.writeString (path);
        int size = swrap.readInt ();
        entries.ensureCapacity (size);
        for (int i = 0; i < size; i ++) {
            entries.add (swrap.readString ());
        }
        lock.unlock ();
    } catch (WrapperException e) {
        e.printStackTrace ();
    }
    return entries;
}


-----Function Pair=329=-----==

public X509Certificate getCertificateByPrincipal (Principal principal) throws KeyStoreException {
    X509Certificate x509 = null;
    X509Certificate matchedX509 = null;
    for (Enumeration aliases = keyStore.aliases (); aliases.hasMoreElements ();) {
        String nextAlias = (String) aliases.nextElement ();
        try {
            x509 = (X509Certificate) keyStore.getCertificate (nextAlias);
        } catch (Exception e) {
            continue;
        }
        if (principal.equals (x509.getSubjectDN ())) {
            matchedX509 = x509;
            break;
        }
    }
    return matchedX509;
}


public X509Certificate getCertificateBySubjectDN (String subject) throws KeyStoreException {
    X509Certificate x509 = null;
    X509Certificate matchedX509 = null;
    for (Enumeration aliases = keyStore.aliases (); aliases.hasMoreElements ();) {
        String nextAlias = (String) aliases.nextElement ();
        try {
            x509 = (X509Certificate) keyStore.getCertificate (nextAlias);
        } catch (Exception e) {
            continue;
        }
        if (subject.equals (x509.getSubjectDN ().getName ())) {
            matchedX509 = x509;
            break;
        }
    }
    return matchedX509;
}


-----Function Pair=330=-----==

public Key engineGetKey (String alias, char [] password) throws NoSuchAlgorithmException, UnrecoverableKeyException {
    KeyEntry entry = entries.get (alias.toLowerCase ());
    Key key = null;
    if (entry == null) {
        return null;
    }
    byte [] encrBytes = entry.protectedPrivKey;
    byte [] encryptedKey;
    AlgorithmParameters algParams;
    ObjectIdentifier algOid;
    try {
        EncryptedPrivateKeyInfo encrInfo = new EncryptedPrivateKeyInfo (encrBytes);
        encryptedKey = encrInfo.getEncryptedData ();
        DerValue val = new DerValue (encrInfo.getAlgorithm ().encode ());
        DerInputStream in = val.toDerInputStream ();
        algOid = in.getOID ();
        algParams = parseAlgParameters (in);
    } catch (IOException ioe) {
        UnrecoverableKeyException uke = new UnrecoverableKeyException ("Private key not stored as " + "PKCS#8 EncryptedPrivateKeyInfo: " + ioe);
        uke.initCause (ioe);
        throw uke;
    }
    try {
        SecretKey skey = getPBEKey (password);
        Cipher cipher = Cipher.getInstance (algOid.toString ());
        cipher.init (Cipher.DECRYPT_MODE, skey, algParams);
        byte [] privateKeyInfo = cipher.doFinal (encryptedKey);
        PKCS8EncodedKeySpec kspec = new PKCS8EncodedKeySpec (privateKeyInfo);
        DerValue val = new DerValue (privateKeyInfo);
        DerInputStream in = val.toDerInputStream ();
        int i = in.getInteger ();
        DerValue [] value = in.getSequence (2);
        AlgorithmId algId = new AlgorithmId (value [0].getOID ());
        String algName = algId.getName ();
        KeyFactory kfac = KeyFactory.getInstance (algName);
        key = kfac.generatePrivate (kspec);
    } catch (Exception e) {
        UnrecoverableKeyException uke = new UnrecoverableKeyException ("Get Key failed: " + e.getMessage ());
        uke.initCause (e);
        throw uke;
    }
    return key;
}


private byte [] createEncryptedData (char [] password) throws CertificateException, IOException {
    DerOutputStream out = new DerOutputStream ();
    for (Enumeration < String > e = entries.keys (); e.hasMoreElements ();) {
        String alias = e.nextElement ();
        KeyEntry entry = entries.get (alias);
        int chainLen;
        if (entry.chain == null) {
            chainLen = 0;
        }
        else {
            chainLen = entry.chain.length;
        }
        for (int i = 0; i < chainLen; i ++) {
            DerOutputStream safeBag = new DerOutputStream ();
            safeBag.putOID (CertBag_OID);
            DerOutputStream certBag = new DerOutputStream ();
            certBag.putOID (PKCS9CertType_OID);
            DerOutputStream certValue = new DerOutputStream ();
            X509Certificate cert = (X509Certificate) entry.chain [i];
            certValue.putOctetString (cert.getEncoded ());
            certBag.write (DerValue.createTag (DerValue.TAG_CONTEXT, true, (byte) 0), certValue);
            DerOutputStream certout = new DerOutputStream ();
            certout.write (DerValue.tag_Sequence, certBag);
            byte [] certBagValue = certout.toByteArray ();
            DerOutputStream bagValue = new DerOutputStream ();
            bagValue.write (certBagValue);
            safeBag.write (DerValue.createTag (DerValue.TAG_CONTEXT, true, (byte) 0), bagValue);
            byte [] bagAttrs = null;
            String friendlyName = cert.getSubjectX500Principal ().getName ();
            if (i == 0) {
                bagAttrs = getBagAttributes (friendlyName, entry.keyId);
            }
            else {
                bagAttrs = getBagAttributes (friendlyName, null);
            }
            if (bagAttrs != null) {
                safeBag.write (bagAttrs);
            }
            out.write (DerValue.tag_Sequence, safeBag);
        }
    }
    DerOutputStream safeBagValue = new DerOutputStream ();
    safeBagValue.write (DerValue.tag_SequenceOf, out);
    byte [] safeBagData = safeBagValue.toByteArray ();
    byte [] encrContentInfo = encryptContent (safeBagData, password);
    DerOutputStream encrData = new DerOutputStream ();
    DerOutputStream encrDataContent = new DerOutputStream ();
    encrData.putInteger (0);
    encrData.write (encrContentInfo);
    encrDataContent.write (DerValue.tag_Sequence, encrData);
    return encrDataContent.toByteArray ();
}


-----Function Pair=331=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=332=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=333=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=334=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=335=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=336=-----==

public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


public void testPartialDimensions () {
    final int rows = 3;
    int [] [] matrix = new int [rows] [];
    matrix [0] = new int [] {0};
    matrix [1] = new int [] {1, 2};
    matrix [2] = new int [] {3, 4, 5};
    assertEquals (1, matrix [1] [0]);
    assertEquals (5, matrix [2] [2]);
    int [] [] matrix2 = {{0}, {1, 2}, {3, 4, 5}};
    assertEquals (1, matrix2 [1] [0]);
    assertEquals (5, matrix2 [2] [2]);
    int [] z1 = {3, 4, 5};
    int [] z2 = {3, 4, 5};
    assertTrue (Arrays.equals (z1, z2));
}


-----Function Pair=337=-----==

private MindRaiderJFrame (final boolean isApplet) {
    super (MindRaider.getTitle (), Gfx.getGraphicsConfiguration ());
    addWindowListener (new WindowAdapter () {
        public void windowClosing (WindowEvent e) {
            logger.debug ("Frame got quit!");
            if (isApplet) {
                dispose ();
            }
            else {
                System.exit (0);
            }
        }
    }
    );
    DropTarget dropTarget = new DropTarget (this, (DropTargetListener) this);
    this.setDropTarget (dropTarget);
    this.isApplet = isApplet;
    singleton = this;
    setIconImage (IconsRegistry.getImage ("programIcon.gif"));
    SplashScreen splash = new SplashScreen (this, false);
    splash.showSplashScreen ();
    MindRaider.preSetProfiles ();
    logger.debug (Messages.getString ("MindRaiderJFrame.bootingKernel"));
    MindRaider.setMasterToolBar (new MasterToolBar ());
    getContentPane ().add (MindRaider.masterToolBar, BorderLayout.NORTH);
    getContentPane ().add (StatusBar.getStatusBar (), BorderLayout.SOUTH);
    buildMenu (MindRaider.spidersGraph);
    MindRaider.setProfiles ();
    final JTabbedPane leftSidebar = new JTabbedPane (SwingConstants.BOTTOM);
    leftSidebar.setTabPlacement (SwingConstants.TOP);
    leftSidebar.addTab (Messages.getString ("MindRaiderJFrame.explorer"), ExplorerJPanel.getInstance ());
    leftSidebar.addTab (Messages.getString ("MindRaiderJFrame.trash"), TrashJPanel.getInstance ());
    if (MindRaider.EXPERIMENTAL_PERSPECTIVE.equals (MindRaider.profile.getUiPerspective ())) {
        leftSidebar.addTab ("Desktops", new VirtualDesktopJPanel ());
    }
    leftSidebar.setSelectedIndex (0);
    leftSidebar.addChangeListener (new ChangeListener () {
        public void stateChanged (ChangeEvent arg0) {
            if (arg0.getSource () instanceof JTabbedPane) {
                if (leftSidebar.getSelectedIndex () == 1) {
                    TrashJPanel.getInstance ().refresh ();
                }
            }
        }
    }
    );
    JPanel mainPanel = new JPanel ();
    mainPanel.setLayout (new BorderLayout ());
    mainPanel.add (NotebookOutlineJPanel.getInstance ().mainPanelControlsBar, BorderLayout.NORTH);
    mainPanel.add (NotebookOutlineJPanel.getInstance (), BorderLayout.CENTER);
    leftSidebarSplitPane = new JSplitPane (JSplitPane.HORIZONTAL_SPLIT, leftSidebar, mainPanel);
    leftSidebarSplitPane.setOneTouchExpandable (true);
    leftSidebarSplitPane.setDividerLocation (200);
    leftSidebarSplitPane.setLastDividerLocation (200);
    leftSidebarSplitPane.setDividerSize (6);
    leftSidebarSplitPane.setContinuousLayout (true);
    getContentPane ().add (leftSidebarSplitPane, BorderLayout.CENTER);
    Gfx.centerAndShowWindow (this, 1024, 768);
    MindRaider.postSetProfiles ();
    if (MindRaider.SW_PERSPECTIVE.equals (MindRaider.profile.getUiPerspective ())) {
        setSemanticWebUiLayout ();
    }
    splash.hideSplash ();
}


public void actionPerformed (ActionEvent ae) {
    if (ae.getSource () == toolbar.button [0]) {
        try {
            panel.readPoint ();
            panel.repaint ();
            panel.OKdraw = true;
        } catch (Exception ex) {
            System.out.println ("" + ex);
        }
    }
    if (ae.getSource () == toolbar.button [1]) {
        panel.savePoint ();
    }
    if (ae.getSource () == toolbar.button [2]) {
        Color c = JColorChooser.showDialog (((Component) null), "set Background Color", Color.blue);
        if (c != null) panel.setBackground (c);
    }
    if (ae.getSource () == toolbar.button [3]) {
        Color c = JColorChooser.showDialog (((Component) null), "set Foregound Color", Color.blue);
        if (c != null) panel.setForeground (c);
    }
    if (ae.getSource () == toolbar.button [4]) {
        panel.clearDraw = true;
        panel.repaint ();
        panel.OKdraw = false;
    }
    if (ae.getSource () == toolbar.button [5]) {
        panel.OKdraw = true;
        panel.openFile ();
        panel.OKdraw = false;
        panel.update ();
        GhinPaint.this.getContentPane ().repaint ();
    }
    if (ae.getSource () == toolbar.button [6]) {
        JFrame frame = new JFrame ("Set Configuration");
        frame.setContentPane (JPanelSetting (frame));
        Toolkit kit = Toolkit.getDefaultToolkit ();
        Image image = kit.getImage (ClassLoader.getSystemResource ("logo.gif"));
        frame.setIconImage (image);
        frame.setSize (360, 240);
        frame.setVisible (true);
    }
    if (ae.getSource () == toolbar.button [7]) {
        Thread runner6 = new Thread () {
            public void run () {
                try {
                    System.exit (0);
                } catch (Exception e) {
                }
            }
        }
        ;
        runner6.start ();
    }
}


-----Function Pair=338=-----==

private boolean initializeLowQualityScreenCapture (GraphicsDevice device) {
    reset ();
    try {
        if (screenCaptureRobot == null) {
            screenCaptureRobot = new Robot (device);
            screenCaptureRobot.setAutoDelay (0);
            screenCaptureRobot.setAutoWaitForIdle (false);
        }
        if (changedLowSettings ()) {
            refreshLowSettings ();
        }
        lowQualityScreenCaptureInitialized = true;
        return true;
    } catch (Exception e) {
        lowQualityScreenCaptureInitialized = false;
        return false;
    }
}


private boolean initializeHighQualityScreenCapture (GraphicsDevice device) {
    reset ();
    try {
        if (screenCaptureRobot == null) {
            screenCaptureRobot = new Robot (device);
            screenCaptureRobot.setAutoDelay (0);
            screenCaptureRobot.setAutoWaitForIdle (false);
        }
        if (changedHighSettings ()) {
            refreshHighSettings ();
        }
        highQualityScreenCaptureInitialized = true;
        return true;
    } catch (Exception e) {
        highQualityScreenCaptureInitialized = false;
        return false;
    }
}


-----Function Pair=339=-----=1=

private void assertComparatorYieldsOrder (Object [] orderedObjects, Comparator comparator) {
    Object [] keys = (Object []) orderedObjects.clone ();
    boolean isInNewOrder = false;
    while (keys.length > 1 && isInNewOrder == false) {
        shuffle : {
            Random rand = new Random ();
            for (int i = keys.length - 1; i > 0; i --) {
                Object swap = keys [i];
                int j = rand.nextInt (i + 1);
                keys [i] = keys [j];
                keys [j] = swap;
            }
        }
        testShuffle : {
            for (int i = 0; i < keys.length && ! isInNewOrder; i ++) {
                if (! orderedObjects [i].equals (keys [i])) {
                    isInNewOrder = true;
                }
            }
        }
    }
    Arrays.sort (keys, comparator);
    for (int i = 0; i < orderedObjects.length; i ++) {
        assertEquals (orderedObjects [i], keys [i]);
    }
}


private void assertComparatorYieldsOrder (String [] orderedObjects, Comparator < String > comparator) {
    String [] keys = (String []) orderedObjects.clone ();
    boolean isInNewOrder = false;
    while (keys.length > 1 && isInNewOrder == false) {
        shuffle : {
            Random rand = new Random ();
            for (int i = keys.length - 1; i > 0; i --) {
                String swap = keys [i];
                int j = rand.nextInt (i + 1);
                keys [i] = keys [j];
                keys [j] = swap;
            }
        }
        testShuffle : {
            for (int i = 0; i < keys.length && ! isInNewOrder; i ++) {
                if (! orderedObjects [i].equals (keys [i])) {
                    isInNewOrder = true;
                }
            }
        }
    }
    Arrays.sort (keys, comparator);
    for (int i = 0; i < orderedObjects.length; i ++) {
        assertEquals (orderedObjects [i], keys [i]);
    }
}


-----Function Pair=340=-----==

public boolean Less (F x) {
    long e1 = m_E;
    long e2 = x.m_E;
    long v1 = m_Val;
    long v2 = x.m_Val;
    while (e1 != e2) {
        if (e1 > e2) {
            if (Math.abs (v1) < maxLimit) {
                v1 *= 10;
                e1 --;
            }
            else {
                v2 /= 10;
                e2 ++;
            }
        }
        else if (e1 < e2) {
            if (Math.abs (v2) < maxLimit) {
                v2 *= 10;
                e2 --;
            }
            else {
                v1 /= 10;
                e1 ++;
            }
        }
    }
    return v1 < v2;
}


public Float Add (Float value) {
    if (value.Equal (ZERO)) return new Float (this);
    long e1 = m_E;
    long e2 = value.m_E;
    long v1 = m_Val;
    long v2 = value.m_Val;
    while (e1 != e2) {
        if (e1 > e2) {
            if (Math.abs (v1) < Long.MAX_VALUE / 100) {
                v1 *= 10;
                e1 --;
            }
            else {
                v2 /= 10;
                e2 ++;
            }
        }
        else if (e1 < e2) {
            if (Math.abs (v2) < Long.MAX_VALUE / 100) {
                v2 *= 10;
                e2 --;
            }
            else {
                v1 /= 10;
                e1 ++;
            }
        }
    }
    if ((v1 > 0 && v2 > Long.MAX_VALUE - v1) || (v1 < 0 && v2 < Long.MIN_VALUE - v1)) {
        v1 /= 10;
        e1 ++;
        v2 /= 10;
        e2 ++;
    }
    if (v1 > 0 && v2 > Long.MAX_VALUE - v1) return new Float (ERROR);
    else if (v1 < 0 && v2 < Long.MIN_VALUE - v1) return new Float (ERROR);
    return new Float (v1 + v2, e1);
}


-----Function Pair=341=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT o FROM Order o");
        Collection < Order > collection = (Collection < Order >) query.getResultList ();
        for (Order order : collection) {
            for (OrderItem item : order.getItems ()) {
                item.setPrice (item.getPrice () * 2);
            }
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=342=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            if ("Brian".equals (person.getFirstName ())) {
                Person sub1 = new Person ();
                sub1.setFirstName ("John");
                sub1.setLastName ("Stuart");
                Person sub2 = new Person ();
                sub2.setFirstName ("Nicole");
                sub2.setLastName ("Franklin");
                person.getSubordinates ().add (sub1);
                person.getSubordinates ().add (sub2);
            }
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


public void testUnionColumnTypes () {
    try {
        Connection conn = newConnection ();
        Statement stmt = conn.createStatement ();
        stmt.execute ("DROP TABLE test1 IF EXISTS");
        stmt.execute ("DROP TABLE test2 IF EXISTS");
        stmt.execute ("CREATE TABLE test1 (id int, b1 boolean)");
        stmt.execute ("CREATE TABLE test2 (id int)");
        stmt.execute ("INSERT INTO test1 VALUES(1,true)");
        stmt.execute ("INSERT INTO test2 VALUES(2)");
        ResultSet rs = stmt.executeQuery ("select id,null as b1 from test2 union select id, b1 from test1");
        Boolean [] array = new Boolean [2];
        for (int i = 0; rs.next (); i ++) {
            boolean boole = rs.getBoolean (2);
            array [i] = Boolean.valueOf (boole);
            if (rs.wasNull ()) {
                array [i] = null;
            }
        }
        boolean result = (array [0] == null && array [1] == Boolean.TRUE) || (array [0] == Boolean.TRUE && array [1] == null);
        assertTrue (result);
    } catch (SQLException e) {
        e.printStackTrace ();
        System.out.println ("TestSql.testUnionColumnType() error: " + e.getMessage ());
    }
}


-----Function Pair=343=-----==

public RestServiceResult create (RestServiceResult serviceResult, CoMultipleChoiceE1 coMultipleChoiceE1) {
    CoMultipleChoiceE1DAO coMultipleChoiceE1DAO = new CoMultipleChoiceE1DAO ();
    try {
        coMultipleChoiceE1.setMultipleChoiceE1Id (getSequence ("sq_co_multiple_choice_e1"));
        EntityManagerHelper.beginTransaction ();
        coMultipleChoiceE1DAO.save (coMultipleChoiceE1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMultipleChoiceE1);
        log.info ("Pregunta de selecci�n creada con �xito: " + coMultipleChoiceE1.getMultipleChoiceName ());
        Object [] arrayParam = {coMultipleChoiceE1.getMultipleChoiceName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult update (RestServiceResult serviceResult, MaParagraphCheckList maSingleParagraphCheckList) {
    MaParagraphCheckListDAO maSingleParagraphCheckListDAO = new MaParagraphCheckListDAO ();
    try {
        log.info ("Actualizando la t�cnica: " + maSingleParagraphCheckList.getTitle ());
        EntityManagerHelper.beginTransaction ();
        maSingleParagraphCheckListDAO.update (maSingleParagraphCheckList);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maSingleParagraphCheckList);
        Object [] arrayParam = {maSingleParagraphCheckList.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("checkList.update.success"), arrayParam));
        log.info ("Se actualizo la t�cnica con �xito: " + maSingleParagraphCheckList.getTitle ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la t�cnica: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


-----Function Pair=344=-----==

public Usergroups queryUserGroupById (Short id) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction ts = null;
    try {
        ts = session.beginTransaction ();
        Usergroups ugBean = (Usergroups) session.get (Usergroups.class, id);
        ts.commit ();
        return ugBean;
    } catch (HibernateException e) {
        if (ts != null) {
            ts.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public E update (E obj) {
    EntityManager em = getEntityManager ();
    EntityTransaction tx = em.getTransaction ();
    E e = null;
    try {
        tx.begin ();
        e = em.merge (obj);
        tx.commit ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
    return e;
}


-----Function Pair=345=-----==

private String getCompressedInput (InputStream i) {
    try {
        ZipInputStream in = new ZipInputStream (i);
        ZipEntry z;
        while ((z = in.getNextEntry ()) != null) {
            if (z.getName ().equals ("done")) {
                System.out.println ("i found the end");
                System.out.flush ();
                return "e";
            }
            System.out.println (z.getName () + ":");
            System.out.flush ();
            BufferedReader zin = new BufferedReader (new InputStreamReader (in));
            String s;
            while ((s = zin.readLine ()) != null) System.out.println (s);
            System.out.flush ();
            in.closeEntry ();
        }
        in.close ();
    } catch (IOException e) {
        System.err.println ("ioexeption");
        return null;
    }
    return new String ("lkj");
}


private void addItemByBarcode (String bc) {
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    if (bc != null) {
        try {
            conn = dbMan.getPOSConnection ();
            stmt = conn.createStatement ();
            if (stmt.execute ("select ibItemID, ibType from " + strPOSPrefix + "item_barcodes where ibBarcode = '" + bc + "'")) {
                rs = stmt.getResultSet ();
                while (rs.next ()) {
                    if (rs.getString ("ibType").compareTo ("1") == 0) {
                        OrderItem item = getItemByID (rs.getInt ("ibItemID"));
                        if (item != null) {
                            addItemToOrder (item);
                        }
                    }
                    else if (rs.getString ("ibType").compareTo ("2") == 0) {
                        System.out.println ("Adding Batch items via barcode scan is not yet supported!");
                    }
                }
            }
        } catch (SQLException sqlEx) {
            System.err.println ("SQLException: " + sqlEx.getMessage ());
            System.err.println ("SQLState: " + sqlEx.getSQLState ());
            System.err.println ("VendorError: " + sqlEx.getErrorCode ());
        } catch (Exception e) {
            System.err.println ("Exception: " + e.getMessage ());
            System.err.println (e);
        } finally {
            if (rs != null) {
                try {
                    rs.close ();
                } catch (SQLException sqlEx) {
                    rs = null;
                }
                if (stmt != null) {
                    try {
                        stmt.close ();
                    } catch (SQLException sqlEx) {
                        stmt = null;
                    }
                }
            }
        }
    }
}


-----Function Pair=346=-----==

private Hashtable getCourseSelected () throws Exception {
    String applicant_id = getParam ("applicant_id");
    if ("".equals (applicant_id)) throw new Exception ("Missing applicant_id..");
    Db db = null;
    String sql = "";
    try {
        db = new Db ();
        Statement stmt = db.getStatement ();
        SQLRenderer r = new SQLRenderer ();
        r.add ("choice1");
        r.add ("choice2");
        r.add ("choice3");
        r.add ("applicant_id", applicant_id);
        sql = r.getSQLSelect ("adm_applicant_choice");
        ResultSet rs = stmt.executeQuery (sql);
        Hashtable h = new Hashtable ();
        if (rs.next ()) {
            h.put ("choice1", rs.getString ("choice1"));
            h.put ("choice2", rs.getString ("choice2"));
            h.put ("choice3", rs.getString ("choice3"));
        }
        return h;
    } finally {
        if (db != null) db.close ();
    }
}


protected void execute (String sql, Object...parameters) {
    try {
        Connection connection = this.database.getDefaultConnection ();
        PreparedStatement statement = connection.prepareStatement (sql);
        int i = 1;
        for (Object parameter : parameters) if (parameter == null) statement.setString (i ++, null);
        else statement.setObject (i ++, parameter);
        try {
            int modified = statement.executeUpdate ();
            Assert.isTrue (modified == 1, "Expecting 1 record to be updated, not " + modified);
        } finally {
            statement.close ();
            connection.commit ();
        }
    } catch (SQLException e) {
        throw new SystemException (e);
    }
}


-----Function Pair=347=-----==

public static void main (String [] args) {
    SessionFactory sessionFactory = new Configuration ().configure ().buildSessionFactory ();
    try {
        LOGGER.info ("*** insert ***");
        insert (sessionFactory);
        LOGGER.info ("*** query ***");
        query (sessionFactory);
        LOGGER.info ("*** update ***");
        update (sessionFactory);
        LOGGER.info ("*** query ***");
        query (sessionFactory);
        LOGGER.info ("*** delete ***");
        delete (sessionFactory);
    } finally {
        sessionFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


public static void main (String [] args) {
    EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory ("default");
    try {
        LOGGER.info ("*** insert ***");
        insert (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** update ***");
        update (entityManagerFactory);
        LOGGER.info ("*** query ***");
        query (entityManagerFactory);
        LOGGER.info ("*** delete ***");
        delete (entityManagerFactory);
    } finally {
        entityManagerFactory.close ();
        LOGGER.info ("*** finished ***");
    }
}


-----Function Pair=348=-----==

private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT o FROM Order o");
        Collection < Order > collection = (Collection < Order >) query.getResultList ();
        for (Order order : collection) {
            for (OrderItem item : order.getItems ()) {
                item.setPrice (item.getPrice () * 2);
            }
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT p FROM Person p");
        Collection < Person > collection = (Collection < Person >) query.getResultList ();
        for (Person person : collection) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=349=-----==

public Collection listTypes () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Type, Description from InstructionTypes order by Type";
            conn = fido.util.FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                InstructionType type = new InstructionType (rs.getInt (1), rs.getString (2));
                list.add (type);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


public void executeProcessReturnNull () throws SQLException {
    psImpl = connImpl.prepareStatement (sqlCommands.getProperty ("realm.add"));
    Iterator < NewRealms > iter = newRealms.iterator ();
    NewRealms newRealm;
    String realm;
    Iterator < String > iter2;
    while (iter.hasNext ()) {
        newRealm = iter.next ();
        psImpl.setInt (3, newRealm.domainId);
        iter2 = newRealm.realms.iterator ();
        while (iter2.hasNext ()) {
            realm = iter2.next ();
            psImpl.setString (1, realm);
            psImpl.setString (2, realm.toLowerCase (locale));
            psImpl.executeUpdate ();
        }
    }
}


-----Function Pair=350=-----==

protected PostgresModelIterator getModelsUnordered (String table, String type, TupleBinding binding) {
    try {
        PreparedStatement ps = null;
        if (persistenceMethod == PostgreSQLStore.BYTEA) {
            ps = conn.prepareStatement ("select bdata, " + table + "_id from " + table + " where type = '" + type + "'");
        }
        else if (persistenceMethod == PostgreSQLStore.OID || persistenceMethod == PostgreSQLStore.FIELDS) {
            ps = conn.prepareStatement ("select oiddata, " + table + "_id from " + table + " where type = '" + type + "'");
        }
        ResultSet rs = ps.executeQuery ();
        return (new PostgresModelIterator (rs, binding, persistenceMethod, lobj));
    } catch (SQLException e) {
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    } catch (Exception e) {
        e.printStackTrace ();
        System.err.println (e.getMessage ());
    }
    return (null);
}


public void testDatetimeRounding2 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 991);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 990);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr2 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr2 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr2");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


-----Function Pair=351=-----==

public static ArrayList < ExperimentResultEx > getExtendedExperimentResultsFromExperimentResults (List < ExperimentResult > results) throws NoConnectionToDBException, SQLException {
    ArrayList < ExperimentResultEx > resx = new ArrayList < ExperimentResultEx > ();
    if (results.isEmpty ()) {
        return resx;
    }
    HashMap < Integer, ExperimentResult > resultMap = new HashMap < Integer, ExperimentResult > ();
    String constTable = "(";
    for (ExperimentResult er : results) {
        resultMap.put (er.getId (), er);
        constTable += "" + er.getId () + ",";
    }
    constTable = constTable.substring (0, constTable.length () - 1) + ")";
    Statement st = DatabaseConnector.getInstance ().getConn ().createStatement ();
    ResultSet rs = st.executeQuery ("SELECT idJob, startTime, solverOutput, launcherOutput, watcherOutput, verifierOutput FROM " + table + " JOIN " + outputTable + " ON (idJob = ExperimentResults_idJob) WHERE idJob IN " + constTable);
    while (rs.next ()) {
        Timestamp startTime = null;
        try {
            startTime = rs.getTimestamp (2);
        } catch (Exception e) {
        }
        ExperimentResult er = resultMap.get (rs.getInt (1));
        ExperimentResultEx erx = createExperimentResult (er.getRun (), er.getPriority (), er.getComputeQueue (), er.getStatus (), er.getResultCode (), er.getSeed (), er.getResultTime (), er.getSolverConfigId (), er.getExperimentId (), er.getInstanceId (), startTime, er.getCPUTimeLimit (), er.getMemoryLimit (), er.getWallClockTimeLimit (), er.getStackSizeLimit (), rs.getBytes (3), rs.getBytes (4), rs.getBytes (5), rs.getBytes (6));
        erx.setResultTime (er.getResultTime ());
        erx.setSolverExitCode (er.getSolverExitCode ());
        erx.setVerifierExitCode (er.getVerifierExitCode ());
        erx.setWatcherExitCode (er.getWatcherExitCode ());
        resx.add (erx);
    }
    rs.close ();
    st.close ();
    return resx;
}


public List getPublishableList (String parentPath) throws Exception {
    Channel channel = null;
    List channels = new ArrayList ();
    DBOperation dbo = null;
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
    try {
        dbo = createDBOperation ();
        StringBuffer sql = new StringBuffer ().append (" select channel.*").append (",site.ascii_name site_ascii_name").append (" from t_ip_channel channel").append (",t_ip_site site").append (" where channel.channel_path like '").append (parentPath).append ("%' ").append (" and channel.site_id=site.id").append (" and (channel.refresh_flag='").append (Channel.REFRESH_FOREVER).append ("' or  channel.refresh_flag='").append (Channel.REFRESH_RIGHT_NOW).append ("' or  channel.refresh_flag='").append (Channel.REFRESH_YES).append ("')");
        ResultSet rs = dbo.select (sql.toString ());
        while (rs.next ()) {
            channel = new Channel (rs.getInt ("id"));
            channel.setAsciiName (rs.getString ("ascii_name"));
            channel.setChannelType (rs.getString ("type"));
            channel.setCreateDate (rs.getDate ("create_date"));
            channel.setCreator (rs.getInt ("creator"));
            channel.setDataUrl (rs.getString ("data_url"));
            channel.setDesc (rs.getString ("description"));
            channel.setName (rs.getString ("name"));
            channel.setOrderNo (rs.getInt ("order_no"));
            channel.setSiteId (rs.getInt ("site_id"));
            channel.setStyle (rs.getString ("style"));
            channel.setTemplateId (rs.getString ("template_id"));
            channel.setUseStatus (rs.getString ("use_status"));
            channel.setPath (rs.getString ("channel_path"));
            channel.setRefresh (rs.getString ("refresh_flag"));
            channel.setSiteAsciiName (rs.getString ("site_ascii_name"));
            channel.setPageNum (rs.getInt ("page_num"));
            channels.add (channel);
        }
    } catch (Exception e) {
        log.error ("�õ�Ƶ���б�ʱ����", e);
        throw e;
    } finally {
        close (resultSet, null, preparedStatement, connection, dbo);
    }
    return channels;
}


-----Function Pair=352=-----==

public static void getSolverOutput (int id, File f) throws NoConnectionToDBException, SQLException, FileNotFoundException, IOException {
    PreparedStatement ps = DatabaseConnector.getInstance ().getConn ().prepareStatement ("SELECT solverOutput " + "FROM " + table + " " + "WHERE idJob=?;");
    ps.setInt (1, id);
    ResultSet rs = ps.executeQuery ();
    if (rs.next ()) {
        FileOutputStream out = new FileOutputStream (f);
        InputStream in = rs.getBinaryStream ("solverOutput");
        int len;
        byte [] buf = new byte [256 * 1024];
        while ((len = in.read (buf)) > - 1) {
            out.write (buf, 0, len);
        }
        out.close ();
        in.close ();
    }
}


public static Vector < String > retornaTutorialID (final Connection con) {
    Vector < String > v = new Vector < String > ();
    Vector < String > v2 = new Vector < String > ();
    Vector < String > v3 = new Vector < String > ();
    String s = "";
    try {
        Statement smt = con.createStatement ();
        ResultSet rs = smt.executeQuery ("SELECT codTutorial, titulo FROM tutorial");
        while (rs.next ()) {
            v.addElement (rs.getString ("codTutorial"));
            v2.addElement (rs.getString ("titulo"));
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    int i = 0;
    while (i < v.size ()) {
        s = v.get (i).toString ();
        s = s + " - ";
        s = s + v2.get (i).toString ();
        v3.addElement (s);
        i ++;
    }
    return v3;
}


-----Function Pair=353=-----==

public Transaction getTransaction (long uid, long txId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Transaction R where R.initiatorId=? and R.txId=?";
        Query q = s.createQuery (query);
        q.setLong (0, uid);
        q.setLong (1, txId);
        return (Transaction) q.uniqueResult ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public static Hashtable getTableKey (Connection conn) throws Exception {
    StringBuffer sbTableKey = new StringBuffer ();
    sbTableKey.append ("SELECT * FROM SYS_TABLE_KEY");
    Hashtable htTableKey = new Hashtable ();
    PreparedStatement preStatTableKey = null;
    ResultSet rsTableKey = null;
    preStatTableKey = conn.prepareStatement (sbTableKey.toString ());
    rsTableKey = preStatTableKey.executeQuery ();
    while (rsTableKey.next ()) {
        htTableKey.put (rsTableKey.getString (1).trim (), new Integer (rsTableKey.getInt (2)));
    }
    preStatTableKey.close ();
    rsTableKey.close ();
    return htTableKey;
}


-----Function Pair=354=-----==

public List < Transaction > getTransactionsForAccount (long userId, long accountId) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R from Transaction R where R.initiatorId=? and " + "(R.fromAccountId=? or R.toAccountId=?) order by R.txDate desc";
        Query q = s.createQuery (query);
        q.setLong (0, userId);
        q.setLong (1, accountId);
        q.setLong (2, accountId);
        return q.list ();
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public static String getCategoryName (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.categoryName from AccountCategory R where R.categoryId=(select A.categoryId from Account A where A.accountId=?)";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        String aname = (String) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


-----Function Pair=355=-----==

public static double getCurrentBalance (long aid) throws Exception {
    Session s = null;
    try {
        s = HibernateUtils.getSessionFactory ().getCurrentSession ();
        s.beginTransaction ();
        String query = "select R.currentBalance from Account R where R.accountId=?";
        Query q = s.createQuery (query);
        q.setLong (0, aid);
        double aname = (Double) q.uniqueResult ();
        s.getTransaction ().commit ();
        return aname;
    } catch (Exception e) {
        throw e;
    } finally {
        if (s != null) HibernateUtils.closeSession ();
    }
}


public synchronized void write2Output (OutputData data) throws Exception {
    Map < String, OPCItemData > itemDataMap = data.itemData;
    for (Entry < String, PstmtItemInfo > e : updaterMap.entrySet ()) {
        e.getValue ().updateVal (itemDataMap.get (e.getKey ()));
    }
    Map < String, ScriptDataResult > compData = data.compData;
    for (Entry < CompositeItem, PsmtCompositeUpdater > e : updaterCompMap.entrySet ()) {
        e.getValue ().updateVal (compData.get (e.getKey ().getName ()));
    }
    try {
        for (TableData t : tables) {
            t.getStmt ().executeUpdate ();
        }
        database.getCon ().commit ();
    } catch (SQLException ex) {
        database.getCon ().rollback ();
        throw ex;
    }
}


-----Function Pair=356=-----==

public int addRow (int row) {
    synchronized (this) {
        Checks.inRange ("row", row, - 1, getRowCount ());
        try {
            if (row < 0) row = getRowCount ();
            incrementOrdinalsStmt.setInt (1, row);
            incrementOrdinalsStmt.executeUpdate ();
            insertRowStmt.setInt (1, row);
            insertRowStmt.executeUpdate ();
            connection.commit ();
            return row;
        } catch (Throwable xp) {
            try {
                connection.rollback ();
            } catch (Throwable xp1) {
            }
            throw new AnnoneException (Text.get ("Can''t add row."), xp);
        }
    }
}


public void removeRow (int row) {
    synchronized (this) {
        Checks.inRange ("row", row, 0, getRowCount () - 1);
        try {
            deleteRowStmt.setInt (1, row);
            deleteRowStmt.executeUpdate ();
            decrementOrdinalsStmt.setInt (1, row + 1);
            decrementOrdinalsStmt.executeUpdate ();
            connection.commit ();
        } catch (Throwable xp) {
            try {
                connection.rollback ();
            } catch (Throwable xp1) {
            }
            throw new AnnoneException (Text.get ("Can''t add row."), xp);
        }
    }
}


-----Function Pair=357=-----==

public void executeDDL (String dml, String schema) throws SQLException {
    dml += "\n";
    CallableStatement csm = null;
    if ((dml != null) && (dml.length () != 0)) {
        try {
            Connection cn = getRepositoryConnection (p_ctx.getApplication (), schema, 1);
            csm = cn.prepareCall (dml);
            csm.execute ();
            log (dml, "OK");
        } catch (SQLException e) {
            log (dml, e.getClass ().getName () + ":" + e.getErrorCode () + " - " + e.getMessage ());
            int error = e.getErrorCode ();
            if (e.getErrorCode () == 2261) {
            }
            else {
                throw new SQLException (MessageLocalizer.getMessage ("ERROR_EXECUTING_DDL") + ":" + e.getMessage () + "\n" + MessageLocalizer.getMessage ("DDL_STATEMENT_WAS") + ":\n" + dml);
            }
        } catch (Exception e) {
            throw new SQLException (MessageLocalizer.getMessage ("ERROR_EXECUTING_DDL") + ":" + e.getMessage () + "\n" + MessageLocalizer.getMessage ("DDL_STATEMENT_WAS") + ":\n" + dml);
        } finally {
            if (csm != null) csm.close ();
        }
    }
}


public int getCount (String className, String [] filters) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "select count(*) from " + className + getWhereStatement (filters);
        Query queryObject = getSession ().createQuery (queryString);
        Integer count = ((Integer) queryObject.iterate ().next ()).intValue ();
        tx.commit ();
        return count;
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=358=-----==

public List findAll () throws TechnicalException {
    Session session = null;
    Transaction transaction = null;
    try {
        session = HibernateUtil.getCurrentSession ();
        transaction = session.beginTransaction ();
        Criteria criteria = session.createCriteria (TimeSlot.class).setResultTransformer (Criteria.DISTINCT_ROOT_ENTITY);
        List result = criteria.list ();
        transaction.commit ();
        return result;
    } catch (HibernateException ex) {
        if (transaction != null) transaction.rollback ();
        throw new TechnicalException (ex);
    }
}


public List < Bbcodes > findByAll () {
    List < Bbcodes > codesList = null;
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Bbcodes as b order by id asc");
        codesList = query.list ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) tr.rollback ();
        tr = null;
        he.printStackTrace ();
    }
    return codesList;
}


-----Function Pair=359=-----==

public final void update (final T obj) throws CannotConnectToDatabaseException {
    if (obj != null) {
        final Session s = this.currentSession ();
        Transaction tx = null;
        try {
            tx = s.beginTransaction ();
            s.update (obj);
            s.flush ();
            s.clear ();
            tx.commit ();
        } catch (HibernateException he) {
            tx.rollback ();
            LOGGER.error ("Failed to save or update entity - transaction was rolled back.", he);
            throw he;
        } finally {
            s.close ();
        }
    }
}


public boolean insertAccess (Access access) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.save (access);
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=360=-----=1=

public static int executeNoQuery (String strStatement) throws SQLException {
    MyDBConnection myc = new MyDBConnection ();
    myc.init ();
    Statement statement = myc.getMyConnection ().createStatement ();
    try {
        int rows = statement.executeUpdate (strStatement);
        myc.myConnection.commit ();
        return rows;
    } catch (SQLException e) {
        myc.myConnection.rollback ();
        throw new SQLException ("rollback e close effettuato dopo " + e.getMessage ());
    } finally {
        myc.close ();
    }
}


public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        sql = "DELETE FROM usuario WHERE cod_usuario =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        sql = "DELETE FROM persona WHERE id =" + id;
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


-----Function Pair=361=-----==

public void inserirParametros (Integer parcelas, Integer tipoImpressao, String enderecoImpressao) {
    HibernateUtil.closeSession ();
    Session session = HibernateUtil.currentSession ();
    Transaction transaction = session.beginTransaction ();
    try {
        Query query = session.createSQLQuery ("update parametros set numeroParcelas = :parcelas, tipo_impressao = :tipoImpressao, endereco_impressora = :enderecoImpressao where id = 1");
        query.setParameter ("parcelas", parcelas);
        query.setParameter ("tipoImpressao", tipoImpressao);
        query.setParameter ("enderecoImpressao", enderecoImpressao);
        query.executeUpdate ();
        transaction.commit ();
    } catch (Exception e) {
        transaction.rollback ();
        e.printStackTrace ();
    }
}


public AcUserRole getUserRole (Integer userId, Integer roleId) throws Exception {
    Transaction tx = null;
    try {
        tx = getSession ().beginTransaction ();
        String queryString = "from " + AcUserRole.class.getName () + " where acUser.id = '" + userId + "' and acRole.id = '" + roleId + "'";
        Query queryObject = getSession ().createQuery (queryString);
        List < AcUserRole > rtn = queryObject.list ();
        tx.commit ();
        return rtn.size () <= 0 ? null : rtn.get (0);
    } catch (Exception e) {
        tx.rollback ();
        e.printStackTrace ();
        throw e;
    }
}


-----Function Pair=362=-----==

public VideoItem addVideo (VideoItem video) {
    TVShowDAO showDAO = factory.getTVShowDAO ();
    TVSeasonDAO seasonDAO = factory.getTVSeasonDAO ();
    TVEpisodeDAO episodeDAO = factory.getTVEpisodeDAO ();
    HibernateTVEpisodeItem item = new HibernateTVEpisodeItem (video);
    HibernateTVShow show = null;
    HibernateTVSeason season = null;
    episodeDAO.beginTransaction ();
    if (video.getShowName () != null && video.getShowName ().length () > 0) {
        show = findOrCreateTVShowItembyName (video.getShowName (), showDAO);
    }
    if (show != null && video.getSeasonNumber () != null) {
        season = findOrCreateTVSeason (show, video.getSeasonNumber (), seasonDAO);
        season = seasonDAO.load (season.getDbId ());
    }
    if (show != null) item.setTVShow (show, true);
    if (season != null) item.setTVSeason (season, true);
    if (show != null && season != null) {
        logger.debug ("Adding TV Episode with db ids: {} {}", item.getTvShow ().getDbId (), item.getTvSeason ().getDbId ());
    }
    episodeDAO.save (item);
    episodeDAO.commitTransaction ();
    return item;
}


public String fetchProperties (Element root) throws SQLException, XMLException {
    String id = root.getAttribute (ID);
    String namespaceId = root.getAttribute (NAMESPACE_ID);
    long termGID = getGID (Integer.parseInt (namespaceId), Integer.parseInt (id));
    StringBuffer result = new StringBuffer (200);
    appendDtd (result, com.apelon.dts.dtd.common.DTD.PROPERTY, "properties");
    XML.asStartTag (result, "properties");
    String statement = getDAO ().getStatement (TABLE_KEY, "FIND_ALL_PROPERTY_GID");
    boolean hasResult = buildProperties (100, statement + termGID, Integer.parseInt (namespaceId), result, false);
    if (! hasResult) {
        return nullDocument (com.apelon.dts.dtd.result.DTD.COMMON_RESULT);
    }
    XML.asEndTag (result, "properties");
    return result.toString ();
}


-----Function Pair=363=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToExercise1Group toExercise1Group) {
    ToExercise1GroupDAO toExercise1GroupDAO = new ToExercise1GroupDAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        toExercise1GroupDAO.update (toExercise1Group);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise1Group);
        Object [] args = {toExercise1Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el ejercicio grupal s1: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise1group.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult serviceResult, CoWordsCompleteE1 coWordsCompleteE1) {
    CoWordsCompleteE1DAO coWordsCompleteE1DAO = new CoWordsCompleteE1DAO ();
    try {
        coWordsCompleteE1.setWordsCompleteE1Id (getSequence ("sq_co_words_complete_e1"));
        EntityManagerHelper.beginTransaction ();
        coWordsCompleteE1DAO.save (coWordsCompleteE1);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coWordsCompleteE1);
        log.info ("Palabra creada con �xito: " + coWordsCompleteE1.getWord ());
        Object [] arrayParam = {coWordsCompleteE1.getWord ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=364=-----==

public SessionType findBySubjectModel (Integer idSubjectModel) throws SelectException, DBConnectionException {
    SessionType sessType = null;
    Statement stmt = null;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (SessionTypeDAO.TABLE_NAME + " sess"));
    tablesFrom.add (new SQLWord (SubjectModelDAO.TABLE_NAME + " subj"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("subj.SUBJECT_MODEL_ID", idSubjectModel);
    critWhere.addCriterion ("sess.SESSION_TYPE_ID", new SQLWord ("subj.SESSION_TYPE_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                sessType = new SessionType ();
                sessType.setId (result.getInt ("SESSION_TYPE_ID"));
                sessType.setName (result.getString ("SESSION_TYPE_NAME"));
                sessType.setAcronym (result.getString ("SESSION_TYPE_ACRONYM"));
                sessType.setEquivTuto (result.getFloat ("SESSION_TYPE_EQV_TD"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return sessType;
}


public GroupType findByStudentsGroup (Integer idStudentsGroup) throws DBConnectionException, SelectException {
    GroupType grpType = null;
    Statement stmt;
    try {
        stmt = OracleJDBConnector.getInstance ().getStatement ();
    } catch (XmlIOException e1) {
        e1.printStackTrace ();
        throw new DBConnectionException ("Unable to Get Statement", e1);
    }
    List < SQLWord > selectAttr = new ArrayList < SQLWord > ();
    selectAttr.add (new SQLWord ("*"));
    List < SQLWord > tablesFrom = new ArrayList < SQLWord > ();
    tablesFrom.add (new SQLWord (GroupTypeDAO.TABLE_NAME + " grpt"));
    tablesFrom.add (new SQLWord (StudentsGroupDAO.TABLE_NAME + " stugrp"));
    Criteria critWhere = new Criteria ();
    critWhere.addCriterion ("stugrp.STUDENT_GROUP_ID", idStudentsGroup);
    critWhere.addCriterion ("grpt.GROUP_TYPE_ID", new SQLWord ("stugrp.GROUP_TYPE_ID"));
    try {
        ResultSet result = stmt.executeQuery (new SelectQuery (tablesFrom, selectAttr, critWhere).toString ());
        if (result != null) {
            while (result.next ()) {
                grpType = new GroupType ();
                grpType.setId (result.getInt ("GROUP_TYPE_ID"));
                grpType.setLabel (result.getString ("GROUP_TYPE_LABEL"));
            }
        }
        stmt.close ();
    } catch (SQLException e) {
        e.printStackTrace ();
        throw new SelectException (TABLE_NAME + " Request Error", e);
    }
    return grpType;
}


-----Function Pair=365=-----==

public Integer updateWords (Words words) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Query query = session.createQuery ("update Words as w set w.replacement=:replacement where w.find like :find");
        query.setString ("replacement", words.getReplacement ());
        query.setString ("find", words.getFind ());
        query.executeUpdate ();
        tr.commit ();
    } catch (HibernateException he) {
        if (tr != null) {
            tr.rollback ();
            tr = null;
        }
        he.printStackTrace ();
    }
    return 1;
}


public RestServiceResult delete (RestServiceResult serviceResult, MaSyntaticError maSyntaticError) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_MA_SYNTACTIC_ERROR);
        query.setParameter (1, maSyntaticError.getErrorId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el error sintactico: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maSyntaticError.getWrongSentence ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("syntacticerror.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=366=-----==

public RestServiceResult create (RestServiceResult serviceResult, ToForumPost toForumPost) {
    ToForumPostDAO toForumPostDAO = new ToForumPostDAO ();
    try {
        toForumPost.setForumPostId (getSequence ("sq_to_forum_post"));
        EntityManagerHelper.beginTransaction ();
        toForumPostDAO.save (toForumPost);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toForumPost);
        log.info ("El Anuncio al foro" + toForumPost.getToForum ().getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toForumPost.getToForum ().getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forumPost.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel foro: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forumPost.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, ToHandbook toHandbook) {
    try {
        log.info ("Eliminando anotaci�n libreta: " + toHandbook.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_HANDBOOK);
        query.setParameter (1, toHandbook.getHandbookId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toHandbook);
        Object [] arrayParam = {toHandbook.getTitle ()};
        log.info ("Libreta eliminado con �xito: " + toHandbook.getTitle ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el Libreta: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toHandbook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=367=-----==

public RestServiceResult create (RestServiceResult serviceResult, ToForumPost toForumPost) {
    ToForumPostDAO toForumPostDAO = new ToForumPostDAO ();
    try {
        toForumPost.setForumPostId (getSequence ("sq_to_forum_post"));
        EntityManagerHelper.beginTransaction ();
        toForumPostDAO.save (toForumPost);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toForumPost);
        log.info ("El Anuncio al foro" + toForumPost.getToForum ().getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toForumPost.getToForum ().getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forumPost.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel foro: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forumPost.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult update (RestServiceResult serviceResult, CoMultipleChoiceE3 coMultipleChoiceE3) {
    CoMultipleChoiceE3DAO coMultipleChoiceE3DAO = new CoMultipleChoiceE3DAO ();
    try {
        EntityManagerHelper.beginTransaction ();
        coMultipleChoiceE3DAO.update (coMultipleChoiceE3);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coMultipleChoiceE3);
        Object [] args = {coMultipleChoiceE3.getMultipleChoiceName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.update.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("multipleChoice.update.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=368=-----==

public void testDatetimeRounding8 () throws Exception {
    Calendar sendValue = Calendar.getInstance ();
    Calendar receiveValue = Calendar.getInstance ();
    sendValue.set (Calendar.MONTH, Calendar.JANUARY);
    sendValue.set (Calendar.DAY_OF_MONTH, 1);
    sendValue.set (Calendar.YEAR, 1998);
    sendValue.set (Calendar.HOUR_OF_DAY, 23);
    sendValue.set (Calendar.MINUTE, 59);
    sendValue.set (Calendar.SECOND, 59);
    sendValue.set (Calendar.MILLISECOND, 997);
    receiveValue.set (Calendar.MONTH, Calendar.JANUARY);
    receiveValue.set (Calendar.DAY_OF_MONTH, 1);
    receiveValue.set (Calendar.YEAR, 1998);
    receiveValue.set (Calendar.HOUR_OF_DAY, 23);
    receiveValue.set (Calendar.MINUTE, 59);
    receiveValue.set (Calendar.SECOND, 59);
    receiveValue.set (Calendar.MILLISECOND, 997);
    Statement stmt = con.createStatement ();
    stmt.execute ("create table #dtr8 (data datetime)");
    stmt.close ();
    PreparedStatement pstmt = con.prepareStatement ("insert into #dtr8 (data) values (?)");
    pstmt.setTimestamp (1, new Timestamp (sendValue.getTime ().getTime ()));
    assertEquals (pstmt.executeUpdate (), 1);
    pstmt.close ();
    pstmt = con.prepareStatement ("select data from #dtr8");
    ResultSet rs = pstmt.executeQuery ();
    assertTrue (rs.next ());
    assertEquals (receiveValue.getTime ().getTime (), getTimeInMs (rs));
    assertTrue (! rs.next ());
    pstmt.close ();
    rs.close ();
}


public static void BubbleSortFloat2 (float [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                float temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=369=-----==

public String formatMessage (String msg) {
    String [] sep = {"[Microsoft]", "[Gestionnaire de pilotes ODBC]", "[Pilote ODBC Microsoft Access]"};
    for (int k = 0; k < sep.length; k ++) {
        msg = msg.replaceAll ("\\" + sep [k], "");
    }
    String context_webForm = StringUtilities.addPrefix (id_webForm, ".");
    String context_lang = StringUtilities.addPrefix (code_lang, ".");
    if (msg.startsWith ("ORA-00001")) {
        msg = StringUtilities.getEString (getContextualMessage ("MSG_UNIQUE_CONSTRAINT"), StringUtilities.getEString (ApplicationProperties.getProperty ("MSG_UNIQUE_CONSTRAINT" + context_lang), "The data you want to add or update in the table already exists."));
    }
    else if (msg.startsWith ("ORA-02292")) {
        msg = StringUtilities.getEString (getContextualMessage ("MSG_INTEGRITY_CONSTRAINT"), StringUtilities.getEString (ApplicationProperties.getProperty ("MSG_INTEGRITY_CONSTRAINT" + context_lang), "This data cannot be deleted. Its deletion would violate the database integrity."));
    }
    else if (msg.startsWith ("ORA-01438")) {
        msg = StringUtilities.getEString (getContextualMessage ("MSG_VALUE_LARGER"), StringUtilities.getEString (ApplicationProperties.getProperty ("MSG_VALUE_LARGER" + context_lang), "Value larger than specified precision allows for this column."));
    }
    else {
        Pattern pattern = Pattern.compile (".*ORA-20\\d\\d\\d: (.*)#.*ORA-\\d\\d\\d\\d\\d.*");
        Matcher matcher = pattern.matcher (msg.replaceAll ("\\n", ""));
        if (matcher.find ()) {
            return matcher.replaceAll ("$1");
        }
        if (StringUtilities.stringToBoolean (ApplicationProperties.getProperty ("ORACLE_ERROR_IS_GENERAL_ERROR"), false) && msg.indexOf ("ORA-") != - 1) {
            return msg + " #ORACLE_ERROR#";
        }
    }
    return msg;
}


public static void test_no_rule (PrintWriter out) {
    try {
        clearTables ();
        LanguageMorphologyTable languageTable = new LanguageMorphologyTable ();
        languageTable.add ("English", "plural", "child", "children");
        languageTable.add ("English", "plural", "*ch", "*ches");
        Collection recog = languageTable.recognize ("English", "boxes");
        if (recog.size () != 1) throw new Exception ("Recognizing 'boxes' produced " + recog.size () + ", not 1 result");
        Iterator it = recog.iterator ();
        MorphologyRecognizeMatch match = (MorphologyRecognizeMatch) it.next ();
        if (match.getRootString ().equals ("boxes") == false) throw new Exception ("Recognizing 'boxes' produced '" + match.getRootString () + "', not 'boxes'");
        Vector expTags = new Vector ();
        if (expTags.containsAll (match.getMorphologyTags ()) == false) throw new Exception ("Tags vectors did not match");
        String surface = languageTable.generate ("English", "plural", "box");
        if (surface.equals ("box") == false) throw new Exception ("Generating plural of 'box' produced '" + surface + "', not 'box'");
        testPassed (out);
    } catch (Exception e) {
        testFailed (e, out);
    }
}


-----Function Pair=370=-----==

public TEntity update (TEntity entity) throws GenericPersistenceException {
    EntityManager em = null;
    try {
        em = EMFactory.getEntityManagerFactory (this.puName).createEntityManager ();
        em.getTransaction ().begin ();
        entity = em.merge (entity);
        em.getTransaction ().commit ();
        return entity;
    } catch (Exception ex) {
        if (em != null) if (em.getTransaction ().isActive ()) em.getTransaction ().rollback ();
        throw (GenericPersistenceException) this.createGenericPersistenceException (ex).initCause (ex);
    } finally {
        if (em != null) em.close ();
    }
}


protected static void clearTables () throws SQLException {
    Connection conn = null;
    Statement stmt = null;
    try {
        conn = FidoDataSource.getConnection ();
        conn.setAutoCommit (false);
        stmt = conn.createStatement ();
        ClearData.clearTables (stmt);
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (2, '')");
        stmt.executeUpdate ("insert into Objects (ObjectId, Description) values (3, '')");
        conn.commit ();
    } catch (SQLException e) {
        if (conn != null) conn.rollback ();
        throw e;
    } finally {
        if (stmt != null) stmt.close ();
        if (conn != null) conn.close ();
    }
}


-----Function Pair=371=-----==

public RestServiceResult create (RestServiceResult serviceResult, ToHandbook toHandbook) {
    ToHandbookDAO toHandbookDAO = new ToHandbookDAO ();
    try {
        toHandbook.setHandbookId (getSequence ("sq_to_handbook"));
        EntityManagerHelper.beginTransaction ();
        toHandbookDAO.save (toHandbook);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toHandbook);
        log.info ("El diario" + toHandbook.getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toHandbook.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel diario: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("handbook.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, MaUser maUser) {
    MaUserDAO maUserDAO = new MaUserDAO ();
    try {
        log.info ("Eliminando el usuario: " + maUser.getUserName ());
        EntityManagerHelper.beginTransaction ();
        maUserDAO.delete (maUser);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (maUser);
        Object [] arrayParam = {maUser.getUserName ()};
        log.info ("Usuario eliminado con �xito: " + maUser.getUserName ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar la secuencia: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {maUser.getUserName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=372=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToAssistance assistance) {
    ToAssistanceDAO assistanceDAO = new ToAssistanceDAO ();
    try {
        log.info ("Actualizando la Ayuda: " + assistance.getAssistanceId ());
        EntityManagerHelper.beginTransaction ();
        assistanceDAO.update (assistance);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (assistance);
        Object [] arrayParam = {assistance.getAssistanceId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("assistance.update.success"), arrayParam));
        log.info ("Se actualizo la Ayuda con �xito: " + assistance.getAssistanceId ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la Ayuda: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult serviceResult, ToNews toNews) {
    ToNewsDAO toNewsDAO = new ToNewsDAO ();
    try {
        toNews.setNewsId (getSequence ("sq_to_news"));
        EntityManagerHelper.beginTransaction ();
        toNewsDAO.save (toNews);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toNews);
        log.info ("El anuncio" + toNews.getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toNews.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel anuncio: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("news.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=373=-----==

public void testNotEquals () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(T) FROM " + Person.class.getName () + " T where T.firstName <> 'Fred1' ").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


public void testLOCATE () {
    EntityManager em = getEM ();
    EntityTransaction tx = em.getTransaction ();
    try {
        tx.begin ();
        Person p1 = new Person (101, "Fred", "Flintstone", "fred.flintstone@jpox.com");
        em.persist (p1);
        em.flush ();
        List result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE LOCATE('r','erik') = 2").getResultList ();
        assertEquals (1, result.size ());
        result = em.createQuery ("SELECT Object(P) FROM " + Person.class.getName () + " P WHERE LOCATE('i','eriki',5) = 5").getResultList ();
        assertEquals (1, result.size ());
        tx.rollback ();
    } finally {
        if (tx.isActive ()) {
            tx.rollback ();
        }
        em.close ();
    }
}


-----Function Pair=374=-----==

public RestServiceResult delete (RestServiceResult serviceResult, ToForum toForum) {
    try {
        log.info ("Eliminando el foro: " + toForum.getTitle ());
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_FORUM);
        query.setParameter (1, toForum.getForumId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toForum);
        Object [] arrayParam = {toForum.getTitle ()};
        log.info ("Anuncio eliminado con �xito: " + toForum.getTitle ());
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al eliminar el foro: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toForum.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult serviceResult, ToPublication toPublication) {
    ToPublicationDAO toPublicationDAO = new ToPublicationDAO ();
    try {
        toPublication.setPublicationId (getSequence ("sq_to_publication"));
        EntityManagerHelper.beginTransaction ();
        toPublicationDAO.save (toPublication);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toPublication);
        log.info ("La publicacion" + toPublication.getTitle () + " fue creada con �xito...");
        Object [] arrayParam = {toPublication.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("publication.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel anuncio: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("publication.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


-----Function Pair=375=-----==

public RestServiceResult create (RestServiceResult serviceResult, ToForum toForum) {
    ToForumDAO toForumDAO = new ToForumDAO ();
    try {
        toForum.setForumId (getSequence ("sq_to_forum"));
        EntityManagerHelper.beginTransaction ();
        toForumDAO.save (toForum);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toForum);
        log.info ("El foro" + toForum.getTitle () + " fue creado con �xito...");
        Object [] arrayParam = {toForum.getTitle ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.create.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al guardarel foro: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("forum.create.error"), e.getMessage ()));
    }
    return serviceResult;
}


public RestServiceResult create (RestServiceResult result, CoSingleTextCheckList2 coSingleTextCheckList) {
    CoSingleTextCheckList2DAO coSingleTextCheckListDAO = new CoSingleTextCheckList2DAO ();
    log.info ("estoy en el create del data manager");
    try {
        coSingleTextCheckList.setCheckListId (getSequence ("sq_co_single_text_check_2"));
        EntityManagerHelper.beginTransaction ();
        coSingleTextCheckListDAO.save (coSingleTextCheckList);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coSingleTextCheckList);
        log.info ("Pregunta de check list creada con �xito: " + coSingleTextCheckList.getCheckListId ());
        Object [] args = {coSingleTextCheckList.getCheckListId (), coSingleTextCheckList.getTitle ()};
        result.setMessage (MessageFormat.format (bundle.getString ("checkListStudent.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar la lista de chequeo: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


-----Function Pair=376=-----==

public void elimina (Cliente cli) throws errorSQL, errorConexionBD {
    System.out.println ("GestorCliente.elimina()");
    int id = cli.getId ();
    String sql;
    Statement stmt = null;
    try {
        gd.begin ();
        sql = "DELETE FROM cliente WHERE cod_cliente = '" + id + "'";
        System.out.println ("Ejecutando: " + sql);
        stmt = gd.getConexion ().createStatement ();
        stmt.executeUpdate (sql);
        System.out.println ("executeUpdate");
        gd.commit ();
        System.out.println ("commit");
        stmt.close ();
    } catch (SQLException e) {
        gd.rollback ();
        throw new errorSQL (e.toString ());
    } catch (errorConexionBD e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    } catch (errorSQL e) {
        System.err.println ("Error en GestorCliente.elimina(): " + e);
    }
}


public static Document parse (File xmlFile) throws ParserConfigurationException, SAXException, IOException {
    DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance ();
    docFactory.setValidating (false);
    docFactory.setNamespaceAware (true);
    docFactory.setExpandEntityReferences (false);
    DocumentBuilder parser = docFactory.newDocumentBuilder ();
    Document document = parser.parse (xmlFile);
    return document;
}


-----Function Pair=377=-----==

public static boolean doExecuteSQL (String sql) {
    session = currentSession ();
    Connection conn = session.connection ();
    PreparedStatement ps = null;
    try {
        conn.setAutoCommit (false);
        log ("[SmsManager] sql:" + sql);
        ps = conn.prepareStatement (sql);
        ps.executeUpdate ();
        conn.commit ();
        conn.setAutoCommit (true);
        return true;
    } catch (SQLException e) {
        e.printStackTrace ();
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
        return false;
    } finally {
        if (conn != null) try {
            conn.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
        if (ps != null) {
            try {
                ps.close ();
            } catch (SQLException e) {
                e.printStackTrace ();
            }
        }
        closeHibernateSession ();
    }
}


public RestServiceResult create (RestServiceResult result, CoCourse coCourse) {
    CoCourseDAO coCourseDAO = new CoCourseDAO ();
    try {
        coCourse.setCourseId (getSequence ("sq_co_course"));
        EntityManagerHelper.beginTransaction ();
        coCourseDAO.save (coCourse);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (coCourse);
        Object [] args = {coCourse.getCourseName (), coCourse.getCourseId ()};
        result.setMessage (MessageFormat.format (bundle.getString ("course.create.success"), args));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        e.printStackTrace ();
        log.error ("Error al guardar el curso: " + e.getMessage ());
        result.setError (true);
        result.setMessage (e.getMessage ());
    }
    return result;
}


-----Function Pair=378=-----==

public void testBulkDelete () {
    try {
        EntityManager em = getEM ();
        EntityTransaction tx = em.getTransaction ();
        try {
            tx.begin ();
            Timer t = new Timer ("Seiko", true, null);
            em.persist (t);
            em.flush ();
            Query q = em.createQuery ("DELETE FROM " + Timer.class.getName () + " t");
            int number = q.executeUpdate ();
            assertEquals (1, number);
            tx.rollback ();
        } finally {
            if (tx.isActive ()) {
                tx.rollback ();
            }
            em.close ();
        }
    } finally {
        clean (Timer.class);
    }
}


public String render (Transferable transferable) {
    Object object = null;
    try {
        if (transferable != null) {
            object = transferable.getTransferData (DBEntityDataFlavor.dbEntityDataFlavor ());
            DBEntity entity = (DBEntity) object;
            SingleTableSelectStatement st = new SingleTableSelectStatement (entity);
            try {
                return SQLFormatter.format (st.getSelectString (this.conn.getMetaData ())) + ";";
            } catch (Exception e1) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e1, "Exception caught while dropping");
            }
        }
    } catch (UnsupportedFlavorException e) {
        try {
            return transferable.getTransferData (DataFlavor.stringFlavor).toString () + ";";
        } catch (UnsupportedFlavorException e1) {
            try {
                DataFlavor [] f = transferable.getTransferDataFlavors ();
                if (f != null && f.length > 0) return transferable.getTransferData (f [0]).toString ();
                else return "";
            } catch (UnsupportedFlavorException e2) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e2, "Exception caught while dropping");
            } catch (IOException e3) {
                ExceptionManagerFactory.getExceptionManager ().manageException (e3, "Exception caught while dropping");
            }
        } catch (IOException e4) {
            ExceptionManagerFactory.getExceptionManager ().manageException (e4, "Exception caught while dropping");
        }
    } catch (IOException e5) {
        ExceptionManagerFactory.getExceptionManager ().manageException (e5, "Exception caught while dropping");
    }
    return "";
}


-----Function Pair=379=-----==

public void shutdown () throws Exception {
    InitialContext ic = new InitialContext ();
    TransactionManager tm = (TransactionManager) ic.lookup ("TransactionManager");
    DataSource ds = (DataSource) ic.lookup ("TestDS");
    Connection conn = null;
    tm.begin ();
    try {
        conn = (Connection) ds.getConnection ();
        executeUpdate (conn, "drop table test");
    } finally {
        close (conn);
    }
    tm.commit ();
    ShutdownCommand shutdown = new ShutdownCommand ();
    shutdown.setContext (ic);
    shutdown.shutdown ();
}


public void testSuspendableTx () throws Exception {
    if (! versionMeetsMinimum (5, 0) || isRunningOnJdk131 ()) {
        return;
    }
    Connection conn1 = null;
    MysqlXADataSource suspXaDs = new MysqlXADataSource ();
    suspXaDs.setUrl (BaseTestCase.dbUrl);
    suspXaDs.setPinGlobalTxToPhysicalConnection (true);
    suspXaDs.setRollbackOnPooledClose (true);
    XAConnection xaConn1 = null;
    Xid xid = createXid ();
    try {
        xaConn1 = suspXaDs.getXAConnection ();
        XAResource xaRes1 = xaConn1.getXAResource ();
        conn1 = xaConn1.getConnection ();
        xaRes1.start (xid, XAResource.TMNOFLAGS);
        conn1.createStatement ().executeQuery ("SELECT 1");
        xaRes1.end (xid, XAResource.TMSUCCESS);
        xaRes1.start (xid, XAResource.TMRESUME);
        conn1.createStatement ().executeQuery ("SELECT 1");
        xaRes1.end (xid, XAResource.TMSUCCESS);
        xaRes1.commit (xid, true);
        xaConn1.close ();
        xaConn1 = suspXaDs.getXAConnection ();
        xaRes1 = xaConn1.getXAResource ();
        conn1 = xaConn1.getConnection ();
        xaRes1.start (xid, XAResource.TMNOFLAGS);
        conn1.createStatement ().executeQuery ("SELECT 1");
        xaRes1.end (xid, XAResource.TMSUCCESS);
        xaRes1.start (xid, XAResource.TMJOIN);
        conn1.createStatement ().executeQuery ("SELECT 1");
        xaRes1.end (xid, XAResource.TMSUCCESS);
        xaRes1.commit (xid, true);
    } finally {
        if (xaConn1 != null) {
            xaConn1.close ();
        }
    }
}


-----Function Pair=380=-----==

public void delete (MedicineList ml) {
    Session session = mpower_hibernate.HibernateUtil.currentSession ();
    Transaction transaction = session.beginTransaction ();
    try {
        org.hibernate.Query query = session.createQuery (" delete " + " from  " + " MedicineList ml WHERE ml.id = ? ");
        query.setLong (0, ml.getId ());
        query.executeUpdate ();
        transaction.commit ();
    } catch (HibernateException e) {
        transaction.rollback ();
        throw e;
    } finally {
        mpower_hibernate.HibernateUtil.closeSession ();
    }
}


public RestServiceResult logout (HttpSession session, RestServiceResult serviceResult, MaUser maUser) {
    log.info ("Starting logout sequence");
    session.removeAttribute ("user");
    session.invalidate ();
    if (maUser != null) {
        Object [] args = {maUser.getIdentification ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("user.logout.success"), args));
        log.info ("Usuario " + maUser.getUserName () + " sali� de la aplicaci�n!");
    }
    else {
        serviceResult.setError (true);
        serviceResult.setMessage (bundle.getString ("user.logout.notLoggedIn"));
        log.info ("Attempted to logout when not logged in");
    }
    return serviceResult;
}


-----Function Pair=381=-----==

public RlxVariable getVariable (long id) throws Exception {
    Session session = null;
    try {
        session = sessionFactory.openSession ();
        RlxVariable variable = (RlxVariable) session.load (RlxVariable.class, id);
        Hibernate.initialize (variable);
        return variable;
    } catch (Exception ex) {
        throw ex;
    } finally {
        if (session != null) {
            session.close ();
        }
    }
}


public Date findUpToDate (LocalFileState in) throws Exception {
    if (in.pf == null) return null;
    Db db = getDb ();
    try {
        db.enter ();
        ps_find_date.setString (1, in.dir);
        ps_find_date.setString (2, in.orig_filename);
        ps_find_date.setString (3, in.pf.getClassName ());
        ps_find_date.setInt (4, in.local_file_state_id);
        ResultSet rs = db.executeQuery (ps_find_date);
        if (rs.next ()) {
            return DateHelper.toDateOrNull (rs.getTimestamp (1));
        }
        else return null;
    } finally {
        db.exit ();
    }
}


-----Function Pair=382=-----==

private boolean canAuth (Connection conn, int partner, String id, int host, int property) throws GeneralFault, SQLException {
    PreparedStatement stmt = null;
    try {
        stmt = conn.prepareStatement ("SELECT value FROM auth " + "WHERE id = ? AND host = ? AND prop = ? AND dir = ? AND partner = ?");
        stmt.setString (1, id);
        stmt.setInt (2, host);
        stmt.setInt (3, property);
        stmt.setBoolean (4, Direction.ORDINARY);
        stmt.setInt (5, partner);
        ResultSet rs = stmt.executeQuery ();
        return rs.next () && PropertyRight.contains (rs.getInt ("value"), PropertyRight.convert (Value.AUTH), true);
    } catch (SQLException ex) {
        throw new GeneralFault ("Could not check authorization of sending partner.", ex);
    } finally {
        StorageUtils.close (stmt);
    }
}


public void configureSession (String dialect, String driver, String url, String username, String password, List < Class > classes) throws HibernateException {
    Properties props = new Properties ();
    props.setProperty ("hibernate.dialect", dialect);
    props.setProperty ("hibernate.connection.driver_class", driver);
    props.setProperty ("hibernate.connection.url", url);
    props.setProperty ("hibernate.connection.username", username);
    props.setProperty ("hibernate.connection.password", password);
    props.setProperty ("hibernate.query.substitutions", "true 1, false 0, yes 'Y', no 'N'");
    props.setProperty ("hibernate.connection.pool_size", "5");
    props.setProperty ("hibernate.show_sql", "false");
    props.setProperty ("hibernate.current_session_context_class", "thread");
    props.setProperty ("hibernate.jdbc.batch_size", "0");
    props.setProperty ("hibernate.jdbc.use_streams_for_binary", "true");
    props.setProperty ("hibernate.max_fetch_depth", "1");
    props.setProperty ("hibernate.cache.region_prefix", "hibernate.test");
    props.setProperty ("hibernate.cache.use_query_cache", "true");
    props.setProperty ("hibernate.cache.provider_class", "org.hibernate.cache.EhCacheProvider");
    configureSession (props, classes);
}


-----Function Pair=383=-----==

private long getObjectGID (String refValue, int namespaceId, String mode) throws SQLException {
    String sql = getClassifyDAO ().getStatement (TABLE_KEY, "GET_" + mode + "_GID_BY_" + REF_BY_NUM);
    sql = getClassifyDAO ().getStatement (sql, 1, String.valueOf (namespaceId));
    sql += "'" + SQL.escapeSingleQoute (refValue) + "'";
    ResultSet rs = null;
    try {
        rs = keepAliveStmt.executeQuery (sql);
        long gid = - 1;
        while (rs.next ()) {
            gid = rs.getLong (1);
        }
        return gid;
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
}


public void testInsertWithGeneratedTimestampVersion () {
    if (! supportsBulkInsertIdGeneration (TimestampVersioned.class)) {
        reportSkip ("bulk id generation not supported", "test bulk inserts with generated id and generated timestamp");
        return;
    }
    if (! getDialect ().supportsParametersInInsertSelect ()) {
        reportSkip ("dialect does not support parameter in INSERT ... SELECT", "test bulk inserts with generated id and generated timestamp");
        return;
    }
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    TimestampVersioned entity = new TimestampVersioned ("int-vers");
    s.save (entity);
    s.createQuery ("select id, name, version from TimestampVersioned").list ();
    t.commit ();
    s.close ();
    Long initialId = entity.getId ();
    s = openSession ();
    t = s.beginTransaction ();
    int count = s.createQuery ("insert into TimestampVersioned ( name ) select name from TimestampVersioned").executeUpdate ();
    t.commit ();
    s.close ();
    assertEquals ("unexpected insertion count", 1, count);
    s = openSession ();
    t = s.beginTransaction ();
    TimestampVersioned created = (TimestampVersioned) s.createQuery ("from TimestampVersioned where id <> :initialId").setLong ("initialId", initialId.longValue ()).uniqueResult ();
    t.commit ();
    s.close ();
    assertNotNull (created.getVersion ());
    s = openSession ();
    t = s.beginTransaction ();
    s.createQuery ("delete TimestampVersioned").executeUpdate ();
    t.commit ();
    s.close ();
}


-----Function Pair=384=-----==

public void update (String channelPath, String dataField, String fatherDocId) {
    String sqlInitial = "select uri from t_ip_doc_res where doc_id = '" + fatherDocId + "' and type=" + " '" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + "' ";
    String sqlsortURL = "update t_ip_doc_res set uri = ? where doc_id = '" + fatherDocId + "' " + " and type = '" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + "' ";
    Connection conn = null;
    ResultSet rs = null;
    PreparedStatement ps = null;
    try {
        dbo = (ERDBOperation) createDBOperation ();
        String url = "";
        boolean flag = true;
        StringTokenizer st = null;
        conn = dbo.getConnection ();
        conn.setAutoCommit (false);
        ps = conn.prepareStatement (sqlInitial);
        rs = ps.executeQuery ();
        if (rs.next ()) url = rs.getString (1);
        if (! url.equals ("")) {
            st = new StringTokenizer (url, ",");
            String sortDocId = "";
            while (st.hasMoreTokens ()) {
                if (flag) {
                    sortDocId = "'" + st.nextToken () + "'";
                    flag = false;
                }
                else {
                    sortDocId = sortDocId + "," + "'" + st.nextToken () + "'";
                }
            }
            String sqlsort = "select id from t_ip_doc where id in (" + sortDocId + ") order by " + dataField;
            ps = conn.prepareStatement (sqlsort);
            rs = ps.executeQuery ();
            String sortURL = "";
            boolean sortflag = true;
            while (rs.next ()) {
                if (sortflag) {
                    sortURL = rs.getString (1);
                    sortflag = false;
                }
                else {
                    sortURL = sortURL + "," + rs.getString (1);
                }
            }
            ps = conn.prepareStatement (sqlsortURL);
            ps.setString (1, sortURL);
            ps.executeUpdate ();
        }
        conn.commit ();
    } catch (Exception e) {
        e.printStackTrace ();
        try {
            conn.rollback ();
        } catch (SQLException e1) {
            e1.printStackTrace ();
        }
    } finally {
        close (rs, null, ps, conn, dbo);
    }
}


private void store (Set < Post > posts, boolean delete) throws SQLException {
    if (null == posts || posts.isEmpty ()) return;
    String insertQuery = "insert into fs.post (id, forum, tid, qid, pid, question, posted_date, type, text, author, deleted, path) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
    String updateQuery = "update fs.post set forum = ?, tid = ?, qid = ?, pid = ?, question = ?, posted_date = ?, type = ?, text = ?, author = ?, deleted = ?, path = ? where id = ?";
    ensureConnection ();
    PreparedStatement statement = null;
    Savepoint savepoint = null;
    String path = null;
    try {
        savepoint = m_connection.setSavepoint ();
        synchronized (posts) {
            for (Post post : posts) {
                path = null;
                boolean insert = ! hasInDatabase (post);
                if (insert) {
                    statement = m_connection.prepareStatement (insertQuery);
                    statement.setNull (1, Types.NUMERIC);
                    statement.setString (2, post.getQuestion ().getTopicArea ().getForum ().getIdentifier ());
                    statement.setString (3, post.getQuestion ().getTopicArea ().getIdentifier ());
                    statement.setString (4, post.getQuestion ().getIdentifier ());
                    statement.setString (5, post.getIdentifier ());
                    statement.setLong (6, post.getQuestion ().getDatabaseID ());
                    statement.setTimestamp (7, new Timestamp (post.getPostedDate ().getTime ()));
                    statement.setString (8, post.getType ().toString ());
                    int contentLength = 0;
                    if (null != post.getText ()) contentLength = post.getText ().toString ().length ();
                    if (contentLength < m_configuration.getThresholdByteSize ()) {
                        statement.setString (9, post.getText ().toString ());
                        statement.setBoolean (12, false);
                    }
                    else {
                        path = getPath (post);
                        statement.setString (9, path);
                        try {
                            IOUtils.writeIntoFile (new File (m_configuration.getRepository (), path), post.getText ().toString ());
                        } catch (IOException e) {
                            SQLException sqle = new SQLException ();
                            sqle.initCause (e);
                            throw sqle;
                        }
                        statement.setBoolean (12, true);
                    }
                    statement.setString (10, post.getAuthor ());
                    statement.setBoolean (11, delete);
                    int count = statement.executeUpdate ();
                    if (0 == count) throw new SQLException ("Nothing updated.");
                    ResultSet keys = statement.getGeneratedKeys ();
                    try {
                        if (keys.next ()) post.setDatabaseID (keys.getLong (1));
                        else throw new SQLException ("No key found.");
                    } finally {
                        try {
                            keys.close ();
                        } catch (SQLException _) {
                        }
                    }
                }
                else {
                    statement = m_connection.prepareStatement (updateQuery);
                    statement.setLong (12, post.getDatabaseID ());
                    statement.setString (1, post.getQuestion ().getTopicArea ().getForum ().getIdentifier ());
                    statement.setString (2, post.getQuestion ().getTopicArea ().getIdentifier ());
                    statement.setString (3, post.getQuestion ().getIdentifier ());
                    statement.setString (4, post.getIdentifier ());
                    statement.setLong (5, post.getQuestion ().getDatabaseID ());
                    statement.setTimestamp (6, new Timestamp (post.getPostedDate ().getTime ()));
                    statement.setString (7, post.getType ().toString ());
                    int contentLength = 0;
                    if (null != post.getText ()) contentLength = post.getText ().toString ().length ();
                    if (contentLength < m_configuration.getThresholdByteSize ()) {
                        String pathIfThere = getPath (post);
                        File file = new File (m_configuration.getRepository (), pathIfThere);
                        if (file.exists ()) delete (file);
                        statement.setString (8, post.getText ().toString ());
                        statement.setBoolean (11, false);
                    }
                    else {
                        path = getPath (post);
                        statement.setString (8, path);
                        File file = new File (m_configuration.getRepository (), path);
                        try {
                            IOUtils.writeIntoFile (file, post.getText ().toString ());
                        } catch (IOException e) {
                            SQLException sqle = new SQLException ();
                            sqle.initCause (e);
                            throw sqle;
                        }
                        statement.setBoolean (11, true);
                        post.setText (new DelayedLoadString (file));
                    }
                    statement.setString (9, post.getAuthor ());
                    statement.setBoolean (10, delete);
                    int count = statement.executeUpdate ();
                    if (0 == count) throw new SQLException ("Nothing updated.");
                }
                PreparedStatement statement1 = m_connection.prepareStatement ("show warnings");
                try {
                    ResultSet rs1 = statement1.executeQuery ();
                    if (rs1.next ()) {
                        try {
                            System.err.println (rs1.getString ("Message"));
                        } finally {
                            rs1.close ();
                        }
                    }
                } finally {
                    statement1.close ();
                }
                statement1 = m_connection.prepareStatement ("select * from fs.post where id = ?");
                try {
                    statement1.setLong (1, post.getDatabaseID ());
                    ResultSet rs1 = statement1.executeQuery ();
                    try {
                        if (! rs1.next ()) throw new SQLException ("Nothing updated.");
                    } finally {
                        rs1.close ();
                    }
                } finally {
                    statement1.close ();
                }
                LOG.info ("Post [ID=" + post.getIdentifier () + "] [Question=" + post.getQuestion ().getIdentifier () + "] [Database ID=" + post.getDatabaseID () + "] [Title=" + post.getQuestion ().getTitle () + "] has been updated.");
            }
        }
        m_connection.commit ();
    } catch (SQLException e) {
        m_connection.rollback (savepoint);
        delete (path);
        throw e;
    } finally {
        if (null != statement) {
            try {
                statement.close ();
            } catch (SQLException _) {
            }
        }
    }
}


-----Function Pair=385=-----==

private ExtNamespaceEntry fetchExtNamespaceEntry (int extNamespaceId) throws SQLException {
    String sql = getClassifyDAO ().getStatement (TABLE_KEY, "GET_EXT_NAMESPACE");
    sql += extNamespaceId;
    ExtNamespaceEntry extNs = null;
    ResultSet rs = null;
    try {
        rs = keepAliveStmt.executeQuery (sql);
        while (rs.next ()) {
            extNs = new ExtNamespaceEntry (rs.getInt (1), rs.getString (2), rs.getInt (3), rs.getString (4));
        }
    } finally {
        if (rs != null) {
            rs.close ();
        }
    }
    return extNs;
}


public void testUpdateOnMammal () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    int count = s.createQuery ("update Mammal set description = description").executeUpdate ();
    assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    count = s.createQuery ("update Mammal set bodyWeight = 25").executeUpdate ();
    assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    if (! (getDialect () instanceof MySQLDialect)) {
        count = s.createQuery ("update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )").executeUpdate ();
        assertEquals ("incorrect update count against 'middle' of joined-subclass hierarchy", 2, count);
    }
    t.commit ();
    s.close ();
    data.cleanup ();
}


-----Function Pair=386=-----==

public String getDOBOUid (String boName) {
    Connection con = null;
    try {
        con = DODataSource.getDefaultCon ();
        String sql = "select objUID from DO_BO where type = '1' and sqlStr = ? ";
        PreparedStatement pstmt = con.prepareStatement (sql);
        pstmt.setString (1, boName);
        ResultSet rs = pstmt.executeQuery ();
        String boUid = null;
        if (rs.next ()) {
            boUid = rs.getString (1);
        }
        return boUid;
    } catch (SQLException ex1) {
        ex1.printStackTrace ();
    } finally {
        try {
            if (! con.isClosed ()) {
                con.close ();
            }
        } catch (SQLException ex1) {
            ex1.printStackTrace ();
        }
    }
    return null;
}


public Collection list () throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        ResultSet rs = null;
        try {
            String sql = "select Word, SenseNumber, GrammarString, ObjectId " + "from Dictionary order by Word";
            conn = FidoDataSource.getConnection ();
            stmt = conn.createStatement ();
            rs = stmt.executeQuery (sql);
            Vector list = new Vector ();
            while (rs.next () == true) {
                DictionaryEntry entry = new DictionaryEntry (rs.getString (1), rs.getInt (2), rs.getString (3), rs.getString (4));
                list.add (entry);
            }
            return list;
        } finally {
            if (rs != null) rs.close ();
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=387=-----==

private boolean updateAdminPassword (Connection conn) {
    logger.info ("Going to update the administrator's password");
    boolean status = false;
    PreparedStatement p = null;
    try {
        p = conn.prepareStatement ("UPDATE jforum_users SET user_password = ? WHERE username = 'Admin'");
        p.setString (1, MD5.crypt (this.getFromSession ("adminPassword")));
        p.executeUpdate ();
        status = true;
    } catch (Exception e) {
        logger.warn ("Error while trying to update the administrator's password: " + e);
        this.context.put ("exceptionMessage", e.getMessage ());
    } finally {
        DbUtils.close (p);
    }
    return status;
}


public boolean modifyMember (Members member) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        session.update (member);
        session.flush ();
        tr.commit ();
        return true;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return false;
}


-----Function Pair=388=-----==

public ArrayList getUserList (String uname, String gname) {
    ArrayList aList = new ArrayList ();
    String username;
    try {
        PreparedStatement stmt = con.prepareStatement ("Select uname from status where uname != ? and gname = ? ");
        stmt.setString (1, uname);
        stmt.setString (2, gname);
        ResultSet rs = stmt.executeQuery ();
        if (rs != null) {
            while (rs.next ()) {
                username = rs.getString ("uname");
                aList.add (username);
            }
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
    return aList;
}


public Price getPriceById (PricePk pk) throws PersistenceException {
    logger.info ("Getting price...");
    if (pk == null) {
        String error = "Id is null.";
        logger.error (error);
        throw new IllegalArgumentException (error);
    }
    EntityManager em = getEntityManager ();
    Price price = null;
    try {
        em.getTransaction ().begin ();
        Query query = em.createQuery ("select p from Price p where " + " p.id = :id ");
        query.setParameter ("id", pk);
        price = (Price) query.getSingleResult ();
    } catch (Exception ex) {
        String error = "Error getting price: " + ex.getMessage ();
        logger.error (error);
        em.getTransaction ().rollback ();
        throw new PersistenceException (ex);
    } finally {
        em.close ();
    }
    logger.info ("Price got successfully.");
    return price;
}


-----Function Pair=389=-----==

public Boolean deleteOperator (String NamaUser) {
    Boolean result = false;
    try {
        configEntity.getTransaction ().begin ();
        configQuery = configEntity.createNativeQuery ("DELETE FROM operator WHERE namauser = #namauser").setParameter ("namauser", NamaUser);
        configQuery.executeUpdate ();
        configEntity.getTransaction ().commit ();
        result = true;
    } catch (Exception ex) {
        configEntity.getTransaction ().rollback ();
        ex.printStackTrace ();
        Logger.getLogger (GeneralConfig.class.getName ()).log (Level.SEVERE, null, ex);
    }
    return result;
}


public void testUseLocalSessionState () throws Exception {
    Properties props = new Properties ();
    props.setProperty ("useLocalSessionState", "true");
    props.setProperty ("profileSQL", "true");
    props.setProperty ("logFactory", "com.mysql.jdbc.log.StandardLogger");
    Connection conn1 = getConnectionWithProps (props);
    conn1.setAutoCommit (true);
    conn1.setTransactionIsolation (Connection.TRANSACTION_REPEATABLE_READ);
    StandardLogger.saveLogsToBuffer ();
    StandardLogger.bufferedLog.setLength (0);
    conn1.setAutoCommit (true);
    conn1.setTransactionIsolation (Connection.TRANSACTION_REPEATABLE_READ);
    conn1.getTransactionIsolation ();
    String logAsString = StandardLogger.bufferedLog.toString ();
    assertTrue (logAsString.indexOf ("SET SESSION") == - 1 && logAsString.indexOf ("SHOW VARIABLES LIKE 'tx_isolation'") == - 1 && logAsString.indexOf ("SET autocommit=") == - 1);
}


-----Function Pair=390=-----==

public Collection getVirtualWikis () throws Exception {
    Connection conn = null;
    Collection all = new ArrayList ();
    try {
        conn = DatabaseConnection.getConnection ();
        Statement st = conn.createStatement ();
        ResultSet rs = st.executeQuery (STATEMENT_GET_ALL_VIRTUAL_WIKIS);
        while (rs.next ()) {
            all.add (rs.getString ("name"));
        }
        rs.close ();
        st.close ();
    } finally {
        DatabaseConnection.closeConnection (conn);
    }
    if (! all.contains (Constants.DEFAULT_VWIKI)) {
        all.add (Constants.DEFAULT_VWIKI);
    }
    return all;
}


public void add (String name) throws FidoDatabaseException {
    try {
        Connection conn = null;
        Statement stmt = null;
        try {
            if (contains (name) == false) {
                String sql = "insert into AttributeCategories (CategoryName) " + "values ('" + name + "')";
                conn = FidoDataSource.getConnection ();
                stmt = conn.createStatement ();
                stmt.executeUpdate (sql);
            }
        } finally {
            if (stmt != null) stmt.close ();
            if (conn != null) conn.close ();
        }
    } catch (SQLException e) {
        throw new FidoDatabaseException (e);
    }
}


-----Function Pair=391=-----==

public RestServiceResult update (RestServiceResult serviceResult, ToGloss gloss) {
    ToGlossDAO glossDAO = new ToGlossDAO ();
    try {
        log.info ("Actualizando la Glosa Explicativa: " + gloss.getGlossId ());
        EntityManagerHelper.beginTransaction ();
        glossDAO.update (gloss);
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (gloss);
        Object [] arrayParam = {gloss.getGlossId ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("singleText.update.success"), arrayParam));
        log.info ("Se actualizo la Glosa Explicativa con �xito: " + gloss.getGlossId ());
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar la Glosa Explicativa: " + e.getMessage ());
        serviceResult.setError (true);
        serviceResult.setMessage (e.getMessage ());
    }
    return serviceResult;
}


public RestServiceResult delete (RestServiceResult serviceResult, ToExercise2Group toExercise2Group) {
    try {
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (Statements.DELETE_TO_EXERCITE2_GROUP);
        query.setParameter (1, toExercise2Group.getExerciseGroupId ());
        query.executeUpdate ();
        EntityManagerHelper.commit ();
        EntityManagerHelper.refresh (toExercise2Group);
        Object [] arrayParam = {toExercise2Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise2group.delete.success"), arrayParam));
    } catch (PersistenceException e) {
        EntityManagerHelper.rollback ();
        log.error ("Error al actualizar el ejercicio grupal S2: " + e.getMessage ());
        serviceResult.setError (true);
        Object [] arrayParam = {toExercise2Group.getGroupName ()};
        serviceResult.setMessage (MessageFormat.format (bundle.getString ("exercise2group.delete.error") + e.getMessage (), arrayParam));
    }
    return serviceResult;
}


-----Function Pair=392=-----==

void createDatabase (String url, String user, String password) throws Exception {
    Connection Conn = connect (url, user, password);
    String s = Conn.getMetaData ().getDatabaseProductName ();
    System.out.println ("DBMS: " + s);
    transactions = true;
    if (transactions) {
        try {
            Conn.setAutoCommit (false);
            System.out.println ("In transaction mode");
        } catch (SQLException Etrxn) {
            transactions = false;
        }
    }
    try {
        int accountsnb = 0;
        Statement Stmt = Conn.createStatement ();
        String Query;
        Query = "SELECT count(*) ";
        Query += "FROM   accounts";
        ResultSet RS = Stmt.executeQuery (Query);
        Stmt.clearWarnings ();
        while (RS.next ()) {
            accountsnb = RS.getInt (1);
        }
        if (transactions) {
            Conn.commit ();
        }
        Stmt.close ();
        if (accountsnb == (naccounts * tps)) {
            System.out.println ("Already initialized");
            connectClose (Conn);
            return;
        }
    } catch (Exception E) {
    }
    System.out.println ("Drop old tables if they exist");
    try {
        Statement Stmt = Conn.createStatement ();
        String Query;
        Query = "DROP TABLE history";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DROP TABLE accounts";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DROP TABLE tellers";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DROP TABLE branches";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        if (transactions) {
            Conn.commit ();
        }
        Stmt.close ();
    } catch (Exception E) {
    }
    System.out.println ("Creates tables");
    try {
        Statement Stmt = Conn.createStatement ();
        String Query;
        if (tableExtension.length () > 0) {
            Query = tableExtension + " branches (";
        }
        else {
            Query = "CREATE TABLE branches (";
        }
        Query += "Bid         INTEGER NOT NULL PRIMARY KEY, ";
        Query += "Bbalance    INTEGER,";
        Query += "filler      CHAR(88))";
        if (createExtension.length () > 0) {
            Query += createExtension;
        }
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        if (tableExtension.length () > 0) {
            Query = tableExtension + " tellers (";
        }
        else {
            Query = "CREATE TABLE tellers (";
        }
        Query += "Tid         INTEGER NOT NULL PRIMARY KEY,";
        Query += "Bid         INTEGER,";
        Query += "Tbalance    INTEGER,";
        Query += "filler      CHAR(84))";
        if (createExtension.length () > 0) {
            Query += createExtension;
        }
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        if (tableExtension.length () > 0) {
            Query = tableExtension + " accounts (";
        }
        else {
            Query = "CREATE TABLE accounts (";
        }
        Query += "Aid         INTEGER NOT NULL PRIMARY KEY, ";
        Query += "Bid         INTEGER, ";
        Query += "Abalance    INTEGER, ";
        Query += "filler      CHAR(84))";
        if (createExtension.length () > 0) {
            Query += createExtension;
        }
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        if (tableExtension.length () > 0) {
            Query = tableExtension + " history (";
        }
        else {
            Query = "CREATE TABLE history (";
        }
        Query += "Tid         INTEGER, ";
        Query += "Bid         INTEGER, ";
        Query += "Aid         INTEGER, ";
        Query += "delta       INTEGER, ";
        Query += "tstime        TIMESTAMP, ";
        Query += "filler      CHAR(22))";
        if (createExtension.length () > 0) {
            Query += createExtension;
        }
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Stmt.execute ("SET TABLE ACCOUNTS SOURCE \"ACCOUNTS.TXT\"");
        Stmt.execute ("SET TABLE BRANCHES SOURCE \"BBRANCHES.TXT\"");
        Stmt.execute ("SET TABLE TELLERS SOURCE \"TELLERS.TXT\"");
        Stmt.execute ("SET TABLE HISTORY SOURCE \"HISTORY.TXT\"");
        if (transactions) {
            Conn.commit ();
        }
        Stmt.close ();
    } catch (Exception E) {
        System.out.println ("Delete elements in table in case Drop didn't work");
    }
    System.out.println ("Delete elements in table in case Drop didn't work");
    try {
        Statement Stmt = Conn.createStatement ();
        String Query;
        Query = "DELETE FROM history";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DELETE FROM accounts";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DELETE FROM tellers";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        Query = "DELETE FROM branches";
        Stmt.execute (Query);
        Stmt.clearWarnings ();
        if (transactions) {
            Conn.commit ();
        }
        PreparedStatement pstmt = null;
        prepared_stmt = true;
        if (prepared_stmt) {
            try {
                Query = "INSERT INTO branches(Bid,Bbalance) VALUES (?,0)";
                pstmt = Conn.prepareStatement (Query);
                System.out.println ("Using prepared statements");
            } catch (SQLException Epstmt) {
                pstmt = null;
                prepared_stmt = false;
            }
        }
        System.out.println ("Insert data in branches table");
        for (int i = 0; i < nbranches * tps; i ++) {
            if (prepared_stmt) {
                pstmt.setInt (1, i);
                pstmt.executeUpdate ();
                pstmt.clearWarnings ();
            }
            else {
                Query = "INSERT INTO branches(Bid,Bbalance) VALUES (" + i + ",0)";
                Stmt.executeUpdate (Query);
            }
            if ((i % 100 == 0) && (transactions)) {
                Conn.commit ();
            }
        }
        if (prepared_stmt) {
            pstmt.close ();
        }
        if (transactions) {
            Conn.commit ();
        }
        if (prepared_stmt) {
            Query = "INSERT INTO tellers(Tid,Bid,Tbalance) VALUES (?,?,0)";
            pstmt = Conn.prepareStatement (Query);
        }
        System.out.println ("Insert data in tellers table");
        for (int i = 0; i < ntellers * tps; i ++) {
            if (prepared_stmt) {
                pstmt.setInt (1, i);
                pstmt.setInt (2, i / ntellers);
                pstmt.executeUpdate ();
                pstmt.clearWarnings ();
            }
            else {
                Query = "INSERT INTO tellers(Tid,Bid,Tbalance) VALUES (" + i + "," + i / ntellers + ",0)";
                Stmt.executeUpdate (Query);
            }
            if ((i % 100 == 0) && (transactions)) {
                Conn.commit ();
            }
        }
        if (prepared_stmt) {
            pstmt.close ();
        }
        if (transactions) {
            Conn.commit ();
        }
        if (prepared_stmt) {
            Query = "INSERT INTO accounts(Aid,Bid,Abalance) VALUES (?,?,0)";
            pstmt = Conn.prepareStatement (Query);
        }
        System.out.println ("Insert data in accounts table");
        for (int i = 0; i < naccounts * tps; i ++) {
            if (prepared_stmt) {
                pstmt.setInt (1, i);
                pstmt.setInt (2, i / naccounts);
                pstmt.executeUpdate ();
                pstmt.clearWarnings ();
            }
            else {
                Query = "INSERT INTO accounts(Aid,Bid,Abalance) VALUES (" + i + "," + i / naccounts + ",0)";
                Stmt.executeUpdate (Query);
            }
            if ((i % 10000 == 0) && (transactions)) {
                Conn.commit ();
            }
            if ((i > 0) && ((i % 10000) == 0)) {
                System.out.println ("\t" + i + "\t records inserted");
            }
        }
        if (prepared_stmt) {
            pstmt.close ();
        }
        if (transactions) {
            Conn.commit ();
        }
        System.out.println ("\t" + (naccounts * tps) + "\t records inserted");
        Stmt.execute (ShutdownCommand);
        Stmt.close ();
    } catch (Exception E) {
        System.out.println (E.getMessage ());
        E.printStackTrace ();
    }
    connectClose (Conn);
}


public void synchronizeUserGroup (Long nExerciseGroupId, String sArrayUserId) {
    List < MaUser > listUserGroup = null;
    int nNumUserGroup = 0;
    int nNumArrayUser = 0;
    String sSql = null;
    try {
        sSql = Statements.UPDATE_FLAG_Y_USER_EXER2_GROUP;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        EntityManagerHelper.beginTransaction ();
        Query query = EntityManagerHelper.createNativeQuery (sSql);
        query.setParameter (1, "Y");
        query.setParameter (2, nExerciseGroupId);
        int nDeleted = query.executeUpdate ();
        sSql = Statements.UPDATE_FLAG_N_USER_EXER2_GROUP;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        query = EntityManagerHelper.createNativeQuery (sSql);
        query.setParameter (1, "N");
        query.setParameter (2, nExerciseGroupId);
        nDeleted = query.executeUpdate ();
        sSql = Statements.SELECT_MA_USER_IN;
        sSql = sSql.replaceFirst ("v1", sArrayUserId);
        query = EntityManagerHelper.createNativeQuery (sSql, MaUser.class);
        query.setParameter (1, nExerciseGroupId);
        query.setHint (QueryHints.REFRESH, HintValues.TRUE);
        listUserGroup = query.getResultList ();
        nNumArrayUser = listUserGroup.size ();
        for (Iterator iterator = listUserGroup.iterator (); iterator.hasNext ();) {
            MaUser maUser = (MaUser) iterator.next ();
            query = EntityManagerHelper.createNativeQuery (Statements.SELECT_CO_USER_EXER2_GROUP_USER, CoUserExer2Group.class);
            query.setParameter (1, maUser.getUserId ());
            query.setParameter (2, nExerciseGroupId);
            query.setHint (QueryHints.REFRESH, HintValues.TRUE);
            Vector vecResult = (Vector) query.getResultList ();
            if (vecResult.size () == 0) {
                CoUserExer2GroupId CoUserExer2GroupId = new CoUserExer2GroupId (nExerciseGroupId, maUser.getUserId ());
                CoUserExer2Group CoUserExer2Group = new CoUserExer2Group ();
                CoUserExer2Group.setToExercise2Group (new ToExercise2GroupDAO ().findById (nExerciseGroupId));
                CoUserExer2Group.setMaUser (maUser);
                CoUserExer2Group.setId (CoUserExer2GroupId);
                CoUserExer2Group.setFlagDeleted ("N");
                new CoUserExer2GroupDAO ().save (CoUserExer2Group);
            }
            else {
            }
        }
        EntityManagerHelper.commit ();
    } catch (Exception e) {
        log.info ("Error buscando el estado para usuarios por grupo ");
        EntityManagerHelper.rollback ();
    }
}


-----Function Pair=393=-----==

public void testInsertAcrossMappedJoinFails () {
    TestData data = new TestData ();
    data.prepare ();
    Session s = openSession ();
    Transaction t = s.beginTransaction ();
    try {
        s.createQuery ("insert into Joiner (name, joinedName) select vin, owner from Car").executeUpdate ();
        fail ("mapped-join insertion did not error");
    } catch (QueryException e) {
    }
    t.commit ();
    t = s.beginTransaction ();
    s.createQuery ("delete Joiner").executeUpdate ();
    s.createQuery ("delete Vehicle").executeUpdate ();
    t.commit ();
    s.close ();
    data.cleanup ();
}


private boolean valida () {
    boolean origemOk = false;
    String mensagem = null;
    int cm = 0;
    if (txtCodPlanOrig.getVlrString () == null || txtCodPlanOrig.getVlrString ().trim ().length () == 0) {
        mensagem = "Planejamento de origem deve ser informado.";
        cm = 1;
    }
    else if (txtCodPlanDest.getVlrString () == null || txtCodPlanDest.getVlrString ().trim ().length () == 0) {
        mensagem = "Planejamento de destino deve ser informado.";
        cm = 2;
    }
    else if ("BC".indexOf (txtTipoPlanOrgi.getVlrString ()) > - 1) {
        mensagem = "Planejamento de origem n�o pode ser CAIXA  ou BANCO.";
        cm = 3;
    }
    else if ("BC".indexOf (txtTipoPlanDest.getVlrString ()) > - 1) {
        mensagem = "Planejamento de destino n�o pode ser CAIXA  ou BANCO.";
        cm = 4;
    }
    else if (! txtTipoPlanOrgi.getVlrString ().equals (txtTipoPlanDest.getVlrString ())) {
        mensagem = "Planejamento de destino deve ser do mesmo tipo que o de origem.";
        cm = 5;
    }
    else {
        origemOk = true;
    }
    if (! origemOk) {
        JOptionPane.showMessageDialog (panelCentro, mensagem, "Alerta", JOptionPane.INFORMATION_MESSAGE);
        if (cm == 1 || cm == 3) {
            txtCodPlanOrig.requestFocus ();
        }
        else {
            txtCodPlanDest.requestFocus ();
        }
    }
    return origemOk;
}


-----Function Pair=394=-----==

private static void update (SessionFactory sessionFactory) {
    Session session = sessionFactory.openSession ();
    try {
        session.beginTransaction ();
        Query query = session.createQuery ("FROM Person");
        Collection < Person > list = (Collection < Person >) query.list ();
        for (Person person : list) {
            person.setFirstName ("Carl");
            Address address = new Address ();
            address.setCity ("Austin");
            address.setStreet ("Silver Avenue 21");
            person.setAddress (address);
        }
        session.getTransaction ().commit ();
    } finally {
        if (session.getTransaction ().isActive ()) {
            session.getTransaction ().rollback ();
        }
        session.close ();
    }
}


private static void update (EntityManagerFactory entityManagerFactory) {
    EntityManager entityManager = entityManagerFactory.createEntityManager ();
    try {
        entityManager.getTransaction ().begin ();
        Query query = entityManager.createQuery ("SELECT o FROM Order o");
        Collection < Order > collection = (Collection < Order >) query.getResultList ();
        for (Order order : collection) {
            for (OrderItem item : order.getItems ()) {
                item.setPrice (item.getPrice () * 2);
            }
        }
        entityManager.getTransaction ().commit ();
    } finally {
        if (entityManager.getTransaction ().isActive ()) {
            entityManager.getTransaction ().rollback ();
        }
        entityManager.close ();
    }
}


-----Function Pair=395=-----==

public void removerTopicos (Topicos topicos) throws ClassNotFoundException, SQLException {
    this.criaConexao (false);
    String sql = "DELETE FROM \"Topicos\"    " + "      WHERE \"id_Topicos\" =  ?";
    PreparedStatement stmt = null;
    try {
        stmt = connection.prepareStatement (sql);
        stmt.setString (1, topicos.getIdTopicos ());
        stmt.executeUpdate ();
        connection.commit ();
    } catch (SQLException e) {
        connection.rollback ();
        throw e;
    } finally {
        try {
            stmt.close ();
            this.fechaConexao ();
        } catch (SQLException e) {
            throw e;
        }
    }
}


public void clearSettingsStartingWith (String prefix) {
    String qry = "DELETE FROM settings WHERE var LIKE ? ESCAPE '\\'";
    PreparedStatement pstmt = null;
    try {
        pstmt = conn.prepareStatement (qry);
        pstmt.setString (1, prefix.replace ("_", "\\_").replace ("%", "\\%") + "%");
        pstmt.executeUpdate ();
    } catch (SQLException e) {
        LOG.error (SQL_ERROR, e);
    } finally {
        if (pstmt != null) try {
            pstmt.close ();
        } catch (SQLException e) {
            LOG.error (SQL_ERROR, e);
        }
    }
}


-----Function Pair=396=-----==

public int modifyAllValidating (byte status) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("update Validating set status = ?");
        query.setByte (0, status);
        int count = query.executeUpdate ();
        tr.commit ();
        return count;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return 0;
}


public List < Medals > findMedalsByAvailable (byte available) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery ("from Medals where available=? order by medalid");
        query.setParameter (0, available);
        List < Medals > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null && tr.isActive ()) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=397=-----=1=

public static void BubbleSortDouble2 (double [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                double temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


public static void BubbleSortLong2 (long [] num) {
    int last_exchange;
    int right_border = num.length - 1;
    do {
        last_exchange = 0;
        for (int j = 0; j < num.length - 1; j ++) {
            if (num [j] > num [j + 1]) {
                long temp = num [j];
                num [j] = num [j + 1];
                num [j + 1] = temp;
                last_exchange = j;
            }
        }
        right_border = last_exchange;
    }
    while (right_border > 0);
}


-----Function Pair=398=-----==

public static byte [] loadFile (File file) throws Exception {
    if (! file.exists () || ! file.canRead ()) {
        String message = "Cannot read file: " + file.getCanonicalPath ();
        throw new Exception (message);
    }
    FileInputStream fis = new FileInputStream (file);
    ByteArrayOutputStream data = new ByteArrayOutputStream ();
    int len = 0;
    byte [] buf = new byte [1024];
    while ((len = fis.read (buf)) >= 0) {
        data.write (buf, 0, len);
    }
    fis.close ();
    byte [] retval = data.toByteArray ();
    data.close ();
    return retval;
}


public Object executeSimple (JdbcTaskContext context) {
    SleeTransaction tx = null;
    try {
        tx = context.getSleeTransactionManager ().beginSleeTransaction ();
        Connection connection = context.getConnection ();
        Statement statement = connection.createStatement ();
        tracer.info ("Created statement to create table, executing query...");
        statement.execute ("CREATE TABLE TestTable (Name VARCHAR(30));");
        PreparedStatement preparedStatement = connection.prepareStatement ("INSERT INTO TestTable VALUES(?)");
        preparedStatement.setString (1, "Mobicents");
        tracer.info ("Created prepared statement for data insert, executing...");
        preparedStatement.execute ();
        preparedStatement = connection.prepareStatement ("SELECT ? From TestTable;");
        preparedStatement.setString (1, "Name");
        tracer.info ("Created prepared statement for data query, executing...");
        preparedStatement.execute ();
        ResultSet resultSet = preparedStatement.getResultSet ();
        resultSet.next ();
        tracer.info ("Data query first result: " + resultSet.getString (1));
        Statement anotherStatement = connection.createStatement ();
        tracer.info ("Created statement to drop table, executing update...");
        anotherStatement.executeUpdate ("DROP TABLE TestTable;");
        tx.commit ();
        tx = null;
        return true;
    } catch (Exception e) {
        tracer.severe ("failed to create table", e);
        if (tx != null) {
            try {
                tx.rollback ();
            } catch (Exception f) {
                tracer.severe ("failed to rollback tx", f);
            }
        }
        return false;
    }
}


-----Function Pair=399=-----==

private synchronized List getResultList (String hqlQuery, int pageNumber, int limit) throws GridBrokerException {
    List result = null;
    Transaction t = null;
    Session s = null;
    try {
        s = getSession ();
        t = s.beginTransaction ();
        Query q = s.createQuery (hqlQuery);
        if (limit > 0) {
            q.setMaxResults (limit);
        }
        if (pageNumber > 0) {
            q.setFirstResult (pageNumber);
        }
        result = q.list ();
        t.commit ();
    } catch (Exception e) {
        if (t != null && t.isActive ()) {
            t.rollback ();
        }
        throw new GridBrokerException ("Error getting list: query=" + hqlQuery, e);
    } finally {
        closeSession (s);
    }
    return result;
}


public List < Members > findMembersByHql (String hql, int startrow, int maxrows) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Query query = session.createQuery (hql);
        query.setFirstResult (startrow);
        query.setMaxResults (maxrows);
        List < Members > list = query.list ();
        tr.commit ();
        return list;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


-----Function Pair=400=-----==

public Threads findThreadsBytid (int tid) {
    Transaction tr = null;
    try {
        Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
        tr = session.beginTransaction ();
        Threads thread = (Threads) session.get (Threads.class, tid);
        tr.commit ();
        return thread;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


public Validating findValidatingById (int id) {
    Session session = HibernateUtil.getSessionFactory ().getCurrentSession ();
    Transaction tr = null;
    try {
        tr = session.beginTransaction ();
        Validating validating = (Validating) session.get (Validating.class, id);
        tr.commit ();
        return validating;
    } catch (HibernateException e) {
        if (tr != null) {
            tr.rollback ();
        }
        e.printStackTrace ();
    }
    return null;
}


